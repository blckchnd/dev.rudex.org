(this["webpackChunkRuDEX3_light"] = this["webpackChunkRuDEX3_light"] || []).push([[34],{

/***/ 3217:
/***/ ((module) => {

"use strict";
/*globals self, window */


/*eslint-disable @mysticatea/prettier */
const { AbortController, AbortSignal } =
    typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window :
    /* otherwise */ undefined
/*eslint-enable @mysticatea/prettier */

module.exports = AbortController
module.exports.AbortSignal = AbortSignal
module.exports["default"] = AbortController


/***/ }),

/***/ 3296:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var Buffer = (__webpack_require__(442).Buffer)

function asUInt32Array (buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)

  var len = (buf.length / 4) | 0
  var out = new Array(len)

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4)
  }

  return out
}

function scrubVec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
}

function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0]
  var SUB_MIX1 = SUB_MIX[1]
  var SUB_MIX2 = SUB_MIX[2]
  var SUB_MIX3 = SUB_MIX[3]

  var s0 = M[0] ^ keySchedule[0]
  var s1 = M[1] ^ keySchedule[1]
  var s2 = M[2] ^ keySchedule[2]
  var s3 = M[3] ^ keySchedule[3]
  var t0, t1, t2, t3
  var ksRow = 4

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }

  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  t0 = t0 >>> 0
  t1 = t1 >>> 0
  t2 = t2 >>> 0
  t3 = t3 >>> 0

  return [t0, t1, t2, t3]
}

// AES constants
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
var G = (function () {
  // Compute double table
  var d = new Array(256)
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1
    } else {
      d[j] = (j << 1) ^ 0x11b
    }
  }

  var SBOX = []
  var INV_SBOX = []
  var SUB_MIX = [[], [], [], []]
  var INV_SUB_MIX = [[], [], [], []]

  // Walk GF(2^8)
  var x = 0
  var xi = 0
  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    SBOX[x] = sx
    INV_SBOX[sx] = x

    // Compute multiplication
    var x2 = d[x]
    var x4 = d[x2]
    var x8 = d[x4]

    // Compute sub bytes, mix columns tables
    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    SUB_MIX[3][x] = t

    // Compute inv sub bytes, inv mix columns tables
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    INV_SUB_MIX[3][sx] = t

    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  }
})()

function AES (key) {
  this._key = asUInt32Array(key)
  this._reset()
}

AES.blockSize = 4 * 4
AES.keySize = 256 / 8
AES.prototype.blockSize = AES.blockSize
AES.prototype.keySize = AES.keySize
AES.prototype._reset = function () {
  var keyWords = this._key
  var keySize = keyWords.length
  var nRounds = keySize + 6
  var ksRows = (nRounds + 1) * 4

  var keySchedule = []
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k]
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1]

    if (k % keySize === 0) {
      t = (t << 8) | (t >>> 24)
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])

      t ^= RCON[(k / keySize) | 0] << 24
    } else if (keySize > 6 && k % keySize === 4) {
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t
  }

  var invKeySchedule = []
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt
    } else {
      invKeySchedule[ik] =
        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]
    }
  }

  this._nRounds = nRounds
  this._keySchedule = keySchedule
  this._invKeySchedule = invKeySchedule
}

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M)
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
}

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M)

  // swap
  var m1 = M[1]
  M[1] = M[3]
  M[3] = m1

  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule)
  scrubVec(this._invKeySchedule)
  scrubVec(this._key)
}

module.exports.AES = AES


/***/ }),

/***/ 3295:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aes = __webpack_require__(3296)
var Buffer = (__webpack_require__(442).Buffer)
var Transform = __webpack_require__(498)
var inherits = __webpack_require__(466)
var GHASH = __webpack_require__(3297)
var xor = __webpack_require__(3287)
var incr32 = __webpack_require__(3293)

function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) out++

  var len = Math.min(a.length, b.length)
  for (var i = 0; i < len; ++i) {
    out += (a[i] ^ b[i])
  }

  return out
}

function calcIv (self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])
  }
  var ghash = new GHASH(ck)
  var len = iv.length
  var toPad = len % 16
  ghash.update(iv)
  if (toPad) {
    toPad = 16 - toPad
    ghash.update(Buffer.alloc(toPad, 0))
  }
  ghash.update(Buffer.alloc(8, 0))
  var ivBits = len * 8
  var tail = Buffer.alloc(8)
  tail.writeUIntBE(ivBits, 0, 8)
  ghash.update(tail)
  self._finID = ghash.state
  var out = Buffer.from(self._finID)
  incr32(out)
  return out
}
function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  var h = Buffer.alloc(4, 0)

  this._cipher = new aes.AES(key)
  var ck = this._cipher.encryptBlock(h)
  this._ghash = new GHASH(ck)
  iv = calcIv(this, iv, ck)

  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  this._mode = mode

  this._authTag = null
  this._called = false
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = Buffer.alloc(rump, 0)
      this._ghash.update(rump)
    }
  }

  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

  this._authTag = tag
  this._cipher.scrub()
}

StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

  return this._authTag
}

StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

  this._authTag = tag
}

StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

  this._ghash.update(buf)
  this._alen += buf.length
}

module.exports = StreamCipher


/***/ }),

/***/ 3282:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var ciphers = __webpack_require__(3283)
var deciphers = __webpack_require__(3300)
var modes = __webpack_require__(3294)

function getCiphers () {
  return Object.keys(modes)
}

exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),

/***/ 3300:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var AuthCipher = __webpack_require__(3295)
var Buffer = (__webpack_require__(442).Buffer)
var MODES = __webpack_require__(3284)
var StreamCipher = __webpack_require__(3298)
var Transform = __webpack_require__(498)
var aes = __webpack_require__(3296)
var ebtk = __webpack_require__(3299)
var inherits = __webpack_require__(466)

function Decipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Decipher, Transform)

Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}

Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }

  return null
}

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache
}

function unpad (last) {
  var padded = last[15]
  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data')
  }
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) return

  return last.slice(0, 16 - padded)
}

function createDecipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true)
  }

  return new Decipher(config.module, password, iv)
}

function createDecipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}

exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv


/***/ }),

/***/ 3283:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var MODES = __webpack_require__(3284)
var AuthCipher = __webpack_require__(3295)
var Buffer = (__webpack_require__(442).Buffer)
var StreamCipher = __webpack_require__(3298)
var Transform = __webpack_require__(498)
var aes = __webpack_require__(3296)
var ebtk = __webpack_require__(3299)
var inherits = __webpack_require__(466)

function Cipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Cipher, Transform)

Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []

  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }

  return Buffer.concat(out)
}

var PADDING = Buffer.alloc(16, 0x10)

Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = Buffer.allocUnsafe(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }

  return Buffer.concat([this.cache, padBuff])
}

function createCipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv)
  }

  return new Cipher(config.module, password, iv)
}

function createCipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher


/***/ }),

/***/ 3297:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(442).Buffer)
var ZEROES = Buffer.alloc(16, 0)

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}

function fromArray (out) {
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0] >>> 0, 0)
  buf.writeUInt32BE(out[1] >>> 0, 4)
  buf.writeUInt32BE(out[2] >>> 0, 8)
  buf.writeUInt32BE(out[3] >>> 0, 12)
  return buf
}

function GHASH (key) {
  this.h = key
  this.state = Buffer.alloc(16, 0)
  this.cache = Buffer.allocUnsafe(0)
}

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vähä-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsbVi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0]
      Zi[1] ^= Vi[1]
      Zi[2] ^= Vi[2]
      Zi[3] ^= Vi[3]
    }

    // Store the value of LSB(V_i)
    lsbVi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsbVi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16))
  }

  this.ghash(fromArray([0, abl, 0, bl]))
  return this.state
}

module.exports = GHASH


/***/ }),

/***/ 3293:
/***/ ((module) => {

function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}
module.exports = incr32


/***/ }),

/***/ 3286:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var xor = __webpack_require__(3287)

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}


/***/ }),

/***/ 3288:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var Buffer = (__webpack_require__(442).Buffer)
var xor = __webpack_require__(3287)

function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0)
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = Buffer.allocUnsafe(0)
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}


/***/ }),

/***/ 3290:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var Buffer = (__webpack_require__(442).Buffer)

function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}

function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = Buffer.allocUnsafe(buffer.length)
  buffer = Buffer.concat([buffer, Buffer.from([value])])

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}


/***/ }),

/***/ 3289:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var Buffer = (__webpack_require__(442).Buffer)

function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam

  self._prev = Buffer.concat([
    self._prev.slice(1),
    Buffer.from([decrypt ? byteParam : out])
  ])

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}


/***/ }),

/***/ 3292:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var xor = __webpack_require__(3287)
var Buffer = (__webpack_require__(442).Buffer)
var incr32 = __webpack_require__(3293)

function getBlock (self) {
  var out = self._cipher.encryptBlockRaw(self._prev)
  incr32(self._prev)
  return out
}

var blockSize = 16
exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize)
  var start = self._cache.length
  self._cache = Buffer.concat([
    self._cache,
    Buffer.allocUnsafe(chunkNum * blockSize)
  ])
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self)
    var offset = start + i * blockSize
    self._cache.writeUInt32BE(out[0], offset + 0)
    self._cache.writeUInt32BE(out[1], offset + 4)
    self._cache.writeUInt32BE(out[2], offset + 8)
    self._cache.writeUInt32BE(out[3], offset + 12)
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}


/***/ }),

/***/ 3285:
/***/ ((__unused_webpack_module, exports) => {

exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}


/***/ }),

/***/ 3284:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var modeModules = {
  ECB: __webpack_require__(3285),
  CBC: __webpack_require__(3286),
  CFB: __webpack_require__(3288),
  CFB8: __webpack_require__(3289),
  CFB1: __webpack_require__(3290),
  OFB: __webpack_require__(3291),
  CTR: __webpack_require__(3292),
  GCM: __webpack_require__(3292)
}

var modes = __webpack_require__(3294)

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode]
}

module.exports = modes


/***/ }),

/***/ 3291:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(443)["Buffer"];
var xor = __webpack_require__(3287)

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}


/***/ }),

/***/ 3298:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aes = __webpack_require__(3296)
var Buffer = (__webpack_require__(442).Buffer)
var Transform = __webpack_require__(498)
var inherits = __webpack_require__(466)

function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._mode = mode
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}

StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

module.exports = StreamCipher


/***/ }),

/***/ 3287:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(443)["Buffer"];
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}


/***/ }),

/***/ 2933:
/***/ (function(module) {

var self = {};
(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    };

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue+','+value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) { items.push(name); });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) { items.push(value); });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) { items.push([name, value]); });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'omit';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  };

  function decode(body) {
    var form = new FormData();
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    rawHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = 'status' in options ? options.status : 200;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);
      var xhr = new XMLHttpRequest();

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  };
  self.fetch.polyfill = true;
})(typeof self !== 'undefined' ? self : this);

/*
 * Rollup wraps up the whatwg-fetch code on ponyfill mode in
 * order to prevent it from adding fetch to the global object.
 */

      var fetch = self.fetch;

      fetch.fetch = fetch;
      fetch.Response = self.Response;
      fetch.Headers = self.Headers;
      fetch.Request = self.Request;

      // fetch now can be imported as the default object
      module.exports = fetch;
    


/***/ }),

/***/ 2938:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* provided dependency */ var process = __webpack_require__(454)["process"];
// Only Node.JS has a process variable that is of [[Class]] process
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]');


/***/ }),

/***/ 3268:
/***/ ((module) => {

"use strict";
/**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */



function assign(target, firstSource) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object');
  }

  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) {
      continue;
    }

    var keysArray = Object.keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
      if (desc !== undefined && desc.enumerable) {
        to[nextKey] = nextSource[nextKey];
      }
    }
  }
  return to;
}

function polyfill() {
  if (!Object.assign) {
    Object.defineProperty(Object, 'assign', {
      enumerable: false,
      configurable: true,
      writable: true,
      value: assign
    });
  }
}

module.exports = {
  assign: assign,
  polyfill: polyfill
};


/***/ }),

/***/ 3299:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(442).Buffer)
var MD5 = __webpack_require__(467)

/* eslint-disable camelcase */
function EVP_BytesToKey (password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
  }

  var keyLen = keyBits / 8
  var key = Buffer.alloc(keyLen)
  var iv = Buffer.alloc(ivLen || 0)
  var tmp = Buffer.alloc(0)

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5()
    hash.update(tmp)
    hash.update(password)
    if (salt) hash.update(salt)
    tmp = hash.digest()

    var used = 0

    if (keyLen > 0) {
      var keyStart = key.length - keyLen
      used = Math.min(keyLen, tmp.length)
      tmp.copy(key, keyStart, 0, used)
      keyLen -= used
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen
      var length = Math.min(ivLen, tmp.length - used)
      tmp.copy(iv, ivStart, used, used + length)
      ivLen -= length
    }
  }

  tmp.fill(0)
  return { key: key, iv: iv }
}

module.exports = EVP_BytesToKey


/***/ }),

/***/ 3260:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isCallable = __webpack_require__(3261);

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

var forEach = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (toStr.call(list) === '[object Array]') {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};

module.exports = forEach;


/***/ }),

/***/ 2942:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

__webpack_require__(2943);

__webpack_require__(3019);

__webpack_require__(3040);

__webpack_require__(3041);

__webpack_require__(3042);

__webpack_require__(3052);

__webpack_require__(3054);

__webpack_require__(3057);

__webpack_require__(3065);

__webpack_require__(3066);

__webpack_require__(3072);

__webpack_require__(3076);

__webpack_require__(3078);

__webpack_require__(3080);

__webpack_require__(3083);

__webpack_require__(3085);

__webpack_require__(3088);

__webpack_require__(3089);

__webpack_require__(3090);

var _events = _interopRequireDefault(__webpack_require__(471));

var _cloneDeep = _interopRequireDefault(__webpack_require__(3092));

var _defaults = _interopRequireDefault(__webpack_require__(3109));

var _detectNode = _interopRequireDefault(__webpack_require__(2938));

var _debug = _interopRequireDefault(__webpack_require__(3110));

var _config = _interopRequireDefault(__webpack_require__(3112));

var _methods = _interopRequireDefault(__webpack_require__(3114));

var _utils = __webpack_require__(3115);

var _promisify = __webpack_require__(3218);

var _transports = _interopRequireDefault(__webpack_require__(3229));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var debugEmitters = (0, _debug.default)('golos:emitters');
var debugSetup = (0, _debug.default)('golos:setup');
var DEFAULTS = {
  id: 0
};

var Golos = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Golos, _EventEmitter);

  var _super = _createSuper(Golos);

  function Golos() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Golos);

    _this = _super.call(this, options);
    (0, _defaults.default)(options, DEFAULTS);
    _this.options = (0, _cloneDeep.default)(options);
    _this._streamDefaults = {
      mode: 'head',
      startBlock: 0
    };
    return _this;
  }

  _createClass(Golos, [{
    key: "_setTransport",
    value: function _setTransport(url) {
      if (url && url.match('^((http|https)?:\/\/)')) {
        this.transport = new _transports.default.http();
        this.url = url;
      } else if (url && url.match('^((ws|wss)?:\/\/)')) {
        this.transport = new _transports.default.ws();
        this.url = url;
      } else {
        throw Error("unknown transport! [" + url + "]");
      }
    }
  }, {
    key: "setWebSocket",
    value: function setWebSocket(url) {
      console.warn("golos.api.setWebSocket(url) is now deprecated instead use golos.config.set('websocket',url)");
      debugSetup('Setting WS', url);

      _config.default.set('websocket', url);

      this._setTransport(url);

      this.stop();
    }
  }, {
    key: "start",
    value: function start() {
      var url = _config.default.get('websocket');

      this._setTransport(url);

      return this.transport.start();
    }
  }, {
    key: "stop",
    value: function stop() {
      debugSetup('Stopping...');
      var ret = this.transport.stop();
      this.transport = null;
      this.url = null;
      return ret;
    }
  }, {
    key: "send",
    value: function send(api, data, callback) {
      debugSetup('Golos::send', api, data);

      if (!this.transport) {
        this.start();
      } else {
        var url = _config.default.get('websocket');

        if (url !== this.url) {
          debugSetup('websocket URL changed, restarting transport...');
          this.stop();
          this.start();
        }
      }

      return this.transport.send(api, data, callback);
    }
  }, {
    key: "callReliable",
    value: function callReliable(method) {
      var _this2 = this;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var callback = args[args.length - 1];
      var argsWithoutCb = args.slice(0, args.length - 1);
      this[method].apply(this, _toConsumableArray(argsWithoutCb).concat([function (err, result) {
        if (err || !result) {
          console.error(method + ' reliable call - fail, retrying... Cause:', err ? err.message : 'API returned null');
          setTimeout(function () {
            _this2.callReliable.apply(_this2, [method].concat(args));
          }, 1000);
          return;
        }

        callback(null, result);
      }]));
    }
  }, {
    key: "streamBlockNumber",
    value: function streamBlockNumber(options, callback) {
      var _this3 = this;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      (0, _defaults.default)(options, this._streamDefaults);
      var startBlock = options.startBlock;
      var prevBlock = 0;
      var running = true;

      var update = function update() {
        if (!running) return;

        _this3.callReliableAsync('getDynamicGlobalProperties').then(function (result) {
          var currentBlock = options.mode === 'irreversible' ? result.last_irreversible_block_num : result.head_block_number;
          if (!startBlock) startBlock = currentBlock;

          for (var i = startBlock; i <= currentBlock; i++) {
            var ret = callback(null, i);
            if (ret === true || !running) return;
          }

          startBlock = currentBlock + 1;
          setTimeout(function () {
            update();
          }, 1000);
        }, function (err) {
          callback(err);
        });
      };

      update();
      return function () {
        running = false;
      };
    }
  }, {
    key: "streamBlock",
    value: function streamBlock(options, callback) {
      var _this4 = this;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      (0, _defaults.default)(options, this._streamDefaults);
      var current = '';
      var last = '';
      var release = this.streamBlockNumber(options, function (err, id) {
        if (err) {
          release();
          callback(err);
          return;
        }

        current = id;

        if (current !== last) {
          last = current;

          _this4.callReliable('getBlock', current, function (err, res) {
            res.block_num = current;
            res.timestamp_prev = new Date(new Date(res.timestamp).getTime() - 3000).toISOString().split('.')[0];
            var ret = callback(err, res);
            if (ret === true) release();
          });
        }
      });
      return release;
    }
  }, {
    key: "streamTransactions",
    value: function streamTransactions(options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      (0, _defaults.default)(options, this._streamDefaults);
      var release = this.streamBlock(options, function (err, block) {
        if (err) {
          release();
          callback(err);
          return;
        }

        if (block && block.transactions) {
          block.transactions.forEach(function (transaction) {
            var ret = callback(null, transaction, block);
            if (ret === true) release();
          });
        }
      });
      return release;
    }
  }, {
    key: "streamOperations",
    value: function streamOperations() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      (0, _defaults.default)(options, this._streamDefaults);
      var release = this.streamTransactions(options, function (err, transaction, block) {
        if (err) {
          release();
          callback(err);
          return;
        }

        transaction.operations.forEach(function (operation) {
          var ret = callback(null, operation, transaction, block);
          if (ret === true) release();
        });
      });
      return release;
    }
  }, {
    key: "streamEvents",
    value: function streamEvents(options, callback) {
      var _this5 = this;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      (0, _defaults.default)(options, this._streamDefaults);
      var current = '';
      var last = '';
      var release = this.streamBlockNumber(options, function (err, id) {
        if (err) {
          release();
          callback(err);
          return;
        }

        current = id;

        if (current !== last) {
          last = current;

          _this5.callReliable('getEventsInBlock', current, false, function (err, res) {
            var _iterator = _createForOfIteratorHelper(res),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var eventMeta = _step.value;
                var ret = callback(err, eventMeta.op, eventMeta);
                if (ret === true) release();
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          });
        }
      });
      return release;
    }
  }]);

  return Golos;
}(_events.default); // Generate Methods from methods.js


_methods.default.forEach(function (method) {
  var methodName = method.method_name || (0, _utils.camelCase)(method.method);
  var methodParams = method.params || [];
  var defaultParms = {};
  var hasDefaultValues = method.has_default_values;

  if (hasDefaultValues) {
    methodParams.forEach(function (param) {
      var _param$split = param.split('='),
          _param$split2 = _slicedToArray(_param$split, 2),
          p = _param$split2[0],
          value = _param$split2[1];

      defaultParms[p] = value ? JSON.parse(value) : '';
    });
  }

  Golos.prototype["".concat(methodName, "With")] = function Golos$$specializedSendWith(options, callback) {
    var params = methodParams.map(function (param) {
      return options[hasDefaultValues ? param.split('=')[0] : param];
    });
    return this.send(method.api, {
      method: method.method,
      params: params
    }, callback);
  };

  Golos.prototype[methodName] = function Golos$specializedSend() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var options = {};

    if (hasDefaultValues) {
      var argsWithoutCb = args.slice(0, args.length - 1);
      methodParams.forEach(function (param, i) {
        var _param$split3 = param.split('='),
            _param$split4 = _slicedToArray(_param$split3, 2),
            p = _param$split4[0],
            value = _param$split4[1];

        if (argsWithoutCb[i]) {
          options[p] = argsWithoutCb[i];
        }
      });
      options = Object.assign({}, defaultParms, options);
    } else {
      var opt = methodParams.reduce(function (memo, param, i) {
        memo[param] = args[i];
        return memo;
      }, {});
      options = Object.assign({}, opt);
    }

    var callback = args[hasDefaultValues ? args.length - 1 : methodParams.length];
    return this["".concat(methodName, "With")](options, callback);
  };
});

(0, _promisify.promisifyAll)(Golos.prototype);

Golos.prototype['setBlockAppliedCallback'] = function Golos$setCallback(type, callback) {
  return this.send('database_api', {
    method: 'set_block_applied_callback',
    params: [type]
  }, callback);
};

Golos.prototype['setPendingTransactionCallback'] = function Golos$setCallback(callback) {
  return this.send('database_api', {
    method: 'set_pending_transaction_callback',
    params: []
  }, callback);
};

Golos.prototype['setPrivateMessageCallback'] = function Golos$setCallback(query, callback) {
  return this.send('private_message', {
    method: 'set_callback',
    params: [query]
  }, callback);
}; // Export singleton instance


var golos = new Golos();
exports = module.exports = golos;
exports.Golos = Golos;
exports.Golos.DEFAULTS = DEFAULTS;

/***/ }),

/***/ 3114:
/***/ ((module) => {

"use strict";


var MOST_RECENT = -1;
var ACCOUNT_HISTORY_DEFAULT_LIMIT = 100;
var DEFAULT_VOTES_LIMIT = 10000;
var DEFAULT_VOTES_OFFSET = 0;
var DEFAULT_MARKET_PAIR = '["GOLOS", "GBG"]';
var DEFAULT_ASSETS_LIMIT = 20;
var DEFAULT_BLOG_FEED_LIMIT = 500;
var EMPTY_STRING = '';
var EMPTY_ARRAY = '[]';
var EMPTY_OPTIONAL = null;
module.exports = [{
  "api": "witness_api",
  "method": "get_current_median_history_price"
}, {
  "api": "witness_api",
  "method": "get_feed_history"
}, {
  "api": "witness_api",
  "method": "get_miner_queue"
}, {
  "api": "witness_api",
  "method": "get_witness_schedule"
}, {
  "api": "witness_api",
  "method": "get_witnesses",
  "params": ["witnessIds"]
}, {
  "api": "witness_api",
  "method": "get_witness_by_account",
  "params": ["accountName"]
}, {
  "api": "witness_api",
  "method": "get_witness_votes",
  "has_default_values": true,
  "params": ["witnessIds", "limit=20", "offset=0", "min_rshares_to_show=\"0.000000 GESTS\""]
}, {
  "api": "witness_api",
  "method": "get_witnesses_by_vote",
  "params": ["from", "limit"]
}, {
  "api": "witness_api",
  "method": "get_witness_count"
}, {
  "api": "witness_api",
  "method": "lookup_witness_accounts",
  "params": ["lowerBoundName", "limit"]
}, {
  "api": "witness_api",
  "method": "get_active_witnesses"
}, {
  "api": "account_history",
  "method": "get_account_history",
  "has_default_values": true,
  "params": ["account", "from=".concat(MOST_RECENT), "limit=".concat(ACCOUNT_HISTORY_DEFAULT_LIMIT), "query={}"]
}, {
  "api": "operation_history",
  "method": "get_ops_in_block",
  "params": ["blockNum", "onlyVirtual"]
}, {
  "api": "operation_history",
  "method": "get_transaction",
  "params": ["trxId"]
}, {
  "api": "tags",
  "method": "get_trending_tags",
  "params": ["afterTag", "limit"]
}, {
  "api": "tags",
  "method": "get_tags",
  "params": ["tags"]
}, {
  "api": "tags",
  "method": "get_tags_used_by_author",
  "params": ["author"]
}, {
  "api": "tags",
  "method": "get_discussions_by_payout",
  "params": ["query"]
}, {
  "api": "tags",
  "method": "get_discussions_by_trending",
  "params": ["query"]
}, {
  "api": "tags",
  "method": "get_discussions_by_created",
  "params": ["query"]
}, {
  "api": "tags",
  "method": "get_discussions_by_active",
  "params": ["query"]
}, {
  "api": "tags",
  "method": "get_discussions_by_cashout",
  "params": ["query"]
}, {
  "api": "tags",
  "method": "get_discussions_by_votes",
  "params": ["query"]
}, {
  "api": "tags",
  "method": "get_discussions_by_children",
  "params": ["query"]
}, {
  "api": "tags",
  "method": "get_discussions_by_donates",
  "params": ["query"]
}, {
  "api": "tags",
  "method": "get_discussions_by_hot",
  "params": ["query"]
}, {
  "api": "tags",
  "method": "get_discussions_by_feed",
  "params": ["query"]
}, {
  "api": "tags",
  "method": "get_discussions_by_blog",
  "params": ["query"]
}, {
  "api": "tags",
  "method": "get_discussions_by_comments",
  "params": ["query"]
}, {
  "api": "tags",
  "method": "get_discussions_by_promoted",
  "params": ["query"]
}, {
  "api": "tags",
  "method": "get_discussions_by_author_before_date",
  "params": ["author", "startPermlink", "beforeDate", "limit"]
}, {
  "api": "tags",
  "method": "get_languages"
}, {
  "api": "social_network",
  "method": "get_replies_by_last_update",
  "has_default_values": true,
  "params": ["startAuthor", "startPermlink", "limit", "voteLimit=".concat(DEFAULT_VOTES_LIMIT), "voteOffset=".concat(DEFAULT_VOTES_OFFSET), "filterTagMasks=".concat(EMPTY_ARRAY)]
}, {
  "api": "social_network",
  "method": "get_all_discussions_by_active",
  "has_default_values": true,
  "params": ["startAuthor", "startPermlink", "from=0", "limit=20", "categories=".concat(EMPTY_ARRAY), "voteLimit=".concat(DEFAULT_VOTES_LIMIT), "voteOffset=".concat(DEFAULT_VOTES_OFFSET), "filterIds=".concat(EMPTY_ARRAY), "filterAuthors=".concat(EMPTY_ARRAY), "categoryPrefix=".concat(EMPTY_STRING)]
}, {
  "api": "social_network",
  "method": "get_content",
  "has_default_values": true,
  "params": ["author", "permlink", "voteLimit=".concat(DEFAULT_VOTES_LIMIT), "voteOffset=".concat(DEFAULT_VOTES_OFFSET)]
}, {
  "api": "social_network",
  "method": "get_content_replies",
  "has_default_values": true,
  "params": ["parent", "parentPermlink", "voteLimit=".concat(DEFAULT_VOTES_LIMIT), "voteOffset=".concat(DEFAULT_VOTES_OFFSET), "filterIds=".concat(EMPTY_ARRAY), "filterAuthors=".concat(EMPTY_ARRAY), "filterNegativeRepAuthors=false"]
}, {
  "api": "social_network",
  "method": "get_all_content_replies",
  "has_default_values": true,
  "params": ["parent", "parentPermlink", "voteLimit=".concat(DEFAULT_VOTES_LIMIT), "voteOffset=".concat(DEFAULT_VOTES_OFFSET), "filterIds=".concat(EMPTY_ARRAY), "filterAuthors=".concat(EMPTY_ARRAY), "filterNegativeRepAuthors=false", "sortByCreatedDesc=".concat(EMPTY_OPTIONAL) // use strings: 'true', 'false'. Non-string false is null
  ]
}, {
  "api": "social_network",
  "method": "get_last_reply",
  "has_default_values": true,
  "params": ["author", "permlink", "voteLimit=".concat(DEFAULT_VOTES_LIMIT), "voteOffset=".concat(DEFAULT_VOTES_OFFSET), "filterIds=".concat(EMPTY_ARRAY), "filterAuthors=".concat(EMPTY_ARRAY)]
}, {
  "api": "social_network",
  "method": "get_active_votes",
  "has_default_values": true,
  "params": ["author", "permlink", "voteLimit=".concat(DEFAULT_VOTES_LIMIT), "voteOffset=".concat(DEFAULT_VOTES_OFFSET)]
}, {
  "api": "social_network",
  "method": "get_account_votes",
  "params": ["voter", "from", "voteLimit"]
}, {
  "api": "social_network",
  "method": "get_donates",
  "params": ["uia", "target", "from", "to", "limit", "offset", "join_froms"]
}, {
  "api": "social_network",
  "method": "get_donates_for_targets",
  "params": ["targets", "limit", "offset", "join_froms"]
}, {
  "api": "database_api",
  "method": "get_block_header",
  "params": ["blockNum"]
}, {
  "api": "database_api",
  "method": "get_block",
  "params": ["blockNum"]
}, {
  "api": "database_api",
  "method": "get_config"
}, {
  "api": "database_api",
  "method": "get_dynamic_global_properties"
}, {
  "api": "database_api",
  "method": "get_chain_properties"
}, {
  "api": "database_api",
  "method": "get_hardfork_version"
}, {
  "api": "database_api",
  "method": "get_next_scheduled_hardfork"
}, {
  "api": "database_api",
  "method": "get_account_count"
}, {
  "api": "database_api",
  "method": "get_owner_history",
  "params": ["account"]
}, {
  "api": "database_api",
  "method": "get_recovery_request",
  "params": ["account"]
}, {
  "api": "database_api",
  "method": "get_recovery_info",
  "params": ["query"]
}, {
  "api": "database_api",
  "method": "get_escrow",
  "params": ["from", "escrowId"]
}, {
  "api": "database_api",
  "method": "get_withdraw_routes",
  "params": ["account", "withdrawRouteType"]
}, {
  "api": "database_api",
  "method": "get_account_bandwidth",
  "params": ["account", "bandwidthType"]
}, {
  "api": "database_api",
  "method": "get_savings_withdraw_from",
  "params": ["account"]
}, {
  "api": "database_api",
  "method": "get_savings_withdraw_to",
  "params": ["account"]
}, {
  "api": "database_api",
  "method": "get_conversion_requests",
  "params": ["accountName"]
}, {
  "api": "database_api",
  "method": "get_transaction_hex",
  "params": ["trx"]
}, {
  "api": "database_api",
  "method": "get_required_signatures",
  "params": ["trx", "availableKeys"]
}, {
  "api": "database_api",
  "method": "get_potential_signatures",
  "params": ["trx"]
}, {
  "api": "database_api",
  "method": "verify_authority",
  "params": ["trx"]
}, {
  "api": "database_api",
  "method": "verify_account_authority",
  "params": ["name", "signers"]
}, {
  "api": "database_api",
  "method": "get_accounts",
  "params": ["accountNames"]
}, {
  "api": "database_api",
  "method": "lookup_account_names",
  "params": ["accountNames"]
}, {
  "api": "database_api",
  "method": "lookup_accounts",
  "params": ["lowerBoundName", "limit"]
}, {
  "api": "database_api",
  "method": "get_proposed_transactions",
  "params": ["account", "from", "limit"]
}, {
  "api": "database_api",
  "method": "get_database_info"
}, {
  "api": "database_api",
  "method": "get_vesting_delegations",
  "params": ["account", "from", "limit", "type"]
}, {
  "api": "database_api",
  "method": "get_expiring_vesting_delegations",
  "params": ["account", "from", "limit"]
}, {
  "api": "database_api",
  "method": "get_invite",
  "params": ["invite_key"]
}, {
  "api": "database_api",
  "method": "get_assets",
  "has_default_values": true,
  "params": ["creator=".concat(EMPTY_STRING), "symbols=".concat(EMPTY_ARRAY), "from=".concat(EMPTY_STRING), "limit=".concat(DEFAULT_ASSETS_LIMIT), "sort=\"by_symbol_name\""]
}, {
  "api": "database_api",
  "method": "get_accounts_balances",
  "params": ['account_names']
}, {
  "api": "follow",
  "method": "get_followers",
  "params": ["following", "startFollower", "followType", "limit"]
}, {
  "api": "follow",
  "method": "get_following",
  "params": ["follower", "startFollowing", "followType", "limit"]
}, {
  "api": "follow",
  "method": "get_follow_count",
  "params": ["account"]
}, {
  "api": "follow",
  "method": "get_feed_entries",
  "has_default_values": true,
  "params": ["account", "entryId=0", "limit=".concat(DEFAULT_BLOG_FEED_LIMIT), "filterTagMasks=".concat(EMPTY_ARRAY)]
}, {
  "api": "follow",
  "method": "get_feed",
  "has_default_values": true,
  "params": ["account", "entryId=0", "limit=".concat(DEFAULT_BLOG_FEED_LIMIT), "filterTagMasks=".concat(EMPTY_ARRAY)]
}, {
  "api": "follow",
  "method": "get_blog_entries",
  "has_default_values": true,
  "params": ["account", "entryId=0", "limit=".concat(DEFAULT_BLOG_FEED_LIMIT), "filterTagMasks=".concat(EMPTY_ARRAY)]
}, {
  "api": "follow",
  "method": "get_blog",
  "has_default_values": true,
  "params": ["account", "entryId=0", "limit=".concat(DEFAULT_BLOG_FEED_LIMIT), "filterTagMasks=".concat(EMPTY_ARRAY)]
}, {
  "api": "follow",
  "method": "get_account_reputations",
  "params": ["names"]
}, {
  "api": "follow",
  "method": "get_reblogged_by",
  "params": ["author", "permlink"]
}, {
  "api": "follow",
  "method": "get_blog_authors",
  "params": ["blogAccount"]
}, {
  "api": "account_by_key",
  "method": "get_key_references",
  "params": ["account_name_type"]
}, {
  "api": "network_broadcast_api",
  "method": "broadcast_transaction",
  "params": ["trx"]
}, {
  "api": "network_broadcast_api",
  "method": "broadcast_transaction_with_callback",
  "params": ["confirmationCallback", "trx"]
}, {
  "api": "network_broadcast_api",
  "method": "broadcast_transaction_synchronous",
  "params": ["trx"]
}, {
  "api": "network_broadcast_api",
  "method": "broadcast_block",
  "params": ["block"]
}, {
  "api": "market_history",
  "method": "get_ticker",
  "has_default_values": true,
  "params": ["pair=".concat(DEFAULT_MARKET_PAIR)]
}, {
  "api": "market_history",
  "method": "get_volume",
  "has_default_values": true,
  "params": ["pair=".concat(DEFAULT_MARKET_PAIR)]
}, {
  "api": "market_history",
  "method": "get_depth",
  "has_default_values": true,
  "params": ["pair=".concat(DEFAULT_MARKET_PAIR)]
}, {
  "api": "market_history",
  "method": "get_order_book",
  "has_default_values": true,
  "params": ["limit", "pair=".concat(DEFAULT_MARKET_PAIR)]
}, {
  "api": "market_history",
  "has_default_values": true,
  "method": "get_order_book_extended",
  "params": ["limit", "pair=".concat(DEFAULT_MARKET_PAIR)]
}, {
  "api": "market_history",
  "has_default_values": true,
  "method": "get_trade_history",
  "params": ["start", "end", "limit", "pair=".concat(DEFAULT_MARKET_PAIR)]
}, {
  "api": "market_history",
  "method": "get_recent_trades",
  "has_default_values": true,
  "params": ["limit", "pair=".concat(DEFAULT_MARKET_PAIR)]
}, {
  "api": "market_history",
  "method": "get_market_history",
  "has_default_values": true,
  "params": ["bucket_seconds", "start", "end", "pair=".concat(DEFAULT_MARKET_PAIR)]
}, {
  "api": "market_history",
  "method": "get_market_history_buckets",
  "params": []
}, {
  "api": "market_history",
  "method": "get_open_orders",
  "has_default_values": true,
  "params": ["owner", "pair=".concat(DEFAULT_MARKET_PAIR)]
}, {
  "api": "market_history",
  "method": "get_fillable_orders",
  "params": ["market_price"]
}, {
  "api": "private_message",
  "method": "get_inbox",
  "params": ["to", "query"]
}, {
  "api": "private_message",
  "method": "get_outbox",
  "params": ["from", "query"]
}, {
  "api": "private_message",
  "method": "get_thread",
  "params": ["from", "to", "query"]
}, {
  "api": "private_message",
  "method": "get_settings",
  "method_name": "getPrivateMessagesSettings",
  "params": ["owner"]
}, {
  "api": "private_message",
  "method": "get_contacts_size",
  "params": ["owner"]
}, {
  "api": "private_message",
  "method": "get_contact_info",
  "params": ["owner", "contact"]
}, {
  "api": "private_message",
  "method": "get_contacts",
  "params": ["owner", "type", "limit", "offset"]
}, {
  "api": "worker_api",
  "method": "get_worker_requests",
  "params": ["query", "sort", "fill_posts"]
}, {
  "api": "worker_api",
  "method": "get_worker_request_votes",
  "params": ["author", "permlink", "start_voter", "limit"]
}, {
  "api": "account_notes",
  "method": "get_values_settings",
  "params": []
}, {
  "api": "account_notes",
  "method": "get_values",
  "has_default_values": true,
  "params": ["account", "keys=".concat(EMPTY_ARRAY)]
}, {
  "api": "event_plugin",
  "method": "get_events_in_block",
  "params": ["blockNum", "onlyVirtual"]
}];

/***/ }),

/***/ 3234:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

__webpack_require__(3083);

__webpack_require__(2943);

__webpack_require__(3019);

__webpack_require__(3040);

__webpack_require__(3041);

__webpack_require__(3042);

__webpack_require__(3052);

__webpack_require__(3054);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

__webpack_require__(3090);

__webpack_require__(3088);

var _events = _interopRequireDefault(__webpack_require__(471));

var _promisify = __webpack_require__(3218);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Transport = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Transport, _EventEmitter);

  var _super = _createSuper(Transport);

  function Transport() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Transport);

    _this = _super.call(this, options);
    _this.options = options;
    _this.id = 0;
    _this.releases = [];
    _this.requests = {};
    _this.callbacks = {};
    return _this;
  }

  _createClass(Transport, [{
    key: "setOptions",
    value: function setOptions(options) {
      Object.assign(this.options, options);
      this.stop();
    }
  }, {
    key: "listenTo",
    value: function listenTo(target, eventName, callback) {
      if (target.addEventListener) target.addEventListener(eventName, callback);else target.on(eventName, callback);
      return function () {
        if (target.removeEventListener) target.removeEventListener(eventName, callback);else target.removeListener(eventName, callback);
      };
    }
  }, {
    key: "send",
    value: function send() {}
  }, {
    key: "start",
    value: function start() {}
  }, {
    key: "stop",
    value: function stop() {}
  }]);

  return Transport;
}(_events.default);

exports["default"] = Transport;
(0, _promisify.promisifyAll)(Transport.prototype);

/***/ }),

/***/ 3236:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

__webpack_require__(3197);

__webpack_require__(2943);

__webpack_require__(3042);

__webpack_require__(3237);

__webpack_require__(3052);

__webpack_require__(3054);

__webpack_require__(3019);

__webpack_require__(3040);

__webpack_require__(3041);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.RPCError = void 0;
exports.jsonRpc = jsonRpc;

__webpack_require__(3065);

__webpack_require__(3078);

__webpack_require__(3090);

__webpack_require__(3083);

__webpack_require__(3118);

__webpack_require__(3088);

var _debug = _interopRequireDefault(__webpack_require__(3110));

var _config = _interopRequireDefault(__webpack_require__(3112));

var _base = _interopRequireDefault(__webpack_require__(3234));

var _promisify = __webpack_require__(3218);

var _fetchEx = _interopRequireDefault(__webpack_require__(3214));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var cbMethods = ['set_block_applied_callback', 'set_pending_transaction_callback', 'set_callback'];
var debugProtocol = (0, _debug.default)('golos:protocol');
var debugHttp = (0, _debug.default)('golos:http');

var RPCError = /*#__PURE__*/function (_Error) {
  _inherits(RPCError, _Error);

  var _super = _createSuper(RPCError);

  function RPCError(rpcError, rpcRes) {
    var _this;

    _classCallCheck(this, RPCError);

    _this = _super.call(this, rpcError.message);
    _this.name = 'RPCError';
    _this.code = rpcError.code;
    _this.data = rpcError.data;
    _this.resid = rpcRes.id;
    return _this;
  }

  return RPCError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports.RPCError = RPCError;

function jsonRpc(uri, _ref) {
  var method = _ref.method,
      id = _ref.id,
      params = _ref.params;
  var payload = {
    id: id,
    jsonrpc: '2.0',
    method: method,
    params: params
  };
  var req = {
    body: JSON.stringify(payload),
    method: 'post',
    mode: 'cors',
    headers: {
      Accept: 'application/json, text/plain, */*',
      'Content-Type': 'application/json'
    },
    timeout: _config.default.get('node_timeout')
  };
  req.credentials = _config.default.get('credentials');
  if (!req.credentials) delete req.credentials;
  return (0, _fetchEx.default)(uri, req).then(function (res) {
    if (!res.ok) {
      throw new Error("HTTP ".concat(res.status, ": ").concat(res.statusText));
    }

    return res.json();
  }).then(function (rpcRes) {
    if (rpcRes.id !== id) {
      throw new Error("Invalid response id: ".concat(rpcRes.id));
    }

    if (rpcRes.error) {
      throw new RPCError(rpcRes.error, rpcRes);
    }

    return rpcRes;
  });
}

var HttpTransport = /*#__PURE__*/function (_Transport) {
  _inherits(HttpTransport, _Transport);

  var _super2 = _createSuper(HttpTransport);

  function HttpTransport() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, HttpTransport);

    return _super2.call(this, Object.assign({
      id: 0
    }, options));
  }

  _createClass(HttpTransport, [{
    key: "send",
    value: function send(api, data, callback) {
      var id = data.id || this.id++;
      this.currentP = new Promise(function (resolve, reject) {
        var params = [api, data.method, data.params];

        var url = _config.default.get('websocket');

        jsonRpc(url, {
          method: 'call',
          id: id,
          params: params
        }).then(function (res) {
          resolve(res.result);
        }, function (err) {
          reject(err);
        });
      });
      this.currentP = (0, _promisify.nodeify)(this.currentP, callback);
      return this.currentP;
    }
  }]);

  return HttpTransport;
}(_base.default);

exports["default"] = HttpTransport;

/***/ }),

/***/ 3229:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _ws = _interopRequireDefault(__webpack_require__(3230));

var _http = _interopRequireDefault(__webpack_require__(3236));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = {
  ws: _ws.default,
  http: _http.default
};
exports["default"] = _default;

/***/ }),

/***/ 3230:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

__webpack_require__(2943);

__webpack_require__(3019);

__webpack_require__(3040);

__webpack_require__(3041);

__webpack_require__(3042);

__webpack_require__(3052);

__webpack_require__(3054);

__webpack_require__(3076);

__webpack_require__(3065);

__webpack_require__(3057);

__webpack_require__(3066);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

__webpack_require__(3090);

__webpack_require__(3083);

__webpack_require__(3118);

__webpack_require__(3231);

__webpack_require__(3078);

__webpack_require__(3085);

__webpack_require__(3233);

__webpack_require__(3088);

var _detectNode = _interopRequireDefault(__webpack_require__(2938));

var _debug = _interopRequireDefault(__webpack_require__(3110));

var _config = _interopRequireDefault(__webpack_require__(3112));

var _base = _interopRequireDefault(__webpack_require__(3234));

var _promisify = __webpack_require__(3218);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var cbMethods = ['set_block_applied_callback', 'set_pending_transaction_callback', 'set_callback'];
var WebSocket;

if (_detectNode.default) {
  WebSocket = __webpack_require__(3235); // eslint-disable-line global-require
} else if (typeof window !== 'undefined') {
  WebSocket = window.WebSocket;
} else {
  throw new Error('Couldn\'t decide on a `WebSocket` class');
}

var debugProtocol = (0, _debug.default)('golos:protocol');
var debugWs = (0, _debug.default)('golos:ws');

var WsTransport = /*#__PURE__*/function (_Transport) {
  _inherits(WsTransport, _Transport);

  var _super = _createSuper(WsTransport);

  function WsTransport() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, WsTransport);

    _this = _super.call(this, Object.assign({
      id: 0
    }, options));
    _this.isOpen = false;
    return _this;
  }

  _createClass(WsTransport, [{
    key: "start",
    value: function start() {
      var _this2 = this;

      if (this.startP) {
        return this.startP;
      }

      var startP = new Promise(function (resolve, reject) {
        if (startP !== _this2.startP) return;

        var url = _config.default.get('websocket');

        _this2.ws = new WebSocket(url);

        var releaseOpen = _this2.listenTo(_this2.ws, 'open', function () {
          debugWs('Opened WS connection with', url);
          _this2.isOpen = true;
          releaseOpen();
          resolve();
        });

        var errHandler = function errHandler() {
          var wasOpen = _this2.isOpen;
          _this2.isOpen = false;
          delete _this2.ws;

          _this2.stop();

          var err = new Error('The WS connection was closed before this operation was made');

          if (!wasOpen) {
            reject(err);
          }

          for (var _i = 0, _Object$entries = Object.entries(_this2.requests); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                id = _Object$entries$_i[0],
                val = _Object$entries$_i[1];

            delete _this2.requests[id];
            val.reject(err);
          }

          for (var _i2 = 0, _Object$entries2 = Object.entries(_this2.callbacks); _i2 < _Object$entries2.length; _i2++) {
            var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
                _id = _Object$entries2$_i[0],
                _val = _Object$entries2$_i[1];

            delete _this2.callbacks[_id];

            _val.cb(err, null);
          }
        };

        var releaseClose = _this2.listenTo(_this2.ws, 'close', function () {
          debugWs('Closed WS connection with', url);
          errHandler();
        });

        var releaseError = _this2.listenTo(_this2.ws, 'error', function (error) {
          debugWs('Closed WS connection with', url, 'error is', error);
          errHandler();
        });

        var releaseMessage = _this2.listenTo(_this2.ws, 'message', function (message) {
          debugWs('Received message', message.data);
          var data = JSON.parse(message.data);
          var id = data.id;
          var request = _this2.requests[id] || _this2.callbacks[id];

          if (!request) {
            debugWs('Golos.onMessage error: unknown request ', id);
            return;
          }

          delete _this2.requests[id];

          _this2.onMessage(data, request);
        });

        _this2.releases = _this2.releases.concat([releaseOpen, releaseClose, releaseError, releaseMessage]);
      });
      this.startP = startP;
      return startP;
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this.ws) this.ws.close();
      delete this.startP;
      delete this.ws;
      this.releases.forEach(function (release) {
        return release();
      });
      this.releases = [];
    }
  }, {
    key: "onMessage",
    value: function onMessage(message, request) {
      var api = request.api,
          data = request.data,
          resolve = request.resolve,
          reject = request.reject,
          start_time = request.start_time;
      debugWs('-- Golos.onMessage -->', message.id);
      var errorCause = message.error;

      if (errorCause) {
        var err = new Error( // eslint-disable-next-line prefer-template
        (errorCause.message || 'Failed to complete operation') + ' (see err.payload for the full error payload)');
        err.payload = message;
        reject(err);
        return;
      }

      debugProtocol('Resolved', api, data, '->', message);

      if (cbMethods.includes(data.method)) {
        this.callbacks[message.id].cb(null, message.result);
      } else {
        delete this.requests[message.id];
        resolve(message.result);
      }
    }
  }, {
    key: "send",
    value: function send(api, data, callback) {
      var _this3 = this;

      var id = data.id || this.id++;
      var startP = this.start();
      this.currentP = startP.then(function () {
        return new Promise(function (resolve, reject) {
          if (!_this3.ws) {
            reject(new Error('The WS connection was closed while this request was pending'));
            return;
          }

          var payload = JSON.stringify({
            id: id,
            method: 'call',
            jsonrpc: '2.0',
            params: [api, data.method, data.params]
          });
          debugWs('Sending message', payload);

          if (cbMethods.includes(data.method)) {
            _this3.callbacks[id] = {
              api: api,
              data: data,
              cb: callback
            };
          } else {
            _this3.requests[id] = {
              api: api,
              data: data,
              resolve: resolve,
              reject: reject,
              start_time: Date.now()
            };
          }

          _this3.ws.send(payload);
        });
      });
      this.currentP = (0, _promisify.nodeify)(this.currentP, callback);
      return this.currentP;
    }
  }]);

  return WsTransport;
}(_base.default);

exports["default"] = WsTransport;

/***/ }),

/***/ 3250:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = {
  Address: __webpack_require__(3251),
  Aes: __webpack_require__(3279),
  PrivateKey: __webpack_require__(3302),
  PublicKey: __webpack_require__(3301),
  Signature: __webpack_require__(3303),
  brainKey: __webpack_require__(3307),
  key_utils: __webpack_require__(3308),
  hash: __webpack_require__(3278),
  ecc_config: __webpack_require__(3112)
};

/***/ }),

/***/ 3251:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];


__webpack_require__(3078);

__webpack_require__(3076);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var assert = __webpack_require__(3252);

var config = __webpack_require__(3112);

var hash = __webpack_require__(3278);

var base58 = __webpack_require__(462);
/** Addresses are shortened non-reversable hashes of a public key.  The full PublicKey is preferred.
    @deprecated
*/


var Address = /*#__PURE__*/function () {
  function Address(addy) {
    _classCallCheck(this, Address);

    this.addy = addy;
  }

  _createClass(Address, [{
    key: "toBuffer",
    value: function toBuffer() {
      return this.addy;
    }
  }, {
    key: "toString",
    value: function toString() {
      var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : config.get('address_prefix');
      var checksum = hash.ripemd160(this.addy);
      var addy = Buffer.concat([this.addy, checksum.slice(0, 4)]);
      return address_prefix + base58.encode(addy);
    }
  }], [{
    key: "fromBuffer",
    value: function fromBuffer(buffer) {
      var _hash = hash.sha512(buffer);

      var addy = hash.ripemd160(_hash);
      return new Address(addy);
    }
  }, {
    key: "fromString",
    value: function fromString(string) {
      var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : config.get('address_prefix');
      var prefix = string.slice(0, address_prefix.length);
      assert.equal(address_prefix, prefix, "Expecting key to begin with ".concat(address_prefix, ", instead got ").concat(prefix));
      var addy = string.slice(address_prefix.length);
      addy = new Buffer(base58.decode(addy), 'binary');
      var checksum = addy.slice(-4);
      addy = addy.slice(0, -4);
      var new_checksum = hash.ripemd160(addy);
      new_checksum = new_checksum.slice(0, 4);
      assert.deepEqual(checksum, new_checksum, 'Checksum did not match');
      return new Address(addy);
    }
    /** @return Address - Compressed PTS format (by default) */

  }, {
    key: "fromPublic",
    value: function fromPublic(public_key) {
      var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 56;
      var sha2 = hash.sha256(public_key.toBuffer(compressed));
      var rep = hash.ripemd160(sha2);
      var versionBuffer = new Buffer(1);
      versionBuffer.writeUInt8(0xFF & version, 0);
      var addr = Buffer.concat([versionBuffer, rep]);
      var check = hash.sha256(addr);
      check = hash.sha256(check);
      var buffer = Buffer.concat([addr, check.slice(0, 4)]);
      return new Address(hash.ripemd160(buffer));
    }
  }]);

  return Address;
}();

module.exports = Address;

/***/ }),

/***/ 3279:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decrypt = decrypt;
exports.encrypt = encrypt;

__webpack_require__(3083);

__webpack_require__(3197);

__webpack_require__(3076);

__webpack_require__(3078);

var _secureRandom = _interopRequireDefault(__webpack_require__(3280));

var _bytebuffer = _interopRequireDefault(__webpack_require__(439));

var _browserifyAes = _interopRequireDefault(__webpack_require__(3282));

var _assert = _interopRequireDefault(__webpack_require__(3252));

var _key_public = _interopRequireDefault(__webpack_require__(3301));

var _key_private = _interopRequireDefault(__webpack_require__(3302));

var _hash = _interopRequireDefault(__webpack_require__(3278));

var _core = __webpack_require__(3117);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Long = _bytebuffer.default.Long;
/**
    Spec: http://localhost:3002/steem/@dantheman/how-to-encrypt-a-memo-when-transferring-steem
    @throws {Error|TypeError} - "Invalid Key, ..."
    @arg {PrivateKey|Uint8Array} private_key - required and used for decryption. If you have many messages to decrypt, it is faster to pass prepared shared_secret, instead of private_key
    @arg {PublicKey} public_key - required (if private_key_or_shared_secret is not a shared secret) and used to calculate the shared secret
    @arg {string} [nonce = uniqueNonce()] - assigned a random unique uint64

    @return {object}
    @property {string} nonce - random or unique uint64, provides entropy when re-using the same private/public keys.
    @property {Buffer} message - Plain text message
    @property {number} checksum - shared secret checksum
*/

function encrypt(private_key_or_shared_secret, public_key, message) {
  var nonce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : uniqueNonce();
  return crypt(private_key_or_shared_secret, public_key, nonce, message);
}
/**
    Spec: http://localhost:3002/steem/@dantheman/how-to-encrypt-a-memo-when-transferring-steem
    @arg {PrivateKey|Uint8Array} private_key_or_shared_secret - required and used for decryption. If you have many messages to decrypt, it is faster to pass prepared shared_secret, instead of private_key
    @arg {PublicKey} public_key - required (if private_key_or_shared_secret is not a shared secret) and used to calculate the shared secret
    @arg {string} nonce - random or unique uint64, provides entropy when re-using the same private/public keys.
    @arg {Buffer} message - Encrypted or plain text message
    @arg {number} checksum - shared secret checksum
    @throws {Error|TypeError} - "Invalid Key, ..."
    @return {Buffer} - message
*/


function decrypt(private_key_or_shared_secret, public_key, nonce, message, checksum) {
  return crypt(private_key_or_shared_secret, public_key, nonce, message, checksum).message;
}
/**
    @arg {Buffer} message - Encrypted or plain text message (see checksum)
    @arg {number} checksum - shared secret checksum (null to encrypt, non-null to decrypt)
*/


function crypt(private_key_or_shared_secret, public_key, nonce, message, checksum) {
  var shared_secret;

  if (!private_key_or_shared_secret.d && typeof private_key_or_shared_secret !== 'string') {
    shared_secret = private_key_or_shared_secret;
  } else {
    var private_key = toPrivateObj(private_key_or_shared_secret);
    if (!private_key) throw new TypeError('private_key is required');
    public_key = toPublicObj(public_key);
    if (!public_key) throw new TypeError('public_key is required');
    shared_secret = private_key.get_shared_secret(public_key);
  }

  nonce = toLongObj(nonce);
  if (!nonce) throw new TypeError('nonce is required');

  if (!Buffer.isBuffer(message)) {
    if (typeof message !== 'string') throw new TypeError('message should be buffer or string');
    message = new Buffer(message, 'binary');
  }

  if (checksum && typeof checksum !== 'number') throw new TypeError('checksum should be a number');
  var ebuf = new _bytebuffer.default(_bytebuffer.default.DEFAULT_CAPACITY, _bytebuffer.default.LITTLE_ENDIAN);
  ebuf.writeUint64(nonce);
  ebuf.append(shared_secret.toString('binary'), 'binary');
  ebuf = new Buffer(ebuf.copy(0, ebuf.offset).toBinary(), 'binary');

  var encryption_key = _hash.default.sha512(ebuf); // D E B U G
  // console.log('crypt', {
  //     priv_to_pub: private_key.toPublicKey().toString(),
  //     pub: public_key.toString(),
  //     nonce: nonce.toString(),
  //     message: message.length,
  //     checksum,
  //     shared_secret: shared_secret.toString('hex'),
  //     encryption_key: encryption_key.toString('hex'),
  // })


  var iv = encryption_key.slice(32, 48);
  var key = encryption_key.slice(0, 32); // check is first 64 bit of sha256 hash treated as uint64_t truncated to 32 bits.

  var check = _hash.default.sha256(encryption_key);

  check = check.slice(0, 4);

  var cbuf = _bytebuffer.default.fromBinary(check.toString('binary'), _bytebuffer.default.DEFAULT_CAPACITY, _bytebuffer.default.LITTLE_ENDIAN);

  check = cbuf.readUint32();

  if (checksum) {
    (0, _core.assertNativeLib)('Aes.decrypt()');
    if (check !== checksum) throw new Error('Invalid key');
    message = Buffer.from((0, _core.aes_decrypt)(key, iv, message));
  } else {
    message = cryptoJsEncrypt(message, key, iv);
  }

  return {
    nonce: nonce,
    message: message,
    checksum: check
  };
}
/** This method does not use a checksum, the returned data must be validated some other way.
    @arg {string|Buffer} plaintext - binary format
    @return {Buffer} binary
*/


function cryptoJsEncrypt(message, key, iv) {
  (0, _assert.default)(message, "Missing plain text");
  message = toBinaryBuffer(message);

  var cipher = _browserifyAes.default.createCipheriv('aes-256-cbc', key, iv); // cipher.setAutoPadding(true)


  message = Buffer.concat([cipher.update(message), cipher.final()]);
  return message;
}
/** @return {string} unique 64 bit unsigned number string.  Being time based, this is careful to never choose the same nonce twice.  This value could be recorded in the blockchain for a long time.
*/


function uniqueNonce() {
  if (unique_nonce_entropy === null) {
    var b = _secureRandom.default.randomUint8Array(2);

    unique_nonce_entropy = parseInt(b[0] << 8 | b[1], 10);
  }

  var long = Long.fromNumber(Date.now());
  var entropy = ++unique_nonce_entropy % 0xFFFF; // console.log('uniqueNonce date\t', ByteBuffer.allocate(8).writeUint64(long).toHex(0))
  // console.log('uniqueNonce entropy\t', ByteBuffer.allocate(8).writeUint64(Long.fromNumber(entropy)).toHex(0))

  long = long.shiftLeft(16).or(Long.fromNumber(entropy)); // console.log('uniqueNonce final\t', ByteBuffer.allocate(8).writeUint64(long).toHex(0))

  return long.toString();
}

var unique_nonce_entropy = null; // for(let i=1; i < 10; i++) key.uniqueNonce()

var toPrivateObj = function toPrivateObj(o) {
  return o ? o.d ? o : _key_private.default.fromWif(o) : o
  /*null or undefined*/
  ;
};

var toPublicObj = function toPublicObj(o) {
  return o ? o.Q ? o : _key_public.default.fromString(o) : o
  /*null or undefined*/
  ;
};

var toLongObj = function toLongObj(o) {
  return o ? Long.isLong(o) ? o : Long.fromString(o) : o;
};

var toBinaryBuffer = function toBinaryBuffer(o) {
  return o ? Buffer.isBuffer(o) ? o : new Buffer(o, 'binary') : o;
};

/***/ }),

/***/ 3307:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.normalize = normalize;

__webpack_require__(3243);

__webpack_require__(3242);

__webpack_require__(3066);

__webpack_require__(3080);

function normalize(brain_key) {
  if (typeof brain_key !== 'string') {
    throw new Error("string required for brain_key");
  }

  brain_key = brain_key.trim();
  return brain_key.split(/[\t\n\v\f\r ]+/).join(' ');
}

/***/ }),

/***/ 3304:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];


__webpack_require__(3078);

__webpack_require__(3201);

var assert = __webpack_require__(3252); // from github.com/bitcoinjs/bitcoinjs-lib from github.com/cryptocoinjs/ecdsa


var crypto = __webpack_require__(3278);

var enforceType = __webpack_require__(3305);

var BigInteger = __webpack_require__(448);

var ECSignature = __webpack_require__(3306); // https://tools.ietf.org/html/rfc6979#section-3.2


function deterministicGenerateK(curve, hash, d, checkSig, nonce) {
  enforceType('Buffer', hash);
  enforceType(BigInteger, d);

  if (nonce) {
    hash = crypto.sha256(Buffer.concat([hash, new Buffer(nonce)]));
  } // sanity check


  assert.equal(hash.length, 32, 'Hash must be 256 bit');
  var x = d.toBuffer(32);
  var k = new Buffer(32);
  var v = new Buffer(32); // Step B

  v.fill(1); // Step C

  k.fill(0); // Step D

  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0]), x, hash]), k); // Step E

  v = crypto.HmacSHA256(v, k); // Step F

  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([1]), x, hash]), k); // Step G

  v = crypto.HmacSHA256(v, k); // Step H1/H2a, ignored as tlen === qlen (256 bit)
  // Step H2b

  v = crypto.HmacSHA256(v, k);
  var T = BigInteger.fromBuffer(v); // Step H3, repeat until T is within the interval [1, n - 1]

  while (T.signum() <= 0 || T.compareTo(curve.n) >= 0 || !checkSig(T)) {
    k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0])]), k);
    v = crypto.HmacSHA256(v, k); // Step H1/H2a, again, ignored as tlen === qlen (256 bit)
    // Step H2b again

    v = crypto.HmacSHA256(v, k);
    T = BigInteger.fromBuffer(v);
  }

  return T;
}

function sign(curve, hash, d, nonce) {
  var e = BigInteger.fromBuffer(hash);
  var n = curve.n;
  var G = curve.G;
  var r, s;
  var k = deterministicGenerateK(curve, hash, d, function (k) {
    // find canonically valid signature
    var Q = G.multiply(k);
    if (curve.isInfinity(Q)) return false;
    r = Q.affineX.mod(n);
    if (r.signum() === 0) return false;
    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);
    if (s.signum() === 0) return false;
    return true;
  }, nonce);
  var N_OVER_TWO = n.shiftRight(1); // enforce low S values, see bip62: 'low s values in signatures'

  if (s.compareTo(N_OVER_TWO) > 0) {
    s = n.subtract(s);
  }

  return new ECSignature(r, s);
}

function verifyRaw(curve, e, signature, Q) {
  var n = curve.n;
  var G = curve.G;
  var r = signature.r;
  var s = signature.s; // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1]

  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false;
  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false; // c = s^-1 mod n

  var c = s.modInverse(n); // 1.4.4 Compute u1 = es^−1 mod n
  //               u2 = rs^−1 mod n

  var u1 = e.multiply(c).mod(n);
  var u2 = r.multiply(c).mod(n); // 1.4.5 Compute R = (xR, yR) = u1G + u2Q

  var R = G.multiplyTwo(u1, Q, u2); // 1.4.5 (cont.) Enforce R is not at infinity

  if (curve.isInfinity(R)) return false; // 1.4.6 Convert the field element R.x to an integer

  var xR = R.affineX; // 1.4.7 Set v = xR mod n

  var v = xR.mod(n); // 1.4.8 If v = r, output "valid", and if v != r, output "invalid"

  return v.equals(r);
}

function verify(curve, hash, signature, Q) {
  // 1.4.2 H = Hash(M), already done by the user
  // 1.4.3 e = H
  var e = BigInteger.fromBuffer(hash);
  return verifyRaw(curve, e, signature, Q);
}
/**
  * Recover a public key from a signature.
  *
  * See SEC 1: Elliptic Curve Cryptography, section 4.1.6, "Public
  * Key Recovery Operation".
  *
  * http://www.secg.org/download/aid-780/sec1-v2.pdf
  */


function recoverPubKey(curve, e, signature, i) {
  assert.strictEqual(i & 3, i, 'Recovery param is more than two bits');
  var n = curve.n;
  var G = curve.G;
  var r = signature.r;
  var s = signature.s;
  assert(r.signum() > 0 && r.compareTo(n) < 0, 'Invalid r value');
  assert(s.signum() > 0 && s.compareTo(n) < 0, 'Invalid s value'); // A set LSB signifies that the y-coordinate is odd

  var isYOdd = i & 1; // The more significant bit specifies whether we should use the
  // first or second candidate key.

  var isSecondKey = i >> 1; // 1.1 Let x = r + jn

  var x = isSecondKey ? r.add(n) : r;
  var R = curve.pointFromX(isYOdd, x); // 1.4 Check that nR is at infinity

  var nR = R.multiply(n);
  assert(curve.isInfinity(nR), 'nR is not a valid curve point'); // Compute -e from e

  var eNeg = e.negate().mod(n); // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)

  var rInv = r.modInverse(n);
  var Q = R.multiplyTwo(s, G, eNeg).multiply(rInv);
  curve.validate(Q);
  return Q;
}
/**
  * Calculate pubkey extraction parameter.
  *
  * When extracting a pubkey from a signature, we have to
  * distinguish four different cases. Rather than putting this
  * burden on the verifier, Bitcoin includes a 2-bit value with the
  * signature.
  *
  * This function simply tries all four cases and returns the value
  * that resulted in a successful pubkey recovery.
  */


function calcPubKeyRecoveryParam(curve, e, signature, Q) {
  for (var i = 0; i < 4; i++) {
    var Qprime = recoverPubKey(curve, e, signature, i); // 1.6.2 Verify Q

    if (Qprime.equals(Q)) {
      return i;
    }
  }

  throw new Error('Unable to find valid recovery factor');
}

module.exports = {
  calcPubKeyRecoveryParam: calcPubKeyRecoveryParam,
  deterministicGenerateK: deterministicGenerateK,
  recoverPubKey: recoverPubKey,
  sign: sign,
  verify: verify,
  verifyRaw: verifyRaw
};

/***/ }),

/***/ 3306:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];


__webpack_require__(3076);

__webpack_require__(3078);

var assert = __webpack_require__(3252); // from https://github.com/bitcoinjs/bitcoinjs-lib


var enforceType = __webpack_require__(3305);

var BigInteger = __webpack_require__(448);

function ECSignature(r, s) {
  enforceType(BigInteger, r);
  enforceType(BigInteger, s);
  this.r = r;
  this.s = s;
} // Import operations


ECSignature.parseCompact = function (buffer) {
  assert.equal(buffer.length, 65, 'Invalid signature length');
  var i = buffer.readUInt8(0) - 27; // At most 3 bits

  assert.equal(i, i & 7, 'Invalid signature parameter');
  var compressed = !!(i & 4); // Recovery param only

  i = i & 3;
  var r = BigInteger.fromBuffer(buffer.slice(1, 33));
  var s = BigInteger.fromBuffer(buffer.slice(33));
  return {
    compressed: compressed,
    i: i,
    signature: new ECSignature(r, s)
  };
};

ECSignature.fromDER = function (buffer) {
  assert.equal(buffer.readUInt8(0), 0x30, 'Not a DER sequence');
  assert.equal(buffer.readUInt8(1), buffer.length - 2, 'Invalid sequence length');
  assert.equal(buffer.readUInt8(2), 0x02, 'Expected a DER integer');
  var rLen = buffer.readUInt8(3);
  assert(rLen > 0, 'R length is zero');
  var offset = 4 + rLen;
  assert.equal(buffer.readUInt8(offset), 0x02, 'Expected a DER integer (2)');
  var sLen = buffer.readUInt8(offset + 1);
  assert(sLen > 0, 'S length is zero');
  var rB = buffer.slice(4, offset);
  var sB = buffer.slice(offset + 2);
  offset += 2 + sLen;

  if (rLen > 1 && rB.readUInt8(0) === 0x00) {
    assert(rB.readUInt8(1) & 0x80, 'R value excessively padded');
  }

  if (sLen > 1 && sB.readUInt8(0) === 0x00) {
    assert(sB.readUInt8(1) & 0x80, 'S value excessively padded');
  }

  assert.equal(offset, buffer.length, 'Invalid DER encoding');
  var r = BigInteger.fromDERInteger(rB);
  var s = BigInteger.fromDERInteger(sB);
  assert(r.signum() >= 0, 'R value is negative');
  assert(s.signum() >= 0, 'S value is negative');
  return new ECSignature(r, s);
}; // FIXME: 0x00, 0x04, 0x80 are SIGHASH_* boundary constants, importing Transaction causes a circular dependency


ECSignature.parseScriptSignature = function (buffer) {
  var hashType = buffer.readUInt8(buffer.length - 1);
  var hashTypeMod = hashType & ~0x80;
  assert(hashTypeMod > 0x00 && hashTypeMod < 0x04, 'Invalid hashType');
  return {
    signature: ECSignature.fromDER(buffer.slice(0, -1)),
    hashType: hashType
  };
}; // Export operations


ECSignature.prototype.toCompact = function (i, compressed) {
  if (compressed) i += 4;
  i += 27;
  var buffer = new Buffer(65);
  buffer.writeUInt8(i, 0);
  this.r.toBuffer(32).copy(buffer, 1);
  this.s.toBuffer(32).copy(buffer, 33);
  return buffer;
};

ECSignature.prototype.toDER = function () {
  var rBa = this.r.toDERInteger();
  var sBa = this.s.toDERInteger();
  var sequence = []; // INTEGER

  sequence.push(0x02, rBa.length);
  sequence = sequence.concat(rBa); // INTEGER

  sequence.push(0x02, sBa.length);
  sequence = sequence.concat(sBa); // SEQUENCE

  sequence.unshift(0x30, sequence.length);
  return new Buffer(sequence);
};

ECSignature.prototype.toScriptSignature = function (hashType) {
  var hashTypeBuffer = new Buffer(1);
  hashTypeBuffer.writeUInt8(hashType, 0);
  return Buffer.concat([this.toDER(), hashTypeBuffer]);
};

module.exports = ECSignature;

/***/ }),

/***/ 3305:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];


__webpack_require__(3066);

__webpack_require__(3072);

__webpack_require__(3083);

__webpack_require__(3197);

module.exports = function enforce(type, value) {
  // Copied from https://github.com/bitcoinjs/bitcoinjs-lib
  switch (type) {
    case 'Array':
      {
        if (Array.isArray(value)) return;
        break;
      }

    case 'Boolean':
      {
        if (typeof value === 'boolean') return;
        break;
      }

    case 'Buffer':
      {
        if (Buffer.isBuffer(value)) return;
        break;
      }

    case 'Number':
      {
        if (typeof value === 'number') return;
        break;
      }

    case 'String':
      {
        if (typeof value === 'string') return;
        break;
      }

    default:
      {
        if (getName(value.constructor) === getName(type)) return;
      }
  }

  throw new TypeError('Expected ' + (getName(type) || type) + ', got ' + value);
};

function getName(fn) {
  // Why not fn.name: https://kangax.github.io/compat-table/es6/#function_name_property
  var match = fn.toString().match(/function (.*?)\(/);
  return match ? match[1] : null;
}

/***/ }),

/***/ 3278:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _createHash = _interopRequireDefault(__webpack_require__(465));

var _createHmac = _interopRequireDefault(__webpack_require__(518));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
function sha1(data, encoding) {
  return (0, _createHash.default)('sha1').update(data).digest(encoding);
}
/** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/


function sha256(data, encoding) {
  return (0, _createHash.default)('sha256').update(data).digest(encoding);
}
/** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/


function sha512(data, encoding) {
  return (0, _createHash.default)('sha512').update(data).digest(encoding);
}

function HmacSHA256(buffer, secret) {
  return (0, _createHmac.default)('sha256', secret).update(buffer).digest();
}

function ripemd160(data) {
  return (0, _createHash.default)('rmd160').update(data).digest();
} // function hash160(buffer) {
//   return ripemd160(sha256(buffer))
// }
// 
// function hash256(buffer) {
//   return sha256(sha256(buffer))
// }
// 
// function HmacSHA512(buffer, secret) {
//   return crypto.createHmac('sha512', secret).update(buffer).digest()
// }


module.exports = {
  sha1: sha1,
  sha256: sha256,
  sha512: sha512,
  HmacSHA256: HmacSHA256,
  ripemd160: ripemd160 // hash160: hash160,
  // hash256: hash256,
  // HmacSHA512: HmacSHA512

};

/***/ }),

/***/ 3302:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];


__webpack_require__(3078);

__webpack_require__(3076);

__webpack_require__(3083);

__webpack_require__(3197);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ecurve = __webpack_require__(457);

var Point = ecurve.Point;
var secp256k1 = ecurve.getCurveByName('secp256k1');

var BigInteger = __webpack_require__(448);

var base58 = __webpack_require__(462);

var assert = __webpack_require__(3252);

var hash = __webpack_require__(3278);

var PublicKey = __webpack_require__(3301);

var G = secp256k1.G;
var n = secp256k1.n;

var PrivateKey = /*#__PURE__*/function () {
  /**
      @private see static functions
      @param {BigInteger}
  */
  function PrivateKey(d) {
    _classCallCheck(this, PrivateKey);

    this.d = d;
  }

  _createClass(PrivateKey, [{
    key: "toWif",
    value: function toWif() {
      var private_key = this.toBuffer(); // checksum includes the version

      private_key = Buffer.concat([new Buffer([0x80]), private_key]);
      var checksum = hash.sha256(private_key);
      checksum = hash.sha256(checksum);
      checksum = checksum.slice(0, 4);
      var private_wif = Buffer.concat([private_key, checksum]);
      return base58.encode(private_wif);
    }
    /** Alias for {@link toWif} */

  }, {
    key: "toString",
    value: function toString() {
      return this.toWif();
    }
    /**
        @return {Point}
    */

  }, {
    key: "toPublicKeyPoint",
    value: function toPublicKeyPoint() {
      var Q;
      return Q = secp256k1.G.multiply(this.d);
    }
  }, {
    key: "toPublic",
    value: function toPublic() {
      if (this.public_key) {
        return this.public_key;
      }

      return this.public_key = PublicKey.fromPoint(this.toPublicKeyPoint());
    }
  }, {
    key: "toBuffer",
    value: function toBuffer() {
      return this.d.toBuffer(32);
    }
    /** ECIES */

  }, {
    key: "get_shared_secret",
    value: function get_shared_secret(public_key) {
      public_key = toPublic(public_key);
      var KB = public_key.toUncompressed().toBuffer();
      var KBP = Point.fromAffine(secp256k1, BigInteger.fromBuffer(KB.slice(1, 33)), // x
      BigInteger.fromBuffer(KB.slice(33, 65)) // y
      );
      var r = this.toBuffer();
      var P = KBP.multiply(BigInteger.fromBuffer(r));
      var S = P.affineX.toBuffer({
        size: 32
      }); // SHA512 used in ECIES

      return hash.sha512(S);
    } // /** ECIES (does not always match the Point.fromAffine version above) */
    // get_shared_secret(public_key){
    //     public_key = toPublic(public_key)
    //     var P = public_key.Q.multiply( this.d );
    //     var S = P.affineX.toBuffer({size: 32});
    //     // ECIES, adds an extra sha512
    //     return hash.sha512(S);
    // }

    /** @throws {Error} - overflow of the key could not be derived */

  }, {
    key: "child",
    value: function child(offset) {
      offset = Buffer.concat([this.toPublicKey().toBuffer(), offset]);
      offset = hash.sha256(offset);
      var c = BigInteger.fromBuffer(offset);
      if (c.compareTo(n) >= 0) throw new Error("Child offset went out of bounds, try again");
      var derived = this.d.add(c); //.mod(n)

      if (derived.signum() === 0) throw new Error("Child offset derived to an invalid key, try again");
      return new PrivateKey(derived);
    } // toByteBuffer() {
    //     var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
    //     this.appendByteBuffer(b);
    //     return b.copy(0, b.offset);
    // }

  }, {
    key: "toHex",
    value: function toHex() {
      return this.toBuffer().toString('hex');
    }
  }, {
    key: "toPublicKey",
    value: function toPublicKey() {
      return this.toPublic();
    }
    /* </helper_functions> */

  }], [{
    key: "fromBuffer",
    value: function fromBuffer(buf) {
      if (!Buffer.isBuffer(buf)) {
        throw new Error("Expecting paramter to be a Buffer type");
      }

      if (32 !== buf.length) {
        console.log("WARN: Expecting 32 bytes, instead got ".concat(buf.length, ", stack trace:"), new Error().stack);
      }

      if (buf.length === 0) {
        throw new Error("Empty buffer");
      }

      return new PrivateKey(BigInteger.fromBuffer(buf));
    }
    /** @arg {string} seed - any length string.  This is private, the same seed produces the same private key every time.  */

  }, {
    key: "fromSeed",
    value: function fromSeed(seed) {
      // generate_private_key
      if (!(typeof seed === 'string')) {
        throw new Error('seed must be of type string');
      }

      return PrivateKey.fromBuffer(hash.sha256(seed));
    }
  }, {
    key: "isWif",
    value: function isWif(text) {
      try {
        this.fromWif(text);
        return true;
      } catch (e) {
        return false;
      }
    }
    /**
        @throws {AssertError|Error} parsing key
        @return {string} Wallet Import Format (still a secret, Not encrypted)
    */

  }, {
    key: "fromWif",
    value: function fromWif(_private_wif) {
      var private_wif = new Buffer(base58.decode(_private_wif));
      var version = private_wif.readUInt8(0);
      assert.equal(0x80, version, "Expected version ".concat(0x80, ", instead got ", version)); // checksum includes the version

      var private_key = private_wif.slice(0, -4);
      var checksum = private_wif.slice(-4);
      var new_checksum = hash.sha256(private_key);
      new_checksum = hash.sha256(new_checksum);
      new_checksum = new_checksum.slice(0, 4);
      if (checksum.toString() !== new_checksum.toString()) throw new Error('Invalid WIF key (checksum miss-match)');
      private_key = private_key.slice(1);
      return PrivateKey.fromBuffer(private_key);
    }
  }, {
    key: "fromHex",
    value: function fromHex(hex) {
      return PrivateKey.fromBuffer(new Buffer(hex, 'hex'));
    }
  }]);

  return PrivateKey;
}();

module.exports = PrivateKey;

var toPublic = function toPublic(data) {
  return data == null ? data : data.Q ? data : PublicKey.fromStringOrThrow(data);
};

/***/ }),

/***/ 3301:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];


__webpack_require__(3078);

__webpack_require__(3076);

__webpack_require__(3083);

__webpack_require__(3197);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var BigInteger = __webpack_require__(448);

var ecurve = __webpack_require__(457);

var secp256k1 = ecurve.getCurveByName('secp256k1');
BigInteger = __webpack_require__(448);

var base58 = __webpack_require__(462);

var hash = __webpack_require__(3278);

var config = __webpack_require__(3112);

var assert = __webpack_require__(3252);

var G = secp256k1.G;
var n = secp256k1.n;

var PublicKey = /*#__PURE__*/function () {
  /** @param {ecurve.Point} public key */
  function PublicKey(Q) {
    _classCallCheck(this, PublicKey);

    this.Q = Q;
  }

  _createClass(PublicKey, [{
    key: "toBuffer",
    value: function toBuffer() {
      var compressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.Q ? this.Q.compressed : null;
      if (this.Q === null) return Buffer.from("000000000000000000000000000000000000000000000000000000000000000000", "hex");
      return this.Q.getEncoded(compressed);
    }
  }, {
    key: "toUncompressed",
    value: function toUncompressed() {
      var buf = this.Q.getEncoded(false);
      var point = ecurve.Point.decodeFrom(secp256k1, buf);
      return PublicKey.fromPoint(point);
    }
    /** bts::blockchain::address (unique but not a full public key) */

  }, {
    key: "toBlockchainAddress",
    value: function toBlockchainAddress() {
      var pub_buf = this.toBuffer();
      var pub_sha = hash.sha512(pub_buf);
      return hash.ripemd160(pub_sha);
    }
  }, {
    key: "toString",
    value: function toString() {
      var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : config.get('address_prefix');
      return this.toPublicKeyString(address_prefix);
    }
    /**
        Full public key
        {return} string
    */

  }, {
    key: "toPublicKeyString",
    value: function toPublicKeyString() {
      var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : config.get('address_prefix');
      if (this.pubdata) return address_prefix + this.pubdata;
      var pub_buf = this.toBuffer();
      var checksum = hash.ripemd160(pub_buf);
      var addy = Buffer.concat([pub_buf, checksum.slice(0, 4)]);
      this.pubdata = base58.encode(addy);
      return address_prefix + this.pubdata;
    }
    /**
        @arg {string} public_key - like GLSXyz...
        @arg {string} address_prefix - like GLS
        @return PublicKey or `null` (if the public_key string is invalid)
        @deprecated fromPublicKeyString (use fromString instead)
    */

  }, {
    key: "toAddressString",
    value: function toAddressString() {
      var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : config.get('address_prefix');
      var pub_buf = this.toBuffer();
      var pub_sha = hash.sha512(pub_buf);
      var addy = hash.ripemd160(pub_sha);
      var checksum = hash.ripemd160(addy);
      addy = Buffer.concat([addy, checksum.slice(0, 4)]);
      return address_prefix + base58.encode(addy);
    }
  }, {
    key: "toPtsAddy",
    value: function toPtsAddy() {
      var pub_buf = this.toBuffer();
      var pub_sha = hash.sha256(pub_buf);
      var addy = hash.ripemd160(pub_sha);
      addy = Buffer.concat([new Buffer([0x38]), addy]); //version 56(decimal)

      var checksum = hash.sha256(addy);
      checksum = hash.sha256(checksum);
      addy = Buffer.concat([addy, checksum.slice(0, 4)]);
      return base58.encode(addy);
    }
  }, {
    key: "child",
    value: function child(offset) {
      assert(Buffer.isBuffer(offset), "Buffer required: offset");
      assert.equal(offset.length, 32, "offset length");
      offset = Buffer.concat([this.toBuffer(), offset]);
      offset = hash.sha256(offset);
      var c = BigInteger.fromBuffer(offset);
      if (c.compareTo(n) >= 0) throw new Error("Child offset went out of bounds, try again");
      var cG = G.multiply(c);
      var Qprime = this.Q.add(cG);
      if (secp256k1.isInfinity(Qprime)) throw new Error("Child offset derived to an invalid key, try again");
      return PublicKey.fromPoint(Qprime);
    } // toByteBuffer() {
    //     var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
    //     this.appendByteBuffer(b);
    //     return b.copy(0, b.offset);
    // }

  }, {
    key: "toHex",
    value: function toHex() {
      return this.toBuffer().toString('hex');
    }
  }], [{
    key: "fromBinary",
    value: function fromBinary(bin) {
      return PublicKey.fromBuffer(new Buffer(bin, 'binary'));
    }
  }, {
    key: "fromBuffer",
    value: function fromBuffer(buffer) {
      if (buffer.toString("hex") === "000000000000000000000000000000000000000000000000000000000000000000") return new PublicKey(null);
      return new PublicKey(ecurve.Point.decodeFrom(secp256k1, buffer));
    }
  }, {
    key: "fromPoint",
    value: function fromPoint(point) {
      return new PublicKey(point);
    }
  }, {
    key: "fromString",
    value: function fromString(public_key) {
      var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : config.get('address_prefix');

      try {
        return PublicKey.fromStringOrThrow(public_key, address_prefix);
      } catch (e) {
        return null;
      }
    }
    /**
        @arg {string} public_key - like GLSXyz...
        @arg {string} address_prefix - like GLS
        @throws {Error} if public key is invalid
        @return PublicKey
    */

  }, {
    key: "fromStringOrThrow",
    value: function fromStringOrThrow(public_key) {
      var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : config.get('address_prefix');
      var prefix = public_key.slice(0, address_prefix.length);
      assert.equal(address_prefix, prefix, "Expecting key to begin with ".concat(address_prefix, ", instead got ").concat(prefix));
      public_key = public_key.slice(address_prefix.length);
      public_key = new Buffer(base58.decode(public_key), 'binary');
      var checksum = public_key.slice(-4);
      public_key = public_key.slice(0, -4);
      var new_checksum = hash.ripemd160(public_key);
      new_checksum = new_checksum.slice(0, 4);
      assert.deepEqual(checksum, new_checksum, 'Checksum did not match');
      return PublicKey.fromBuffer(public_key);
    }
  }, {
    key: "fromHex",
    value: function fromHex(hex) {
      return PublicKey.fromBuffer(new Buffer(hex, 'hex'));
    }
  }, {
    key: "fromStringHex",
    value: function fromStringHex(hex) {
      return PublicKey.fromString(new Buffer(hex, 'hex'));
    }
    /* </HEX> */

  }]);

  return PublicKey;
}();

module.exports = PublicKey;

/***/ }),

/***/ 3308:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];


__webpack_require__(3078);

__webpack_require__(3242);

__webpack_require__(3083);

__webpack_require__(3197);

__webpack_require__(3019);

__webpack_require__(3040);

var PrivateKey = __webpack_require__(3302);

var hash = __webpack_require__(3278);

var secureRandom = __webpack_require__(3280); // hash for .25 second


var HASH_POWER_MILLS = 250;
var entropyPos = 0,
    entropyCount = 0;
var entropyArray = secureRandom.randomBuffer(101);
module.exports = {
  addEntropy: function addEntropy() {
    entropyCount++;

    for (var _len = arguments.length, ints = new Array(_len), _key = 0; _key < _len; _key++) {
      ints[_key] = arguments[_key];
    }

    for (var _i = 0, _ints = ints; _i < _ints.length; _i++) {
      var i = _ints[_i];
      var pos = entropyPos++ % 101;
      var i2 = entropyArray[pos] += i;
      if (i2 > 9007199254740991) entropyArray[pos] = 0;
    }
  },

  /**
      A week random number generator can run out of entropy.  This should ensure even the worst random number implementation will be reasonably safe.
       @param1 string entropy of at least 32 bytes
  */
  random32ByteBuffer: function random32ByteBuffer() {
    var entropy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.browserEntropy();

    if (!(typeof entropy === 'string')) {
      throw new Error("string required for entropy");
    }

    if (entropy.length < 32) {
      throw new Error("expecting at least 32 bytes of entropy");
    }

    var start_t = Date.now();

    while (Date.now() - start_t < HASH_POWER_MILLS) {
      entropy = hash.sha256(entropy);
    }

    var hash_array = [];
    hash_array.push(entropy); // Hashing for 1 second may helps the computer is not low on entropy (this method may be called back-to-back).

    hash_array.push(secureRandom.randomBuffer(32));
    return hash.sha256(Buffer.concat(hash_array));
  },
  get_random_key: function get_random_key(entropy) {
    return PrivateKey.fromBuffer(this.random32ByteBuffer(entropy));
  },
  // Turn invisible space like characters into a single space
  // normalize_brain_key(brain_key){
  //     if (!(typeof brain_key === 'string')) {
  //         throw new Error("string required for brain_key");
  //     }
  //     brain_key = brain_key.trim();
  //     return brain_key.split(/[\t\n\v\f\r ]+/).join(' ');
  // },
  browserEntropy: function browserEntropy() {
    var entropyStr = Array(entropyArray).join();

    try {
      entropyStr += new Date().toString() + " " + window.screen.height + " " + window.screen.width + " " + window.screen.colorDepth + " " + " " + window.screen.availHeight + " " + window.screen.availWidth + " " + window.screen.pixelDepth + navigator.language + " " + window.location + " " + window.history.length;

      for (var i = 0, mimeType; i < navigator.mimeTypes.length; i++) {
        mimeType = navigator.mimeTypes[i];
        entropyStr += mimeType.description + " " + mimeType.type + " " + mimeType.suffixes + " ";
      }

      console.log("INFO\tbrowserEntropy gathered", entropyCount, 'events');
    } catch (error) {
      //nodejs:ReferenceError: window is not defined
      entropyStr += hash.sha256(new Date().toString());
    }

    var b = new Buffer(entropyStr);
    entropyStr += b.toString('binary') + " " + new Date().toString();
    return entropyStr;
  }
};

/***/ }),

/***/ 3303:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];


__webpack_require__(3083);

__webpack_require__(3197);

__webpack_require__(3076);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ecdsa = __webpack_require__(3304);

var hash = __webpack_require__(3278);

var curve = (__webpack_require__(457).getCurveByName)('secp256k1');

var assert = __webpack_require__(3252);

var BigInteger = __webpack_require__(448);

var PublicKey = __webpack_require__(3301);

var PrivateKey = __webpack_require__(3302);

var Signature = /*#__PURE__*/function () {
  function Signature(r1, s1, i1) {
    _classCallCheck(this, Signature);

    this.r = r1;
    this.s = s1;
    this.i = i1;
    assert.equal(this.r != null, true, 'Missing parameter');
    assert.equal(this.s != null, true, 'Missing parameter');
    assert.equal(this.i != null, true, 'Missing parameter');
  }

  _createClass(Signature, [{
    key: "toBuffer",
    value: function toBuffer() {
      var buf;
      buf = new Buffer(65);
      buf.writeUInt8(this.i, 0);
      this.r.toBuffer(32).copy(buf, 1);
      this.s.toBuffer(32).copy(buf, 33);
      return buf;
    }
  }, {
    key: "recoverPublicKeyFromBuffer",
    value: function recoverPublicKeyFromBuffer(buffer) {
      return this.recoverPublicKey(hash.sha256(buffer));
    }
  }, {
    key: "recoverPublicKey",
    value:
    /**
        @return {PublicKey}
    */
    function recoverPublicKey(sha256_buffer) {
      var Q, e, i;
      e = BigInteger.fromBuffer(sha256_buffer);
      i = this.i;
      i -= 27;
      i = i & 3;
      Q = ecdsa.recoverPubKey(curve, e, this, i);
      return PublicKey.fromPoint(Q);
    }
  }, {
    key: "verifyBuffer",
    value:
    /**
        @param {Buffer} un-hashed
        @param {./PublicKey}
        @return {boolean}
    */
    function verifyBuffer(buf, public_key) {
      var _hash = hash.sha256(buf);

      return this.verifyHash(_hash, public_key);
    }
  }, {
    key: "verifyHash",
    value: function verifyHash(hash, public_key) {
      assert.equal(hash.length, 32, "A SHA 256 should be 32 bytes long, instead got " + hash.length);
      return ecdsa.verify(curve, hash, {
        r: this.r,
        s: this.s
      }, public_key.Q);
    }
  }, {
    key: "toHex",
    value: function toHex() {
      return this.toBuffer().toString("hex");
    }
  }, {
    key: "verifyHex",
    value: function verifyHex(hex, public_key) {
      var buf;
      buf = new Buffer(hex, 'hex');
      return this.verifyBuffer(buf, public_key);
    }
  }], [{
    key: "fromBuffer",
    value: function fromBuffer(buf) {
      var i, r, s;
      assert.equal(buf.length, 65, 'Invalid signature length');
      i = buf.readUInt8(0);
      assert.equal(i - 27, i - 27 & 7, 'Invalid signature parameter');
      r = BigInteger.fromBuffer(buf.slice(1, 33));
      s = BigInteger.fromBuffer(buf.slice(33));
      return new Signature(r, s, i);
    }
  }, {
    key: "signBuffer",
    value:
    /**
        @param {Buffer} buf
        @param {PrivateKey} private_key
        @return {Signature}
    */
    function signBuffer(buf, private_key) {
      var _hash = hash.sha256(buf);

      return Signature.signBufferSha256(_hash, private_key);
    }
    /** Sign a buffer of exactally 32 bytes in size (sha256(text))
        @param {Buffer} buf - 32 bytes binary
        @param {PrivateKey} private_key
        @return {Signature}
    */

  }, {
    key: "signBufferSha256",
    value: function signBufferSha256(buf_sha256, private_key) {
      if (buf_sha256.length !== 32 || !Buffer.isBuffer(buf_sha256)) throw new Error("buf_sha256: 32 byte buffer requred");
      private_key = toPrivateObj(private_key);
      assert(private_key, 'private_key required');
      var der, e, ecsignature, i, lenR, lenS, nonce;
      i = null;
      nonce = 0;
      e = BigInteger.fromBuffer(buf_sha256);

      while (true) {
        ecsignature = ecdsa.sign(curve, buf_sha256, private_key.d, nonce++);
        der = ecsignature.toDER();
        lenR = der[3];
        lenS = der[5 + lenR];

        if (lenR === 32 && lenS === 32) {
          i = ecdsa.calcPubKeyRecoveryParam(curve, e, ecsignature, private_key.toPublicKey().Q);
          i += 4; // compressed

          i += 27; // compact  //  24 or 27 :( forcing odd-y 2nd key candidate)

          break;
        }

        if (nonce % 10 === 0) {
          console.log("WARN: " + nonce + " attempts to find canonical signature");
        }
      }

      return new Signature(ecsignature.r, ecsignature.s, i);
    }
  }, {
    key: "sign",
    value: function sign(string, private_key) {
      return Signature.signBuffer(new Buffer(string), private_key);
    }
  }, {
    key: "fromHex",
    value: // toByteBuffer() {
    //     var b;
    //     b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
    //     this.appendByteBuffer(b);
    //     return b.copy(0, b.offset);
    // };
    function fromHex(hex) {
      return Signature.fromBuffer(new Buffer(hex, "hex"));
    }
  }, {
    key: "signHex",
    value: function signHex(hex, private_key) {
      var buf;
      buf = new Buffer(hex, 'hex');
      return Signature.signBuffer(buf, private_key);
    }
  }]);

  return Signature;
}();

var toPrivateObj = function toPrivateObj(o) {
  return o ? o.d ? o : PrivateKey.fromWif(o) : o
  /*null or undefined*/
  ;
};

module.exports = Signature;

/***/ }),

/***/ 3239:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];


__webpack_require__(3057);

__webpack_require__(3052);

__webpack_require__(3019);

__webpack_require__(3040);

__webpack_require__(3041);

__webpack_require__(3042);

__webpack_require__(3054);

__webpack_require__(3240);

__webpack_require__(3228);

__webpack_require__(3241);

__webpack_require__(3083);

__webpack_require__(3085);

__webpack_require__(3242);

__webpack_require__(3066);

__webpack_require__(3080);

__webpack_require__(3243);

__webpack_require__(3078);

__webpack_require__(3076);

__webpack_require__(3197);

__webpack_require__(3215);

__webpack_require__(3089);

__webpack_require__(3090);

__webpack_require__(3065);

var _promisify = __webpack_require__(3218);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var bigi = __webpack_require__(448),
    bs58 = __webpack_require__(462),
    ecurve = __webpack_require__(457),
    Point = ecurve.Point,
    secp256k1 = ecurve.getCurveByName('secp256k1'),
    config = __webpack_require__(3112),
    operations = __webpack_require__(3247),
    Signature = __webpack_require__(3303),
    PrivateKey = __webpack_require__(3302),
    PublicKey = __webpack_require__(3301),
    session = __webpack_require__(3318),
    api = __webpack_require__(2942),
    hash = __webpack_require__(3278);

var Auth = {};
var transaction = operations.transaction;
var signed_transaction = operations.signed_transaction;

Auth.verify = function (name, password, auths) {
  var hasKey = false;
  var roles = [];

  for (var role in auths) {
    roles.push(role);
  }

  var pubKeys = this.generateKeys(name, password, roles);
  roles.forEach(function (role) {
    if (auths[role][0][0] === pubKeys[role]) {
      hasKey = true;
    }
  });
  return hasKey;
};

Auth.generateKeys = function (name, password, roles) {
  var pubKeys = {};
  roles.forEach(function (role) {
    var seed = name + role + password;
    var brainKey = seed.trim().split(/[\t\n\v\f\r ]+/).join(' ');
    var hashSha256 = hash.sha256(brainKey);
    var bigInt = bigi.fromBuffer(hashSha256);
    var toPubKey = secp256k1.G.multiply(bigInt);
    var point = new Point(toPubKey.curve, toPubKey.x, toPubKey.y, toPubKey.z);
    var pubBuf = point.getEncoded(toPubKey.compressed);
    var checksum = hash.ripemd160(pubBuf);
    var addy = Buffer.concat([pubBuf, checksum.slice(0, 4)]);
    pubKeys[role] = config.get('address_prefix') + bs58.encode(addy);
  });
  return pubKeys;
};
/**
    @arg {string} name - blockchain account name
    @arg {string} password - very strong password typically no shorter than a private key
    @arg {array} roles - defaults to standard Golos blockchain-level roles
*/


Auth.getPrivateKeys = function (name, password) {
  var roles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['owner', 'active', 'posting', 'memo'];
  var privKeys = {};
  roles.forEach(function (role) {
    privKeys[role] = this.toWif(name, password, role);
    privKeys[role + 'Pubkey'] = this.wifToPublic(privKeys[role]);
  }.bind(this));
  return privKeys;
};

Auth.isWif = function (privWif) {
  var isWif = false;

  try {
    var bufWif = new Buffer(bs58.decode(privWif));
    var privKey = bufWif.slice(0, -4);
    var checksum = bufWif.slice(-4);
    var newChecksum = hash.sha256(privKey);
    newChecksum = hash.sha256(newChecksum);
    newChecksum = newChecksum.slice(0, 4);

    if (checksum.toString() == newChecksum.toString()) {
      isWif = true;
    }
  } catch (e) {}

  return isWif;
};

Auth.loginAsync = function (name, password, callback) {
  var _this = this;

  try {
    var result = {
      owner: null,
      active: null,
      posting: null,
      memo: null,
      password: null
    };
    var roles = Object.keys(result).slice(0, 4);
    var privateKeys = {};
    var isPass = false;

    try {
      var pk = PrivateKey.fromWif(password);
      roles.map(function (role) {
        return privateKeys[role] = pk.toString();
      });
    } catch (err) {
      isPass = true;
      roles.map(function (role) {
        return privateKeys[role] = PrivateKey.fromSeed("".concat(name).concat(role).concat(password)).toString();
      });
    }

    api.getAccountsAsync([name], function (err, res) {
      if (err) {
        callback(err, null);
        return;
      }

      if (res.length == 0) {
        callback('No such account', null);
        return;
      }

      roles.slice(0, 3).map(function (role) {
        var key_auths = res[0][role].key_auths;

        for (var i = 0; i < key_auths.length; i++) {
          if (_this.wifIsValid(privateKeys[role], key_auths[i][0])) {
            result[role] = privateKeys[role];
            break;
          }
        }
      });
      if (_this.wifIsValid(privateKeys.memo, res[0].memo_key)) result.memo = privateKeys.memo;
      if (isPass && result.posting) result.password = password;
      callback(null, result);
    });
  } catch (err) {
    callback(err, null);
  }
};

Auth.login = (0, _promisify.promisify)(Auth.loginAsync);

Auth.toWif = function (name, password, role) {
  var seed = name + role + password;
  var brainKey = seed.trim().split(/[\t\n\v\f\r ]+/).join(' ');
  var hashSha256 = hash.sha256(brainKey);
  var privKey = Buffer.concat([new Buffer([0x80]), hashSha256]);
  var checksum = hash.sha256(privKey);
  checksum = hash.sha256(checksum);
  checksum = checksum.slice(0, 4);
  var privWif = Buffer.concat([privKey, checksum]);
  return bs58.encode(privWif);
};

Auth.wifIsValid = function (privWif, pubWif) {
  return this.wifToPublic(privWif) == pubWif;
};

Auth.wifToPublic = function (privWif) {
  var pubWif = PrivateKey.fromWif(privWif);
  pubWif = pubWif.toPublic().toString();
  return pubWif;
};

Auth.isPubkey = function (pubkey, address_prefix) {
  return PublicKey.fromString(pubkey, address_prefix) != null;
};

Auth.signTransaction = function (trx, keys) {
  var signatures = [];

  if (trx.signatures) {
    signatures = [].concat(trx.signatures);
  }

  var cid = new Buffer(config.get('chain_id'), 'hex');
  var buf = transaction.toBuffer(trx);

  for (var key in keys) {
    var sig = Signature.signBuffer(Buffer.concat([cid, buf]), keys[key]);
    signatures.push(sig.toBuffer());
  }

  return signed_transaction.toObject(Object.assign(trx, {
    signatures: signatures
  }));
};

Auth.signData = function (data, keys) {
  var signatures = {};
  var bufSha = hash.sha256(data);

  var sign = function sign(role, d) {
    if (!d) return;
    var sig = Signature.signBufferSha256(bufSha, d);
    signatures[role] = sig.toHex();
  };

  for (var key in keys) {
    sign(key, keys[key]);
  }

  return signatures;
};

Auth.verifySignedData = function (data, signatures, account, authTypes) {
  var auth = {};
  var bufSha = hash.sha256(data);

  var verify = function verify(type, sigHex, pubkey, weight, weight_threshold) {
    if (!sigHex) return;

    if (weight !== 1 || weight_threshold !== 1) {
      console.error("Auth.verifySignedData unsupported ".concat(type, " auth configuration: ").concat(account.name));
    } else {
      var parseSig = function parseSig(hexSig) {
        try {
          return Signature.fromHex(hexSig);
        } catch (e) {
          return null;
        }
      };

      var sig = parseSig(sigHex);
      var public_key = PublicKey.fromString(pubkey);
      var verified = sig.verifyHash(bufSha, public_key);
      auth[type] = verified;
    }
  };

  var _iterator = _createForOfIteratorHelper(authTypes),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var authType = _step.value;
      var _account$authType = account[authType],
          key_auths = _account$authType.key_auths,
          weight_threshold = _account$authType.weight_threshold;

      var _key_auths = _slicedToArray(key_auths, 1),
          _key_auths$ = _slicedToArray(_key_auths[0], 2),
          pubKey = _key_auths$[0],
          weight = _key_auths$[1];

      verify(authType, signatures[authType], pubKey, weight, weight_threshold);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return auth;
};

Auth = _objectSpread(_objectSpread({}, Auth), session);
module.exports = Auth;

/***/ }),

/***/ 3336:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decode = decode;
exports.encode = encode;

__webpack_require__(3066);

__webpack_require__(3083);

__webpack_require__(3197);

__webpack_require__(3019);

__webpack_require__(3040);

__webpack_require__(3041);

__webpack_require__(3042);

__webpack_require__(3052);

__webpack_require__(3054);

var _bytebuffer = _interopRequireDefault(__webpack_require__(439));

var _assert = _interopRequireDefault(__webpack_require__(3252));

var _bs = _interopRequireDefault(__webpack_require__(462));

var _ecc = __webpack_require__(3250);

var _serializer = __webpack_require__(3337);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var encMemo = _serializer.ops.encrypted_memo;
/**
    Some fields are only required if the memo is marked for decryption (starts with a hash).
    @arg {string|PrivateKey} private_key - WIF or PrivateKey object
    @arg {string} memo - plain text is returned, hash prefix base58 is decrypted
    @return {string} - utf8 decoded string (hash prefix)
*/

function decode(private_key, memo) {
  (0, _assert.default)(memo, 'memo is required');

  _assert.default.equal(_typeof(memo), 'string', 'memo');

  if (!/^#/.test(memo)) return memo;
  memo = memo.substring(1);
  (0, _assert.default)(private_key, 'private_key is required');
  checkEncryption();
  private_key = toPrivateObj(private_key);
  memo = _bs.default.decode(memo);
  memo = encMemo.fromBuffer(new Buffer(memo, 'binary'));
  var _memo = memo,
      from = _memo.from,
      to = _memo.to,
      nonce = _memo.nonce,
      check = _memo.check,
      encrypted = _memo.encrypted;
  var pubkey = private_key.toPublicKey().toString();
  var otherpub = pubkey === from.toString() ? to.toString() : from.toString();
  memo = _ecc.Aes.decrypt(private_key, otherpub, nonce, encrypted, check); // remove varint length prefix

  var mbuf = _bytebuffer.default.fromBinary(memo.toString('binary'), _bytebuffer.default.DEFAULT_CAPACITY, _bytebuffer.default.LITTLE_ENDIAN);

  try {
    mbuf.mark();
    return '#' + mbuf.readVString();
  } catch (e) {
    mbuf.reset(); // Sender did not length-prefix the memo

    memo = new Buffer(mbuf.toString('binary'), 'binary').toString('utf-8');
    return '#' + memo;
  }
}
/**
    Some fields are only required if the memo is marked for encryption (starts with a hash).
    @arg {string|PrivateKey} private_key - WIF or PrivateKey object
    @arg {string|PublicKey} public_key - Recipient
    @arg {string} memo - plain text is returned, hash prefix text is encrypted
    @arg {string} [testNonce = undefined] - just for testing
    @return {string} - base64 decoded string (or plain text)
*/


function encode(private_key, public_key, memo, testNonce) {
  (0, _assert.default)(memo, 'memo is required');

  _assert.default.equal(_typeof(memo), 'string', 'memo');

  if (!/^#/.test(memo)) return memo;
  memo = memo.substring(1);
  (0, _assert.default)(private_key, 'private_key is required');
  (0, _assert.default)(public_key, 'public_key is required');
  checkEncryption();
  private_key = toPrivateObj(private_key);
  public_key = toPublicObj(public_key);
  var mbuf = new _bytebuffer.default(_bytebuffer.default.DEFAULT_CAPACITY, _bytebuffer.default.LITTLE_ENDIAN);
  mbuf.writeVString(memo);
  memo = new Buffer(mbuf.copy(0, mbuf.offset).toBinary(), 'binary');

  var _Aes$encrypt = _ecc.Aes.encrypt(private_key, public_key, memo, testNonce),
      nonce = _Aes$encrypt.nonce,
      message = _Aes$encrypt.message,
      checksum = _Aes$encrypt.checksum;

  memo = encMemo.fromObject({
    from: private_key.toPublicKey(),
    to: public_key,
    nonce: nonce,
    check: checksum,
    encrypted: message
  }); // serialize

  memo = encMemo.toBuffer(memo);
  return '#' + _bs.default.encode(new Buffer(memo, 'binary'));
}

var encodeTest = undefined;
/**
  Memo encryption has failed in the browser before.  An Error will be thrown
  if a memo can't be encrypted and decrypted.
*/

function checkEncryption() {
  if (encodeTest === undefined) {
    var plaintext;
    encodeTest = true; // prevent infinate looping

    try {
      var wif = '5JdeC9P7Pbd1uGdFVEsJ41EkEnADbbHGq6p1BwFxm6txNBsQnsw';
      var pubkey = 'GLS8m5UgaFAAYQRuaNejYdS8FVLVp9Ss3K1qAVk5de6F8s3HnVbvA';
      var cyphertext = encode(wif, pubkey, '#memo爱');
      plaintext = decode(wif, cyphertext);
    } catch (e) {
      console.error(e);
    } finally {
      encodeTest = plaintext === '#memo爱';
    }
  }

  if (encodeTest === false) throw new Error('This environment does not support encryption.');
}

var toPrivateObj = function toPrivateObj(o) {
  return o ? o.d ? o : _ecc.PrivateKey.fromWif(o) : o
  /*null or undefined*/
  ;
};

var toPublicObj = function toPublicObj(o) {
  return o ? o.Q ? o : _ecc.PublicKey.fromString(o) : o
  /*null or undefined*/
  ;
};

/***/ }),

/***/ 3339:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];


__webpack_require__(3019);

__webpack_require__(3040);

__webpack_require__(3041);

__webpack_require__(3042);

__webpack_require__(3052);

__webpack_require__(3054);

__webpack_require__(3065);

__webpack_require__(3057);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MAX_TEXT_QUOTE_LENGTH = exports.MAX_PREVIEW_WIDTH = exports.MAX_PREVIEW_HEIGHT = exports.MAX_IMAGE_QUOTE_LENGTH = exports.DEFAULT_VERSION = exports.DEFAULT_APP = void 0;
exports.decode = decode;
exports.encode = encode;
exports.makeDatedGroups = makeDatedGroups;
exports.makeQuoteMsg = makeQuoteMsg;
exports.newTextMsg = newTextMsg;

__webpack_require__(3340);

__webpack_require__(3341);

__webpack_require__(3076);

__webpack_require__(3083);

__webpack_require__(3197);

__webpack_require__(3066);

__webpack_require__(3080);

var _bytebuffer = _interopRequireDefault(__webpack_require__(439));

var _assert = _interopRequireDefault(__webpack_require__(3252));

var _bs = _interopRequireDefault(__webpack_require__(462));

var _truncate = _interopRequireDefault(__webpack_require__(3342));

var _ecc = __webpack_require__(3250);

var _serializer = __webpack_require__(3337);

var _utils = __webpack_require__(3115);

var _promisify = __webpack_require__(3218);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var isInteger = Number.isInteger;
/** @const {string} DEFAULT_APP 
    @default 'golos-messenger' */

var DEFAULT_APP = 'golos-messenger';
/** @const {string} DEFAULT_VERSION 
    @default 1 */

exports.DEFAULT_APP = DEFAULT_APP;
var DEFAULT_VERSION = 1;
/** @const {string} MAX_PREVIEW_WIDTH 
    @default 600 */

exports.DEFAULT_VERSION = DEFAULT_VERSION;
var MAX_PREVIEW_WIDTH = 600;
/** @const {string} MAX_PREVIEW_HEIGHT 
    @default 300 */

exports.MAX_PREVIEW_WIDTH = MAX_PREVIEW_WIDTH;
var MAX_PREVIEW_HEIGHT = 300;
/** @const {string} MAX_TEXT_QUOTE_LENGTH
    @default 200 */

exports.MAX_PREVIEW_HEIGHT = MAX_PREVIEW_HEIGHT;
var MAX_TEXT_QUOTE_LENGTH = 200;
/** @const {string} MAX_IMAGE_QUOTE_LENGTH
    @default 2000 */

exports.MAX_TEXT_QUOTE_LENGTH = MAX_TEXT_QUOTE_LENGTH;
var MAX_IMAGE_QUOTE_LENGTH = 2000;
exports.MAX_IMAGE_QUOTE_LENGTH = MAX_IMAGE_QUOTE_LENGTH;

var toPrivateObj = function toPrivateObj(o) {
  return o ? o.d ? o : _ecc.PrivateKey.fromWif(o) : o
  /*null or undefined*/
  ;
};

var toPublicObj = function toPublicObj(o) {
  return o ? o.Q ? o : _ecc.PublicKey.fromString(o) : o
  /*null or undefined*/
  ;
};

function validateAppVersion(app, version) {
  (0, _assert.default)(typeof app === 'string' && app.length >= 1 && app.length <= 16, 'message.app should be a string, >= 1, <= 16');
  (0, _assert.default)(isInteger(version) && version >= 1, 'message.version should be an integer, >= 1');
}

function validateBody(body) {
  (0, _assert.default)(typeof body === 'string', 'message.body should be a string');
}

function validateImageMsg(msg) {
  (0, _assert.default)(isInteger(msg.previewWidth) && msg.previewWidth >= 1 && msg.previewWidth <= MAX_PREVIEW_WIDTH, 'message.previewWidth (for image) should be an integer, >= 1, <= ' + MAX_PREVIEW_WIDTH);
  (0, _assert.default)(isInteger(msg.previewHeight) && msg.previewHeight >= 1 && msg.previewHeight <= MAX_PREVIEW_HEIGHT, 'message.previewHeight (for image) should be an integer, >= 1, <= ' + MAX_PREVIEW_HEIGHT);
}

function validateMsgWithQuote(msg) {
  if (msg.quote !== undefined) {
    (0, _assert.default)(_typeof(msg.quote) === 'object', 'message.quote should be an object or undefined at all');
    (0, _assert.default)(typeof msg.quote.from === 'string' && msg.quote.from.length >= 1 && msg.quote.from.length <= 16, 'message.quote.from should be a valid nickname of sender of message, to which this reply is');
    (0, _assert.default)(typeof msg.quote.nonce === 'string' && msg.quote.nonce.length, 'message.quote.nonce should be a valid nonce of message, to which this reply is');

    if (msg.quote.type !== 'image') {
      (0, _assert.default)(typeof msg.quote.body === 'string' && msg.quote.body.length <= MAX_TEXT_QUOTE_LENGTH, 'message.quote.body should be a truncated (length <= 200) text of message, to which this reply is');
    } else {
      (0, _assert.default)(typeof msg.quote.body === 'string' && msg.quote.body.length <= MAX_IMAGE_QUOTE_LENGTH, 'message.quote.body should be a truncated (length <= 2000) image URL from message, to which this reply is');
    }
  }
}
/**
    Creates new message, which can be encoded by golos.messages.encode.
    @arg {string} text - text ("body") of the message.
    @arg {string} [app = DEFAULT_APP] - "app" field of the message. Should be a string with length from 1 to 16.
    @arg {string} [version = DEFAULT_VERSION] - "version" field of the message. Should be an integer, starting of 1.
    @throws {Exception} when supplied data is invalid.
    @return {object} - result message object.
*/


function newTextMsg(text) {
  var app = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_APP;
  var version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_VERSION;
  validateBody(text);
  validateAppVersion(app, version);
  var msg = {
    app: app,
    version: version,
    body: text
  };
  return msg;
}
/**
    Creates new image message, which can be encoded by golos.messages.encode.
    @arg {string} image_url - URL of the image in the Internet (please use https://, and store images in image hostings, to make them storing eternally). This URL will be a "body" of the message.
    @arg {function} callback - callback. Params are <code>(err, message)</code>. Calling after message construction (err is null in this case), or if error occured (err is exception, message is null).
    @arg {function} [on_progress = undefined] - progress callback. Params are <code>(percent, extra_data)</code>. Percent is integer from 1 to 100.
    @arg {string} [app = DEFAULT_APP] - "app" field of the message. Should be a string with length from 1 to 16.
    @arg {string} [version = DEFAULT_VERSION] - "version" field of the message. Should be an integer, starting of 1.
    @throws {Exception} only if callback called due error, and callback also throws error. So callback shouldn't throw errors.
*/


exports.newImageMsg = function (image_url, callback) {
  var on_progress = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  var app = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_APP;
  var version = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_VERSION;

  var reportProgress = function reportProgress(progress) {
    var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (on_progress) on_progress(progress, {
      error: error
    });
  };

  try {
    (0, _assert.default)(typeof Image !== 'undefined', 'Current environment does not support Image()');
    (0, _assert.default)(image_url, 'image_url is required');
    (0, _assert.default)(callback, 'callback is required');
    validateAppVersion(app, version);
    reportProgress(0);

    var reportLoadError = function reportLoadError(errorText) {
      var err = new Error(errorText);
      reportProgress(100, err);
      callback(err, null);
    };

    var img = new Image();
    var watchdog;

    var clearWatchdog = function clearWatchdog() {
      if (watchdog) clearTimeout(watchdog);
    };

    img.onerror = img.onabort = function () {
      clearWatchdog();
      reportLoadError('Cannot load image');
    };

    img.onload = function () {
      clearWatchdog();
      reportProgress(100);
      var previewSize = (0, _utils.fitImageToSize)(img.width, img.height, MAX_PREVIEW_WIDTH, MAX_PREVIEW_HEIGHT);
      var msg = {
        app: app,
        version: version,
        body: image_url,
        type: 'image',
        previewWidth: previewSize.width,
        previewHeight: previewSize.height
      };
      validateImageMsg(msg);
      callback(null, msg);
    };

    watchdog = setTimeout(function () {
      if (!img.complete) {
        img.onload = img.onerror = img.onabort = {};
        reportLoadError('Image load timed out, maybe it is too large');
      }
    }, 5000);
    img.src = image_url;
  } catch (err) {
    reportProgress(100, err);
    if (callback) callback(err, null);
  }
};
/**
    Creates new image message, which can be encoded by golos.messages.encode. Async version of function, should be called with await.
    @arg {string} image_url - URL of the image in the Internet. It will be a "body" of the message.
    @arg {function} [on_progress = undefined] - progress callback. Params are <code>(percent, extra_data)</code>. Percent is integer from 1 to 100.
    @arg {string} [app = DEFAULT_APP] - "app" field of the message. Should be a string with length from 1 to 16.
    @arg {string} [version = DEFAULT_VERSION] - "version" field of the message. Should be an integer, starting of 1.
    @throws {Exception} if error occured.
    @return {object} - result message object.
    @function newImageMsgAsync
*/


exports.newImageMsgAsync = (0, _promisify.promisify)(function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var callback = args[args.length - 1];

  var _args$slice = args.slice(0, args.length - 1),
      _args$slice2 = _slicedToArray(_args$slice, 4),
      image_url = _args$slice2[0],
      on_progress = _args$slice2[1],
      app = _args$slice2[2],
      version = _args$slice2[3];

  return exports.newImageMsg(image_url, callback, on_progress, app, version);
});
/**
    Makes your message the reply to another message_object. Call it after `newTextMsg`/`newImageMsg`/etc, next call `encode`, and finally send resulting message as usually.
    @arg {object} msg = Your message, created by `newTextMsg`, `newImageMsg`, etc.
    @arg {object} quoted_message_object = Message to which you want to reply. It should be one of messages returned by `golos.messages.decode`, and have "from", "nonce", and (warning!) "message". If message is invalid (cannot be decoded), it has no "message" field, and if you try reply it, it will throw.
    @throws {Exception} if quoted_message_object is invalid.
    @return {object} - result message object, which can be encoded and sent.
    @function newImageMsgAsync
*/

function makeQuoteMsg(msg, quoted_message_object) {
  (0, _assert.default)(quoted_message_object, 'quoted_message_object is required');
  var assertPrefix = 'quoted_message_object should be one of VALID objects, returned by `golos.messages.decode`';
  (0, _assert.default)(quoted_message_object.from, "".concat(assertPrefix, ", and have \"from\" field"));
  (0, _assert.default)(quoted_message_object.nonce, "".concat(assertPrefix, ", and have \"nonce\" field"));
  (0, _assert.default)(quoted_message_object.message, "".concat(assertPrefix, ", and have \"message\" field"));
  (0, _assert.default)(quoted_message_object.message.body, "".concat(assertPrefix, ", and have \"message\" field with \"body\""));
  var type = quoted_message_object.message.type;
  var body = quoted_message_object.message.body;

  if (type !== 'image') {
    body = (0, _truncate.default)(body, {
      length: MAX_TEXT_QUOTE_LENGTH,
      omission: '...'
    });
  } else {
    if (body.length > MAX_IMAGE_QUOTE_LENGTH) {
      body = (0, _truncate.default)(body, {
        length: MAX_TEXT_QUOTE_LENGTH,
        omission: '...'
      });
      type = undefined; // make it text
    }
  }

  if (!msg) msg = {};
  msg.quote = {
    from: quoted_message_object.from,
    nonce: quoted_message_object.nonce,
    body: body
  };
  if (type) msg.quote.type = type;
  return msg;
}

function forEachMessage(message_objects, begin_idx, end_idx, callback) {
  if (begin_idx === undefined) begin_idx = 0;
  if (end_idx === undefined) end_idx = message_objects.length;
  var step = end_idx > begin_idx ? 1 : -1;

  for (var i = begin_idx; i != end_idx; i += step) {
    var message_object = message_objects[i]; // return true is `continue`
    // return false is `break`

    if (!callback(message_object, i)) break;
  }
}
/**
    Decodes messages of format used by golos.messages.encode(), which are length-prefixed, and also messages sent by another way (not length-prefixed).<br>
    Also, parses (JSON) and validates each message (app, version...). (Invalid messages are also added to result, it is need to mark them as read. To change it, use <code>on_error</code>).<br>
    Processes whole incoming array, or only part of it.<br>
    Can process in reversed order.
    @arg {string|PrivateKey} private_memo_key - private memo key of "from" or "to".
    @arg {string|PublicKey} second_user_public_memo_key - public memo key of second user.
    @arg {array} message_objects - array of objects. Each object should contain nonce, checksum and encrypted_message (such object returns from private_message API).
    @arg {function} [before_decode = undefined] - callback, calling on each message before processing. Params are <code>(message, idx, results)</code>. If returns true, message will not be processed. Also, you can push it to <code>results</code> manually.
    @arg {function} [for_each = undefined] - callback, calling on each message, after message is decoded, parsed and validated, but before add it to result array. Params are <code>(message, idx)</code>. If returns true, message willn't be added to result array.
    @arg {function} [on_error = undefined] - callback, calling on each message which can't be decrypted, parsed, validated, or if <code>for_each</code> throws. Params are <code>(message, idx, exception)</code>. If returns true, message willn't be added to result array.
    @arg {int} [begin_idx = undefined] - if set, function will process messages only from this index (incl.). If begin_idx > end_idx, messages will be processed in reversed order.
    @arg {int} [end_idx = undefined] - if set, function will process messages only before this index (excl.). If end_idx < begin_idx, messages will be processed in reversed order.
    @arg {bool} [raw_messages = false] - if set, function will not parse messages as JSON and validate them.
    @return {array} - result array of message_objects. Each object has "message" and "raw_message" fields. If message is invalid, it has only "raw_message" field. And if message cannot be decoded at all, it hasn't any of these fields.
*/


function decode(private_memo_key, second_user_public_memo_key, message_objects) {
  var before_decode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
  var for_each = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
  var on_error = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;
  var begin_idx = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;
  var end_idx = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;
  var raw_messages = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
  (0, _assert.default)(private_memo_key, 'private_memo_key is required');
  (0, _assert.default)(second_user_public_memo_key, 'second_user_public_memo_key is required');
  (0, _assert.default)(message_objects, 'message_objects is required'); // Most "heavy" lines

  var private_key = toPrivateObj(private_memo_key);
  var public_key = toPublicObj(second_user_public_memo_key);
  var shared_secret = private_key.get_shared_secret(public_key);
  var results = [];
  forEachMessage(message_objects, begin_idx, end_idx, function (message_object, i) {
    // Return true if for_each should not be called
    var processOnError = function processOnError(exception) {
      if (on_error) {
        if (!on_error(message_object, i, exception)) {
          results.push(message_object);
        }

        return true;
      }

      return false;
    };

    try {
      message_object.raw_message = null; // Will be set if message will be successfully decoded

      message_object.message = null; // Will be set if message will be also successfully parsed and validated

      if (before_decode && before_decode(message_object, i, results)) {
        return true;
      }

      var decrypted = _ecc.Aes.decrypt(shared_secret, null, message_object.nonce.toString(), Buffer.from(message_object.encrypted_message, 'hex'), message_object.checksum);

      var mbuf = _bytebuffer.default.fromBinary(decrypted.toString('binary'), _bytebuffer.default.DEFAULT_CAPACITY, _bytebuffer.default.LITTLE_ENDIAN);

      try {
        mbuf.mark();
        decrypted = mbuf.readVString();
      } catch (e) {
        mbuf.reset(); // Sender did not length-prefix the memo

        decrypted = new Buffer(mbuf.toString('binary'), 'binary').toString('utf-8');
      }

      decrypted = decrypted.toString();
      message_object.raw_message = decrypted;

      if (!raw_messages) {
        var msg = JSON.parse(message_object.raw_message);
        msg.type = msg.type || 'text';
        validateBody(msg.body);
        if (msg.type === 'image') validateImageMsg(msg);
        validateAppVersion(msg.app, msg.version);
        validateMsgWithQuote(msg);
        message_object.message = msg;
      }
    } catch (exception) {
      if (processOnError(exception)) return true;
    }

    try {
      if (!for_each || !for_each(message_object, i)) {
        results.push(message_object);
      }
    } catch (exception) {
      processOnError(exception);
    }

    return true;
  });
  return results;
}
/**
    Encodes message to send with private_message_operation. Converts object to JSON string. Uses writeVString, so format of data to encode is string length + string.
    @arg {string|PrivateKey} from_private_memo_key - private memo key of "from"
    @arg {string|PublicKey} to_public_memo_key - private memo key of "to"
    @arg {object} message - message to encode.
    @arg {string|undefined} nonce - unique identifier of message. When editing message, set to its nonce. Otherwise keep undefined.
    @return {object} - Object with fields: nonce, checksum and message.
*/


function encode(from_private_memo_key, to_public_memo_key, message) {
  var nonce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
  (0, _assert.default)(from_private_memo_key, 'from_private_memo_key is required');
  (0, _assert.default)(to_public_memo_key, 'to_public_memo_key is required');
  (0, _assert.default)(message, 'message is required');
  var fromKey = toPrivateObj(from_private_memo_key);
  var toKey = toPublicObj(to_public_memo_key);
  var mbuf = new _bytebuffer.default(_bytebuffer.default.DEFAULT_CAPACITY, _bytebuffer.default.LITTLE_ENDIAN);
  mbuf.writeVString(JSON.stringify(message));
  message = new Buffer(mbuf.copy(0, mbuf.offset).toBinary(), 'binary');

  var data = _ecc.Aes.encrypt(fromKey, toKey, message, nonce);

  return {
    nonce: data.nonce.toString(),
    encrypted_message: data.message.toString('hex'),
    checksum: data.checksum
  };
}
/**
    Selects messages by condition (e.g unread, or selected by user), and groups them into ranges with `nonce` (if range has 1 message) or `start_date`+`stop_date` (if range has few messages). Can wrap these ranges into operations: `private_mark_message` and `private_delete_message`.
    @arg {array} message_objects - array of message objects. It can be result array from `golos.messages.decode`.
    @arg {function} condition - callback, calling on each message. Params are (message, idx). If returns true, message is adding to ranges. If returns false/undefined/null, message is skipping. If returns -1, processing loop breaks.
    @arg {function} wrapper - callback, calling on each range, when adding it to result array. Allows to wrap range as an operation. Params are (range). Should return wrapped result. If returns false/undefined/null, range skipping.
    @arg {int|undefined} begin_idx - if set, function will process messages only from it index (incl.). If begin_idx > end_idx, messages will be processed in reversed order.
    @arg {int|undefined} end_idx - if set, function will process messages only before it index (excl.). If end_idx < begin_idx, messages will be processed in reversed order.
    @return {array} - result array of operations, which can be sent in single transaction.
*/


function makeDatedGroups(message_objects, condition, wrapper, begin_idx, end_idx) {
  (0, _assert.default)(message_objects, 'message_objects is required');
  (0, _assert.default)(condition, 'condition is required');
  (0, _assert.default)(wrapper, 'wrapper is required');
  var results = [];
  var group = null;
  var before = null;

  var fixStartDate = function fixStartDate(start_date) {
    return new Date(new Date(start_date + 'Z').getTime() - 1000).toISOString().split('.')[0];
  };

  var time_point_min = '1970-01-01T00:00:00';

  var pushResult = function pushResult(nonces, start_date, stop_date) {
    if (nonces) {
      var _iterator = _createForOfIteratorHelper(nonces),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var nonce = _step.value;
          var wrapped = wrapper({
            start_date: time_point_min,
            stop_date: time_point_min,
            nonce: nonce
          });
          if (wrapped) results.push(wrapped);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } else {
      var _wrapped = wrapper({
        start_date: start_date,
        stop_date: stop_date,
        nonce: 0
      });

      if (_wrapped) results.push(_wrapped);
    }
  };

  var pushGroup = function pushGroup(nextCreateDate) {
    if (!group) return;
    var _group = group,
        beforeNonces = _group.beforeNonces,
        nonces = _group.nonces,
        afterNonces = _group.afterNonces;

    if (!nextCreateDate || nextCreateDate !== group.start_date) {
      nonces.push.apply(nonces, _toConsumableArray(afterNonces));
      afterNonces = [];
    }

    pushResult(beforeNonces);

    if (nonces.length > 1) {
      if (!afterNonces.length) group.start_date = fixStartDate(group.start_date);
      pushResult(null, group.start_date, group.stop_date);
    } else if (nonces[0]) {
      pushResult([nonces[0]]);
    }

    pushResult(afterNonces);
    group = null;
  };

  forEachMessage(message_objects, begin_idx, end_idx, function (message_object, i) {
    var cond = condition(message_object, i);
    var create_date = message_object.create_date,
        nonce = message_object.nonce;

    if (cond === -1) {
      return false;
    } else if (cond) {
      if (!group) {
        group = {
          stop_date: create_date,
          beforeNonces: [],
          afterNonces: [],
          nonces: []
        };
      }

      if (create_date === before) {
        group.beforeNonces.push(nonce);
      } else {
        if (before) {
          before = null;
          group.stop_date = create_date;
        }

        if (create_date !== group.start_date) {
          var _group$nonces;

          (_group$nonces = group.nonces).push.apply(_group$nonces, _toConsumableArray(group.afterNonces));

          group.afterNonces = [];
        }

        group.afterNonces.push(nonce);
      }

      group.start_date = create_date;
    } else if (cond === false) {
      pushGroup(create_date);
      before = create_date;
    }

    return true;
  });
  pushGroup();
  return results;
}

/***/ }),

/***/ 3337:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = {
  // Primary class for creating operations
  Serializer: __webpack_require__(3316),
  // helper functions for creating operations
  fp: __webpack_require__(3315),
  // Low level types
  types: __webpack_require__(3248),
  // Higher level operations (made out of generic types)
  ops: __webpack_require__(3247),
  // Utility that generates JSON examples
  template: __webpack_require__(3338),
  number_utils: __webpack_require__(3309)
};

/***/ }),

/***/ 3313:
/***/ ((module) => {

"use strict";


var ChainTypes;
module.exports = ChainTypes = {};
ChainTypes.reserved_spaces = {
  relative_protocol_ids: 0,
  protocol_ids: 1,
  implementation_ids: 2
};
ChainTypes.operations = {
  vote: 0,
  comment: 1,
  transfer: 2,
  transfer_to_vesting: 3,
  withdraw_vesting: 4,
  limit_order_create: 5,
  limit_order_cancel: 6,
  feed_publish: 7,
  convert: 8,
  account_create: 9,
  account_update: 10,
  witness_update: 11,
  account_witness_vote: 12,
  account_witness_proxy: 13,
  pow: 14,
  custom: 15,
  report_over_production: 16,
  delete_comment: 17,
  custom_json: 18,
  comment_options: 19,
  set_withdraw_vesting_route: 20,
  limit_order_create2: 21,
  challenge_authority: 22,
  prove_authority: 23,
  request_account_recovery: 24,
  recover_account: 25,
  change_recovery_account: 26,
  escrow_transfer: 27,
  escrow_dispute: 28,
  escrow_release: 29,
  pow2: 30,
  escrow_approve: 31,
  transfer_to_savings: 32,
  transfer_from_savings: 33,
  cancel_transfer_from_savings: 34,
  custom_binary: 35,
  decline_voting_rights: 36,
  reset_account: 37,
  set_reset_account: 38,
  delegate_vesting_shares: 39,
  account_create_with_delegation: 40,
  account_metadata: 41,
  proposal_create: 42,
  proposal_update: 43,
  proposal_delete: 44,
  chain_properties_update: 45,
  break_free_referral: 46,
  delegate_vesting_shares_with_interest: 47,
  reject_vesting_shares_delegation: 48,
  transit_to_cyberway: 49,
  worker_request: 50,
  worker_request_delete: 51,
  worker_request_vote: 52,
  claim: 53,
  donate: 54,
  transfer_to_tip: 55,
  transfer_from_tip: 56,
  invite: 57,
  invite_claim: 58,
  account_create_with_invite: 59,
  asset_create: 60,
  asset_update: 61,
  asset_issue: 62,
  asset_transfer: 63,
  override_transfer: 64,
  invite_donate: 65,
  invite_transfer: 66,
  limit_order_cancel_ex: 67,
  fill_convert_request: 68,
  author_reward: 69,
  curation_reward: 70,
  comment_reward: 71,
  liquidity_reward: 72,
  interest: 73,
  fill_vesting_withdraw: 74,
  fill_order: 75,
  shutdown_witness: 76,
  fill_transfer_from_savings: 77,
  hardfork: 78,
  comment_payout_update: 79,
  comment_benefactor_reward: 80,
  return_vesting_delegation: 81,
  producer_reward: 82,
  delegation_reward: 83,
  auction_window_reward: 84
}; //types.hpp

ChainTypes.object_type = {
  "null": 0,
  base: 1
};

/***/ }),

/***/ 3317:
/***/ ((module) => {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/** Exception nesting.  */
var ErrorWithCause = /*#__PURE__*/function () {
  function ErrorWithCause(message, cause) {
    _classCallCheck(this, ErrorWithCause);

    this.message = message;

    if (typeof cause !== "undefined" && cause !== null ? cause.message : undefined) {
      this.message = "cause\t".concat(cause.message, "\t") + this.message;
    }

    var stack = ""; //(new Error).stack

    if (typeof cause !== "undefined" && cause !== null ? cause.stack : undefined) {
      stack = "caused by\n\t".concat(cause.stack, "\t") + stack;
    }

    this.stack = this.message + "\n" + stack;
  }

  _createClass(ErrorWithCause, null, [{
    key: "throw",
    value: function _throw(message, cause) {
      var msg = message;

      if (typeof cause !== "undefined" && cause !== null ? cause.message : undefined) {
        msg += "\t cause: ".concat(cause.message, " ");
      }

      if (typeof cause !== "undefined" && cause !== null ? cause.stack : undefined) {
        msg += "\n stack: ".concat(cause.stack, " ");
      }

      throw new Error(msg);
    }
  }]);

  return ErrorWithCause;
}();

module.exports = ErrorWithCause;

/***/ }),

/***/ 3315:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];


__webpack_require__(3083);

__webpack_require__(3197);

__webpack_require__(3076);

var _ecc = __webpack_require__(3250);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var FastParser = /*#__PURE__*/function () {
  function FastParser() {
    _classCallCheck(this, FastParser);
  }

  _createClass(FastParser, null, [{
    key: "fixed_data",
    value: function fixed_data(b, len, buffer) {
      if (!b) {
        return;
      }

      if (buffer) {
        var data = buffer.slice(0, len).toString('binary');
        b.append(data, 'binary');

        while (len-- > data.length) {
          b.writeUint8(0);
        }
      } else {
        var b_copy = b.copy(b.offset, b.offset + len);
        b.skip(len);
        return new Buffer(b_copy.toBinary(), 'binary');
      }
    }
  }, {
    key: "public_key",
    value: function public_key(b, _public_key) {
      if (!b) {
        return;
      }

      if (_public_key) {
        var buffer = _public_key.toBuffer();

        b.append(buffer.toString('binary'), 'binary');
        return;
      } else {
        buffer = FastParser.fixed_data(b, 33);
        return _ecc.PublicKey.fromBuffer(buffer);
      }
    }
  }, {
    key: "ripemd160",
    value: function ripemd160(b, _ripemd) {
      if (!b) {
        return;
      }

      if (_ripemd) {
        FastParser.fixed_data(b, 20, _ripemd);
        return;
      } else {
        return FastParser.fixed_data(b, 20);
      }
    }
  }, {
    key: "time_point_sec",
    value: function time_point_sec(b, epoch) {
      if (epoch) {
        epoch = Math.ceil(epoch / 1000);
        b.writeInt32(epoch);
        return;
      } else {
        epoch = b.readInt32(); // fc::time_point_sec

        return new Date(epoch * 1000);
      }
    }
  }]);

  return FastParser;
}();

module.exports = FastParser;

/***/ }),

/***/ 3309:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(3019);

__webpack_require__(3040);

__webpack_require__(3041);

__webpack_require__(3042);

__webpack_require__(3052);

__webpack_require__(3054);

__webpack_require__(3076);

__webpack_require__(3065);

__webpack_require__(3057);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.fromImpliedDecimal = fromImpliedDecimal;
exports.toImpliedDecimal = toImpliedDecimal;

__webpack_require__(3083);

__webpack_require__(3197);

__webpack_require__(3243);

__webpack_require__(3066);

__webpack_require__(3080);

var _assert = _interopRequireDefault(__webpack_require__(3252));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
    Convert 12.34 with a precision of 3 into 12340

    @arg {number|string} number - Use strings for large numbers.  This may contain one decimal but no sign
    @arg {number} precision - number of implied decimal places (usually causes right zero padding)
    @return {string} -
*/
function toImpliedDecimal(number, precision) {
  if (typeof number === "number") {
    (0, _assert.default)(number <= 9007199254740991, "overflow");
    number = "" + number;
  } else if (number.toString) number = number.toString();

  (0, _assert.default)(typeof number === "string", "number should be an actual number or string: " + _typeof(number));
  number = number.trim();
  (0, _assert.default)(/^[0-9]*\.?[0-9]*$/.test(number), "Invalid decimal number " + number);

  var _number$split = number.split("."),
      _number$split2 = _slicedToArray(_number$split, 2),
      _number$split2$ = _number$split2[0],
      whole = _number$split2$ === void 0 ? "" : _number$split2$,
      _number$split2$2 = _number$split2[1],
      decimal = _number$split2$2 === void 0 ? "" : _number$split2$2;

  var padding = precision - decimal.length;
  (0, _assert.default)(padding >= 0, "Too many decimal digits in " + number + " to create an implied decimal of " + precision);

  for (var i = 0; i < padding; i++) {
    decimal += "0";
  }

  while (whole.charAt(0) === "0") {
    whole = whole.substring(1);
  }

  return whole + decimal;
}

function fromImpliedDecimal(number, precision) {
  if (typeof number === "number") {
    (0, _assert.default)(number <= 9007199254740991, "overflow");
    number = "" + number;
  } else if (number.toString) number = number.toString();

  while (number.length < precision + 1) {
    // 0.123
    number = "0" + number;
  } // 44000 => 44.000


  var dec_string = number.substring(number.length - precision);
  return number.substring(0, number.length - precision) + (dec_string ? "." + dec_string : "");
}

/***/ }),

/***/ 3314:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(3083);

__webpack_require__(3197);

__webpack_require__(3078);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Long = (__webpack_require__(439).Long);

var v = __webpack_require__(3310);

var DB_MAX_INSTANCE_ID = Long.fromNumber(Math.pow(2, 48) - 1);

var ObjectId = /*#__PURE__*/function () {
  function ObjectId(space, type, instance) {
    _classCallCheck(this, ObjectId);

    this.space = space;
    this.type = type;
    this.instance = instance;
    var instance_string = this.instance.toString();
    var object_id = "".concat(this.space, ".").concat(this.type, ".").concat(instance_string);

    if (!v.is_digits(instance_string)) {
      throw new ("Invalid object id ".concat(object_id))();
    }
  }

  _createClass(ObjectId, [{
    key: "toLong",
    value: function toLong() {
      return Long.fromNumber(this.space).shiftLeft(56).or(Long.fromNumber(this.type).shiftLeft(48).or(this.instance));
    }
  }, {
    key: "appendByteBuffer",
    value: function appendByteBuffer(b) {
      return b.writeUint64(this.toLong());
    }
  }, {
    key: "toString",
    value: function toString() {
      return "".concat(this.space, ".").concat(this.type, ".").concat(this.instance.toString());
    }
  }], [{
    key: "fromString",
    value: function fromString(value) {
      if (value.space !== undefined && value.type !== undefined && value.instance !== undefined) {
        return value;
      }

      var params = v.require_match(/^([0-9]+)\.([0-9]+)\.([0-9]+)$/, v.required(value, "object_id"), "object_id");
      return new ObjectId(parseInt(params[1]), parseInt(params[2]), Long.fromString(params[3]));
    }
  }, {
    key: "fromLong",
    value: function fromLong(long) {
      var space = long.shiftRight(56).toInt();
      var type = long.shiftRight(48).toInt() & 0x00ff;
      var instance = long.and(DB_MAX_INSTANCE_ID);
      return new ObjectId(space, type, instance);
    }
  }, {
    key: "fromByteBuffer",
    value: function fromByteBuffer(b) {
      return ObjectId.fromLong(b.readUint64());
    }
  }]);

  return ObjectId;
}();

module.exports = ObjectId;

/***/ }),

/***/ 3247:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(3089);

var _types = _interopRequireDefault(__webpack_require__(3248));

var _serializer = _interopRequireDefault(__webpack_require__(3316));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This file is merge updated from steemd's js_operation_serializer program.

/*

./js_operation_serializer |
sed 's/void/future_extensions/g'|
sed 's/steemit_protocol:://g'|
sed 's/14static_variantIJNS_12fixed_stringINSt3__14pairIyyEEEEEEE/string/g'|
sed 's/steemit_future_extensions/future_extensions/g'|
sed 's/steemit_protocol_//g' > tmp.coffee

*/
// coffee tmp.coffee # fix errors until you see: `ChainTypes is not defined`

/*

   remove these 7 lines from tmp.coffee:

static_variant [
    pow2
    equihash_pow
] = static_variant [
    pow2
    equihash_pow
]

*/
// npm i -g decaffeinate
// decaffeinate tmp.coffee
// Merge tmp.js - See "Generated code follows" below
var int16 = _types.default.int16,
    uint8 = _types.default.uint8,
    uint16 = _types.default.uint16,
    uint32 = _types.default.uint32,
    uint64 = _types.default.uint64,
    string = _types.default.string,
    fixed_string = _types.default.fixed_string,
    string_binary = _types.default.string_binary,
    bytes = _types.default.bytes,
    bool = _types.default.bool,
    array = _types.default.array,
    static_variant = _types.default.static_variant,
    variant_object = _types.default.variant_object,
    map = _types.default.map,
    set = _types.default.set,
    public_key = _types.default.public_key,
    time_point_sec = _types.default.time_point_sec,
    optional = _types.default.optional,
    asset = _types.default.asset,
    asset_16 = _types.default.asset_16;
var future_extensions = _types.default.void;
var hardfork_version_vote = _types.default.void;
var version = _types.default.void; // Place-holder, their are dependencies on "operation" .. The final list of
// operations is not avialble until the very end of the generated code.
// See: operation.st_operations = ...

var operation = static_variant();
module.exports.operation = operation; // For module.exports

var Serializer = function Serializer(operation_name, serilization_types_object) {
  var s = new _serializer.default(operation_name, serilization_types_object);
  return module.exports[operation_name] = s;
};

var beneficiaries = new Serializer("beneficiaries", {
  account: string,
  weight: uint16
});
var comment_payout_beneficiaries = new Serializer(0, {
  beneficiaries: set(beneficiaries)
});
var comment_auction_window_reward_destination = new Serializer(1, {
  destination: uint64
});
var comment_curation_rewards_percent = new Serializer(2, {
  percent: uint16
});
var account_referral = new Serializer(0, {
  referrer: string,
  interest_rate: uint16,
  end_date: time_point_sec,
  break_fee: asset
});
var transaction = new Serializer("transaction", {
  ref_block_num: uint16,
  ref_block_prefix: uint32,
  expiration: time_point_sec,
  operations: array(operation),
  extensions: set(future_extensions)
});
var encrypted_memo = new Serializer("encrypted_memo", {
  from: public_key,
  to: public_key,
  nonce: uint64,
  check: uint32,
  encrypted: string_binary
}); // Custom-types after Generated code
// ##  Generated code follows
// -------------------------------

/*
When updating generated code (fix closing notation)
Replace:  var operation = static_variant([
with:     operation.st_operations = [

Delete (these are custom types instead):
let public_key = new Serializer( 
    "public_key",
    {key_data: bytes(33)}
);

let asset = new Serializer( 
    "asset",
    {amount: int64,
    symbol: uint64}
);

Replace: authority.prototype.account_authority_map
With: map((string), (uint16))
*/

var signed_transaction = new Serializer("signed_transaction", {
  ref_block_num: uint16,
  ref_block_prefix: uint32,
  expiration: time_point_sec,
  operations: array(operation),
  extensions: set(future_extensions),
  signatures: array(bytes(65))
});
var signed_block = new Serializer("signed_block", {
  previous: bytes(20),
  timestamp: time_point_sec,
  witness: string,
  transaction_merkle_root: bytes(20),
  extensions: set(static_variant([future_extensions, version, hardfork_version_vote])),
  witness_signature: bytes(65),
  transactions: array(signed_transaction)
});
var block_header = new Serializer("block_header", {
  previous: bytes(20),
  timestamp: time_point_sec,
  witness: string,
  transaction_merkle_root: bytes(20),
  extensions: set(static_variant([future_extensions, version, hardfork_version_vote]))
});
var signed_block_header = new Serializer("signed_block_header", {
  previous: bytes(20),
  timestamp: time_point_sec,
  witness: string,
  transaction_merkle_root: bytes(20),
  extensions: set(static_variant([future_extensions, version, hardfork_version_vote])),
  witness_signature: bytes(65)
});
var vote = new Serializer("vote", {
  voter: string,
  author: string,
  permlink: string,
  weight: int16
});
var comment = new Serializer("comment", {
  parent_author: string,
  parent_permlink: string,
  author: string,
  permlink: string,
  title: string,
  body: string,
  json_metadata: string
});
var transfer = new Serializer("transfer", {
  from: string,
  to: string,
  amount: asset,
  memo: string
});
var transfer_to_vesting = new Serializer("transfer_to_vesting", {
  from: string,
  to: string,
  amount: asset
});
var withdraw_vesting = new Serializer("withdraw_vesting", {
  account: string,
  vesting_shares: asset
});
var limit_order_create = new Serializer("limit_order_create", {
  owner: string,
  orderid: uint32,
  amount_to_sell: asset,
  min_to_receive: asset,
  fill_or_kill: bool,
  expiration: time_point_sec
});
var limit_order_cancel = new Serializer("limit_order_cancel", {
  owner: string,
  orderid: uint32
});
var price = new Serializer("price", {
  base: asset,
  quote: asset
});
var feed_publish = new Serializer("feed_publish", {
  publisher: string,
  exchange_rate: price
});
var convert = new Serializer("convert", {
  owner: string,
  requestid: uint32,
  amount: asset
});
var authority = new Serializer("authority", {
  weight_threshold: uint32,
  account_auths: map(string, uint16),
  key_auths: map(public_key, uint16)
});
var account_create = new Serializer("account_create", {
  fee: asset,
  creator: string,
  new_account_name: fixed_string,
  owner: authority,
  active: authority,
  posting: authority,
  memo_key: public_key,
  json_metadata: string
});
var account_update = new Serializer("account_update", {
  account: string,
  owner: optional(authority),
  active: optional(authority),
  posting: optional(authority),
  memo_key: public_key,
  json_metadata: string
});
var chain_properties = new Serializer("chain_properties", {
  account_creation_fee: asset,
  maximum_block_size: uint32,
  sbd_interest_rate: uint16
});
var witness_update = new Serializer("witness_update", {
  owner: string,
  url: string,
  block_signing_key: public_key,
  props: chain_properties,
  fee: asset
});
var account_witness_vote = new Serializer("account_witness_vote", {
  account: string,
  witness: string,
  approve: bool
});
var account_witness_proxy = new Serializer("account_witness_proxy", {
  account: string,
  proxy: string
});
var pow = new Serializer("pow", {
  worker: public_key,
  input: bytes(32),
  signature: bytes(65),
  work: bytes(32)
});
var custom = new Serializer("custom", {
  required_auths: set(string),
  id: uint16,
  data: bytes()
});
var report_over_production = new Serializer("report_over_production", {
  reporter: string,
  first_block: signed_block_header,
  second_block: signed_block_header
});
var delete_comment = new Serializer("delete_comment", {
  author: string,
  permlink: string
});
var custom_json = new Serializer("custom_json", {
  required_auths: set(string),
  required_posting_auths: set(string),
  id: string,
  json: string
});
var comment_options = new Serializer("comment_options", {
  author: string,
  permlink: string,
  max_accepted_payout: asset,
  percent_steem_dollars: uint16,
  allow_votes: bool,
  allow_curation_rewards: bool,
  extensions: set(static_variant([comment_payout_beneficiaries, comment_auction_window_reward_destination, comment_curation_rewards_percent]))
});
var set_withdraw_vesting_route = new Serializer("set_withdraw_vesting_route", {
  from_account: string,
  to_account: string,
  percent: uint16,
  auto_vest: bool
});
var limit_order_create2 = new Serializer("limit_order_create2", {
  owner: string,
  orderid: uint32,
  amount_to_sell: asset,
  exchange_rate: price,
  fill_or_kill: bool,
  expiration: time_point_sec
});
var challenge_authority = new Serializer("challenge_authority", {
  challenger: string,
  challenged: string,
  require_owner: bool
});
var prove_authority = new Serializer("prove_authority", {
  challenged: string,
  require_owner: bool
});
var request_account_recovery = new Serializer("request_account_recovery", {
  recovery_account: string,
  account_to_recover: string,
  new_owner_authority: authority,
  extensions: set(future_extensions)
});
var recover_account = new Serializer("recover_account", {
  account_to_recover: string,
  new_owner_authority: authority,
  recent_owner_authority: authority,
  extensions: set(future_extensions)
});
var change_recovery_account = new Serializer("change_recovery_account", {
  account_to_recover: string,
  new_recovery_account: string,
  extensions: set(future_extensions)
});
var escrow_transfer = new Serializer("escrow_transfer", {
  from: string,
  to: string,
  sbd_amount: asset,
  steem_amount: asset,
  escrow_id: uint32,
  agent: string,
  fee: asset,
  json_meta: string,
  ratification_deadline: time_point_sec,
  escrow_expiration: time_point_sec
});
var escrow_dispute = new Serializer("escrow_dispute", {
  from: string,
  to: string,
  agent: string,
  who: string,
  escrow_id: uint32
});
var escrow_release = new Serializer("escrow_release", {
  from: string,
  to: string,
  agent: string,
  who: string,
  receiver: string,
  escrow_id: uint32,
  sbd_amount: asset,
  steem_amount: asset
});
var pow2_input = new Serializer("pow2_input", {
  worker_account: string,
  prev_block: bytes(20),
  nonce: uint64
});
var pow2 = new Serializer("pow2", {
  input: pow2_input,
  pow_summary: uint32
});
var equihash_proof = new Serializer("equihash_proof", {
  n: uint32,
  k: uint32,
  seed: bytes(32),
  inputs: array(uint32)
});
var equihash_pow = new Serializer("equihash_pow", {
  input: pow2_input,
  proof: equihash_proof,
  prev_block: bytes(20),
  pow_summary: uint32
});
var escrow_approve = new Serializer("escrow_approve", {
  from: string,
  to: string,
  agent: string,
  who: string,
  escrow_id: uint32,
  approve: bool
});
var transfer_to_savings = new Serializer("transfer_to_savings", {
  from: string,
  to: string,
  amount: asset,
  memo: string
});
var transfer_from_savings = new Serializer("transfer_from_savings", {
  from: string,
  request_id: uint32,
  to: string,
  amount: asset,
  memo: string
});
var cancel_transfer_from_savings = new Serializer("cancel_transfer_from_savings", {
  from: string,
  request_id: uint32
});
var custom_binary = new Serializer("custom_binary", {
  required_owner_auths: set(string),
  required_active_auths: set(string),
  required_posting_auths: set(string),
  required_auths: array(authority),
  id: string,
  data: bytes()
});
var decline_voting_rights = new Serializer("decline_voting_rights", {
  account: string,
  decline: bool
});
var reset_account = new Serializer("reset_account", {
  reset_account: string,
  account_to_reset: string,
  new_owner_authority: authority
});
var set_reset_account = new Serializer("set_reset_account", {
  account: string,
  current_reset_account: string,
  reset_account: string
});
var delegate_vesting_shares = new Serializer("delegate_vesting_shares", {
  delegator: string,
  delegatee: string,
  vesting_shares: asset
});
var account_create_with_delegation = new Serializer("account_create_with_delegation", {
  fee: asset,
  delegation: asset,
  creator: string,
  new_account_name: fixed_string,
  owner: authority,
  active: authority,
  posting: authority,
  memo_key: public_key,
  json_metadata: string,
  extensions: set(static_variant([account_referral]))
});
var account_create_with_invite = new Serializer("account_create_with_invite", {
  invite_secret: string,
  creator: string,
  new_account_name: fixed_string,
  owner: authority,
  active: authority,
  posting: authority,
  memo_key: public_key,
  json_metadata: string,
  extensions: set(future_extensions)
});
var account_metadata = new Serializer("account_metadata", {
  account: string,
  json_metadata: string
});
var operation_wrapper = new Serializer("operation_wrapper", {
  op: operation
});
var proposal_create = new Serializer("proposal_create", {
  author: string,
  title: string,
  memo: string,
  expiration_time: time_point_sec,
  proposed_operations: array(operation_wrapper),
  review_period_time: optional(time_point_sec),
  extensions: set(future_extensions)
});
var proposal_update = new Serializer("proposal_update", {
  author: string,
  title: string,
  active_approvals_to_add: set(string),
  active_approvals_to_remove: set(string),
  owner_approvals_to_add: set(string),
  owner_approvals_to_remove: set(string),
  posting_approvals_to_add: set(string),
  posting_approvals_to_remove: set(string),
  key_approvals_to_add: set(public_key),
  key_approvals_to_remove: set(public_key),
  extensions: set(future_extensions)
});
var proposal_delete = new Serializer("proposal_delete", {
  author: string,
  title: string,
  requester: string,
  extensions: set(future_extensions)
});
var chain_properties_18 = new Serializer(1, {
  account_creation_fee: asset,
  maximum_block_size: uint32,
  sbd_interest_rate: uint16,
  create_account_min_golos_fee: asset,
  create_account_min_delegation: asset,
  create_account_delegation_time: uint32,
  min_delegation: asset
});
var chain_properties_19 = new Serializer(2, {
  account_creation_fee: asset,
  maximum_block_size: uint32,
  sbd_interest_rate: uint16,
  create_account_min_golos_fee: asset,
  create_account_min_delegation: asset,
  create_account_delegation_time: uint32,
  min_delegation: asset,
  max_referral_interest_rate: uint16,
  max_referral_term_sec: uint32,
  min_referral_break_fee: asset,
  max_referral_break_fee: asset,
  posts_window: uint16,
  posts_per_window: uint16,
  comments_window: uint16,
  comments_per_window: uint16,
  votes_window: uint16,
  votes_per_window: uint16,
  auction_window_size: uint16,
  max_delegated_vesting_interest_rate: uint16,
  custom_ops_bandwidth_multiplier: uint16,
  min_curation_percent: uint16,
  max_curation_percent: uint16,
  curation_reward_curve: uint64,
  allow_distribute_auction_reward: bool,
  allow_return_auction_reward_to_fund: bool
});
var chain_properties_22 = new Serializer(3, {
  account_creation_fee: asset,
  maximum_block_size: uint32,
  sbd_interest_rate: uint16,
  create_account_min_golos_fee: asset,
  create_account_min_delegation: asset,
  create_account_delegation_time: uint32,
  min_delegation: asset,
  max_referral_interest_rate: uint16,
  max_referral_term_sec: uint32,
  min_referral_break_fee: asset,
  max_referral_break_fee: asset,
  posts_window: uint16,
  posts_per_window: uint16,
  comments_window: uint16,
  comments_per_window: uint16,
  votes_window: uint16,
  votes_per_window: uint16,
  auction_window_size: uint16,
  max_delegated_vesting_interest_rate: uint16,
  custom_ops_bandwidth_multiplier: uint16,
  min_curation_percent: uint16,
  max_curation_percent: uint16,
  curation_reward_curve: uint64,
  allow_distribute_auction_reward: bool,
  allow_return_auction_reward_to_fund: bool,
  worker_reward_percent: uint16,
  witness_reward_percent: uint16,
  vesting_reward_percent: uint16,
  worker_request_creation_fee: asset,
  worker_request_approve_min_percent: uint16,
  sbd_debt_convert_rate: uint16,
  vote_regeneration_per_day: uint32,
  witness_skipping_reset_time: uint32,
  witness_idleness_time: uint32,
  account_idleness_time: uint32
});
var chain_properties_23 = new Serializer(4, {
  account_creation_fee: asset,
  maximum_block_size: uint32,
  sbd_interest_rate: uint16,
  create_account_min_golos_fee: asset,
  create_account_min_delegation: asset,
  create_account_delegation_time: uint32,
  min_delegation: asset,
  max_referral_interest_rate: uint16,
  max_referral_term_sec: uint32,
  min_referral_break_fee: asset,
  max_referral_break_fee: asset,
  posts_window: uint16,
  posts_per_window: uint16,
  comments_window: uint16,
  comments_per_window: uint16,
  votes_window: uint16,
  votes_per_window: uint16,
  auction_window_size: uint16,
  max_delegated_vesting_interest_rate: uint16,
  custom_ops_bandwidth_multiplier: uint16,
  min_curation_percent: uint16,
  max_curation_percent: uint16,
  curation_reward_curve: uint64,
  allow_distribute_auction_reward: bool,
  allow_return_auction_reward_to_fund: bool,
  worker_reward_percent: uint16,
  witness_reward_percent: uint16,
  vesting_reward_percent: uint16,
  worker_request_creation_fee: asset,
  worker_request_approve_min_percent: uint16,
  sbd_debt_convert_rate: uint16,
  vote_regeneration_per_day: uint32,
  witness_skipping_reset_time: uint32,
  witness_idleness_time: uint32,
  account_idleness_time: uint32,
  claim_idleness_time: uint32,
  min_invite_balance: asset
});
var chain_properties_24 = new Serializer(5, {
  account_creation_fee: asset,
  maximum_block_size: uint32,
  sbd_interest_rate: uint16,
  create_account_min_golos_fee: asset,
  create_account_min_delegation: asset,
  create_account_delegation_time: uint32,
  min_delegation: asset,
  max_referral_interest_rate: uint16,
  max_referral_term_sec: uint32,
  min_referral_break_fee: asset,
  max_referral_break_fee: asset,
  posts_window: uint16,
  posts_per_window: uint16,
  comments_window: uint16,
  comments_per_window: uint16,
  votes_window: uint16,
  votes_per_window: uint16,
  auction_window_size: uint16,
  max_delegated_vesting_interest_rate: uint16,
  custom_ops_bandwidth_multiplier: uint16,
  min_curation_percent: uint16,
  max_curation_percent: uint16,
  curation_reward_curve: uint64,
  allow_distribute_auction_reward: bool,
  allow_return_auction_reward_to_fund: bool,
  worker_reward_percent: uint16,
  witness_reward_percent: uint16,
  vesting_reward_percent: uint16,
  worker_request_creation_fee: asset,
  worker_request_approve_min_percent: uint16,
  sbd_debt_convert_rate: uint16,
  vote_regeneration_per_day: uint32,
  witness_skipping_reset_time: uint32,
  witness_idleness_time: uint32,
  account_idleness_time: uint32,
  claim_idleness_time: uint32,
  min_invite_balance: asset,
  asset_creation_fee: asset,
  invite_transfer_interval_sec: uint32
});
var chain_properties_26 = new Serializer(6, {
  account_creation_fee: asset,
  maximum_block_size: uint32,
  sbd_interest_rate: uint16,
  create_account_min_golos_fee: asset,
  create_account_min_delegation: asset,
  create_account_delegation_time: uint32,
  min_delegation: asset,
  max_referral_interest_rate: uint16,
  max_referral_term_sec: uint32,
  min_referral_break_fee: asset,
  max_referral_break_fee: asset,
  posts_window: uint16,
  posts_per_window: uint16,
  comments_window: uint16,
  comments_per_window: uint16,
  votes_window: uint16,
  votes_per_window: uint16,
  auction_window_size: uint16,
  max_delegated_vesting_interest_rate: uint16,
  custom_ops_bandwidth_multiplier: uint16,
  min_curation_percent: uint16,
  max_curation_percent: uint16,
  curation_reward_curve: uint64,
  allow_distribute_auction_reward: bool,
  allow_return_auction_reward_to_fund: bool,
  worker_reward_percent: uint16,
  witness_reward_percent: uint16,
  vesting_reward_percent: uint16,
  worker_request_creation_fee: asset,
  worker_request_approve_min_percent: uint16,
  sbd_debt_convert_rate: uint16,
  vote_regeneration_per_day: uint32,
  witness_skipping_reset_time: uint32,
  witness_idleness_time: uint32,
  account_idleness_time: uint32,
  claim_idleness_time: uint32,
  min_invite_balance: asset,
  asset_creation_fee: asset,
  invite_transfer_interval_sec: uint32,
  convert_fee_percent: uint16,
  min_golos_power_to_curate: asset,
  worker_emission_percent: uint16,
  vesting_of_remain_percent: uint16,
  negrep_posting_window: uint16,
  negrep_posting_per_window: uint16
});
var chain_properties_update = new Serializer("chain_properties_update", {
  owner: string,
  props: static_variant([chain_properties, chain_properties_18, chain_properties_19, chain_properties_22, chain_properties_23, chain_properties_24, chain_properties_26])
});
var break_free_referral = new Serializer("break_free_referral", {
  referral: string,
  extensions: set(future_extensions)
});
var delegate_vesting_shares_with_interest = new Serializer("delegate_vesting_shares_with_interest", {
  delegator: string,
  delegatee: string,
  vesting_shares: asset,
  interest_rate: uint16,
  extensions: set(future_extensions)
});
var reject_vesting_shares_delegation = new Serializer("reject_vesting_shares_delegation", {
  delegator: string,
  delegatee: string,
  extensions: set(future_extensions)
});
var transit_to_cyberway = new Serializer("transit_to_cyberway", {
  owner: string,
  vote_to_transit: bool
});
var worker_request = new Serializer("worker_request", {
  author: string,
  permlink: string,
  worker: string,
  required_amount_min: asset,
  required_amount_max: asset,
  vest_reward: bool,
  duration: uint32,
  extensions: set(future_extensions)
});
var worker_request_delete = new Serializer("worker_request_delete", {
  author: string,
  permlink: string,
  extensions: set(future_extensions)
});
var worker_request_vote = new Serializer("worker_request_vote", {
  voter: string,
  author: string,
  permlink: string,
  vote_percent: int16,
  extensions: set(future_extensions)
});
var claim = new Serializer("claim", {
  from: string,
  to: string,
  amount: asset,
  to_vesting: bool,
  extensions: set(future_extensions)
});
var donate_memo = new Serializer("donate_memo", {
  app: string,
  version: uint16,
  target: _types.default.variant_object,
  comment: optional(string)
});
var donate = new Serializer("donate", {
  from: string,
  to: string,
  amount: asset,
  memo: donate_memo,
  extensions: set(future_extensions)
});
var transfer_to_tip = new Serializer("transfer_to_tip", {
  from: string,
  to: string,
  amount: asset,
  memo: string,
  extensions: set(future_extensions)
});
var transfer_from_tip = new Serializer("transfer_from_tip", {
  from: string,
  to: string,
  amount: asset,
  memo: string,
  extensions: set(future_extensions)
});
var is_invite_referral = new Serializer(0, {
  is_referral: bool
});
var invite = new Serializer("invite", {
  creator: string,
  balance: asset,
  invite_key: public_key,
  extensions: set(static_variant([is_invite_referral]))
});
var invite_claim = new Serializer("invite_claim", {
  initiator: string,
  receiver: string,
  invite_secret: string,
  extensions: set(future_extensions)
});
var asset_create = new Serializer("asset_create", {
  creator: string,
  max_supply: asset,
  allow_fee: bool,
  allow_override_transfer: bool,
  json_metadata: string,
  extensions: set(future_extensions)
});
var asset_update = new Serializer("asset_update", {
  creator: string,
  symbol: string,
  symbols_whitelist: set(string),
  fee_percent: uint16,
  json_metadata: string,
  extensions: set(future_extensions)
});
var asset_issue = new Serializer("asset_issue", {
  creator: string,
  amount: asset,
  to: string,
  extensions: set(future_extensions)
});
var asset_transfer = new Serializer("asset_transfer", {
  creator: string,
  symbol: string,
  new_owner: string,
  extensions: set(future_extensions)
});
var override_transfer = new Serializer("override_transfer", {
  creator: string,
  from: string,
  to: string,
  amount: asset,
  memo: string,
  extensions: set(future_extensions)
});
var invite_donate = new Serializer("invite_donate", {
  from: string,
  invite_key: public_key,
  amount: asset,
  memo: string,
  extensions: set(future_extensions)
});
var invite_transfer = new Serializer("invite_transfer", {
  from: public_key,
  to: public_key,
  amount: asset,
  memo: string,
  extensions: set(future_extensions)
});
var pair_to_cancel = new Serializer(0, {
  base: string,
  quote: string,
  reverse: bool
});
var limit_order_cancel_ex = new Serializer("limit_order_cancel_ex", {
  owner: string,
  orderid: uint32,
  extensions: set(static_variant([pair_to_cancel]))
});
var fill_convert_request = new Serializer("fill_convert_request", {
  owner: string,
  requestid: uint32,
  amount_in: asset,
  amount_out: asset
});
var author_reward = new Serializer("author_reward", {
  author: string,
  permlink: string,
  sbd_payout: asset,
  steem_payout: asset,
  vesting_payout: asset
});
var curation_reward = new Serializer("curation_reward", {
  curator: string,
  reward: asset,
  comment_author: string,
  comment_permlink: string
});
var comment_reward = new Serializer("comment_reward", {
  author: string,
  permlink: string,
  payout: asset
});
var liquidity_reward = new Serializer("liquidity_reward", {
  owner: string,
  payout: asset
});
var interest = new Serializer("interest", {
  owner: string,
  interest: asset
});
var fill_vesting_withdraw = new Serializer("fill_vesting_withdraw", {
  from_account: string,
  to_account: string,
  withdrawn: asset,
  deposited: asset
});
var fill_order = new Serializer("fill_order", {
  current_owner: string,
  current_orderid: uint32,
  current_pays: asset,
  current_trade_fee: asset,
  current_trade_fee_receiver: string,
  open_owner: string,
  open_orderid: uint32,
  open_pays: asset,
  open_trade_fee: asset,
  open_trade_fee_receiver: string
});
var shutdown_witness = new Serializer("shutdown_witness", {
  owner: string
});
var fill_transfer_from_savings = new Serializer("fill_transfer_from_savings", {
  from: string,
  to: string,
  amount: asset,
  request_id: uint32,
  memo: string
});
var hardfork = new Serializer("hardfork", {
  hardfork_id: uint32
});
var comment_payout_update = new Serializer("comment_payout_update", {
  author: string,
  permlink: string
});
var comment_benefactor_reward = new Serializer("comment_benefactor_reward", {
  benefactor: string,
  author: string,
  permlink: string,
  reward: asset
});
var return_vesting_delegation = new Serializer("return_vesting_delegation", {
  account: string,
  vesting_shares: asset
});
operation.st_operations = [vote, comment, transfer, transfer_to_vesting, withdraw_vesting, limit_order_create, limit_order_cancel, feed_publish, convert, account_create, account_update, witness_update, account_witness_vote, account_witness_proxy, pow, custom, report_over_production, delete_comment, custom_json, comment_options, set_withdraw_vesting_route, limit_order_create2, challenge_authority, prove_authority, request_account_recovery, recover_account, change_recovery_account, escrow_transfer, escrow_dispute, escrow_release, pow2, escrow_approve, transfer_to_savings, transfer_from_savings, cancel_transfer_from_savings, custom_binary, decline_voting_rights, reset_account, set_reset_account, delegate_vesting_shares, account_create_with_delegation, account_metadata, proposal_create, proposal_update, proposal_delete, chain_properties_update, break_free_referral, delegate_vesting_shares_with_interest, reject_vesting_shares_delegation, transit_to_cyberway, worker_request, worker_request_delete, worker_request_vote, claim, donate, transfer_to_tip, transfer_from_tip, invite, invite_claim, account_create_with_invite, asset_create, asset_update, asset_issue, asset_transfer, override_transfer, invite_donate, invite_transfer, limit_order_cancel_ex, fill_convert_request, author_reward, curation_reward, comment_reward, liquidity_reward, interest, fill_vesting_withdraw, fill_order, shutdown_witness, fill_transfer_from_savings, hardfork, comment_payout_update, comment_benefactor_reward, return_vesting_delegation]; //# -------------------------------
//#  Generated code end  S T O P
//# -------------------------------
// Make sure all tests pass
// npm test

/***/ }),

/***/ 3316:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];


__webpack_require__(3042);

__webpack_require__(3083);

__webpack_require__(3054);

__webpack_require__(3215);

__webpack_require__(3078);

__webpack_require__(3197);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ByteBuffer = __webpack_require__(439);

var EC = __webpack_require__(3317);

var HEX_DUMP = ({"NODE_ENV":"production"}).npm_config__graphene_serializer_hex_dump;

var Serializer = /*#__PURE__*/function () {
  function Serializer(operation_name, types) {
    _classCallCheck(this, Serializer);

    this.operation_name = operation_name;
    this.types = types;
    if (this.types) this.keys = Object.keys(this.types);
    Serializer.printDebug = true;
  }

  _createClass(Serializer, [{
    key: "fromByteBuffer",
    value: function fromByteBuffer(b) {
      var object = {};
      var field = null;

      try {
        var iterable = this.keys;

        for (var i = 0, field; i < iterable.length; i++) {
          field = iterable[i];
          var type = this.types[field];

          try {
            if (HEX_DUMP) {
              if (type.operation_name) {
                console.error(type.operation_name);
              } else {
                var o1 = b.offset;
                type.fromByteBuffer(b);
                var o2 = b.offset;
                b.offset = o1; //b.reset()

                var _b = b.copy(o1, o2);

                console.error("".concat(this.operation_name, ".").concat(field, "\t"), _b.toHex());
              }
            }

            object[field] = type.fromByteBuffer(b);
          } catch (e) {
            if (Serializer.printDebug) {
              console.error("Error reading ".concat(this.operation_name, ".").concat(field, " in data:"));
              b.printDebug();
            }

            throw e;
          }
        }
      } catch (error) {
        EC.throw(this.operation_name + '.' + field, error);
      }

      return object;
    }
  }, {
    key: "appendByteBuffer",
    value: function appendByteBuffer(b, object) {
      var field = null;

      try {
        var iterable = this.keys;

        for (var i = 0, field; i < iterable.length; i++) {
          field = iterable[i];
          var type = this.types[field];
          type.appendByteBuffer(b, object[field]);
        }
      } catch (error) {
        try {
          EC.throw(this.operation_name + '.' + field + " = " + JSON.stringify(object[field]), error);
        } catch (e) {
          // circular ref
          EC.throw(this.operation_name + '.' + field + " = " + object[field], error);
        }
      }

      return;
    }
  }, {
    key: "fromObject",
    value: function fromObject(serialized_object) {
      var result = {};
      var field = null;

      try {
        var iterable = this.keys;

        for (var i = 0, field; i < iterable.length; i++) {
          field = iterable[i];
          var type = this.types[field];
          var value = serialized_object[field]; //DEBUG value = value.resolve if value.resolve
          //DEBUG console.log('... value',field,value)

          var object = type.fromObject(value);
          result[field] = object;
        }
      } catch (error) {
        EC.throw(this.operation_name + '.' + field, error);
      }

      return result;
    }
    /**
        @arg {boolean} [debug.use_default = false] - more template friendly
        @arg {boolean} [debug.annotate = false] - add user-friendly information
    */

  }, {
    key: "toObject",
    value: function toObject() {
      var serialized_object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        use_default: false,
        annotate: false
      };
      var result = {};
      var field = null;

      try {
        if (!this.types) return result;
        var iterable = this.keys;

        for (var i = 0, field; i < iterable.length; i++) {
          field = iterable[i];
          var type = this.types[field];
          var object = type.toObject(typeof serialized_object !== "undefined" && serialized_object !== null ? serialized_object[field] : undefined, debug);
          result[field] = object;

          if (HEX_DUMP) {
            var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
            var has_value = typeof serialized_object !== "undefined" && serialized_object !== null;

            if (has_value) {
              var value = serialized_object[field];
              if (value) type.appendByteBuffer(b, value);
            }

            b = b.copy(0, b.offset);
            console.error(this.operation_name + '.' + field, b.toHex());
          }
        }
      } catch (error) {
        EC.throw(this.operation_name + '.' + field, error);
      }

      return result;
    }
    /** Sort by the first element in a operation */

  }, {
    key: "compare",
    value: function compare(a, b) {
      var first_key = this.keys[0];
      var first_type = this.types[first_key];
      var valA = a[first_key];
      var valB = b[first_key];
      if (first_type.compare) return first_type.compare(valA, valB);
      if (typeof valA === "number" && typeof valB === "number") return valA - valB;
      var encoding;

      if (Buffer.isBuffer(valA) && Buffer.isBuffer(valB)) {
        // A binary string compare does not work.  If localeCompare is well supported that could replace HEX.  Performanance is very good so comparing HEX works.
        encoding = "hex";
      }

      var strA = valA.toString(encoding);
      var strB = valB.toString(encoding);
      return strA > strB ? 1 : strA < strB ? -1 : 0;
    } // <helper_functions>

  }, {
    key: "fromHex",
    value: function fromHex(hex) {
      var b = ByteBuffer.fromHex(hex, ByteBuffer.LITTLE_ENDIAN);
      return this.fromByteBuffer(b);
    }
  }, {
    key: "fromBuffer",
    value: function fromBuffer(buffer) {
      var b = ByteBuffer.fromBinary(buffer.toString("binary"), ByteBuffer.LITTLE_ENDIAN);
      return this.fromByteBuffer(b);
    }
  }, {
    key: "toHex",
    value: function toHex(object) {
      // return this.toBuffer(object).toString("hex")
      var b = this.toByteBuffer(object);
      return b.toHex();
    }
  }, {
    key: "toByteBuffer",
    value: function toByteBuffer(object) {
      var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
      this.appendByteBuffer(b, object);
      return b.copy(0, b.offset);
    }
  }, {
    key: "toBuffer",
    value: function toBuffer(object) {
      return new Buffer(this.toByteBuffer(object).toBinary(), 'binary');
    }
  }]);

  return Serializer;
}();

module.exports = Serializer;

/***/ }),

/***/ 3338:
/***/ ((module) => {

"use strict";


/** Console print any transaction object with zero default values. */
module.exports = function template(op) {
  var object = op.toObject(void 0, {
    use_default: true,
    annotate: true
  }); // visual (with descriptions)

  console.error(JSON.stringify(object, null, 4)); // usable in a copy-paste

  object = op.toObject(void 0, {
    use_default: true,
    annotate: false
  }); // copy-paste one-lineer

  console.error(JSON.stringify(object));
};

/***/ }),

/***/ 3248:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];


__webpack_require__(3019);

__webpack_require__(3040);

__webpack_require__(3041);

__webpack_require__(3042);

__webpack_require__(3052);

__webpack_require__(3054);

__webpack_require__(3076);

__webpack_require__(3065);

__webpack_require__(3057);

__webpack_require__(3066);

__webpack_require__(3203);

__webpack_require__(3083);

__webpack_require__(3197);

__webpack_require__(3243);

__webpack_require__(3080);

__webpack_require__(3242);

__webpack_require__(3078);

__webpack_require__(3231);

__webpack_require__(3249);

var _ecc = __webpack_require__(3250);

var _number_utils = __webpack_require__(3309);

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

// Low-level types that make up operations
var v = __webpack_require__(3310);

var ObjectId = __webpack_require__(3314);

var fp = __webpack_require__(3315);

var chain_types = __webpack_require__(3313);

var Types = {};
module.exports = Types;
var HEX_DUMP = ({"NODE_ENV":"production"}).npm_config__graphene_serializer_hex_dump;
var TEST = "production" === "test";
/**
* Asset symbols contain the following information
*
*  4 bit PRECISION (from 0 to 15)
*  4 bit VERSION (if whole first byte >= 100, then version is 2, and you should subtract 100 to obtain PRECISION)
*  CHAR[] up to 6 (v1) or 14 (v2) upper case alpha numeric ascii characters,
*  char = \0  null terminated
*
*  It is treated as a uint64_t (v1) or uint128_t (v2) for all internal operations, but
*  is easily converted to something that can be displayed.
*/

Types.asset = {
  fromByteBuffer: function fromByteBuffer(b) {
    var amount = b.readInt64();
    var precision = b.readUint8();
    var is_v2 = precision >= 100;
    if (is_v2) precision -= 100;
    var symbol_size = is_v2 ? 15 : 7;
    var b_copy = b.copy(b.offset, b.offset + symbol_size);
    var symbol = new Buffer(b_copy.toBinary(), "binary").toString().replace(/\x00/g, "");
    b.skip(symbol_size); // "1.000 GOLOS" always written with full precision

    var amount_string = (0, _number_utils.fromImpliedDecimal)(amount, precision);
    return amount_string + " " + symbol;
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    if (object.asset) {
      // golos.utils.AssetEditor
      object = object.asset.toString();
    } else if (object.symbol) {
      // golos.utils.Asset
      object = object.toString();
    } else {
      object = object.trim();
      if (!/^[0-9]+\.?[0-9]* [A-Za-z0-9]+\.?[A-Za-z0-9]*$/.test(object)) throw new Error("Expecting amount like '99.000 SYMBOL' or '99.000 SYMBOL.SUBSYM', instead got '" + object + "'");
    }

    var _object$split = object.split(" "),
        _object$split2 = _slicedToArray(_object$split, 2),
        amount = _object$split2[0],
        symbol = _object$split2[1];

    if (symbol.length > 14) throw new Error("Symbols are not longer than 14 characters " + symbol + "-" + symbol.length);
    var is_v2 = symbol.length > 6;
    var symbol_size = is_v2 ? 15 : 7;
    b.writeInt64(v.to_long(amount.replace(".", "")));
    var dot = amount.indexOf("."); // 0.000

    var precision = dot === -1 ? 0 : amount.length - dot - 1;
    if (is_v2) precision += 100;
    b.writeUint8(precision);
    b.append(symbol.toUpperCase(), 'binary');

    for (var i = 0; i < symbol_size - symbol.length; i++) {
      b.writeUint8(0);
    }

    return;
  },
  fromObject: function fromObject(object) {
    return object;
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (debug.use_default && object === undefined) {
      return "0.000 GOLOS";
    }

    return object;
  }
};
Types.uint8 = {
  fromByteBuffer: function fromByteBuffer(b) {
    return b.readUint8();
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    v.require_range(0, 0xFF, object, "uint8 ".concat(object));
    b.writeUint8(object);
    return;
  },
  fromObject: function fromObject(object) {
    v.require_range(0, 0xFF, object, "uint8 ".concat(object));
    return object;
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (debug.use_default && object === undefined) {
      return 0;
    }

    v.require_range(0, 0xFF, object, "uint8 ".concat(object));
    return parseInt(object);
  }
};
Types.uint16 = {
  fromByteBuffer: function fromByteBuffer(b) {
    return b.readUint16();
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    v.require_range(0, 0xFFFF, object, "uint16 ".concat(object));
    b.writeUint16(object);
    return;
  },
  fromObject: function fromObject(object) {
    v.require_range(0, 0xFFFF, object, "uint16 ".concat(object));
    return object;
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (debug.use_default && object === undefined) {
      return 0;
    }

    v.require_range(0, 0xFFFF, object, "uint16 ".concat(object));
    return parseInt(object);
  }
};
Types.uint32 = {
  fromByteBuffer: function fromByteBuffer(b) {
    return b.readUint32();
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    v.require_range(0, 0xFFFFFFFF, object, "uint32 ".concat(object));
    b.writeUint32(object);
    return;
  },
  fromObject: function fromObject(object) {
    v.require_range(0, 0xFFFFFFFF, object, "uint32 ".concat(object));
    return object;
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (debug.use_default && object === undefined) {
      return 0;
    }

    v.require_range(0, 0xFFFFFFFF, object, "uint32 ".concat(object));
    return parseInt(object);
  }
};
var MIN_SIGNED_32 = -1 * Math.pow(2, 31);
var MAX_SIGNED_32 = Math.pow(2, 31) - 1;
Types.varint32 = {
  fromByteBuffer: function fromByteBuffer(b) {
    return b.readVarint32();
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    v.require_range(MIN_SIGNED_32, MAX_SIGNED_32, object, "uint32 ".concat(object));
    b.writeVarint32(object);
    return;
  },
  fromObject: function fromObject(object) {
    v.require_range(MIN_SIGNED_32, MAX_SIGNED_32, object, "uint32 ".concat(object));
    return object;
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (debug.use_default && object === undefined) {
      return 0;
    }

    v.require_range(MIN_SIGNED_32, MAX_SIGNED_32, object, "uint32 ".concat(object));
    return parseInt(object);
  }
};
Types.int16 = {
  fromByteBuffer: function fromByteBuffer(b) {
    return b.readInt16();
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    b.writeInt16(object);
    return;
  },
  fromObject: function fromObject(object) {
    return object;
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (debug.use_default && object === undefined) {
      return 0;
    }

    return parseInt(object);
  }
};
Types.int64 = {
  fromByteBuffer: function fromByteBuffer(b) {
    return b.readInt64();
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    v.required(object);
    b.writeInt64(v.to_long(object));
    return;
  },
  fromObject: function fromObject(object) {
    v.required(object);
    return v.to_long(object);
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (debug.use_default && object === undefined) {
      return "0";
    }

    v.required(object);
    return v.to_long(object).toString();
  }
};
Types.uint64 = {
  fromByteBuffer: function fromByteBuffer(b) {
    return b.readUint64();
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    b.writeUint64(v.to_long(v.unsigned(object)));
    return;
  },
  fromObject: function fromObject(object) {
    return v.to_long(v.unsigned(object));
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (debug.use_default && object === undefined) {
      return "0";
    }

    return v.to_long(object).toString();
  }
};
Types.string = {
  fromByteBuffer: function fromByteBuffer(b) {
    return new Buffer(b.readVString(), 'utf8');
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    v.required(object);
    b.writeVString(object.toString());
    return;
  },
  fromObject: function fromObject(object) {
    v.required(object);
    return new Buffer(object, 'utf8');
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (debug.use_default && object === undefined) {
      return "";
    }

    return object.toString('utf8');
  }
};
Types.fixed_string = {
  fromByteBuffer: function fromByteBuffer(b) {
    return Types.string.fromByteBuffer(b);
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    v.required(object);
    if (object.length > 16) throw new Error("account name cannot be longer than 16 characters");
    Types.string.appendByteBuffer(b, object);
    return;
  },
  fromObject: function fromObject(object) {
    v.required(object);
    if (object.length > 16) throw new Error("account name cannot be longer than 16 characters");
    return Types.string.fromObject(object);
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return Types.string.toObject(object, debug);
  }
};
Types.string_binary = {
  fromByteBuffer: function fromByteBuffer(b) {
    var b_copy;
    var len = b.readVarint32();
    b_copy = b.copy(b.offset, b.offset + len), b.skip(len);
    return new Buffer(b_copy.toBinary(), 'binary');
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    b.writeVarint32(object.length);
    b.append(object.toString('binary'), 'binary');
    return;
  },
  fromObject: function fromObject(object) {
    v.required(object);
    return new Buffer(object);
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (debug.use_default && object === undefined) {
      return "";
    }

    return object.toString();
  }
};

Types.bytes = function (size) {
  return {
    fromByteBuffer: function fromByteBuffer(b) {
      if (size === undefined) {
        var b_copy;
        var len = b.readVarint32();
        b_copy = b.copy(b.offset, b.offset + len), b.skip(len);
        return new Buffer(b_copy.toBinary(), 'binary');
      } else {
        b_copy = b.copy(b.offset, b.offset + size), b.skip(size);
        return new Buffer(b_copy.toBinary(), 'binary');
      }
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
      v.required(object);
      if (typeof object === "string") object = new Buffer(object, "hex");

      if (size === undefined) {
        b.writeVarint32(object.length);
      }

      b.append(object.toString('binary'), 'binary');
      return;
    },
    fromObject: function fromObject(object) {
      v.required(object);
      if (Buffer.isBuffer(object)) return object;
      return new Buffer(object, 'hex');
    },
    toObject: function toObject(object) {
      var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (debug.use_default && object === undefined) {
        var zeros = function zeros(num) {
          return new Array(num).join("00");
        };

        return zeros(size);
      }

      v.required(object);
      return object.toString('hex');
    }
  };
};

Types.bool = {
  fromByteBuffer: function fromByteBuffer(b) {
    return b.readUint8() === 1;
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    // supports boolean or integer
    b.writeUint8(JSON.parse(object) ? 1 : 0);
    return;
  },
  fromObject: function fromObject(object) {
    return JSON.parse(object) ? true : false;
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (debug.use_default && object === undefined) {
      return false;
    }

    return JSON.parse(object) ? true : false;
  }
};
Types.void = {
  fromByteBuffer: function fromByteBuffer(b) {
    throw new Error("(void) undefined type");
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    throw new Error("(void) undefined type");
  },
  fromObject: function fromObject(object) {
    throw new Error("(void) undefined type");
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (debug.use_default && object === undefined) {
      return undefined;
    }

    throw new Error("(void) undefined type");
  }
};

Types.array = function (st_operation) {
  return {
    fromByteBuffer: function fromByteBuffer(b) {
      var size = b.readVarint32();

      if (HEX_DUMP) {
        console.log("varint32 size = " + size.toString(16));
      }

      var result = [];

      for (var i = 0; 0 < size ? i < size : i > size; 0 < size ? i++ : i++) {
        result.push(st_operation.fromByteBuffer(b));
      }

      return sortOperation(result, st_operation);
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
      v.required(object);
      object = sortOperation(object, st_operation);
      b.writeVarint32(object.length);

      for (var i = 0, o; i < object.length; i++) {
        o = object[i];
        st_operation.appendByteBuffer(b, o);
      }
    },
    fromObject: function fromObject(object) {
      v.required(object);
      object = sortOperation(object, st_operation);
      var result = [];

      for (var i = 0, o; i < object.length; i++) {
        o = object[i];
        result.push(st_operation.fromObject(o));
      }

      return result;
    },
    toObject: function toObject(object) {
      var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (debug.use_default && object === undefined) {
        return [st_operation.toObject(object, debug)];
      }

      v.required(object);
      object = sortOperation(object, st_operation);
      var result = [];

      for (var i = 0, o; i < object.length; i++) {
        o = object[i];
        result.push(st_operation.toObject(o, debug));
      }

      return result;
    }
  };
};

Types.time_point_sec = {
  fromByteBuffer: function fromByteBuffer(b) {
    return b.readUint32();
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    if (typeof object !== "number") object = Types.time_point_sec.fromObject(object);
    b.writeUint32(object);
    return;
  },
  fromObject: function fromObject(object) {
    v.required(object);
    if (typeof object === "number") return object;
    if (object.getTime) return Math.floor(object.getTime() / 1000);
    if (typeof object !== "string") throw new Error("Unknown date type: " + object);
    if (typeof object === "string" && !/Z$/.test(object)) object = object + "Z";
    return Math.floor(new Date(object).getTime() / 1000);
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (debug.use_default && object === undefined) return new Date(0).toISOString().split('.')[0];
    v.required(object);
    if (typeof object === "string") return object;
    if (object.getTime) return object.toISOString().split('.')[0];
    var int = parseInt(object);
    v.require_range(0, 0xFFFFFFFF, int, "uint32 ".concat(object));
    return new Date(int * 1000).toISOString().split('.')[0];
  }
};

Types.set = function (st_operation) {
  return {
    validate: function validate(array) {
      var dup_map = {};

      for (var i = 0, o; i < array.length; i++) {
        o = array[i];
        var ref;

        if (ref = _typeof(o), ['string', 'number'].indexOf(ref) >= 0) {
          if (dup_map[o] !== undefined) {
            throw new Error("duplicate (set)");
          }

          dup_map[o] = true;
        }
      }

      return sortOperation(array, st_operation);
    },
    fromByteBuffer: function fromByteBuffer(b) {
      var size = b.readVarint32();

      if (HEX_DUMP) {
        console.log("varint32 size = " + size.toString(16));
      }

      return this.validate(function () {
        var result = [];

        for (var i = 0; 0 < size ? i < size : i > size; 0 < size ? i++ : i++) {
          result.push(st_operation.fromByteBuffer(b));
        }

        return result;
      }());
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
      if (!object) {
        object = [];
      }

      b.writeVarint32(object.length);
      var iterable = this.validate(object);

      for (var i = 0, o; i < iterable.length; i++) {
        o = iterable[i];
        st_operation.appendByteBuffer(b, o);
      }

      return;
    },
    fromObject: function fromObject(object) {
      if (!object) {
        object = [];
      }

      return this.validate(function () {
        var result = [];

        for (var i = 0, o; i < object.length; i++) {
          o = object[i];
          result.push(st_operation.fromObject(o));
        }

        return result;
      }());
    },
    toObject: function toObject(object) {
      var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (debug.use_default && object === undefined) {
        return [st_operation.toObject(object, debug)];
      }

      if (!object) {
        object = [];
      }

      return this.validate(function () {
        var result = [];

        for (var i = 0, o; i < object.length; i++) {
          o = object[i];
          result.push(st_operation.toObject(o, debug));
        }

        return result;
      }());
    }
  };
}; // global_parameters_update_operation current_fees


Types.fixed_array = function (count, st_operation) {
  return {
    fromByteBuffer: function fromByteBuffer(b) {
      var i, j, ref, results;
      results = [];

      for (i = j = 0, ref = count; j < ref; i = j += 1) {
        results.push(st_operation.fromByteBuffer(b));
      }

      return sortOperation(results, st_operation);
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
      var i, j, ref;

      if (count !== 0) {
        v.required(object);
        object = sortOperation(object, st_operation);
      }

      for (i = j = 0, ref = count; j < ref; i = j += 1) {
        st_operation.appendByteBuffer(b, object[i]);
      }
    },
    fromObject: function fromObject(object) {
      var i, j, ref, results;

      if (count !== 0) {
        v.required(object);
      }

      results = [];

      for (i = j = 0, ref = count; j < ref; i = j += 1) {
        results.push(st_operation.fromObject(object[i]));
      }

      return results;
    },
    toObject: function toObject(object, debug) {
      var i, j, k, ref, ref1, results, results1;

      if (debug == null) {
        debug = {};
      }

      if (debug.use_default && object === void 0) {
        results = [];

        for (i = j = 0, ref = count; j < ref; i = j += 1) {
          results.push(st_operation.toObject(void 0, debug));
        }

        return results;
      }

      if (count !== 0) {
        v.required(object);
      }

      results1 = [];

      for (i = k = 0, ref1 = count; k < ref1; i = k += 1) {
        results1.push(st_operation.toObject(object[i], debug));
      }

      return results1;
    }
  };
};
/* Supports instance numbers (11) or object types (1.2.11).  Object type
validation is enforced when an object type is used. */


var id_type = function id_type(reserved_spaces, object_type) {
  v.required(reserved_spaces, "reserved_spaces");
  v.required(object_type, "object_type");
  return {
    fromByteBuffer: function fromByteBuffer(b) {
      return b.readVarint32();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
      v.required(object);

      if (object.resolve !== undefined) {
        object = object.resolve;
      } // convert 1.2.n into just n


      if (/^[0-9]+\.[0-9]+\.[0-9]+$/.test(object)) {
        object = v.get_instance(reserved_spaces, object_type, object);
      }

      b.writeVarint32(v.to_number(object));
      return;
    },
    fromObject: function fromObject(object) {
      v.required(object);

      if (object.resolve !== undefined) {
        object = object.resolve;
      }

      if (v.is_digits(object)) {
        return v.to_number(object);
      }

      return v.get_instance(reserved_spaces, object_type, object);
    },
    toObject: function toObject(object) {
      var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var object_type_id = chain_types.object_type[object_type];

      if (debug.use_default && object === undefined) {
        return "".concat(reserved_spaces, ".").concat(object_type_id, ".0");
      }

      v.required(object);

      if (object.resolve !== undefined) {
        object = object.resolve;
      }

      if (/^[0-9]+\.[0-9]+\.[0-9]+$/.test(object)) {
        object = v.get_instance(reserved_spaces, object_type, object);
      }

      return "".concat(reserved_spaces, ".").concat(object_type_id, ".") + object;
    }
  };
};

Types.protocol_id_type = function (name) {
  v.required(name, "name");
  return id_type(chain_types.reserved_spaces.protocol_ids, name);
};

Types.object_id_type = {
  fromByteBuffer: function fromByteBuffer(b) {
    return ObjectId.fromByteBuffer(b);
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    v.required(object);

    if (object.resolve !== undefined) {
      object = object.resolve;
    }

    object = ObjectId.fromString(object);
    object.appendByteBuffer(b);
    return;
  },
  fromObject: function fromObject(object) {
    v.required(object);

    if (object.resolve !== undefined) {
      object = object.resolve;
    }

    return ObjectId.fromString(object);
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (debug.use_default && object === undefined) {
      return "0.0.0";
    }

    v.required(object);

    if (object.resolve !== undefined) {
      object = object.resolve;
    }

    object = ObjectId.fromString(object);
    return object.toString();
  }
};
Types.vote_id = {
  TYPE: 0x000000FF,
  ID: 0xFFFFFF00,
  fromByteBuffer: function fromByteBuffer(b) {
    var value = b.readUint32();
    return {
      type: value & this.TYPE,
      id: value & this.ID
    };
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    v.required(object);
    if (object === "string") object = Types.vote_id.fromObject(object);
    var value = object.id << 8 | object.type;
    b.writeUint32(value);
    return;
  },
  fromObject: function fromObject(object) {
    v.required(object, "(type vote_id)");

    if (_typeof(object) === "object") {
      v.required(object.type, "type");
      v.required(object.id, "id");
      return object;
    }

    v.require_test(/^[0-9]+:[0-9]+$/, object, "vote_id format ".concat(object));

    var _object$split3 = object.split(':'),
        _object$split4 = _slicedToArray(_object$split3, 2),
        type = _object$split4[0],
        id = _object$split4[1];

    v.require_range(0, 0xff, type, "vote type ".concat(object));
    v.require_range(0, 0xffffff, id, "vote id ".concat(object));
    return {
      type: type,
      id: id
    };
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (debug.use_default && object === undefined) {
      return "0:0";
    }

    v.required(object);
    if (typeof object === "string") object = Types.vote_id.fromObject(object);
    return object.type + ":" + object.id;
  },
  compare: function compare(a, b) {
    if (_typeof(a) !== "object") a = Types.vote_id.fromObject(a);
    if (_typeof(b) !== "object") b = Types.vote_id.fromObject(b);
    return parseInt(a.id) - parseInt(b.id);
  }
};

Types.optional = function (st_operation) {
  v.required(st_operation, "st_operation");
  return {
    fromByteBuffer: function fromByteBuffer(b) {
      if (!(b.readUint8() === 1)) {
        return undefined;
      }

      return st_operation.fromByteBuffer(b);
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
      if (object !== null && object !== undefined) {
        b.writeUint8(1);
        st_operation.appendByteBuffer(b, object);
      } else {
        b.writeUint8(0);
      }

      return;
    },
    fromObject: function fromObject(object) {
      if (object === undefined) {
        return undefined;
      }

      return st_operation.fromObject(object);
    },
    toObject: function toObject(object) {
      var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // toObject is only null save if use_default is true
      var result_object = function () {
        if (!debug.use_default && object === undefined) {
          return undefined;
        } else {
          return st_operation.toObject(object, debug);
        }
      }();

      if (debug.annotate) {
        if (_typeof(result_object) === "object") {
          result_object.__optional = "parent is optional";
        } else {
          result_object = {
            __optional: result_object
          };
        }
      }

      return result_object;
    }
  };
};

Types.variant_object = {
  fromByteBuffer: function fromByteBuffer(b) {
    var res = {};
    var count = b.readUint8();
    if (!count) return res;

    for (var i = 0; i < count; ++i) {
      var key = string.fromByteBuffer(b);
      var val_type = b.readUint8();

      if (val_type == 5) {
        res[key] = string.fromByteBuffer(b);
      } else if (val_type == 2) {
        res[key] = uint64.fromByteBuffer(b);
      }
    }
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    b.writeUint8(Object.entries(object).length);

    for (var _i2 = 0, _Object$entries = Object.entries(object); _i2 < _Object$entries.length; _i2++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      Types.string.appendByteBuffer(b, key);

      if (typeof value === 'string') {
        b.writeUint8(5);
        Types.string.appendByteBuffer(b, value);
      } else if (typeof value === 'number') {
        b.writeUint8(2);
        Types.uint64.appendByteBuffer(b, value);
      }
    }

    return;
  },
  fromObject: function fromObject(object) {
    return object;
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return object;
  }
};

Types.static_variant = function (_st_operations) {
  return {
    nosort: true,
    st_operations: _st_operations,
    opTypeId: function opTypeId(value) {
      var pos = 0,
          type_id;
      if (typeof value === "number") type_id = value;else {
        var _iterator = _createForOfIteratorHelper(this.st_operations),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var op = _step.value;

            if (op.operation_name === value) {
              type_id = pos;
              break;
            }

            pos++;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      return type_id;
    },
    fromByteBuffer: function fromByteBuffer(b) {
      var type_id = b.readVarint32();
      var st_operation = this.st_operations[type_id];

      if (HEX_DUMP) {
        console.error("static_variant id 0x".concat(type_id.toString(16), " (").concat(type_id, ")"));
      }

      v.required(st_operation, "operation ".concat(type_id));
      return [type_id, st_operation.fromByteBuffer(b)];
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
      v.required(object);
      var type_id = this.opTypeId(object[0]);
      var st_operation = this.st_operations[type_id];
      v.required(st_operation, "operation ".concat(type_id));
      b.writeVarint32(type_id);
      st_operation.appendByteBuffer(b, object[1]);
      return;
    },
    fromObject: function fromObject(object) {
      v.required(object);
      var type_id = this.opTypeId(object[0]);
      var st_operation = this.st_operations[type_id];
      v.required(st_operation, "operation ".concat(type_id));
      return [type_id, st_operation.fromObject(object[1])];
    },
    toObject: function toObject(object) {
      var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (debug.use_default && object === undefined) {
        return [this.st_operations[0].operation_name, this.st_operations[0].toObject(undefined, debug)];
      }

      v.required(object);
      var type_id = this.opTypeId(object[0]);
      var st_operation = this.st_operations[type_id];
      v.required(st_operation, "operation ".concat(type_id));
      return [st_operation.operation_name, st_operation.toObject(object[1], debug)];
    },
    compare: function compare(a, b) {
      return strCmp(this.opTypeId(a[0]), this.opTypeId(b[0]));
    }
  };
};

Types.map = function (key_st_operation, value_st_operation) {
  return {
    validate: function validate(array) {
      if (!Array.isArray(array)) {
        throw new Error("expecting array");
      }

      var dup_map = {};

      for (var i = 0, o; i < array.length; i++) {
        o = array[i];
        var ref;

        if (!(o.length === 2)) {
          throw new Error("expecting two elements");
        }

        if (ref = _typeof(o[0]), ['number', 'string'].indexOf(ref) >= 0) {
          if (dup_map[o[0]] !== undefined) {
            throw new Error("duplicate (map)");
          }

          dup_map[o[0]] = true;
        }
      }

      return sortOperation(array, key_st_operation);
    },
    fromByteBuffer: function fromByteBuffer(b) {
      var result = [];
      var end = b.readVarint32();

      for (var i = 0; 0 < end ? i < end : i > end; 0 < end ? i++ : i++) {
        result.push([key_st_operation.fromByteBuffer(b), value_st_operation.fromByteBuffer(b)]);
      }

      return this.validate(result);
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
      this.validate(object);
      b.writeVarint32(object.length);

      for (var i = 0, o; i < object.length; i++) {
        o = object[i];
        key_st_operation.appendByteBuffer(b, o[0]);
        value_st_operation.appendByteBuffer(b, o[1]);
      }

      return;
    },
    fromObject: function fromObject(object) {
      v.required(object);
      var result = [];

      for (var i = 0, o; i < object.length; i++) {
        o = object[i];
        result.push([key_st_operation.fromObject(o[0]), value_st_operation.fromObject(o[1])]);
      }

      return this.validate(result);
    },
    toObject: function toObject(object) {
      var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (debug.use_default && object === undefined) {
        return [[key_st_operation.toObject(undefined, debug), value_st_operation.toObject(undefined, debug)]];
      }

      v.required(object);
      object = this.validate(object);
      var result = [];

      for (var i = 0, o; i < object.length; i++) {
        o = object[i];
        result.push([key_st_operation.toObject(o[0], debug), value_st_operation.toObject(o[1], debug)]);
      }

      return result;
    }
  };
};

Types.public_key = {
  toPublic: function toPublic(object) {
    if (object.resolve !== undefined) {
      object = object.resolve;
    }

    return object == null ? object : object.Q ? object : _ecc.PublicKey.fromStringOrThrow(object);
  },
  fromByteBuffer: function fromByteBuffer(b) {
    return fp.public_key(b);
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    v.required(object);
    fp.public_key(b, Types.public_key.toPublic(object));
    return;
  },
  fromObject: function fromObject(object) {
    v.required(object);

    if (object.Q) {
      return object;
    }

    return Types.public_key.toPublic(object);
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (debug.use_default && object === undefined) {
      return _ecc.ecc_config.get('address_prefix') + "859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2HqhToVM";
    }

    v.required(object);
    return object.toString();
  },
  compare: function compare(a, b) {
    // sort decending
    return -1 * strCmp(a.toString(), b.toString());
  }
};
Types.address = {
  _to_address: function _to_address(object) {
    v.required(object);

    if (object.addy) {
      return object;
    }

    return _ecc.Address.fromString(object);
  },
  fromByteBuffer: function fromByteBuffer(b) {
    return new _ecc.Address(fp.ripemd160(b));
  },
  appendByteBuffer: function appendByteBuffer(b, object) {
    fp.ripemd160(b, Types.address._to_address(object).toBuffer());
    return;
  },
  fromObject: function fromObject(object) {
    return Types.address._to_address(object);
  },
  toObject: function toObject(object) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (debug.use_default && object === undefined) {
      return _ecc.ecc_config.get('address_prefix') + "664KmHxSuQyDsfwo4WEJvWpzg1QKdg67S";
    }

    return Types.address._to_address(object).toString();
  },
  compare: function compare(a, b) {
    // sort decending
    return -1 * strCmp(a.toString(), b.toString());
  }
};

var strCmp = function strCmp(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
};

var firstEl = function firstEl(el) {
  return Array.isArray(el) ? el[0] : el;
};

var sortOperation = function sortOperation(array, st_operation) {
  // console.log('operation.nosort', st_operation.nosort)
  return st_operation.nosort ? array : st_operation.compare ? array.sort(function (a, b) {
    return st_operation.compare(firstEl(a), firstEl(b));
  }) : // custom compare operation
  array.sort(function (a, b) {
    return typeof firstEl(a) === "number" && typeof firstEl(b) === "number" ? firstEl(a) - firstEl(b) : // A binary string compare does not work. Performanance is very good so HEX is used..  localeCompare is another option.
    Buffer.isBuffer(firstEl(a)) && Buffer.isBuffer(firstEl(b)) ? strCmp(firstEl(a).toString("hex"), firstEl(b).toString("hex")) : strCmp(firstEl(a).toString(), firstEl(b).toString());
  });
};

/***/ }),

/***/ 3310:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(3019);

__webpack_require__(3040);

__webpack_require__(3041);

__webpack_require__(3042);

__webpack_require__(3052);

__webpack_require__(3054);

__webpack_require__(3078);

__webpack_require__(3066);

__webpack_require__(3083);

__webpack_require__(3197);

__webpack_require__(3072);

__webpack_require__(3311);

__webpack_require__(3080);

__webpack_require__(3215);

__webpack_require__(3203);

__webpack_require__(3243);

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _my;

var is_empty;
var is_digits;
var to_number;
var require_match;
var require_object_id;
var require_object_type;
var get_instance;
var require_relative_type;
var get_relative_instance;
var require_protocol_type;
var get_protocol_instance;
var get_protocol_type;
var require_implementation_type;
var get_implementation_instance;

var Long = (__webpack_require__(439).Long); // var BigInteger = require('bigi');


var chain_types = __webpack_require__(3313);

var MAX_SAFE_INT = 9007199254740991;
var MIN_SAFE_INT = -9007199254740991;
/**
    Most validations are skipped and the value returned unchanged when an empty string, null, or undefined is encountered (except "required"). 

    Validations support a string format for dealing with large numbers.
*/

module.exports = _my = {
  is_empty: is_empty = function is_empty(value) {
    return value === null || value === undefined;
  },
  required: function required(value) {
    var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

    if (is_empty(value)) {
      throw new Error("value required ".concat(field_name, " ").concat(value));
    }

    return value;
  },
  require_long: function require_long(value) {
    var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

    if (!Long.isLong(value)) {
      throw new Error("Long value required ".concat(field_name, " ").concat(value));
    }

    return value;
  },
  string: function string(value) {
    if (is_empty(value)) {
      return value;
    }

    if (typeof value !== "string") {
      throw new Error("string required: ".concat(value));
    }

    return value;
  },
  number: function number(value) {
    if (is_empty(value)) {
      return value;
    }

    if (typeof value !== "number") {
      throw new Error("number required: ".concat(value));
    }

    return value;
  },
  whole_number: function whole_number(value) {
    var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

    if (is_empty(value)) {
      return value;
    }

    if (/\./.test(value)) {
      throw new Error("whole number required ".concat(field_name, " ").concat(value));
    }

    return value;
  },
  unsigned: function unsigned(value) {
    var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

    if (is_empty(value)) {
      return value;
    }

    if (/-/.test(value)) {
      throw new Error("unsigned required ".concat(field_name, " ").concat(value));
    }

    return value;
  },
  is_digits: is_digits = function is_digits(value) {
    if (typeof value === "numeric") {
      return true;
    }

    return /^[0-9]+$/.test(value);
  },
  to_number: to_number = function to_number(value) {
    var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

    if (is_empty(value)) {
      return value;
    }

    _my.no_overflow53(value, field_name);

    var int_value = function () {
      if (typeof value === "number") {
        return value;
      } else {
        return parseInt(value);
      }
    }();

    return int_value;
  },
  to_long: function to_long(value) {
    var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

    if (is_empty(value)) {
      return value;
    }

    if (Long.isLong(value)) {
      return value;
    }

    _my.no_overflow64(value, field_name);

    if (typeof value === "number") {
      value = "" + value;
    }

    return Long.fromString(value);
  },
  to_string: function to_string(value) {
    var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

    if (is_empty(value)) {
      return value;
    }

    if (typeof value === "string") {
      return value;
    }

    if (typeof value === "number") {
      _my.no_overflow53(value, field_name);

      return "" + value;
    }

    if (Long.isLong(value)) {
      return value.toString();
    }

    throw "unsupported type ".concat(field_name, ": (").concat(_typeof(value), ") ").concat(value);
  },
  require_test: function require_test(regex, value) {
    var field_name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

    if (is_empty(value)) {
      return value;
    }

    if (!regex.test(value)) {
      throw new Error("unmatched ".concat(regex, " ").concat(field_name, " ").concat(value));
    }

    return value;
  },
  require_match: require_match = function require_match(regex, value) {
    var field_name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

    if (is_empty(value)) {
      return value;
    }

    var match = value.match(regex);

    if (match === null) {
      throw new Error("unmatched ".concat(regex, " ").concat(field_name, " ").concat(value));
    }

    return match;
  },
  // require_object_id: require_object_id=function(value, field_name){
  //     return require_match(
  //         /^([0-9]+)\.([0-9]+)\.([0-9]+)$/,
  //         value,
  //         field_name
  //     );
  // },
  // Does not support over 53 bits
  require_range: function require_range(min, max, value) {
    var field_name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";

    if (is_empty(value)) {
      return value;
    }

    var number = to_number(value);

    if (value < min || value > max) {
      throw new Error("out of range ".concat(value, " ").concat(field_name, " ").concat(value));
    }

    return value;
  },
  require_object_type: require_object_type = function require_object_type() {
    var reserved_spaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var type = arguments.length > 1 ? arguments[1] : undefined;
    var value = arguments.length > 2 ? arguments[2] : undefined;
    var field_name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";

    if (is_empty(value)) {
      return value;
    }

    var object_type = chain_types.object_type[type];

    if (!object_type) {
      throw new Error("Unknown object type: ".concat(type, ", ").concat(field_name, ", ").concat(value));
    }

    var re = new RegExp("".concat(reserved_spaces, ".").concat(object_type, ".[0-9]+$"));

    if (!re.test(value)) {
      throw new Error("Expecting ".concat(type, " in format ") + "".concat(reserved_spaces, ".").concat(object_type, ".[0-9]+ ") + "instead of ".concat(value, " ").concat(field_name, " ").concat(value));
    }

    return value;
  },
  get_instance: get_instance = function get_instance(reserve_spaces, type, value, field_name) {
    if (is_empty(value)) {
      return value;
    }

    require_object_type(reserve_spaces, type, value, field_name);
    return to_number(value.split('.')[2]);
  },
  require_relative_type: require_relative_type = function require_relative_type(type, value, field_name) {
    require_object_type(0, type, value, field_name);
    return value;
  },
  get_relative_instance: get_relative_instance = function get_relative_instance(type, value, field_name) {
    if (is_empty(value)) {
      return value;
    }

    require_object_type(0, type, value, field_name);
    return to_number(value.split('.')[2]);
  },
  require_protocol_type: require_protocol_type = function require_protocol_type(type, value, field_name) {
    require_object_type(1, type, value, field_name);
    return value;
  },
  get_protocol_instance: get_protocol_instance = function get_protocol_instance(type, value, field_name) {
    if (is_empty(value)) {
      return value;
    }

    require_object_type(1, type, value, field_name);
    return to_number(value.split('.')[2]);
  },
  get_protocol_type: get_protocol_type = function get_protocol_type(value, field_name) {
    if (is_empty(value)) {
      return value;
    }

    require_object_id(value, field_name);
    var values = value.split('.');
    return to_number(values[1]);
  },
  get_protocol_type_name: function get_protocol_type_name(value, field_name) {
    if (is_empty(value)) {
      return value;
    }

    var type_id = get_protocol_type(value, field_name);
    return Object.keys(chain_types.object_type)[type_id];
  },
  require_implementation_type: require_implementation_type = function require_implementation_type(type, value, field_name) {
    require_object_type(2, type, value, field_name);
    return value;
  },
  get_implementation_instance: get_implementation_instance = function get_implementation_instance(type, value, field_name) {
    if (is_empty(value)) {
      return value;
    }

    require_object_type(2, type, value, field_name);
    return to_number(value.split('.')[2]);
  },
  // signed / unsigned decimal
  no_overflow53: function no_overflow53(value) {
    var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

    if (typeof value === "number") {
      if (value > MAX_SAFE_INT || value < MIN_SAFE_INT) {
        throw new Error("overflow ".concat(field_name, " ").concat(value));
      }

      return;
    }

    if (typeof value === "string") {
      var int = parseInt(value);

      if (value > MAX_SAFE_INT || value < MIN_SAFE_INT) {
        throw new Error("overflow ".concat(field_name, " ").concat(value));
      }

      return;
    }

    if (Long.isLong(value)) {
      // typeof value.toInt() is 'number'
      _my.no_overflow53(value.toInt(), field_name);

      return;
    }

    throw "unsupported type ".concat(field_name, ": (").concat(_typeof(value), ") ").concat(value);
  },
  // signed / unsigned whole numbers only
  no_overflow64: function no_overflow64(value) {
    var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

    // https://github.com/dcodeIO/Long.js/issues/20
    if (Long.isLong(value)) {
      return;
    } // BigInteger#isBigInteger https://github.com/cryptocoinjs/bigi/issues/20


    if (value.t !== undefined && value.s !== undefined) {
      _my.no_overflow64(value.toString(), field_name);

      return;
    }

    if (typeof value === "string") {
      // remove leading zeros, will cause a false positive
      value = value.replace(/^0+/, ''); // remove trailing zeros

      while (/0$/.test(value)) {
        value = value.substring(0, value.length - 1);
      }

      if (/\.$/.test(value)) {
        // remove trailing dot
        value = value.substring(0, value.length - 1);
      }

      if (value === "") {
        value = "0";
      }

      var long_string = Long.fromString(value).toString();

      if (long_string !== value.trim()) {
        throw new Error("overflow ".concat(field_name, " ").concat(value));
      }

      return;
    }

    if (typeof value === "number") {
      if (value > MAX_SAFE_INT || value < MIN_SAFE_INT) {
        throw new Error("overflow ".concat(field_name, " ").concat(value));
      }

      return;
    }

    throw "unsupported type ".concat(field_name, ": (").concat(_typeof(value), ") ").concat(value);
  }
};

/***/ }),

/***/ 3318:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

__webpack_require__(3088);

__webpack_require__(2943);

__webpack_require__(3019);

__webpack_require__(3040);

__webpack_require__(3041);

__webpack_require__(3042);

__webpack_require__(3052);

__webpack_require__(3054);

__webpack_require__(3083);

__webpack_require__(3197);

__webpack_require__(3078);

__webpack_require__(3066);

__webpack_require__(3080);

var _ecc = __webpack_require__(3250);

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function toWif(key) {
  return key.toWif ? key.toWif() : key;
}

;

var Session = /*#__PURE__*/function () {
  function Session() {
    var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'autopost2';

    _classCallCheck(this, Session);

    // key is compatible with Golos UI
    this.key = key;
  }

  _createClass(Session, [{
    key: "ensure",
    value: function ensure() {
      if (typeof localStorage === 'undefined') throw new Error('Browser should support localStorage.');
    }
  }, {
    key: "save",
    value: function save(username, postingKey, memoKey, loginOwnerPubKey) {
      this.ensure();
      memoKey = memoKey ? toWif(memoKey) : '';
      loginOwnerPubKey = loginOwnerPubKey || '';
      var data = new Buffer("".concat(username, "\t").concat(toWif(postingKey), "\t").concat(memoKey, "\t").concat(loginOwnerPubKey)).toString('hex');
      localStorage.setItem(this.key, data);
    }
  }, {
    key: "load",
    value: function load() {
      this.ensure();
      var data = localStorage.getItem(this.key);

      if (data) {
        return new Buffer(data, 'hex').toString().split('\t');
      }

      return null;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.ensure();
      localStorage.removeItem(this.key);
    }
  }]);

  return Session;
}();

var PageSession = /*#__PURE__*/function (_Session) {
  _inherits(PageSession, _Session);

  var _super = _createSuper(PageSession);

  function PageSession() {
    var _this;

    var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'session_id';

    _classCallCheck(this, PageSession);

    _this = _super.call(this);
    _this.key = key;
    return _this;
  }

  _createClass(PageSession, [{
    key: "ensure",
    value: function ensure() {
      if (typeof sessionStorage === 'undefined') throw new Error('Browser should support sessionStorage.');
    }
  }, {
    key: "save",
    value: function save(password, username) {
      var authType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'active';
      this.ensure();

      try {
        _ecc.PrivateKey.fromWif(password);
      } catch (e) {
        password = _ecc.PrivateKey.fromSeed(username + authType + password).toString();
      }

      var data = Date.now().toString() + '\t' + new Buffer(password).toString('hex');
      sessionStorage.setItem(this.key, data);
    }
  }, {
    key: "load",
    value: function load() {
      this.ensure();
      var saved = sessionStorage.getItem(this.key);

      if (saved) {
        var arr = saved.split('\t');
        arr[0] = parseInt(arr[0]);
        arr[1] = new Buffer(arr[1], 'hex').toString();
        return arr;
      }

      return null;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.ensure();
      sessionStorage.removeItem(this.key);
    }
  }]);

  return PageSession;
}(Session);

module.exports = {
  session: new Session(),
  Session: Session,
  pageSession: new PageSession(),
  PageSession: PageSession
};

/***/ }),

/***/ 3329:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(3019);

__webpack_require__(3040);

__webpack_require__(3083);

__webpack_require__(3041);

__webpack_require__(3042);

__webpack_require__(3052);

__webpack_require__(3054);

__webpack_require__(3076);

__webpack_require__(3057);

__webpack_require__(3066);

__webpack_require__(3089);

__webpack_require__(3065);

__webpack_require__(3330);

var _api = _interopRequireDefault(__webpack_require__(2942));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var defaultWeight = 1;

exports = module.exports = function (steemBroadcast) {
  steemBroadcast.addAccountAuth = function (activeWif, username, authorizedUsername) {
    var role = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "posting";
    var cb = arguments.length > 4 ? arguments[4] : undefined;

    _api.default.getAccountsAsync([username]).then(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 1),
          userAccount = _ref2[0];

      var updatedAuthority = userAccount[role];
      var authorizedAccounts = updatedAuthority.account_auths.map(function (auth) {
        return auth[0];
      });
      var hasAuthority = authorizedAccounts.indexOf(authorizedUsername) !== -1;

      if (hasAuthority) {
        // user does already exist in authorized list
        return cb(null, null);
      }

      updatedAuthority.account_auths.push([authorizedUsername, defaultWeight]);
      var owner = role === "owner" ? updatedAuthority : undefined;
      var active = role === "active" ? updatedAuthority : undefined;
      var posting = role === "posting" ? updatedAuthority : undefined;
      /** Add authority on user account */

      steemBroadcast.accountUpdate(activeWif, userAccount.name, owner, active, posting, userAccount.memo_key, userAccount.json_metadata, cb);
    });
  };

  steemBroadcast.removeAccountAuth = function (activeWif, username, authorizedUsername) {
    var role = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "posting";
    var cb = arguments.length > 4 ? arguments[4] : undefined;

    _api.default.getAccountsAsync([username]).then(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 1),
          userAccount = _ref4[0];

      var updatedAuthority = userAccount[role];
      var totalAuthorizedUser = updatedAuthority.account_auths.length;

      for (var i = 0; i < totalAuthorizedUser; i++) {
        var user = updatedAuthority.account_auths[i];

        if (user[0] === authorizedUsername) {
          updatedAuthority.account_auths.splice(i, 1);
          break;
        }
      } // user does not exist in authorized list


      if (totalAuthorizedUser === updatedAuthority.account_auths.length) {
        return cb(null, null);
      }

      var owner = role === "owner" ? updatedAuthority : undefined;
      var active = role === "active" ? updatedAuthority : undefined;
      var posting = role === "posting" ? updatedAuthority : undefined;
      steemBroadcast.accountUpdate(activeWif, userAccount.name, owner, active, posting, userAccount.memo_key, userAccount.json_metadata, cb);
    });
  };
};

/***/ }),

/***/ 3328:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];


__webpack_require__(3019);

__webpack_require__(3040);

__webpack_require__(3041);

__webpack_require__(3144);

__webpack_require__(3042);

__webpack_require__(3083);

__webpack_require__(3220);

__webpack_require__(3052);

__webpack_require__(3054);

__webpack_require__(3197);

__webpack_require__(3320);

__webpack_require__(3066);

__webpack_require__(3080);

__webpack_require__(3076);

__webpack_require__(3085);

__webpack_require__(3090);

__webpack_require__(3057);

__webpack_require__(3118);

var _debug = _interopRequireDefault(__webpack_require__(3110));

var _noop = _interopRequireDefault(__webpack_require__(1695));

var _helpers = _interopRequireDefault(__webpack_require__(3329));

var _formatter = _interopRequireDefault(__webpack_require__(3331));

var _operations = _interopRequireDefault(__webpack_require__(3335));

var _api = _interopRequireDefault(__webpack_require__(2942));

var _auth = _interopRequireDefault(__webpack_require__(3239));

var _utils = __webpack_require__(3115);

var _promisify = __webpack_require__(3218);

var _middlewares = __webpack_require__(3323);

var _config = _interopRequireDefault(__webpack_require__(3112));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var debug = (0, _debug.default)('golos:broadcast');
var formatter = (0, _formatter.default)(_api.default);
var steemBroadcast = {}; // Base transaction logic -----------------------------------------------------

/**
 * Sign and broadcast transactions on the steem network
 */

steemBroadcast.send = /*#__PURE__*/function () {
  var _steemBroadcast$send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(tx, privKeys, callback) {
    var keyMeta, role, str, keys, broadcast, res, transaction, signedTransaction;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            keyMeta = new Set();

            if (!privKeys) {
              _context2.next = 16;
              break;
            }

            _context2.t0 = regeneratorRuntime.keys(privKeys);

          case 3:
            if ((_context2.t1 = _context2.t0()).done) {
              _context2.next = 16;
              break;
            }

            role = _context2.t1.value;

            if (!privKeys[role]) {
              _context2.next = 14;
              break;
            }

            str = privKeys[role].toString();

            if (str.startsWith('(')) {
              _context2.next = 12;
              break;
            }

            keyMeta = null;
            return _context2.abrupt("break", 16);

          case 12:
            keys = str.slice(1, -1).split(',');
            keys.forEach(keyMeta.add, keyMeta);

          case 14:
            _context2.next = 3;
            break;

          case 16:
            broadcast = /*#__PURE__*/function () {
              var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(signedTransaction) {
                var res;
                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        if (!_config.default.get('broadcast_transaction_with_callback')) {
                          _context.next = 6;
                          break;
                        }

                        _context.next = 3;
                        return _api.default.broadcastTransactionWithCallbackAsync(function () {}, signedTransaction);

                      case 3:
                        _context.t0 = _context.sent;
                        _context.next = 9;
                        break;

                      case 6:
                        _context.next = 8;
                        return _api.default.broadcastTransactionAsync(signedTransaction);

                      case 8:
                        _context.t0 = _context.sent;

                      case 9:
                        res = _context.t0;
                        return _context.abrupt("return", Object.assign(res, signedTransaction));

                      case 11:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function broadcast(_x4) {
                return _ref.apply(this, arguments);
              };
            }();

            _context2.prev = 17;
            res = null;

            if (!keyMeta) {
              _context2.next = 27;
              break;
            }

            tx._meta = {
              _keys: Array.from(keyMeta)
            };
            debug('Broadcasting transaction without signing (transaction, transaction.operations, transaction._meta)', tx, tx.operations, tx._meta);
            _context2.next = 24;
            return (0, _middlewares.mw)().broadcast({
              tx: tx,
              privKeys: privKeys,
              orig: broadcast
            });

          case 24:
            res = _context2.sent;
            _context2.next = 36;
            break;

          case 27:
            _context2.next = 29;
            return steemBroadcast._prepareTransaction(tx);

          case 29:
            transaction = _context2.sent;
            debug('Signing transaction (transaction, transaction.operations)', transaction, transaction.operations);
            signedTransaction = _auth.default.signTransaction(transaction, privKeys);
            debug('Broadcasting transaction (transaction, transaction.operations)', transaction, transaction.operations);
            _context2.next = 35;
            return (0, _middlewares.mw)().broadcast({
              tx: signedTransaction,
              privKeys: privKeys,
              orig: broadcast
            });

          case 35:
            res = _context2.sent;

          case 36:
            if (callback) callback(null, res);
            _context2.next = 42;
            break;

          case 39:
            _context2.prev = 39;
            _context2.t2 = _context2["catch"](17);
            if (callback) callback(_context2.t2, null);

          case 42:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[17, 39]]);
  }));

  function steemBroadcast$send(_x, _x2, _x3) {
    return _steemBroadcast$send.apply(this, arguments);
  }

  return steemBroadcast$send;
}();

steemBroadcast._prepareTransaction = /*#__PURE__*/function () {
  var _steemBroadcast$_prepareTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(tx) {
    var props, chainDate, refBlockNum, block, headBlockId;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return _api.default.getDynamicGlobalPropertiesAsync();

          case 2:
            props = _context3.sent;
            // Set defaults on the transaction
            chainDate = new Date(props.time + 'Z');
            refBlockNum = props.head_block_number - 3 & 0xFFFF;
            _context3.next = 7;
            return _api.default.getBlockAsync(props.head_block_number - 2);

          case 7:
            block = _context3.sent;
            headBlockId = block.previous;
            return _context3.abrupt("return", Object.assign({
              ref_block_num: refBlockNum,
              ref_block_prefix: new Buffer(headBlockId, 'hex').readUInt32LE(4),
              expiration: new Date(chainDate.getTime() + 60 * 1000)
            }, tx));

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  function steemBroadcast$_prepareTransaction(_x5) {
    return _steemBroadcast$_prepareTransaction.apply(this, arguments);
  }

  return steemBroadcast$_prepareTransaction;
}();

steemBroadcast._operations = {}; // Generated wrapper ----------------------------------------------------------
// Generate operations from operations.js

_operations.default.forEach(function (operation) {
  steemBroadcast._operations[operation.operation] = operation;
  var operationName = (0, _utils.camelCase)(operation.operation);
  var operationParams = operation.params || [];
  var useCommentPermlink = operationParams.indexOf('parent_permlink') !== -1 && operationParams.indexOf('parent_permlink') !== -1;

  steemBroadcast["".concat(operationName, "With")] = function steemBroadcast$specializedSendWith(wif, options, callback) {
    debug("Sending operation \"".concat(operationName, "\" with"), {
      options: options,
      callback: callback
    });
    var keys = {};

    if (operation.roles && operation.roles.length) {
      keys[operation.roles[0]] = wif; // TODO - Automatically pick a role? Send all?
    }

    return steemBroadcast.send({
      extensions: [],
      operations: [[operation.operation, Object.assign({}, options, options.json_metadata != null ? {
        json_metadata: toString(options.json_metadata)
      } : {}, useCommentPermlink && options.permlink == null ? {
        permlink: formatter.commentPermlink(options.parent_author, options.parent_permlink)
      } : {})]]
    }, keys, callback);
  };

  steemBroadcast[operationName] = function steemBroadcast$specializedSend(wif) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    debug("Parsing operation \"".concat(operationName, "\" with"), {
      args: args
    });
    var options = operationParams.reduce(function (memo, param, i) {
      memo[param] = args[i]; // eslint-disable-line no-param-reassign

      return memo;
    }, {});
    var callback = args[operationParams.length];
    return steemBroadcast["".concat(operationName, "With")](wif, options, callback);
  };
});

var toString = function toString(obj) {
  return _typeof(obj) === 'object' ? JSON.stringify(obj) : obj;
};

(0, _helpers.default)(steemBroadcast);
(0, _promisify.promisifyAll)(steemBroadcast);
exports = module.exports = steemBroadcast;

/***/ }),

/***/ 3335:
/***/ ((module) => {

"use strict";


module.exports = [{
  "roles": ["posting"],
  "operation": "vote",
  "params": ["voter", "author", "permlink", "weight"]
}, {
  "roles": ["posting"],
  "operation": "comment",
  "params": ["parent_author", "parent_permlink", "author", "permlink", "title", "body", "json_metadata"]
}, {
  "roles": ["active", "owner"],
  "operation": "transfer",
  "params": ["from", "to", "amount", "memo"]
}, {
  "roles": ["active"],
  "operation": "transfer_to_vesting",
  "params": ["from", "to", "amount"]
}, {
  "roles": ["active"],
  "operation": "withdraw_vesting",
  "params": ["account", "vesting_shares"]
}, {
  "roles": ["active"],
  "operation": "limit_order_create",
  "params": ["owner", "orderid", "amount_to_sell", "min_to_receive", "fill_or_kill", "expiration"]
}, {
  "roles": ["active"],
  "operation": "limit_order_cancel",
  "params": ["owner", "orderid"]
}, {
  "roles": ["active"],
  "operation": "price",
  "params": ["base", "quote"]
}, {
  "roles": ["active"],
  "operation": "feed_publish",
  "params": ["publisher", "exchange_rate"]
}, {
  "roles": ["active"],
  "operation": "convert",
  "params": ["owner", "requestid", "amount"]
}, {
  "roles": ["active"],
  "operation": "account_create",
  "params": ["fee", "creator", "new_account_name", "owner", "active", "posting", "memo_key", "json_metadata"]
}, {
  "roles": ["owner", "active"],
  "operation": "account_update",
  "params": ["account", "owner", "active", "posting", "memo_key", "json_metadata"]
}, {
  "roles": ["active"],
  "operation": "witness_update",
  "params": ["owner", "url", "block_signing_key", "props", "fee"]
}, {
  "roles": ["posting"],
  "operation": "account_witness_vote",
  "params": ["account", "witness", "approve"]
}, {
  "roles": ["posting"],
  "operation": "account_witness_proxy",
  "params": ["account", "proxy"]
}, {
  "roles": ["active"],
  "operation": "pow",
  "params": ["worker", "input", "signature", "work"]
}, {
  "roles": ["active"],
  "operation": "custom",
  "params": ["required_auths", "id", "data"]
}, {
  "roles": ["posting"],
  "operation": "delete_comment",
  "params": ["author", "permlink"]
}, {
  "roles": ["posting", "active"],
  "operation": "custom_json",
  "params": ["required_auths", "required_posting_auths", "id", "json"]
}, {
  "roles": ["posting"],
  "operation": "comment_options",
  "params": ["author", "permlink", "max_accepted_payout", "percent_steem_dollars", "allow_votes", "allow_curation_rewards", "extensions"]
}, {
  "roles": ["active"],
  "operation": "set_withdraw_vesting_route",
  "params": ["from_account", "to_account", "percent", "auto_vest"]
}, {
  "roles": ["active"],
  "operation": "limit_order_create2",
  "params": ["owner", "orderid", "amount_to_sell", "exchange_rate", "fill_or_kill", "expiration"]
}, {
  "roles": ["posting"],
  "operation": "challenge_authority",
  "params": ["challenger", "challenged", "require_owner"]
}, {
  "roles": ["active", "owner"],
  "operation": "prove_authority",
  "params": ["challenged", "require_owner"]
}, {
  "roles": ["active"],
  "operation": "request_account_recovery",
  "params": ["recovery_account", "account_to_recover", "new_owner_authority", "extensions"]
}, {
  "roles": ["owner"],
  "operation": "recover_account",
  "params": ["account_to_recover", "new_owner_authority", "recent_owner_authority", "extensions"]
}, {
  "roles": ["owner"],
  "operation": "change_recovery_account",
  "params": ["account_to_recover", "new_recovery_account", "extensions"]
}, {
  "roles": ["active"],
  "operation": "escrow_transfer",
  "params": ["from", "to", "agent", "escrow_id", "sbd_amount", "steem_amount", "fee", "ratification_deadline", "escrow_expiration", "json_meta"]
}, {
  "roles": ["active"],
  "operation": "escrow_dispute",
  "params": ["from", "to", "agent", "who", "escrow_id"]
}, {
  "roles": ["active"],
  "operation": "escrow_release",
  "params": ["from", "to", "agent", "who", "receiver", "escrow_id", "sbd_amount", "steem_amount"]
}, {
  "roles": ["active"],
  "operation": "pow2",
  "params": ["input", "pow_summary"]
}, {
  "roles": ["active"],
  "operation": "escrow_approve",
  "params": ["from", "to", "agent", "who", "escrow_id", "approve"]
}, {
  "roles": ["active"],
  "operation": "transfer_to_savings",
  "params": ["from", "to", "amount", "memo"]
}, {
  "roles": ["active"],
  "operation": "transfer_from_savings",
  "params": ["from", "request_id", "to", "amount", "memo"]
}, {
  "roles": ["active"],
  "operation": "cancel_transfer_from_savings",
  "params": ["from", "request_id"]
}, {
  "roles": ["posting", "active", "owner"],
  "operation": "custom_binary",
  "params": ["required_owner_auths", "required_active_auths", "required_posting_auths", "required_auths", "id", "data"]
}, {
  "roles": ["owner"],
  "operation": "decline_voting_rights",
  "params": ["account", "decline"]
}, {
  "roles": ["active"],
  "operation": "reset_account",
  "params": ["reset_account", "account_to_reset", "new_owner_authority"]
}, {
  "roles": ["owner", "posting"],
  "operation": "set_reset_account",
  "params": ["account", "current_reset_account", "reset_account"]
}, {
  "roles": ["posting"],
  "operation": "claim_reward_balance",
  "params": ["account", "reward_steem", "reward_sbd", "reward_vests"]
}, {
  "roles": ["active"],
  "operation": "fill_convert_request",
  "params": ["owner", "requestid", "amount_in", "amount_out"]
}, {
  "roles": ["posting"],
  "operation": "comment_reward",
  "params": ["author", "permlink", "payout"]
}, {
  "roles": ["active"],
  "operation": "liquidity_reward",
  "params": ["owner", "payout"]
}, {
  "roles": ["active"],
  "operation": "interest",
  "params": ["owner", "interest"]
}, {
  "roles": ["active"],
  "operation": "fill_vesting_withdraw",
  "params": ["from_account", "to_account", "withdrawn", "deposited"]
}, {
  "roles": ["posting"],
  "operation": "fill_order",
  "params": ["current_owner", "current_orderid", "current_pays", "current_trade_fee", "current_trade_fee_receiver", "open_owner", "open_orderid", "open_pays", "open_trade_fee", "open_trade_fee_receiver"]
}, {
  "roles": ["posting"],
  "operation": "fill_transfer_from_savings",
  "params": ["from", "to", "amount", "request_id", "memo"]
}, {
  "roles": ["active", "owner"],
  "operation": "delegate_vesting_shares",
  "params": ["delegator", "delegatee", "vesting_shares"]
}, {
  "roles": ["active", "owner"],
  "operation": "account_create_with_delegation",
  "params": ["fee", "delegation", "creator", "new_account_name", "owner", "active", "posting", "memo_key", "json_metadata", "extensions"]
}, {
  "roles": ["active", "owner"],
  "operation": "account_create_with_invite",
  "params": ["invite_secret", "creator", "new_account_name", "owner", "active", "posting", "memo_key", "json_metadata", "extensions"]
}, {
  "roles": ["posting"],
  "operation": "account_metadata",
  "params": ["account", "json_metadata"]
}, {
  "roles": ["active", "owner"],
  "operation": "proposal_create",
  "params": ["author", "title", "memo", "expiration_time", "proposed_operations", "review_period_time", "extensions"]
}, {
  "roles": ["posting", "active", "owner"],
  "operation": "proposal_update",
  "params": ["author", "title", "active_approvals_to_add", "active_approvals_to_remove", "owner_approvals_to_add", "owner_approvals_to_remove", "posting_approvals_to_add", "posting_approvals_to_remove", "key_approvals_to_add", "key_approvals_to_remove", "extensions"]
}, {
  "roles": ["active", "owner"],
  "operation": "proposal_delete",
  "params": ["author", "title", "requester", "extensions"]
}, {
  "roles": ["active", "owner"],
  "operation": "chain_properties_update",
  "params": ["owner", "props"]
}, {
  "roles": ["active"],
  "operation": "break_free_referral",
  "params": ["referral", "extensions"]
}, {
  "roles": ["active"],
  "operation": "delegate_vesting_shares_with_interest",
  "params": ["delegator", "delegatee", "vesting_shares", "interest_rate", "extensions"]
}, {
  "roles": ["active"],
  "operation": "reject_vesting_shares_delegation",
  "params": ["delegator", "delegatee", "extensions"]
}, {
  "roles": ["posting"],
  "operation": "worker_request",
  "params": ["author", "permlink", "worker", "required_amount_min", "required_amount_max", "vest_reward", "duration", "extensions"]
}, {
  "roles": ["posting"],
  "operation": "worker_request_delete",
  "params": ["author", "permlink", "extensions"]
}, {
  "roles": ["posting"],
  "operation": "worker_request_vote",
  "params": ["voter", "author", "permlink", "vote_percent", "extensions"]
}, {
  "roles": ["posting"],
  "operation": "claim",
  "params": ["from", "to", "amount", "to_vesting", "extensions"]
}, {
  "roles": ["posting"],
  "operation": "donate",
  "params": ["from", "to", "amount", "memo", "extensions"]
}, {
  "roles": ["active"],
  "operation": "transfer_to_tip",
  "params": ["from", "to", "amount", "memo", "extensions"]
}, {
  "roles": ["active"],
  "operation": "transfer_from_tip",
  "params": ["from", "to", "amount", "memo", "extensions"]
}, {
  "roles": ["active"],
  "operation": "invite",
  "params": ["creator", "balance", "invite_key", "extensions"]
}, {
  "roles": ["active"],
  "operation": "invite_claim",
  "params": ["initiator", "receiver", "invite_secret", "extensions"]
}, {
  "roles": ["active"],
  "operation": "asset_create",
  "params": ["creator", "max_supply", "allow_fee", "allow_override_transfer", "json_metadata", "extensions"]
}, {
  "roles": ["active"],
  "operation": "asset_update",
  "params": ["creator", "symbol", "symbols_whitelist", "fee_percent", "json_metadata", "extensions"]
}, {
  "roles": ["active"],
  "operation": "asset_issue",
  "params": ["creator", "amount", "to", "extensions"]
}, {
  "roles": ["active"],
  "operation": "asset_transfer",
  "params": ["creator", "symbol", "new_owner", "extensions"]
}, {
  "roles": ["active"],
  "operation": "override_transfer",
  "params": ["creator", "from", "to", "amount", "memo", "extensions"]
}, {
  "roles": ["active"],
  "operation": "invite_donate",
  "params": ["from", "invite_key", "amount", "memo", "extensions"]
}, {
  "roles": ["active"],
  "operation": "invite_transfer",
  "params": ["from", "to", "amount", "memo", "extensions"]
}, {
  "roles": ["active"],
  "operation": "limit_order_cancel_ex",
  "params": ["owner", "orderid", "extensions"]
}];

/***/ }),

/***/ 3112:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var defaultConfig = __webpack_require__(3113);

module.exports = function () {
  var config = defaultConfig;

  var get = function get(key) {
    return config[key];
  };

  var set = function set(key, value) {
    config[key] = value;
  };

  return {
    get: get,
    set: set
  };
}();

/***/ }),

/***/ 3199:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = 'AGFzbQEAAAABrwEaYAJ/fwF/YAJ/fwBgAX8Bf2ADf39/AX9gAX8AYAN/f38AYAR/f39/AGACf3wBf2AAAGAFf39/f38AYAR/f39/AX9gAX8BfmAGf39/f39/AGAFf39/f38Bf2AEfH9/fwF/YAd/f39/f39/AGAFf399f38AYAV/f3x/fwBgBX9+f39/AGAEf31/fwBgAn98AGAEf3x/fwBgAAF/YAZ/f39/f38Bf2ACfn8Bf2ABfwF8AsYCCgN3YmcaX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYABAN3YmcSX193YmluZGdlbl9jYl9kcm9wAAIDd2JnG19fd2JnX2NhbGxfZTkxZjcxZGRmMWY0NWNmZgAAA3diZxpfX3diZ19uZXdfODA4MTFkY2I2NmQxYjUzZgAAA3diZxtfX3diZ19jYWxsX2UzYzcyMzU1ZDA5MWQ1ZDQAAwN3YmcpX193YmdfaW5zdGFuY2VvZl9Qcm9taXNlXzBmYjVkN2UyNmNhODM2MjYAAgN3YmcbX193YmdfdGhlbl82ZDUwNzJmZWMzZmRiMjM3AAADd2JnEF9fd2JpbmRnZW5fdGhyb3cAAQN3YmcSX193YmluZGdlbl9yZXRocm93AAQDd2JnHV9fd2JpbmRnZW5fY2xvc3VyZV93cmFwcGVyMTEzAAMDswGxAQYCAQEMAAQDAwMFAQoFBAMEBAQAAQAEEgICBQAHBwAAAAAGDwEBAAADBQcHBxgAAAABBBYCAgUBDgEBCQAGBQEFAQECBQEBAQEFDAUBBQUCBQ4BAAAAAAAAARQFAQQFBAQEAAEBAwYDBQMEBQEBBAgBAgECAgEZAQQEBAMFFxANCREBBAYFBQMCAgEACgECAAAEAQACAAICAQIAAAIACAgBAgICAgEDAwAAAgILCwsEAQQFAXABKCgFAwEAEQYJAX8BQYCAwAALB+kJPQZtZW1vcnkCABFfX3diZ19fYXNzZXRfZnJlZQB0EV9hc3NldF9mcm9tU3RyaW5nAEYKX2Fzc2V0X25ldwBbDF9hc3NldF9jbG9uZQA/DV9hc3NldF9hbW91bnQAgAERX2Fzc2V0X3NldF9hbW91bnQAZBNfYXNzZXRfYW1vdW50X2Zsb2F0AEwXX2Fzc2V0X3NldF9hbW91bnRfZmxvYXQAThhfYXNzZXRfdXBkYXRlQW1vdW50RmxvYXQARxBfYXNzZXRfcHJlY2lzaW9uAH4UX2Fzc2V0X3NldF9wcmVjaXNpb24AfA1fYXNzZXRfc3ltYm9sAE8RX2Fzc2V0X3NldF9zeW1ib2wAUw1fYXNzZXRfaXNfdWlhAFkPX2Fzc2V0X3RvU3RyaW5nACwTX2Fzc2V0X2Zsb2F0X3N0cmluZwAuEF9hc3NldF9fcGx1c19udW0ANAxfYXNzZXRfX3BsdXMAOBFfYXNzZXRfX21pbnVzX251bQA1DV9hc3NldF9fbWludXMAOQ9fYXNzZXRfX211bF9udW0ANgtfYXNzZXRfX211bAA6D19hc3NldF9fZGl2X251bQAmC19hc3NldF9fZGl2ACgPX2Fzc2V0X19tb2RfbnVtACcLX2Fzc2V0X19tb2QAKRFfYXNzZXRfX211bF9wcmljZQASCV9hc3NldF9lcQBdCV9hc3NldF9uZQBeCV9hc3NldF9sdABfCl9hc3NldF9sdGUAYAlfYXNzZXRfZ3QAYQpfYXNzZXRfZ3RlAGIKX2Fzc2V0X21pbgAwCl9hc3NldF9tYXgAMRdfX3diZ19fYXNzZXRlZGl0b3JfZnJlZQBpFl9hc3NldGVkaXRvcl9mcm9tQXNzZXQAIxdfYXNzZXRlZGl0b3JfZnJvbVN0cmluZwArEF9hc3NldGVkaXRvcl9uZXcAQhdfYXNzZXRlZGl0b3Jfd2l0aENoYW5nZQAZEl9hc3NldGVkaXRvcl9hc3NldAA/F19hc3NldGVkaXRvcl9hbW91bnRfc3RyAFAXX2Fzc2V0ZWRpdG9yX2hhc19jaGFuZ2UAfRFfX3diZ19fcHJpY2VfZnJlZQBqCl9wcmljZV9uZXcAHwxfcHJpY2VfY2xvbmUAIgtfcHJpY2VfYmFzZQA/D19wcmljZV9zZXRfYmFzZQBDDF9wcmljZV9xdW90ZQA+EF9wcmljZV9zZXRfcXVvdGUARBpfX3diZ19zdHJlYW1pbmdoYW5kbGVfZnJlZQBrE3N0cmVhbV9ibG9ja19udW1iZXIAKg5hZXMyNTZfZGVjcnlwdAAtE19fd2JpbmRnZW5fZXhwb3J0XzABAHxfZHluX2NvcmVfX29wc19fZnVuY3Rpb25fX0ZuTXV0X19BX19fX091dHB1dF9fX1JfYXNfd2FzbV9iaW5kZ2VuX19jbG9zdXJlX19XYXNtQ2xvc3VyZV9fX2Rlc2NyaWJlX19pbnZva2VfX2hjZTJlZDM4N2FhMWMyYjY5AJABEV9fd2JpbmRnZW5fbWFsbG9jAHsSX193YmluZGdlbl9yZWFsbG9jAIUBH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIApgEPX193YmluZGdlbl9mcmVlAJcBFF9fd2JpbmRnZW5fZXhuX3N0b3JlAJsBCU8CAEEBCwi5AacBjQFWUZABgQGPAQBBCgseiQFUigGJAYcBkQGOAYoBigGIAYsBugGDAbYBuQG3AYQBQVJ2nAFvnQFspQGkAZkBnwG5AbgBCoH1ArEB+R4BlAF/IwBBMGsiBiQAIANBD3EEf0EABSACIANBgH9xIgdqIQUgA0EEdkEHcSEnIAFB7wNqLQAAIQggAUHuA2otAAAhCSABQe0Dai0AACEKIAFB7ANqLQAAIQsgAUHrA2otAAAhDCABQeoDai0AACENIAFB6QNqLQAAIQ4gAUHoA2otAAAhDyABQecDai0AACEQIAFB5gNqLQAAIREgAUHlA2otAAAhEiABQeQDai0AACETIAFB4wNqLQAAIRQgAUHiA2otAAAhFSABQeEDai0AACEWIAEtAOADIRcCQCAHRQRAIBchByAWIRggFSEZIBQhGiATIRsgEiEcIBEhHSAQIR4gDyEfIA4hICANISEgDCEiIAshIyAKISQgCSElIAghJgwBCyACIQQDQCAELQB/ISYgBC0AfiElIAQtAH0hJCAELQB8ISMgBC0AeyEiIAQtAHohISAELQB5ISAgBC0AeCEfIAQtAHchHiAELQB2IR0gBC0AdSEcIAQtAHQhGyAELQBzIRogBC0AciEZIAQtAHEhGCAELQBwIQcgBC0AbyEoIAQtAG4hKSAELQBtISogBC0AbCErIAQtAGshLCAELQBqIS0gBC0AaSEuIAQtAGghLyAELQBnITAgBC0AZiExIAQtAGUhMiAELQBkITMgBC0AYyE0IAQtAGIhNSAELQBhITYgBC0AYCE3IAQtAF8hOCAELQBeITkgBC0AXSE6IAQtAFwhOyAELQBbITwgBC0AWiE9IAQtAFkhPiAELQBYIT8gBC0AVyFAIAQtAFYhQSAELQBVIUIgBC0AVCFDIAQtAFMhRCAELQBSIUUgBC0AUSFGIAQtAFAhRyAELQBPIUggBC0ATiFJIAQtAE0hSiAELQBMIUsgBC0ASyFMIAQtAEohTSAELQBJIU4gBC0ASCFPIAQtAEchUCAELQBGIVEgBC0ARSFSIAQtAEQhUyAELQBDIVQgBC0AQiFVIAQtAEEhViAELQBAIVcgBC0APyFYIAQtAD4hWSAELQA9IVogBC0APCFbIAQtADshXCAELQA6IV0gBC0AOSFeIAQtADghXyAELQA3IWAgBC0ANiFhIAQtADUhYiAELQA0IWMgBC0AMyFkIAQtADIhZSAELQAxIWYgBC0AMCFnIAQtAC8haCAELQAuIWkgBC0ALSFqIAQtACwhayAELQArIWwgBC0AKiFtIAQtACkhbiAELQAoIW8gBC0AJyFwIAQtACYhcSAELQAlIXIgBC0AJCFzIAQtACMhdCAELQAiIXUgBC0AISF2IAQtACAhdyAELQAfIXggBC0AHiF5IAQtAB0heiAELQAcIXsgBC0AGyF8IAQtABohfSAELQAZIX4gBC0AGCF/IAQtABchgAEgBC0AFiGBASAELQAVIYIBIAQtABQhgwEgBC0AEyGEASAELQASIYUBIAQtABEhhgEgBC0AECGHASAELQAPIYgBIAQtAA4hiQEgBC0ADSGKASAELQAMIYsBIAQtAAshjAEgBC0ACiGNASAELQAJIY4BIAQtAAghjwEgBC0AByGQASAELQAGIZEBIAQtAAUhkgEgBC0ABCGTASAELQADIZQBIAQtAAIhlQEgBC0AASGWASAELQAAIZcBIAEgBBANIAEgBEEgahANIAEgBEFAaxANIAEgBEHgAGoQDSAEIAQtAAAgF3M6AAAgBCAELQABIBZzOgABIAQgBC0AAiAVczoAAiAEIAQtAAMgFHM6AAMgBCAELQAEIBNzOgAEIAQgBC0ABSASczoABSAEIAQtAAYgEXM6AAYgBCAELQAHIBBzOgAHIAQgBC0ACCAPczoACCAEIAQtAAkgDnM6AAkgBCAELQAKIA1zOgAKIAQgBC0ACyAMczoACyAEIAQtAAwgC3M6AAwgBCAELQANIApzOgANIAQgBC0ADiAJczoADiAEIAQtAA8gCHM6AA8gBCCXASAELQAQczoAECAEIJYBIAQtABFzOgARIAQglQEgBC0AEnM6ABIgBCCUASAELQATczoAEyAEIJMBIAQtABRzOgAUIAQgkgEgBC0AFXM6ABUgBCCRASAELQAWczoAFiAEIJABIAQtABdzOgAXIAQgjwEgBC0AGHM6ABggBCCOASAELQAZczoAGSAEII0BIAQtABpzOgAaIAQgjAEgBC0AG3M6ABsgBCCLASAELQAcczoAHCAEIIoBIAQtAB1zOgAdIAQgiQEgBC0AHnM6AB4gBCCIASAELQAfczoAHyAEIIcBIAQtACBzOgAgIAQghgEgBC0AIXM6ACEgBCCFASAELQAiczoAIiAEIIQBIAQtACNzOgAjIAQggwEgBC0AJHM6ACQgBCCCASAELQAlczoAJSAEIIEBIAQtACZzOgAmIAQggAEgBC0AJ3M6ACcgBCB/IAQtAChzOgAoIAQgfiAELQApczoAKSAEIH0gBC0AKnM6ACogBCB8IAQtACtzOgArIAQgeyAELQAsczoALCAEIHogBC0ALXM6AC0gBCB5IAQtAC5zOgAuIAQgeCAELQAvczoALyAEIHcgBC0AMHM6ADAgBCB2IAQtADFzOgAxIAQgdSAELQAyczoAMiAEIHQgBC0AM3M6ADMgBCBzIAQtADRzOgA0IAQgciAELQA1czoANSAEIHEgBC0ANnM6ADYgBCBwIAQtADdzOgA3IAQgbyAELQA4czoAOCAEIG4gBC0AOXM6ADkgBCBtIAQtADpzOgA6IAQgbCAELQA7czoAOyAEIGsgBC0APHM6ADwgBCBqIAQtAD1zOgA9IAQgaSAELQA+czoAPiAEIGggBC0AP3M6AD8gBCBnIAQtAEBzOgBAIAQgZiAELQBBczoAQSAEIGUgBC0AQnM6AEIgBCBkIAQtAENzOgBDIAQgYyAELQBEczoARCAEIGIgBC0ARXM6AEUgBCBhIAQtAEZzOgBGIAQgYCAELQBHczoARyAEIF8gBC0ASHM6AEggBCBeIAQtAElzOgBJIAQgXSAELQBKczoASiAEIFwgBC0AS3M6AEsgBCBbIAQtAExzOgBMIAQgWiAELQBNczoATSAEIFkgBC0ATnM6AE4gBCBYIAQtAE9zOgBPIAQgVyAELQBQczoAUCAEIFYgBC0AUXM6AFEgBCBVIAQtAFJzOgBSIAQgVCAELQBTczoAUyAEIFMgBC0AVHM6AFQgBCBSIAQtAFVzOgBVIAQgUSAELQBWczoAViAEIFAgBC0AV3M6AFcgBCBPIAQtAFhzOgBYIAQgTiAELQBZczoAWSAEIE0gBC0AWnM6AFogBCBMIAQtAFtzOgBbIAQgSyAELQBcczoAXCAEIEogBC0AXXM6AF0gBCBJIAQtAF5zOgBeIAQgSCAELQBfczoAXyAEIEcgBC0AYHM6AGAgBCBGIAQtAGFzOgBhIAQgRSAELQBiczoAYiAEIEQgBC0AY3M6AGMgBCBDIAQtAGRzOgBkIAQgQiAELQBlczoAZSAEIEEgBC0AZnM6AGYgBCBAIAQtAGdzOgBnIAQgPyAELQBoczoAaCAEID4gBC0AaXM6AGkgBCA9IAQtAGpzOgBqIAQgPCAELQBrczoAayAEIDsgBC0AbHM6AGwgBCA6IAQtAG1zOgBtIAQgOSAELQBuczoAbiAEIDggBC0Ab3M6AG8gBCA3IAQtAHBzOgBwIAQgNiAELQBxczoAcSAEIDUgBC0AcnM6AHIgBCA0IAQtAHNzOgBzIAQgMyAELQB0czoAdCAEIDIgBC0AdXM6AHUgBCAxIAQtAHZzOgB2IAQgMCAELQB3czoAdyAEIC8gBC0AeHM6AHggBCAuIAQtAHlzOgB5IAQgLSAELQB6czoAeiAEICwgBC0Ae3M6AHsgBCArIAQtAHxzOgB8IAQgKiAELQB9czoAfSAEICkgBC0AfnM6AH4gBCAoIAQtAH9zOgB/IAchFyAYIRYgGSEVIBohFCAbIRMgHCESIB0hESAeIRAgHyEPICAhDiAhIQ0gIiEMICMhCyAkIQogJSEJICYhCCAEQYABaiIEIAVHDQALCyABICY6AO8DIAEgJToA7gMgASAkOgDtAyABICM6AOwDIAEgIjoA6wMgASAhOgDqAyABICA6AOkDIAEgHzoA6AMgASAeOgDnAyABIB06AOYDIAEgHDoA5QMgASAbOgDkAyABIBo6AOMDIAEgGToA4gMgASAYOgDhAyABIAc6AOADAkAgJ0UEQCAHIRYgGCEXIBkhCCAaIQkgGyEKIBwhCyAdIQwgHiENIB8hDiAgIQ8gISEQICIhESAjIRIgJCETICUhFCAmIRUMAQsgBSAnQQR0aiE2IAZBIGohJwNAIAVBD2oiKC0AACEVIAVBDmoiKS0AACEUIAVBDWoiKi0AACETIAVBDGoiKy0AACESIAVBC2oiLC0AACERIAVBCmoiLS0AACEQIAVBCWoiLi0AACEPIAVBCGoiBC0AACEOIAVBB2oiLy0AACENIAVBBmoiMC0AACEMIAVBBWoiMS0AACELIAVBBGoiMi0AACEKIAVBA2oiMy0AACEJIAVBAmoiNC0AACEIIAVBAWoiNS0AACEXIAUtAAAhFiAnQQhqQgA3AAAgJ0IANwAAIAZBGGoiNyAEKQAANwMAIAYgBSkAADcDECABIAZBEGoQDSAFIAYpAxA3AAAgBCA3KQMANwAAIAUgBS0AACAHczoAACA1IDUtAAAgGHM6AAAgNCA0LQAAIBlzOgAAIDMgMy0AACAaczoAACAyIDItAAAgG3M6AAAgMSAxLQAAIBxzOgAAIDAgMC0AACAdczoAACAvIC8tAAAgHnM6AAAgBCAELQAAIB9zOgAAIC4gLi0AACAgczoAACAtIC0tAAAgIXM6AAAgLCAsLQAAICJzOgAAICsgKy0AACAjczoAACAqICotAAAgJHM6AAAgKSApLQAAICVzOgAAICggKC0AACAmczoAACAWIQcgFyEYIAghGSAJIRogCiEbIAshHCAMIR0gDSEeIA4hHyAPISAgECEhIBEhIiASISMgEyEkIBQhJSAVISYgBUEQaiIFIDZHDQALCyABIBU6AO8DIAEgFDoA7gMgASATOgDtAyABIBI6AOwDIAEgEToA6wMgASAQOgDqAyABIA86AOkDIAEgDjoA6AMgASANOgDnAyABIAw6AOYDIAEgCzoA5QMgASAKOgDkAyABIAk6AOMDIAEgCDoA4gMgASAXOgDhAyABIBY6AOADIAZBCGogAiADEFggBigCDCEFIAYoAggLIQQgACAFNgIEIAAgBDYCACAGQTBqJAALvCACD38BfiMAQRBrIgskAAJAAkAgAEH1AU8EQEGAgHxBCEEIEJUBQRRBCBCVAWpBEEEIEJUBamtBd3FBfWoiAkEAQRBBCBCVAUECdGsiASABIAJLGyAATQ0CIABBBGpBCBCVASEEQYCSwAAoAgBFDQFBACAEayEDAkACQAJ/QQAgBEGAAkkNABpBHyAEQf///wdLDQAaIARBBiAEQQh2ZyIAa3ZBAXEgAEEBdGtBPmoLIgZBAnRBjJTAAGooAgAiAARAIAQgBhCTAXQhB0EAIQEDQAJAIAAQqwEiAiAESQ0AIAIgBGsiAiADTw0AIAAhASACIgMNAEEAIQMMAwsgAEEUaigCACICIAUgAiAAIAdBHXZBBHFqQRBqKAIAIgBHGyAFIAIbIQUgB0EBdCEHIAANAAsgBQRAIAUhAAwCCyABDQILQQAhAUEBIAZ0EJgBQYCSwAAoAgBxIgBFDQMgABCgAWhBAnRBjJTAAGooAgAiAEUNAwsDQCAAIAEgABCrASIBIARPIAEgBGsiBSADSXEiAhshASAFIAMgAhshAyAAEJIBIgANAAsgAUUNAgtBjJXAACgCACIAIARPQQAgAyAAIARrTxsNASABIgAgBBCyASEGIAAQPAJAIANBEEEIEJUBTwRAIAAgBBCiASAGIAMQlAEgA0GAAk8EQCAGIAMQOwwCCyADQQN2IgFBA3RBhJLAAGohBQJ/QfyRwAAoAgAiAkEBIAF0IgFxBEAgBSgCCAwBC0H8kcAAIAEgAnI2AgAgBQshASAFIAY2AgggASAGNgIMIAYgBTYCDCAGIAE2AggMAQsgACADIARqEIwBCyAAELQBIgNFDQEMAgtBECAAQQRqQRBBCBCVAUF7aiAASxtBCBCVASEEAkACQAJAAn8CQAJAQfyRwAAoAgAiASAEQQN2IgB2IgJBA3FFBEAgBEGMlcAAKAIATQ0HIAINAUGAksAAKAIAIgBFDQcgABCgAWhBAnRBjJTAAGooAgAiARCrASAEayEDIAEQkgEiAARAA0AgABCrASAEayICIAMgAiADSSICGyEDIAAgASACGyEBIAAQkgEiAA0ACwsgASIAIAQQsgEhBSAAEDwgA0EQQQgQlQFJDQUgACAEEKIBIAUgAxCUAUGMlcAAKAIAIgFFDQQgAUEDdiIBQQN0QYSSwABqIQdBlJXAACgCACEGQfyRwAAoAgAiAkEBIAF0IgFxRQ0CIAcoAggMAwsCQCACQX9zQQFxIABqIgNBA3QiAEGMksAAaigCACIFQQhqKAIAIgIgAEGEksAAaiIARwRAIAIgADYCDCAAIAI2AggMAQtB/JHAACABQX4gA3dxNgIACyAFIANBA3QQjAEgBRC0ASEDDAcLAkBBASAAQR9xIgB0EJgBIAIgAHRxEKABaCICQQN0IgBBjJLAAGooAgAiA0EIaigCACIBIABBhJLAAGoiAEcEQCABIAA2AgwgACABNgIIDAELQfyRwABB/JHAACgCAEF+IAJ3cTYCAAsgAyAEEKIBIAMgBBCyASIFIAJBA3QgBGsiAhCUAUGMlcAAKAIAIgAEQCAAQQN2IgBBA3RBhJLAAGohB0GUlcAAKAIAIQYCf0H8kcAAKAIAIgFBASAAdCIAcQRAIAcoAggMAQtB/JHAACAAIAFyNgIAIAcLIQAgByAGNgIIIAAgBjYCDCAGIAc2AgwgBiAANgIIC0GUlcAAIAU2AgBBjJXAACACNgIAIAMQtAEhAwwGC0H8kcAAIAEgAnI2AgAgBwshASAHIAY2AgggASAGNgIMIAYgBzYCDCAGIAE2AggLQZSVwAAgBTYCAEGMlcAAIAM2AgAMAQsgACADIARqEIwBCyAAELQBIgMNAQsCQAJAAkACQAJAAkACQAJAQYyVwAAoAgAiACAESQRAQZCVwAAoAgAiACAESw0CIAtBCEEIEJUBIARqQRRBCBCVAWpBEEEIEJUBakGAgAQQlQEQdyALKAIAIggNAUEAIQMMCQtBlJXAACgCACECIAAgBGsiAUEQQQgQlQFJBEBBlJXAAEEANgIAQYyVwAAoAgAhAEGMlcAAQQA2AgAgAiAAEIwBIAIQtAEhAwwJCyACIAQQsgEhAEGMlcAAIAE2AgBBlJXAACAANgIAIAAgARCUASACIAQQogEgAhC0ASEDDAgLIAsoAgghDEGclcAAIAsoAgQiCkGclcAAKAIAaiIBNgIAQaCVwABBoJXAACgCACIAIAEgACABSxs2AgACQAJAQZiVwAAoAgAEQEGklcAAIQADQCAAEKMBIAhGDQIgACgCCCIADQALDAILQbiVwAAoAgAiAEUgCCAASXINAwwHCyAAEK0BDQAgABCuASAMRw0AIAAiASgCACIFQZiVwAAoAgAiAk0EfyAFIAEoAgRqIAJLBUEACw0DC0G4lcAAQbiVwAAoAgAiACAIIAggAEsbNgIAIAggCmohAUGklcAAIQACQAJAA0AgASAAKAIARwRAIAAoAggiAA0BDAILCyAAEK0BDQAgABCuASAMRg0BC0GYlcAAKAIAIQlBpJXAACEAAkADQCAAKAIAIAlNBEAgABCjASAJSw0CCyAAKAIIIgANAAtBACEACyAJIAAQowEiBkEUQQgQlQEiD2tBaWoiARC0ASIAQQgQlQEgAGsgAWoiACAAQRBBCBCVASAJakkbIg0QtAEhDiANIA8QsgEhAEEIQQgQlQEhA0EUQQgQlQEhBUEQQQgQlQEhAkGYlcAAIAggCBC0ASIBQQgQlQEgAWsiARCyASIHNgIAQZCVwAAgCkEIaiACIAMgBWpqIAFqayIDNgIAIAcgA0EBcjYCBEEIQQgQlQEhBUEUQQgQlQEhAkEQQQgQlQEhASAHIAMQsgEgASACIAVBCGtqajYCBEG0lcAAQYCAgAE2AgAgDSAPEKIBQaSVwAApAgAhECAOQQhqQayVwAApAgA3AgAgDiAQNwIAQbCVwAAgDDYCAEGolcAAIAo2AgBBpJXAACAINgIAQayVwAAgDjYCAANAIABBBBCyASEBIABBBzYCBCAGIAEiAEEEaksNAAsgCSANRg0HIAkgDSAJayIAIAkgABCyARCGASAAQYACTwRAIAkgABA7DAgLIABBA3YiAEEDdEGEksAAaiECAn9B/JHAACgCACIBQQEgAHQiAHEEQCACKAIIDAELQfyRwAAgACABcjYCACACCyEAIAIgCTYCCCAAIAk2AgwgCSACNgIMIAkgADYCCAwHCyAAKAIAIQMgACAINgIAIAAgACgCBCAKajYCBCAIELQBIgVBCBCVASECIAMQtAEiAUEIEJUBIQAgCCACIAVraiIGIAQQsgEhByAGIAQQogEgAyAAIAFraiIAIAQgBmprIQQgAEGYlcAAKAIARwRAQZSVwAAoAgAgAEYNBCAAKAIEQQNxQQFHDQUCQCAAEKsBIgVBgAJPBEAgABA8DAELIABBDGooAgAiAiAAQQhqKAIAIgFHBEAgASACNgIMIAIgATYCCAwBC0H8kcAAQfyRwAAoAgBBfiAFQQN2d3E2AgALIAQgBWohBCAAIAUQsgEhAAwFC0GYlcAAIAc2AgBBkJXAAEGQlcAAKAIAIARqIgA2AgAgByAAQQFyNgIEIAYQtAEhAwwHC0GQlcAAIAAgBGsiATYCAEGYlcAAQZiVwAAoAgAiAiAEELIBIgA2AgAgACABQQFyNgIEIAIgBBCiASACELQBIQMMBgtBuJXAACAINgIADAMLIAAgACgCBCAKajYCBEGYlcAAKAIAQZCVwAAoAgAgCmoQYwwDC0GUlcAAIAc2AgBBjJXAAEGMlcAAKAIAIARqIgA2AgAgByAAEJQBIAYQtAEhAwwDCyAHIAQgABCGASAEQYACTwRAIAcgBBA7IAYQtAEhAwwDCyAEQQN2IgBBA3RBhJLAAGohAgJ/QfyRwAAoAgAiAUEBIAB0IgBxBEAgAigCCAwBC0H8kcAAIAAgAXI2AgAgAgshACACIAc2AgggACAHNgIMIAcgAjYCDCAHIAA2AgggBhC0ASEDDAILQbyVwABB/x82AgBBsJXAACAMNgIAQaiVwAAgCjYCAEGklcAAIAg2AgBBkJLAAEGEksAANgIAQZiSwABBjJLAADYCAEGMksAAQYSSwAA2AgBBoJLAAEGUksAANgIAQZSSwABBjJLAADYCAEGoksAAQZySwAA2AgBBnJLAAEGUksAANgIAQbCSwABBpJLAADYCAEGkksAAQZySwAA2AgBBuJLAAEGsksAANgIAQaySwABBpJLAADYCAEHAksAAQbSSwAA2AgBBtJLAAEGsksAANgIAQciSwABBvJLAADYCAEG8ksAAQbSSwAA2AgBB0JLAAEHEksAANgIAQcSSwABBvJLAADYCAEHMksAAQcSSwAA2AgBB2JLAAEHMksAANgIAQdSSwABBzJLAADYCAEHgksAAQdSSwAA2AgBB3JLAAEHUksAANgIAQeiSwABB3JLAADYCAEHkksAAQdySwAA2AgBB8JLAAEHkksAANgIAQeySwABB5JLAADYCAEH4ksAAQeySwAA2AgBB9JLAAEHsksAANgIAQYCTwABB9JLAADYCAEH8ksAAQfSSwAA2AgBBiJPAAEH8ksAANgIAQYSTwABB/JLAADYCAEGQk8AAQYSTwAA2AgBBmJPAAEGMk8AANgIAQYyTwABBhJPAADYCAEGgk8AAQZSTwAA2AgBBlJPAAEGMk8AANgIAQaiTwABBnJPAADYCAEGck8AAQZSTwAA2AgBBsJPAAEGkk8AANgIAQaSTwABBnJPAADYCAEG4k8AAQayTwAA2AgBBrJPAAEGkk8AANgIAQcCTwABBtJPAADYCAEG0k8AAQayTwAA2AgBByJPAAEG8k8AANgIAQbyTwABBtJPAADYCAEHQk8AAQcSTwAA2AgBBxJPAAEG8k8AANgIAQdiTwABBzJPAADYCAEHMk8AAQcSTwAA2AgBB4JPAAEHUk8AANgIAQdSTwABBzJPAADYCAEHok8AAQdyTwAA2AgBB3JPAAEHUk8AANgIAQfCTwABB5JPAADYCAEHkk8AAQdyTwAA2AgBB+JPAAEHsk8AANgIAQeyTwABB5JPAADYCAEGAlMAAQfSTwAA2AgBB9JPAAEHsk8AANgIAQYiUwABB/JPAADYCAEH8k8AAQfSTwAA2AgBBhJTAAEH8k8AANgIAQQhBCBCVASEFQRRBCBCVASECQRBBCBCVASEBQZiVwAAgCCAIELQBIgBBCBCVASAAayIAELIBIgM2AgBBkJXAACAKQQhqIAEgAiAFamogAGprIgU2AgAgAyAFQQFyNgIEQQhBCBCVASECQRRBCBCVASEBQRBBCBCVASEAIAMgBRCyASAAIAEgAkEIa2pqNgIEQbSVwABBgICAATYCAAtBACEDQZCVwAAoAgAiACAETQ0AQZCVwAAgACAEayIBNgIAQZiVwABBmJXAACgCACICIAQQsgEiADYCACAAIAFBAXI2AgQgAiAEEKIBIAIQtAEhAwsgC0EQaiQAIAMLuhgBB38gABBNIgMgASABECQgA0EgaiABQRBqIgAgABAkQRghAUHAACEEAkADQAJAIAMgBmoiAEHYAGoiBSAAQThqKQIANwIAIABB0ABqIABBMGopAgA3AgAgAEHIAGogAEEoaikCADcCACAAQUBrIgIgAEEgaikCADcCACACEBwgAiACKAIAQX9zNgIAIABBxABqIgggCCgCAEF/czYCACAAQdQAaiIHIAcoAgBBf3M2AgAgBSAFKAIAQX9zNgIAIAMgBGoiBSAFKAIAQYCAA3M2AgAgAyABQXhqQQ4QFCAGQYADRgRAQQghAEEAIQEDQCABQQFxBEAgAEHJAE8NAyAAQR9qIQALIAMgAEECdGoiAUEgaiICIAIoAgAiAkEEdiACc0GAnoD4AHEiBCACcyAEQQR0czYCACABIAEoAgAiAkEEdiACc0GAmLwYcSIEIAJzIARBBHRzIgJBAnYgAnNBgOaAmANxIgQgAnMgBEECdHM2AgAgASABKAIEIgJBBHYgAnNBgJi8GHEiBCACcyAEQQR0cyICQQJ2IAJzQYDmgJgDcSIEIAJzIARBAnRzNgIEIAEgASgCCCICQQR2IAJzQYCYvBhxIgQgAnMgBEEEdHMiAkECdiACc0GA5oCYA3EiBCACcyAEQQJ0czYCCCABIAEoAgwiAkEEdiACc0GAmLwYcSIEIAJzIARBBHRzIgJBAnYgAnNBgOaAmANxIgQgAnMgBEECdHM2AgwgASABKAIQIgJBBHYgAnNBgJi8GHEiBCACcyAEQQR0cyICQQJ2IAJzQYDmgJgDcSIEIAJzIARBAnRzNgIQIAEgASgCFCICQQR2IAJzQYCYvBhxIgQgAnMgBEEEdHMiAkECdiACc0GA5oCYA3EiBCACcyAEQQJ0czYCFCABIAEoAhgiAkEEdiACc0GAmLwYcSIEIAJzIARBBHRzIgJBAnYgAnNBgOaAmANxIgQgAnMgBEECdHM2AhggASABKAIcIgJBBHYgAnNBgJi8GHEiBCACcyAEQQR0cyICQQJ2IAJzQYDmgJgDcSIEIAJzIARBAnRzNgIcIAFBJGoiAiACKAIAIgJBBHYgAnNBgJ6A+ABxIgQgAnMgBEEEdHM2AgAgAUEoaiICIAIoAgAiAkEEdiACc0GAnoD4AHEiBCACcyAEQQR0czYCACABQSxqIgIgAigCACICQQR2IAJzQYCegPgAcSIEIAJzIARBBHRzNgIAIAFBMGoiAiACKAIAIgJBBHYgAnNBgJ6A+ABxIgQgAnMgBEEEdHM2AgAgAUE0aiICIAIoAgAiAkEEdiACc0GAnoD4AHEiBCACcyAEQQR0czYCACABQThqIgIgAigCACICQQR2IAJzQYCegPgAcSIEIAJzIARBBHRzNgIAIAFBPGoiAiACKAIAIgJBBHYgAnNBgJ6A+ABxIgQgAnMgBEEEdHM2AgAgAEHhAE8NBCABQUBrIgIgAigCACICQQR2IAJzQYCGvOAAcSIEIAJzIARBBHRzIgJBAnYgAnNBgOaAmANxIgQgAnMgBEECdHM2AgAgAUHEAGoiAiACKAIAIgJBBHYgAnNBgIa84ABxIgQgAnMgBEEEdHMiAkECdiACc0GA5oCYA3EiBCACcyAEQQJ0czYCACABQcgAaiICIAIoAgAiAkEEdiACc0GAhrzgAHEiBCACcyAEQQR0cyICQQJ2IAJzQYDmgJgDcSIEIAJzIARBAnRzNgIAIAFBzABqIgIgAigCACICQQR2IAJzQYCGvOAAcSIEIAJzIARBBHRzIgJBAnYgAnNBgOaAmANxIgQgAnMgBEECdHM2AgAgAUHQAGoiAiACKAIAIgJBBHYgAnNBgIa84ABxIgQgAnMgBEEEdHMiAkECdiACc0GA5oCYA3EiBCACcyAEQQJ0czYCACABQdQAaiICIAIoAgAiAkEEdiACc0GAhrzgAHEiBCACcyAEQQR0cyICQQJ2IAJzQYDmgJgDcSIEIAJzIARBAnRzNgIAIAFB2ABqIgIgAigCACICQQR2IAJzQYCGvOAAcSIEIAJzIARBBHRzIgJBAnYgAnNBgOaAmANxIgQgAnMgBEECdHM2AgAgAUHcAGoiASABKAIAIgFBBHYgAXNBgIa84ABxIgIgAXMgAkEEdHMiAUECdiABc0GA5oCYA3EiAiABcyACQQJ0czYCAEEBIQEgAEEBaiEADAALAAUgAEHgAGoiBSACKAIANgIAIABB/ABqIABB3ABqKAIANgIAIABB9ABqIgIgBykCADcCACAAQewAaiAAQcwAaikCADcCACAAQeQAaiIHIAgpAgA3AgAgBRAcIAUgBSgCAEF/czYCACAHIAcoAgBBf3M2AgAgAiACKAIAQX9zNgIAIABB+ABqIgAgACgCAEF/czYCACADIAFBBhAUIARBxABqIQQgAUEQaiEBIAZBQGshBgwCCwALCyADIAMoAiBBf3M2AiAgAyADKAIkQX9zNgIkIAMgAygCNEF/czYCNCADIAMoAqgDIgBBBHYgAHNBgJi8GHEiASAAcyABQQR0cyIAQQJ2IABzQYDmgJgDcSIBIABzIAFBAnRzNgKoAyADIAMoAqwDIgBBBHYgAHNBgJi8GHEiASAAcyABQQR0cyIAQQJ2IABzQYDmgJgDcSIBIABzIAFBAnRzNgKsAyADIAMoArADIgBBBHYgAHNBgJi8GHEiASAAcyABQQR0cyIAQQJ2IABzQYDmgJgDcSIBIABzIAFBAnRzNgKwAyADIAMoArwDIgBBBHYgAHNBgJi8GHEiASAAcyABQQR0cyIAQQJ2IABzQYDmgJgDcSIBIABzIAFBAnRzNgK8AyADKAKgAyEAIAMoAqQDIQEgAygCtAMhAiADKAK4AyEEIAMgAygCOEF/czYCOCADIAMoAkBBf3M2AkAgAyADKAJEQX9zNgJEIAMgAygCVEF/czYCVCADIAMoAlhBf3M2AlggAyADKAJgQX9zNgJgIAMgAygCZEF/czYCZCADIAMoAnRBf3M2AnQgAyADKAJ4QX9zNgJ4IAMgAygCgAFBf3M2AoABIAMgAygChAFBf3M2AoQBIAMgAygClAFBf3M2ApQBIAMgAygCmAFBf3M2ApgBIAMgAygCoAFBf3M2AqABIAMgAygCpAFBf3M2AqQBIAMgAygCtAFBf3M2ArQBIAMgAygCuAFBf3M2ArgBIAMgAygCwAFBf3M2AsABIAMgAygCxAFBf3M2AsQBIAMgAygC1AFBf3M2AtQBIAMgAygC2AFBf3M2AtgBIAMgAygC4AFBf3M2AuABIAMgAygC5AFBf3M2AuQBIAMgAygC9AFBf3M2AvQBIAMgAygC+AFBf3M2AvgBIAMgAygCgAJBf3M2AoACIAMgAygChAJBf3M2AoQCIAMgAygClAJBf3M2ApQCIAMgAygCmAJBf3M2ApgCIAMgAygCoAJBf3M2AqACIAMgAygCpAJBf3M2AqQCIAMgAygCtAJBf3M2ArQCIAMgAygCuAJBf3M2ArgCIAMgAygCwAJBf3M2AsACIAMgAygCxAJBf3M2AsQCIAMgAygC1AJBf3M2AtQCIAMgAygC2AJBf3M2AtgCIAMgAygC4AJBf3M2AuACIAMgAygC5AJBf3M2AuQCIAMgAygC9AJBf3M2AvQCIAMgAygC+AJBf3M2AvgCIAMgAygCgANBf3M2AoADIAMgAygChANBf3M2AoQDIAMgAygClANBf3M2ApQDIAMoApgDIQYgAyAEIAQgBEEEdnNBgJi8GHEiBXMgBUEEdHMiBEECdiAEc0GA5oCYA3EiBSAEcyAFQQJ0c0F/czYCuAMgAyACIAIgAkEEdnNBgJi8GHEiBHMgBEEEdHMiAkECdiACc0GA5oCYA3EiBCACcyAEQQJ0c0F/czYCtAMgAyABIAEgAUEEdnNBgJi8GHEiAnMgAkEEdHMiAUECdiABc0GA5oCYA3EiAiABcyACQQJ0c0F/czYCpAMgAyAAIAAgAEEEdnNBgJi8GHEiAXMgAUEEdHMiAEECdiAAc0GA5oCYA3EiASAAcyABQQJ0c0F/czYCoAMgAyAGQX9zNgKYAyADIAMoAsADQX9zNgLAAyADIAMoAsQDQX9zNgLEAyADIAMoAtQDQX9zNgLUAyADIAMoAtgDQX9zNgLYAw8LIABBGGoQZwAL/BEBEn8jAEEgayICJAAgAiAAKALMAyABQRxqKAAAIgMgASgADCIEQQF2c0HVqtWqBXEiCiADcyIDIAFBGGooAAAiCSABKAAIIgZBAXZzQdWq1aoFcSIHIAlzIglBAnZzQbPmzJkDcSIIIANzIgMgAUEUaigAACIFIAEoAAQiC0EBdnNB1arVqgVxIg0gBXMiBSABKAAQIgwgASgAACIOQQF2c0HVqtWqBXEiECAMcyIMQQJ2c0Gz5syZA3EiDyAFcyIFQQR2c0GPnrz4AHEiEUEEdCAFc3M2AgwgAiAAKALEAyAIQQJ0IAlzIgkgD0ECdCAMcyIIQQR2c0GPnrz4AHEiBUEEdCAIc3M2AgQgAiAAKALIAyAEIApBAXRzIgQgBiAHQQF0cyIKQQJ2c0Gz5syZA3EiBiAEcyIEIAsgDUEBdHMiByAOIBBBAXRzIghBAnZzQbPmzJkDcSILIAdzIgdBBHZzQY+evPgAcSINQQR0IAdzczYCCCACIAAoAtADIAZBAnQgCnMiCiALQQJ0IAhzIgZBBHZzQY+evPgAcSIHIApzczYCECACIAAoAsADIAdBBHQgBnNzNgIAIAIgACgC1AMgBSAJc3M2AhQgAiAAKALYAyAEIA1zczYCGCACIAAoAtwDIAMgEXNzNgIcIAIQGCACKAIcIgNBBHYgA3NBgJ6A+ABxIgQgA3MgBEEEdHMhCSACKAIYIgNBBHYgA3NBgJ6A+ABxIgQgA3MgBEEEdHMhBiACKAIUIgNBBHYgA3NBgJ6A+ABxIgQgA3MgBEEEdHMhByACKAIQIgNBBHYgA3NBgJ6A+ABxIgQgA3MgBEEEdHMhCCACKAIMIgNBBHYgA3NBgJ6A+ABxIgQgA3MgBEEEdHMhBSACKAIIIgNBBHYgA3NBgJ6A+ABxIgQgA3MgBEEEdHMhCyACKAIEIgNBBHYgA3NBgJ6A+ABxIgQgA3MgBEEEdHMhDSACKAIAIgNBBHYgA3NBgJ6A+ABxIgQgA3MgBEEEdHMhDEEAIQpB0AAhBAJAAkADQAJAIAIgDCAAIApqIgNBoANqKAIAczYCACACIA0gA0GkA2ooAgBzNgIEIAIgCyADQagDaigCAHM2AgggAiAFIANBrANqKAIAczYCDCACIAggA0GwA2ooAgBzNgIQIAIgByADQbQDaigCAHM2AhQgAiAGIANBuANqKAIAczYCGCACIAkgA0G8A2ooAgBzNgIcIAIQGiACEBggCkGAfUYNACACIAIoAhwgA0GcA2ooAgBzIgZBGHcgBnMiCSACKAIQIANBkANqKAIAcyIIQRh3IAhzIg0gAigCFCADQZQDaigCAHMiB3MiDHMiCyACKAIYIANBmANqKAIAcyIFQRh3IAVzIg4gBnMiBnMgC0EQd3M2AhwgAiAJIAIoAgAgA0GAA2ooAgBzIgtzIhAgBSAHQRh3IAdzIg9zIgcgC0EYdyALcyILcyIFcyAFQRB3czYCACACIA4gCCACKAIMIANBjANqKAIAcyIFQRh3IAVzIhFzIAlzIhJzIgggB3MgCEEQd3M2AhggAiAMIAUgAigCCCADQYgDaigCAHMiCEEYdyAIcyIOcyAJcyITIAYgD3NzIgVzIAVBEHdzNgIUIAIgEiAGIAdzIgwgDSAIIAIoAgQgA0GEA2ooAgBzIgVBGHcgBXMiD3MiCHNzIg1zIA1BEHdzNgIQIAIgBSALcyAJcyIJIAcgEXNzIgcgE3MgB0EQd3M2AgwgAiAGIA5zIBBzIgYgCHMgBkEQd3M2AgggAiAJIAwgD3MiBnMgBkEQd3M2AgQgAhAYIAIgAigCACADQeACaigCAHM2AgAgAiACKAIEIANB5AJqKAIAczYCBCACIAIoAgggA0HoAmooAgBzNgIIIAIgAigCDCADQewCaigCAHM2AgwgAiACKAIQIANB8AJqKAIAczYCECACIAIoAhQgA0H0AmooAgBzNgIUIAIgAigCGCADQfgCaigCAHM2AhggAiACKAIcIANB/AJqKAIAczYCHCACEBsgAhAYIARBCGogBEkNAiACIAIoAgAgA0HAAmooAgBzNgIAIAIgAigCBCADQcQCaigCAHM2AgQgAiACKAIIIANByAJqKAIAczYCCCACIAIoAgwgA0HMAmooAgBzNgIMIAIgAigCECADQdACaigCAHM2AhAgAiACKAIUIANB1AJqKAIAczYCFCACIAIoAhggA0HYAmooAgBzNgIYIAIgAigCHCADQdwCaigCAHM2AhwgAhAgIAIQGCAKQcB9Rg0DIARBYGohBCAKQYB/aiEKIAIoAhwhCSACKAIYIQYgAigCFCEHIAIoAhAhCCACKAIMIQUgAigCCCELIAIoAgQhDSACKAIAIQwMAQsLIAFBHGogAigCHCAAKAIccyIDIAIoAhggACgCGHMiBEEBdnNB1arVqgVxIgogA3MiAyACKAIUIAAoAhRzIgkgAigCECAAKAIQcyIGQQF2c0HVqtWqBXEiByAJcyIJQQJ2c0Gz5syZA3EiCCADcyIDIAIoAgwgACgCDHMiBSACKAIIIAAoAghzIgtBAXZzQdWq1aoFcSINIAVzIgUgAigCBCAAKAIEcyIMIAIoAgAgACgCAHMiAEEBdnNB1arVqgVxIg4gDHMiDEECdnNBs+bMmQNxIhAgBXMiBUEEdnNBj568+ABxIg8gA3M2AAAgAUEYaiAIQQJ0IAlzIgMgEEECdCAMcyIJQQR2c0GPnrz4AHEiCCADczYAACABQRRqIA9BBHQgBXM2AAAgAUEMaiAKQQF0IARzIgMgB0EBdCAGcyIEQQJ2c0Gz5syZA3EiCiADcyIDIA1BAXQgC3MiBiAOQQF0IABzIgBBAnZzQbPmzJkDcSIHIAZzIgZBBHZzQY+evPgAcSIFIANzNgAAIAEgCEEEdCAJczYAECABIApBAnQgBHMiAyAHQQJ0IABzIgBBBHZzQY+evPgAcSIEIANzNgAIIAEgBUEEdCAGczYABCABIARBBHQgAHM2AAAgAkEgaiQADwsgBCAEQQhqQaCKwAAQaAALQXggBEGQisAAEGgAC6IIAgt/An4jAEEgayIGJAAgBEEANgIAAkACQAJ+AkACQCABQQhqKAIAIghBAE4EQCADQQAgAhshCyAIDQEgBkEANgIIIAYgCDYCBCAGQQE2AgAgASgCACENDAILEHkACwJAIAhBARCaASIDBEAgBkEANgIIIAYgAzYCACAGIAg2AgQgASgCACINIAhqIQ9CASESIA0hCANAAn8gCCwAACIDQX9KBEAgA0H/AXEhAyAIQQFqDAELIAgtAAFBP3EhCiADQR9xIQ4gA0FfTQRAIA5BBnQgCnIhAyAIQQJqDAELIAgtAAJBP3EgCkEGdHIhCiADQXBJBEAgCiAOQQx0ciEDIAhBA2oMAQsgDkESdEGAgPAAcSAILQADQT9xIApBBnRyciIDQYCAxABGDQQgCEEEagshCAJAAn8CQAJAAkACQAJAAkACQCAJQQFrDgICAQALIBBFQQAgA0EtRhsNAiADQVBqIglBCkkNAyADQf3//wBxQSxGDQRBACEJIANBCUYNByADQSBHDQoMBwsgA0FQaiIJQQpPBEBBAiEJIANBCUYgA0EgRnIgA0H9//8AcUEsRnINBwwKCyAEIAxBAWoiDDYCACACQQFGQQAgDCALSxsNCiARQgp+IBIgCa1C/wGDfnwhESAGKAIEIAdGBH8gBiAHEEkgBigCCAUgBwsgBigCAGogAzoAAAwECwJAIANBUGoiCUEKTwRAIANB/f//AHFBLEYNAUEBIQkgA0EJRg0HIANBIEcNCgwHCyARQgp+IBIgCa1C/wGDfnwhESAGKAIEIAdGBH8gBiAHEEkgBigCCAUgBwsgBigCAGogAzoAAEEBDAULIAYoAgQgB0YEfyAGIAcQSSAGKAIIBSAHCyAGKAIAakEuOgAADAMLIAYoAgQgB0YEfyAGIAcQSSAGKAIIBSAHCyAGKAIAakEtOgAAQn8hEkEBIRBBAAwDCyASIAmtQv8Bg34gEXwhESAGKAIEIAdGBH8gBiAHEEkgBigCCAUgBwsgBigCAGogAzoAAEEBDAILIAYoAgQgB0YEfyAGIAcQSSAGKAIIBSAHCyAGKAIAakEuOgAAC0ECCyEJIAYgBigCCEEBaiIHNgIICyAIIA9HDQALDAILIAhBARCvAQALQgEMAQsCQCALIAxNDQAgCyAMayICQQ5NBEAgBCALNgIAIAJBA3RBwITAAGopAwAgEX4hEQwBCyACQQ9BzIXAABBlAAsgBQ0BQgALIRIgBigCBEUNASAGKAIAEBAMAQsgBkEYaiICIAZBCGooAgA2AgAgBiAGKQMANwMQIAVBBGooAgAEQCAFKAIAEBALIAUgBikDEDcCACAFQQhqIAIoAgA2AgBCACESCyABQQRqKAIABEAgDRAQCyAAIBE3AwggACASNwMAIAZBIGokAAv/BwEIfwJAAkAgAEEDakF8cSICIABrIgMgAUsgA0EES3INACABIANrIgZBBEkNACAGQQNxIQdBACEBAkAgA0UNACADQQNxIQgCQCACIABBf3NqQQNJBEAgACECDAELIANBfHEhBCAAIQIDQCABIAIsAABBv39KaiACQQFqLAAAQb9/SmogAkECaiwAAEG/f0pqIAJBA2osAABBv39KaiEBIAJBBGohAiAEQXxqIgQNAAsLIAhFDQADQCABIAIsAABBv39KaiEBIAJBAWohAiAIQX9qIggNAAsLIAAgA2ohAAJAIAdFDQAgACAGQXxxaiICLAAAQb9/SiEFIAdBAUYNACAFIAIsAAFBv39KaiEFIAdBAkYNACAFIAIsAAJBv39KaiEFCyAGQQJ2IQMgASAFaiEEA0AgACEBIANFDQIgA0HAASADQcABSRsiBUEDcSEGIAVBAnQhBwJAIAVB/AFxIghBAnQiAEUEQEEAIQIMAQsgACABaiEJQQAhAiABIQADQCACIAAoAgAiAkF/c0EHdiACQQZ2ckGBgoQIcWogAEEEaigCACICQX9zQQd2IAJBBnZyQYGChAhxaiAAQQhqKAIAIgJBf3NBB3YgAkEGdnJBgYKECHFqIABBDGooAgAiAkF/c0EHdiACQQZ2ckGBgoQIcWohAiAAQRBqIgAgCUcNAAsLIAEgB2ohACADIAVrIQMgAkEIdkH/gfwHcSACQf+B/AdxakGBgARsQRB2IARqIQQgBkUNAAsgASAIQQJ0aiEAIAZB/////wNqIgNB/////wNxIgFBAWoiAkEDcQJAIAFBA0kEQEEAIQIMAQsgAkH8////B3EhAUEAIQIDQCACIAAoAgAiAkF/c0EHdiACQQZ2ckGBgoQIcWogAEEEaigCACICQX9zQQd2IAJBBnZyQYGChAhxaiAAQQhqKAIAIgJBf3NBB3YgAkEGdnJBgYKECHFqIABBDGooAgAiAkF/c0EHdiACQQZ2ckGBgoQIcWohAiAAQRBqIQAgAUF8aiIBDQALCwRAIANBgYCAgHxqIQEDQCACIAAoAgAiAkF/c0EHdiACQQZ2ckGBgoQIcWohAiAAQQRqIQAgAUF/aiIBDQALCyACQQh2Qf+B/AdxIAJB/4H8B3FqQYGABGxBEHYgBGoPCyABRQRAQQAPCyABQQNxIQICQCABQX9qQQNJBEAMAQsgAUF8cSEBA0AgBCAALAAAQb9/SmogAEEBaiwAAEG/f0pqIABBAmosAABBv39KaiAAQQNqLAAAQb9/SmohBCAAQQRqIQAgAUF8aiIBDQALCyACRQ0AA0AgBCAALAAAQb9/SmohBCAAQQFqIQAgAkF/aiICDQALCyAEC4cHAQV/IAAQtQEiACAAEKsBIgIQsgEhAQJAAkACQCAAEKwBDQAgACgCACEDAkAgABChAUUEQCACIANqIQIgACADELMBIgBBlJXAACgCAEcNASABKAIEQQNxQQNHDQJBjJXAACACNgIAIAAgAiABEIYBDwsgAiADakEQaiEADAILIANBgAJPBEAgABA8DAELIABBDGooAgAiBCAAQQhqKAIAIgVHBEAgBSAENgIMIAQgBTYCCAwBC0H8kcAAQfyRwAAoAgBBfiADQQN2d3E2AgALAkAgARCeAQRAIAAgAiABEIYBDAELAkACQAJAQZiVwAAoAgAgAUcEQCABQZSVwAAoAgBHDQFBlJXAACAANgIAQYyVwABBjJXAACgCACACaiIBNgIAIAAgARCUAQ8LQZiVwAAgADYCAEGQlcAAQZCVwAAoAgAgAmoiATYCACAAIAFBAXI2AgQgAEGUlcAAKAIARg0BDAILIAEQqwEiAyACaiECAkAgA0GAAk8EQCABEDwMAQsgAUEMaigCACIEIAFBCGooAgAiAUcEQCABIAQ2AgwgBCABNgIIDAELQfyRwABB/JHAACgCAEF+IANBA3Z3cTYCAAsgACACEJQBIABBlJXAACgCAEcNAkGMlcAAIAI2AgAMAwtBjJXAAEEANgIAQZSVwABBADYCAAtBtJXAACgCACABTw0BQYCAfEEIQQgQlQFBFEEIEJUBakEQQQgQlQFqa0F3cUF9aiIAQQBBEEEIEJUBQQJ0ayIBIAEgAEsbRQ0BQZiVwAAoAgBFDQFBCEEIEJUBIQBBFEEIEJUBIQFBEEEIEJUBIQJBAAJAQZCVwAAoAgAiBCACIAEgAEEIa2pqIgJNDQBBmJXAACgCACEBQaSVwAAhAAJAA0AgACgCACABTQRAIAAQowEgAUsNAgsgACgCCCIADQALQQAhAAsgABCtAQ0AIABBDGooAgAaDAALQQAQPWtHDQFBkJXAACgCAEG0lcAAKAIATQ0BQbSVwABBfzYCAA8LIAJBgAJJDQEgACACEDtBvJXAAEG8lcAAKAIAQX9qIgA2AgAgAA0AED0aDwsPCyACQQN2IgNBA3RBhJLAAGohAQJ/QfyRwAAoAgAiAkEBIAN0IgNxBEAgASgCCAwBC0H8kcAAIAIgA3I2AgAgAQshAyABIAA2AgggAyAANgIMIAAgATYCDCAAIAM2AggL8gYBBn8CQAJAAkACQAJAIAAoAggiCEEBR0EAIAAoAhAiBEEBRxtFBEAgBEEBRw0DIAEgAmohByAAQRRqKAIAIgYNASABIQQMAgsgACgCGCABIAIgAEEcaigCACgCDBEDACEDDAMLIAEhBANAIAQiAyAHRg0CAn8gA0EBaiADLAAAIgRBf0oNABogA0ECaiAEQWBJDQAaIANBA2ogBEFwSQ0AGiAEQf8BcUESdEGAgPAAcSADLQADQT9xIAMtAAJBP3FBBnQgAy0AAUE/cUEMdHJyckGAgMQARg0DIANBBGoLIgQgBSADa2ohBSAGQX9qIgYNAAsLIAQgB0YNACAELAAAIgNBf0ogA0FgSXIgA0FwSXJFBEAgA0H/AXFBEnRBgIDwAHEgBC0AA0E/cSAELQACQT9xQQZ0IAQtAAFBP3FBDHRycnJBgIDEAEYNAQsCQAJAIAVFBEBBACEEDAELIAUgAk8EQEEAIQMgBSACIgRGDQEMAgtBACEDIAUiBCABaiwAAEFASA0BCyAEIQUgASEDCyAFIAIgAxshAiADIAEgAxshAQsgCEUNASAAQQxqKAIAIQcCQCACQRBPBEAgASACEA8hBAwBCyACRQRAQQAhBAwBCyACQQNxIQUCQCACQX9qQQNJBEBBACEEIAEhAwwBCyACQXxxIQZBACEEIAEhAwNAIAQgAywAAEG/f0pqIANBAWosAABBv39KaiADQQJqLAAAQb9/SmogA0EDaiwAAEG/f0pqIQQgA0EEaiEDIAZBfGoiBg0ACwsgBUUNAANAIAQgAywAAEG/f0pqIQQgA0EBaiEDIAVBf2oiBQ0ACwsgByAESwRAQQAhAyAHIARrIgQhBgJAAkACQEEAIAAtACAiBSAFQQNGG0EDcUEBaw4CAAECC0EAIQYgBCEDDAELIARBAXYhAyAEQQFqQQF2IQYLIANBAWohAyAAQRxqKAIAIQQgACgCBCEFIAAoAhghAAJAA0AgA0F/aiIDRQ0BIAAgBSAEKAIQEQAARQ0AC0EBDwtBASEDIAVBgIDEAEYNASAAIAEgAiAEKAIMEQMADQFBACEDA0AgAyAGRgRAQQAPCyADQQFqIQMgACAFIAQoAhARAABFDQALIANBf2ogBkkPCwwBCyADDwsgACgCGCABIAIgAEEcaigCACgCDBEDAAv8BgILfwN+IwBB8ABrIgMkAAJAAkACQCAARQ0AIAAoAgAiBEF/Rg0BIAAgBEEBajYCACABRQ0AIAEoAgAiBEF/Rg0BIAEgBEEBajYCACACRQ0AIAIoAgANASACQX82AgAgAUEIaiIEKQMAIQ4gBCgCCCEFIANBLGoiCiAEQQxqIgsQbSADIAU2AiggAyAONwMgIAQpAxghDyAEKAIgIQUgA0HEAGogBEEkaiIGEG0gAyAFNgJAIAMgDzcDOCAAQQhqIgdBDGohCSACQQhqIQUgB0EUaigCACIIIANBNGooAgBHDQIgCSgCACADKAIsIgwgCBCwAQ0CIAQpAxghDiAEKAIgIQggA0HcAGoiDSAGEG0gAyAINgJYIAMgDjcDUCADQTBqIgYoAgAEQCAMEBALIAYgA0HgAGopAwA3AwAgA0EoaiADQdgAaiIGKQMANwMAIAMgAykDUDcDICAEKQMAIQ4gBCgCCCEEIA0gCxBtIAMgBDYCWCADIA43A1AgA0HIAGooAgAEQCADKAJEEBALIANByABqIANB4ABqKQMANwMAIANBQGsgBikDADcDACADIAMpA1A3AzggAykDICEODAILEKgBAAsQqQEACyAHKQMAIRAgBygCCCEEIANB3ABqIAkQbSADIAQ2AlggAyAQNwNQIAVBEGoiBCgCAARAIAUoAgwQEAsgBSADKQNQNwMAIAQgA0HgAGopAwA3AwAgBUEIaiADQdgAaikDADcDAAJAIAMpAzgiD1BFBEAgDiAQfiIOQoCAgICAgICAgH9SIA9Cf1JyDQFBgILAAEEwQcCCwAAQdQALQcCBwABBOUHAgsAAEHUACyAFIA4gDiAPfyIOIA9+fTcDACADKAIoIQQgA0EUaiAKEG0gAyAONwMIIAMgBDYCECADQcgAaigCAARAIAMoAkQQEAsgA0EwaigCAARAIAMoAiwQEAsgAkEANgIAIAEgASgCAEF/ajYCACAAIAAoAgBBf2o2AgAgA0HkAGogA0EYaikDADcCACADQdwAaiADQRBqKQMANwIAIAMgAykDCDcCVEEgQQgQmgEiAARAIABBADYCACAAIAMpAlA3AgQgAEEMaiADQdgAaikCADcCACAAQRRqIANB4ABqKQIANwIAIABBHGogA0HoAGooAgA2AgAgA0HwAGokACAADwtBIEEIEK8BAAvCBQEHf0ErQYCAxAAgACgCACIDQQFxIgQbIQYgAiAEaiEEQcyNwABBACADQQRxGyEHAkACQCAAKAIIRQRAQQEhAyAAIAYgBxBzDQEMAgsCQAJAAkACQCAAQQxqKAIAIgUgBEsEQCAALQAAQQhxDQRBACEDIAUgBGsiBCEFQQEgAC0AICIIIAhBA0YbQQNxQQFrDgIBAgMLQQEhAyAAIAYgBxBzDQQMBQtBACEFIAQhAwwBCyAEQQF2IQMgBEEBakEBdiEFCyADQQFqIQMgAEEcaigCACEIIAAoAgQhBCAAKAIYIQkCQANAIANBf2oiA0UNASAJIAQgCCgCEBEAAEUNAAtBAQ8LQQEhAyAEQYCAxABGDQEgACAGIAcQcw0BIAAoAhggASACIAAoAhwoAgwRAwANASAAKAIcIQEgACgCGCEAQQAhAwJ/A0AgBSADIAVGDQEaIANBAWohAyAAIAQgASgCEBEAAEUNAAsgA0F/agsgBUkhAwwBCyAAKAIEIQggAEEwNgIEIAAtACAhCUEBIQMgAEEBOgAgIAAgBiAHEHMNAEEAIQMgBSAEayIEIQUCQAJAAkBBASAALQAgIgYgBkEDRhtBA3FBAWsOAgABAgtBACEFIAQhAwwBCyAEQQF2IQMgBEEBakEBdiEFCyADQQFqIQMgAEEcaigCACEGIAAoAgQhBCAAKAIYIQcCQANAIANBf2oiA0UNASAHIAQgBigCEBEAAEUNAAtBAQ8LQQEhAyAEQYCAxABGDQAgACgCGCABIAIgACgCHCgCDBEDAA0AIAAoAhwhAiAAKAIYIQNBACEBAkADQCABIAVGDQEgAUEBaiEBIAMgBCACKAIQEQAARQ0AC0EBIQMgAUF/aiAFSQ0BCyAAIAk6ACAgACAINgIEQQAPCyADDwsgACgCGCABIAIgAEEcaigCACgCDBEDAAueBwEDfwJAAkAgAUEQayIEQfgATw0AAkBB+AAgAU0NACAAIAFBAnRqIgMgACAEQQJ0aigCACADKAIAIAJ4QYOGjBhxcyIDQQJ0Qfz582dxIANzIANBBHRB8OHDh39xcyADQQZ0QcCBg4Z8cXM2AgAgAUEBaiIDQRBrIgRB+ABPDQFBAEH4ACABayIFIAVB+ABLGyIFQQFGBEAgAyEBDAELIAAgA0ECdGoiAyAAIARBAnRqKAIAIAMoAgAgAnhBg4aMGHFzIgNBAnRB/PnzZ3EgA3MgA0EEdEHw4cOHf3FzIANBBnRBwIGDhnxxczYCACABQQJqIgNBEGsiBEH4AE8NASAFQQJGBEAgAyEBDAELIAAgA0ECdGoiAyAAIARBAnRqKAIAIAMoAgAgAnhBg4aMGHFzIgNBAnRB/PnzZ3EgA3MgA0EEdEHw4cOHf3FzIANBBnRBwIGDhnxxczYCACABQQNqIgNBEGsiBEH4AE8NASAFQQNGBEAgAyEBDAELIAAgA0ECdGoiAyAAIARBAnRqKAIAIAMoAgAgAnhBg4aMGHFzIgNBAnRB/PnzZ3EgA3MgA0EEdEHw4cOHf3FzIANBBnRBwIGDhnxxczYCACABQQRqIgNBEGsiBEH4AE8NASAFQQRGBEAgAyEBDAELIAAgA0ECdGoiAyAAIARBAnRqKAIAIAMoAgAgAnhBg4aMGHFzIgNBAnRB/PnzZ3EgA3MgA0EEdEHw4cOHf3FzIANBBnRBwIGDhnxxczYCACABQQVqIgNBEGsiBEH4AE8NASAFQQVGBEAgAyEBDAELIAAgA0ECdGoiAyAAIARBAnRqKAIAIAMoAgAgAnhBg4aMGHFzIgNBAnRB/PnzZ3EgA3MgA0EEdEHw4cOHf3FzIANBBnRBwIGDhnxxczYCACABQQZqIgNBEGsiBEH4AE8NASAFQQZGBEAgAyEBDAELIAAgA0ECdGoiAyAAIARBAnRqKAIAIAMoAgAgAnhBg4aMGHFzIgNBAnRB/PnzZ3EgA3MgA0EEdEHw4cOHf3FzIANBBnRBwIGDhnxxczYCACABQQdqIgFBEGsiBEH4AE8NASAFQQdHDQILIAFB+ABBwIrAABBlAAsgBEH4AEGwisAAEGUACyAAIAFBAnRqIgEgACAEQQJ0aigCACABKAIAIAJ4QYOGjBhxcyIAQQJ0Qfz582dxIABzIABBBHRB8OHDh39xcyAAQQZ0QcCBg4Z8cXM2AgALsAYCCX8BfiMAQUBqIgMkACADQSBqIAEQbSADKAIgIQggAygCKCIJIQIDQCAEIAhqIQYCQCACQQhPBEAgA0EYaiAGIAIQMyADKAIcIQIgAygCGCEEDAELIAJFBEBBACECQQAhBAwBC0EAIQUCQCAGLQAAQSBGDQBBACEEIAJBAUYNAUEBIQUgBi0AAUEgRg0AIAJBAkYNAUECIQUgBi0AAkEgRg0AIAJBA0YNAUEDIQUgBi0AA0EgRg0AIAJBBEYNAUEEIQUgBi0ABEEgRg0AIAJBBUYNAUEFIQUgBi0ABUEgRg0AIAJBBkYNAUEGIQUgBi0ABkEgRw0BC0EBIQQgBSECCwJAIARBAUcNAEEAIQQgAiAHaiICQQFqIgcgAk8EQAJAIAkgB0kiBQ0AIAIgCGoiCi0AAEEgRw0AAkACQCAJIAdNBEAgByAJRg0BDAILIAcgCGosAABBv39MDQELAkACQCAJIAdrIgRBAE4EQCAEDQFBASECDAILEHkACyAEQQEQmgEiAg0AIARBARCvAQALIAMgBzYCKCACIAcgCGoiBSAEELEBIQlBfyEGAkACQCAKLAAAIgJBf0oNACACQT9xAn8gBUF+ai0AACICQRh0QRh1IghBv39KBEAgAkEfcQwBCyAIQT9xAn8gBUF9ai0AACICQRh0QRh1IghBQE4EQCACQQ9xDAELIAhBP3EgBUF8ai0AAEEHcUEGdHILQQZ0cgtBBnRyIgJBgIDEAEYNASACQYABSQ0AQX4hBiACQYAQSQ0AQX1BfCACQYCABEkbIQYLIAMgBiAHajYCKAsgA0EANgIsIANBMGogA0EgahBtIANBCGogA0EwakEAIAIgA0EsakEAEA4gAykDCKdFBEAgAykDECELIAAgCTYCDCAAIAMoAiw2AgggAEEUaiAENgIAIABBEGogBDYCACAAIAs3AwAgAygCJARAIAMoAiAQEAsgAUEEaigCAARAIAEoAgAQEAsgA0FAayQADwsgA0EwakGcgMAAEFwAC0HQgsAAQStByIPAABB1AAsgByEEIAUNAQsgCSAEayECDAELC0HYg8AAQStBjIDAABB1AAv7BgEGfwJAAkACQCACQQlPBEAgAyACECUiAg0BQQAPC0EAIQJBgIB8QQhBCBCVAUEUQQgQlQFqQRBBCBCVAWprQXdxQX1qIgFBAEEQQQgQlQFBAnRrIgUgBSABSxsgA00NAUEQIANBBGpBEEEIEJUBQXtqIANLG0EIEJUBIQUgABC1ASIBIAEQqwEiBhCyASEEAkACQAJAAkACQAJAAkAgARChAUUEQCAGIAVPDQEgBEGYlcAAKAIARg0CIARBlJXAACgCAEYNAyAEEJ4BDQcgBBCrASIHIAZqIgggBUkNByAIIAVrIQYgB0GAAkkNBCAEEDwMBQsgARCrASEEIAVBgAJJDQYgBCAFQQRqT0EAIAQgBWtBgYAISRsNBSABKAIAIgYgBGpBEGohByAFQR9qQYCABBCVASEEQQAiBUUNBiAFIAZqIgEgBCAGayIAQXBqIgI2AgQgASACELIBQQc2AgQgASAAQXRqELIBQQA2AgRBnJXAAEGclcAAKAIAIAQgB2tqIgA2AgBBuJXAAEG4lcAAKAIAIgIgBSAFIAJLGzYCAEGglcAAQaCVwAAoAgAiAiAAIAIgAEsbNgIADAkLIAYgBWsiBEEQQQgQlQFJDQQgASAFELIBIQYgASAFEH8gBiAEEH8gBiAEEB4MBAtBkJXAACgCACAGaiIGIAVNDQQgASAFELIBIQQgASAFEH8gBCAGIAVrIgVBAXI2AgRBkJXAACAFNgIAQZiVwAAgBDYCAAwDC0GMlcAAKAIAIAZqIgYgBUkNAwJAIAYgBWsiBEEQQQgQlQFJBEAgASAGEH9BACEEQQAhBgwBCyABIAUQsgEiBiAEELIBIQcgASAFEH8gBiAEEJQBIAcgBygCBEF+cTYCBAtBlJXAACAGNgIAQYyVwAAgBDYCAAwCCyAEQQxqKAIAIgkgBEEIaigCACIERwRAIAQgCTYCDCAJIAQ2AggMAQtB/JHAAEH8kcAAKAIAQX4gB0EDdndxNgIACyAGQRBBCBCVAU8EQCABIAUQsgEhBCABIAUQfyAEIAYQfyAEIAYQHgwBCyABIAgQfwsgAQ0DCyADEAsiBUUNASAFIAAgAyABEKsBQXhBfCABEKEBG2oiASABIANLGxCxASAAEBAPCyACIAAgAyABIAEgA0sbELEBGiAAEBALIAIPCyABEKEBGiABELQBC5gFAQd/AkACfwJAIAAgAWsgAkkEQCABIAJqIQUgACACaiEDIAAgAkEPTQ0CGiADQXxxIQBBACADQQNxIgZrIQcgBgRAIAEgAmpBf2ohBANAIANBf2oiAyAELQAAOgAAIARBf2ohBCAAIANJDQALCyAAIAIgBmsiBkF8cSICayEDQQAgAmshAiAFIAdqIgVBA3EEQCACQX9KDQIgBUEDdCIEQRhxIQcgBUF8cSIIQXxqIQFBACAEa0EYcSEJIAgoAgAhBANAIABBfGoiACAEIAl0IAEoAgAiBCAHdnI2AgAgAUF8aiEBIAAgA0sNAAsMAgsgAkF/Sg0BIAEgBmpBfGohAQNAIABBfGoiACABKAIANgIAIAFBfGohASAAIANLDQALDAELAkAgAkEPTQRAIAAhAwwBCyAAQQAgAGtBA3EiBWohBCAFBEAgACEDIAEhAANAIAMgAC0AADoAACAAQQFqIQAgA0EBaiIDIARJDQALCyAEIAIgBWsiAkF8cSIGaiEDAkAgASAFaiIFQQNxBEAgBkEBSA0BIAVBA3QiAEEYcSEHIAVBfHEiCEEEaiEBQQAgAGtBGHEhCSAIKAIAIQADQCAEIAAgB3YgASgCACIAIAl0cjYCACABQQRqIQEgBEEEaiIEIANJDQALDAELIAZBAUgNACAFIQEDQCAEIAEoAgA2AgAgAUEEaiEBIARBBGoiBCADSQ0ACwsgAkEDcSECIAUgBmohAQsgAkUNAiACIANqIQADQCADIAEtAAA6AAAgAUEBaiEBIANBAWoiAyAASQ0ACwwCCyAGQQNxIgBFDQEgAiAFaiEFIAMgAGsLIQAgBUF/aiEBA0AgA0F/aiIDIAEtAAA6AAAgAUF/aiEBIAAgA0kNAAsLC9wEAR1/IAAgACgCGCIBIAAoAgQiBHMiCyAAKAIUIgIgACgCDCIHc3MiDCAAKAIQIgUgB3MiAyAEIAAoAgAiBnMiCHMiFXIgASAFcyIKIAMgBnMiE3FzIAUgACgCHCIFcyIPIAFzIhAgB3MiFyADIAQgACgCCCIEcyINcyIWcSABIAVzIgEgBiAHcyIGcyIHIBZzIhggA3EiDnMiCXMiESAJIA8gEHEgASAIcyIZIAogAiAEcyIJcyIacSISIAcgDXNzc3MiDXEiBCAOIAEgB3FzIhQgCCAKcyIOIAJzIhsgBiALcyIccSAMIBVxIAIgA3Nzc3MiAnMgDSAUIA4gBSAJcyIUcSAGcyASc3MiBXMiC3EgBXMiBiACIBFzIgkgBCAFc3EgAnMiCHMiEiADcSIdIAggDnEiDnMgCCAFIBFxIAlxIAQgCXNzIgNzIgUgGXEgASACIA1xIAtxIAQgC3NzIgEgA3MiAnEiEXMiDXM2AgAgACASIBhxIB1zIgsgDCABIAZzIgxxIgQgASATcSIJIAMgEHFzIhAgBiAccXNzcyITIAggFHEiCCADIA9xcyIPIAIgB3EiAyABIApxIgFzcyANc3M2AhggACACIBJzIgIgF3EiByADcyIKIAEgDCAVcSIBcyALcyIMcyIDIAQgBiAbcSIGc3M2AhwgACABIA4gD3MiAXMgE3MgCnM2AhQgACAFIBpxIgogCHMgA3M2AhAgACACIBZxIAlzIAxzIgIgASAGIApzIgEgEXNzczYCDCAAIAEgEHMgA3M2AgggACAEIAdzIAJzNgIEC9gEAgR/AX4jAEHwAGsiAyQAAkACQCAABEAgACgCACIEQX9GDQFBASEFIAAgBEEBajYCACAAQRBqKAIAIQQgACkDCCEHIANBzABqIABBFGoQbSADIAQ2AkggAyAHNwNAIAMgAjYCECADIAI2AgwgAyABNgIIIABBCGohASADQTBqIANBQGsgA0EIahBAAkAgAygCMEUEQCADQThqKAIAIQYgAygCNCECIANBPGooAgAiBCABKAIgRgRAIAIgASgCGCAEELABQQBHIQULIANBKGogBDYCACADQSRqIAY2AgAgA0EYaiADQdAAaikDADcDACADQRBqIANByABqKQMANwMAIAMgAykDQDcDCCADIAU6ACwgAyACNgIgDAELIANBEGogA0HIAGopAwA3AwAgA0EYaiADQdAAaikDADcDACADIAMpA0A3AwggAygCNCECIANBIGogAUEYahBtIANBADoALCACQSRJDQAgAhAACyAAIAAoAgBBf2o2AgAgA0HkAGogA0EoaikDADcCACADQdwAaiADQSBqKQMANwIAIANB1ABqIANBGGopAwA3AgAgA0HMAGogA0EQaikDADcCACADIAMpAwg3AkRBMEEIEJoBIgBFDQIgAEEANgIAIAAgAykCQDcCBCAAQQxqIANByABqKQIANwIAIABBFGogA0HQAGopAgA3AgAgAEEcaiADQdgAaikCADcCACAAQSRqIANB4ABqKQIANwIAIABBLGogA0HoAGooAgA2AgAgA0HwAGokACAADwsQqAEACxCpAQALQTBBCBCvAQALlgUBDn8gACAAKAIcIgNBFndBv/78+QNxIANBHndBwIGDhnxxciADcyIEIAAoAhAiAkEWd0G//vz5A3EgAkEed0HAgYOGfHFyIAJzIgsgACgCFCIBcyIGcyIFIAMgACgCGCIDQRZ3Qb/+/PkDcSADQR53QcCBg4Z8cXIgA3MiB3MiCHMgBUEMd0GPnrz4AHEgBUEUd0Hw4cOHf3FyczYCHCAAIAQgACgCACIFcyIMIAMgASABQRZ3Qb/+/PkDcSABQR53QcCBg4Z8cXJzIglzIgMgBUEWd0G//vz5A3EgBUEed0HAgYOGfHFyIAVzIgVzIgFzIAFBDHdBj568+ABxIAFBFHdB8OHDh39xcnM2AgAgACAHIAIgACgCDCIBQRZ3Qb/+/PkDcSABQR53QcCBg4Z8cXIgAXMiB3MgBHMiCnMiAiADcyACQQx3QY+evPgAcSACQRR3QfDhw4d/cXJzNgIYIAAgBiABIAAoAggiAkEWd0G//vz5A3EgAkEed0HAgYOGfHFyIAJzIgZzIARzIg0gCCAJc3MiAXMgAUEMd0GPnrz4AHEgAUEUd0Hw4cOHf3FyczYCFCAAIAogAyAIcyIJIAsgAiAAKAIEIgFBFndBv/78+QNxIAFBHndBwIGDhnxxciABcyIKcyIOc3MiAnMgAkEMd0GPnrz4AHEgAkEUd0Hw4cOHf3FyczYCECAAIAEgBXMgBHMiAiADIAdzcyIEIA1zIARBDHdBj568+ABxIARBFHdB8OHDh39xcnM2AgwgACAGIAhzIAxzIgQgDnMgBEEMd0GPnrz4AHEgBEEUd0Hw4cOHf3FyczYCCCAAIAkgCnMiACACcyAAQQx3QY+evPgAcSAAQRR3QfDhw4d/cXJzNgIEC4YFAQ5/IAAgACgCHCIDQRJ3QYOGjBhxIANBGndB/PnzZ3FyIANzIgQgACgCECICQRJ3QYOGjBhxIAJBGndB/PnzZ3FyIAJzIgsgACgCFCIBcyIGcyIFIAMgACgCGCIDQRJ3QYOGjBhxIANBGndB/PnzZ3FyIANzIgdzIghzIAVBDHdBj568+ABxIAVBFHdB8OHDh39xcnM2AhwgACAEIAAoAgAiBXMiDCADIAEgAUESd0GDhowYcSABQRp3Qfz582dxcnMiCXMiAyAFQRJ3QYOGjBhxIAVBGndB/PnzZ3FyIAVzIgVzIgFzIAFBDHdBj568+ABxIAFBFHdB8OHDh39xcnM2AgAgACAHIAIgACgCDCIBQRJ3QYOGjBhxIAFBGndB/PnzZ3FyIAFzIgdzIARzIgpzIgIgA3MgAkEMd0GPnrz4AHEgAkEUd0Hw4cOHf3FyczYCGCAAIAYgASAAKAIIIgJBEndBg4aMGHEgAkEad0H8+fNncXIgAnMiBnMgBHMiDSAIIAlzcyIBcyABQQx3QY+evPgAcSABQRR3QfDhw4d/cXJzNgIUIAAgCiADIAhzIgkgCyACIAAoAgQiAUESd0GDhowYcSABQRp3Qfz582dxciABcyIKcyIOc3MiAnMgAkEMd0GPnrz4AHEgAkEUd0Hw4cOHf3FyczYCECAAIAEgBXMgBHMiAiADIAdzcyIEIA1zIARBDHdBj568+ABxIARBFHdB8OHDh39xcnM2AgwgACAGIAhzIAxzIgQgDnMgBEEMd0GPnrz4AHEgBEEUd0Hw4cOHf3FyczYCCCAAIAkgCnMiACACcyAAQQx3QY+evPgAcSAAQRR3QfDhw4d/cXJzNgIEC6MEARt/IAAgACgCGCIGIAAoAhRzIgMgACgCACICcyIFIAAoAgQiAXMiDCAFcSABIAAoAhwiAXMiB3MgByAAKAIQIgQgACgCCCIKcyINcyIQIAAoAgxzIgggBnMiCyABIARzIhFzIgYgA3MiEiAHQX9zcSIOcyAGIBFxIgkgAyAIIApzIgNzIgggBnMiFyANcXMiE3MiDyATIAIgA3MiEyAMIAEgCnMiCnMiGHEgAyAQcSIUIAtzc3MiFXEiCyAIIApxIAlzIgkgFCAEIAVzIhQgAnEgCnMgCHNzcyIEcyAPIAkgAiAGcyIJIAEgBXMiGXEgASAOc3NzIgFzcSIOIAtzIAFxIhYgD3MiDyADcSIaIAEgDnMiAyACcXMiDiAEIAEgC3MiASAEIBVzIgRxcyICIAlxcyABIBZzIAJxIARzIgEgAnMiCyAScSIScyIJIAEgDHFzIA0gASADIA9zIgxzIgQgAiADcyINcyIVcSANIBFxIhFzIhZzIhsgEiABIAVxcyIBIBUgF3FzIgUgBCAIcSAHIAtxIgcgDnNzcyIIczYCBCAAIAcgG3M2AgAgACAWIAwgGHFzIgcgDyAQcXMiECAFIAYgDXFzIgVzNgIcIAAgCCACIBlxcyIGIAQgCnEgEXMgBXNzNgIUIAAgDCATcSAacyABcyAQcyICNgIQIAAgByADIBRxcyAGczYCCCAAIAIgBXM2AhggACACIAlzNgIMC4EFAQt/IwBBMGsiAiQAIAJBJGpB7IzAADYCACACQQM6ACggAkKAgICAgAQ3AwggAiAANgIgIAJBADYCGCACQQA2AhACQAJAAkAgASgCCCIKRQRAIAFBFGooAgAiBEUNASABKAIAIQMgASgCECEAIARBf2pB/////wFxQQFqIgchBQNAIANBBGooAgAiBARAIAIoAiAgAygCACAEIAIoAiQoAgwRAwANBAsgACgCACACQQhqIABBBGooAgARAAANAyAAQQhqIQAgA0EIaiEDIAVBf2oiBQ0ACwwBCyABQQxqKAIAIgBFDQAgAEEFdCELIABBf2pB////P3FBAWohByABKAIAIQMDQCADQQRqKAIAIgAEQCACKAIgIAMoAgAgACACKAIkKAIMEQMADQMLIAIgBSAKaiIEQRxqLQAAOgAoIAIgBEEEaikCAEIgiTcDCCAEQRhqKAIAIQYgASgCECEIQQAhCUEAIQACQAJAAkAgBEEUaigCAEEBaw4CAAIBCyAGQQN0IAhqIgwoAgRBI0cNASAMKAIAKAIAIQYLQQEhAAsgAiAGNgIUIAIgADYCECAEQRBqKAIAIQACQAJAAkAgBEEMaigCAEEBaw4CAAIBCyAAQQN0IAhqIgYoAgRBI0cNASAGKAIAKAIAIQALQQEhCQsgAiAANgIcIAIgCTYCGCAIIAQoAgBBA3RqIgAoAgAgAkEIaiAAKAIEEQAADQIgA0EIaiEDIAsgBUEgaiIFRw0ACwtBACEAIAcgASgCBEkiA0UNASACKAIgIAEoAgAgB0EDdGpBACADGyIBKAIAIAEoAgQgAigCJCgCDBEDAEUNAQtBASEACyACQTBqJAAgAAvXBAEEfyAAIAEQsgEhAgJAAkACQCAAEKwBDQAgACgCACEDAkAgABChAUUEQCABIANqIQEgACADELMBIgBBlJXAACgCAEcNASACKAIEQQNxQQNHDQJBjJXAACABNgIAIAAgASACEIYBDwsgASADakEQaiEADAILIANBgAJPBEAgABA8DAELIABBDGooAgAiBCAAQQhqKAIAIgVHBEAgBSAENgIMIAQgBTYCCAwBC0H8kcAAQfyRwAAoAgBBfiADQQN2d3E2AgALIAIQngEEQCAAIAEgAhCGAQwCCwJAQZiVwAAoAgAgAkcEQCACQZSVwAAoAgBHDQFBlJXAACAANgIAQYyVwABBjJXAACgCACABaiIBNgIAIAAgARCUAQ8LQZiVwAAgADYCAEGQlcAAQZCVwAAoAgAgAWoiATYCACAAIAFBAXI2AgQgAEGUlcAAKAIARw0BQYyVwABBADYCAEGUlcAAQQA2AgAPCyACEKsBIgMgAWohAQJAIANBgAJPBEAgAhA8DAELIAJBDGooAgAiBCACQQhqKAIAIgJHBEAgAiAENgIMIAQgAjYCCAwBC0H8kcAAQfyRwAAoAgBBfiADQQN2d3E2AgALIAAgARCUASAAQZSVwAAoAgBHDQFBjJXAACABNgIACw8LIAFBgAJPBEAgACABEDsPCyABQQN2IgJBA3RBhJLAAGohAQJ/QfyRwAAoAgAiA0EBIAJ0IgJxBEAgASgCCAwBC0H8kcAAIAIgA3I2AgAgAQshAiABIAA2AgggAiAANgIMIAAgATYCDCAAIAI2AggL7gMCBX8GfiMAQYABayICJAACQAJAAkAgAEUNACAAKAIAIgNBf0YNASAAIANBAWo2AgAgAUUNACABKAIAIgNBf0YNASABIANBAWo2AgAgACkDCCEHIAAoAhAhAyACQTxqIABBFGoQbSACQThqIgQgAzYCACACIAc3AzAgAUEQaigCACEFIAEpAwghByACQdQAaiIGIAFBFGoQbSACQdAAaiIDIAU2AgAgAkEYaiAHNwMAIAJBCGogBCkDACIINwMAIAJBEGogAkFAaykDACIJNwMAIAJBKGogAkHYAGoiBCkDACIKNwMAIAJBIGogAykDACILNwMAIAIgAikDMCIMNwMAIAEgASgCAEF/ajYCACAAIAAoAgBBf2o2AgAgAkH0AGogCjcCACACQewAaiALNwIAIAJB5ABqIAc3AgAgAkHcAGogCTcCACAGIAg3AgAgAiAMNwJMQThBCBCaASIARQ0CIABBADYCACAAIAIpAkg3AgQgAEEMaiADKQIANwIAIABBFGogBCkCADcCACAAQRxqIAJB4ABqKQIANwIAIABBJGogAkHoAGopAgA3AgAgAEEsaiACQfAAaikCADcCACAAQTRqIAJB+ABqKAIANgIAIAJBgAFqJAAgAA8LEKgBAAsQqQEAC0E4QQgQrwEAC/YDAQ1/IAAgACgCHCIBQRR3QY+evPgAcSABQRx3QfDhw4d/cXIgAXMiBSAAKAIQIgNBFHdBj568+ABxIANBHHdB8OHDh39xciADcyIGIAAoAhQiAnMiB3MiBCABIAAoAhgiAUEUd0GPnrz4AHEgAUEcd0Hw4cOHf3FyIAFzIghzIglzIARBEHdzNgIcIAAgBSAAKAIAIgRzIgwgASACIAJBFHdBj568+ABxIAJBHHdB8OHDh39xcnMiCnMiASAEQRR3QY+evPgAcSAEQRx3QfDhw4d/cXIgBHMiBHMiAnMgAkEQd3M2AgAgACAIIAMgACgCDCICQRR3QY+evPgAcSACQRx3QfDhw4d/cXIgAnMiCHMgBXMiC3MiAyABcyADQRB3czYCGCAAIAcgAiAAKAIIIgNBFHdBj568+ABxIANBHHdB8OHDh39xciADcyIHcyAFcyINIAkgCnNzIgJzIAJBEHdzNgIUIAAgCyABIAlzIgogBiADIAAoAgQiAkEUd0GPnrz4AHEgAkEcd0Hw4cOHf3FyIAJzIgtzIgNzcyIGcyAGQRB3czYCECAAIAIgBHMgBXMiBSABIAhzcyIBIA1zIAFBEHdzNgIMIAAgByAJcyAMcyIBIANzIAFBEHdzNgIIIAAgCiALcyIAIAVzIABBEHdzNgIEC8kDAgV/A34jAEEQayIFJAACQCACQQ5NBEAgAkEDdEHAhMAAaikDACIKUEUEQAJAIAFCgICAgICAgICAf1FBACAKQn9RG0UEQCABIAp/IQxBCkEBEJoBIgZFDQEgAEIKNwIEIAAgBjYCAEIAIAp9IAogAUIAUxtCACAMUBsgAXwiClBFBEAgAiAEIAIgAxsiB2shCCADQQFHIQlBACEEA0AgCiELAkACQAJAIAQgCE8EQCACIARHDQIgBw0BDAMLIAtCCn8hCgwCCyAJIAAoAghFcQRADAILIAVBLjYCDCAAIAVBDGoQbgwBCyALQgp/IQogDFBBACALQgl8QhNUG0UEQCALIApCCn59IgsgC0I/hyILfCALhaciBkH/AXEgA0EBRiAEIAJPcnJFBEAgACgCCEUNAgsgBUEANgIMIAUgBkEwajoADCAAIAVBDGoQbgwBCyAFQTA2AgwgACAFQQxqEG4LIARBAWohBCAKUEUNAAsLIAFCAFkNBCAFQS02AgwgACAFQQxqEG4MBAtBoIbAAEEfQeyFwAAQdQALQQpBARCvAQALQYCGwABBGUHshcAAEHUACyACQQ9B3IXAABBlAAsgBUEQaiQAC8kDAgV/Bn4jAEGAAWsiASQAAkACQCAABEAgACgCACICQX9GDQEgACACQQFqNgIAIABBEGooAgAhAiAAKQMIIQYgAUE8aiAAQRRqEG0gAUE4aiIDIAI2AgAgASAGNwMwIABBIGopAwAhBiAAQShqKAIAIQQgAUHUAGoiBSAAQSxqEG0gAUHQAGoiAiAENgIAIAFBGGogBjcDACABQQhqIAMpAwAiBzcDACABQRBqIAFBQGspAwAiCDcDACABQShqIAFB2ABqIgMpAwAiCTcDACABQSBqIAIpAwAiCjcDACABIAEpAzAiCzcDACAAIAAoAgBBf2o2AgAgAUH0AGogCTcCACABQewAaiAKNwIAIAFB5ABqIAY3AgAgAUHcAGogCDcCACAFIAc3AgAgASALNwJMQThBCBCaASIARQ0CIABBADYCACAAIAEpAkg3AgQgAEEMaiACKQIANwIAIABBFGogAykCADcCACAAQRxqIAFB4ABqKQIANwIAIABBJGogAUHoAGopAgA3AgAgAEEsaiABQfAAaikCADcCACAAQTRqIAFB+ABqKAIANgIAIAFBgAFqJAAgAA8LEKgBAAsQqQEAC0E4QQgQrwEAC54DAgV/BH4jAEHgAGsiASQAAkACQCAABEAgACgCACICQX9GDQEgACACQQFqNgIAIABBCGohAgJ+IAApAwgiBlBFBEAgAUEoaiAGIAIoAghBACABECEgAikDAAwBCyABQQA2AjAgAUIBNwMoQgALIQYgACgCECEDIAFBxABqIgQgAkEMahBtIAFBQGsiAiADNgIAIAFBGGogASkDKCIHNwMAIAFBIGogAUEwaigCACIDNgIAIAFBEGogAUHIAGoiBSkDACIINwMAIAFBCGogAikDACIJNwMAIAEgBjcDOCABIAY3AwAgACAAKAIAQX9qNgIAIAFB3ABqIAM2AgAgAUHUAGogBzcCACABQcwAaiAINwIAIAQgCTcCACABIAY3AjxBMEEIEJoBIgBFDQIgAEEANgIAIAAgASkCODcCBCAAQQE6ACwgAEEMaiACKQIANwIAIABBFGogBSkCADcCACAAQRxqIAFB0ABqKQIANwIAIABBJGogAUHYAGopAgA3AgAgAUHgAGokACAADwsQqAEACxCpAQALQTBBCBCvAQALpAMBDX8gACACKAAMIgMgASgADCIEQQF2c0HVqtWqBXEiCCADcyIDIAIoAAgiBSABKAAIIgZBAXZzQdWq1aoFcSIJIAVzIgVBAnZzQbPmzJkDcSILIANzIgMgAigABCIHIAEoAAQiCkEBdnNB1arVqgVxIgwgB3MiByACKAAAIgIgASgAACIBQQF2c0HVqtWqBXEiDSACcyICQQJ2c0Gz5syZA3EiDiAHcyIHQQR2c0GPnrz4AHEiDyADczYCHCAAIAQgCEEBdHMiAyAGIAlBAXRzIgRBAnZzQbPmzJkDcSIIIANzIgMgCiAMQQF0cyIGIAEgDUEBdHMiAUECdnNBs+bMmQNxIgkgBnMiBkEEdnNBj568+ABxIgogA3M2AhggACALQQJ0IAVzIgMgDkECdCACcyICQQR2c0GPnrz4AHEiBSADczYCFCAAIA9BBHQgB3M2AgwgACAIQQJ0IARzIgMgCUECdCABcyIBQQR2c0GPnrz4AHEiBCADczYCECAAIApBBHQgBnM2AgggACAFQQR0IAJzNgIEIAAgBEEEdCABczYCAAv/AgEDfwJAAkACQAJAIAFBCU8EQEEQQQgQlQEgAUsNAQwCCyAAEAshAwwCC0EQQQgQlQEhAQtBgIB8QQhBCBCVAUEUQQgQlQFqQRBBCBCVAWprQXdxQX1qIgRBAEEQQQgQlQFBAnRrIgIgAiAESxsgAWsgAE0NACABQRAgAEEEakEQQQgQlQFBe2ogAEsbQQgQlQEiBGpBEEEIEJUBakF8ahALIgJFDQAgAhC1ASEAAkAgAUF/aiIDIAJxRQRAIAAhAQwBCyACIANqQQAgAWtxELUBIQJBEEEIEJUBIQMgABCrASACQQAgASACIABrIANLG2oiASAAayICayEDIAAQoQFFBEAgASADEH8gACACEH8gACACEB4MAQsgACgCACEAIAEgAzYCBCABIAAgAmo2AgALIAEQoQENASABEKsBIgJBEEEIEJUBIARqTQ0BIAEgBBCyASEAIAEgBBB/IAAgAiAEayIEEH8gACAEEB4MAQsgAw8LIAEQtAEgARChARoLmAMCA38CfiMAQUBqIgIkAAJAAkACQAJAIAAEQCAAKAIAIgNBf0YNASAAIANBAWo2AgAgAUQAAAAAAADgw2YhA0IAQv///////////wACfiABmUQAAAAAAADgQ2MEQCABsAwBC0KAgICAgICAgIB/C0KAgICAgICAgIB/IAMbIAFE////////30NkGyABIAFiGyIFUA0CIAVCf1FBACAAKQMIIgZCgICAgICAgICAf1EbDQMgACgCECEDIAJBFGogAEEUahBtIAJBEGoiBCADNgIAIAAgACgCAEF/ajYCACACIAYgBX8iBTcDCCACQThqIAJBGGopAwA3AgAgAkEwaiAEKQMANwIAIAIgBTcCKEEgQQgQmgEiAEUNBCAAQQA2AgAgACACKQIkNwIEIABBDGogAkEsaikCADcCACAAQRRqIAJBNGopAgA3AgAgAEEcaiACQTxqKAIANgIAIAJBQGskACAADwsQqAEACxCpAQALQeCAwABBGUHMgMAAEHUAC0GAgcAAQR9BzIDAABB1AAtBIEEIEK8BAAuYAwIDfwJ+IwBBQGoiAiQAAkACQAJAAkAgAARAIAAoAgAiA0F/Rg0BIAAgA0EBajYCACABRAAAAAAAAODDZiEDQgBC////////////AAJ+IAGZRAAAAAAAAOBDYwRAIAGwDAELQoCAgICAgICAgH8LQoCAgICAgICAgH8gAxsgAUT////////fQ2QbIAEgAWIbIgVQDQIgBUJ/UUEAIAApAwgiBkKAgICAgICAgIB/URsNAyAAKAIQIQMgAkEUaiAAQRRqEG0gAkEQaiIEIAM2AgAgACAAKAIAQX9qNgIAIAIgBiAFgSIFNwMIIAJBOGogAkEYaikDADcCACACQTBqIAQpAwA3AgAgAiAFNwIoQSBBCBCaASIARQ0EIABBADYCACAAIAIpAiQ3AgQgAEEMaiACQSxqKQIANwIAIABBFGogAkE0aikCADcCACAAQRxqIAJBPGooAgA2AgAgAkFAayQAIAAPCxCoAQALEKkBAAtBwIHAAEE5QbCBwAAQdQALQYCCwABBMEGwgcAAEHUAC0EgQQgQrwEAC+4CAgN/An4jAEFAaiICJAACQAJAAkACQAJAIABFDQAgACgCACIDQX9GDQEgACADQQFqNgIAIAFFDQAgASgCACIDQX9GDQEgASADQQFqNgIAIAEpAwgiBVANAiAFQn9RQQAgAEEIaiIDKQMAIgZCgICAgICAgICAf1EbDQMgACgCECEEIAJBFGogA0EMahBtIAEgASgCAEF/ajYCACACQRBqIgEgBDYCACAAIAAoAgBBf2o2AgAgAiAGIAV/IgU3AwggAkE4aiACQRhqKQMANwIAIAJBMGogASkDADcCACACIAU3AihBIEEIEJoBIgBFDQQgAEEANgIAIAAgAikCJDcCBCAAQQxqIAJBLGopAgA3AgAgAEEUaiACQTRqKQIANwIAIABBHGogAkE8aigCADYCACACQUBrJAAgAA8LEKgBAAsQqQEAC0HggMAAQRlBoIHAABB1AAtBgIHAAEEfQaCBwAAQdQALQSBBCBCvAQAL7gICA38CfiMAQUBqIgIkAAJAAkACQAJAAkAgAEUNACAAKAIAIgNBf0YNASAAIANBAWo2AgAgAUUNACABKAIAIgNBf0YNASABIANBAWo2AgAgASkDCCIFUA0CIAVCf1FBACAAQQhqIgMpAwAiBkKAgICAgICAgIB/URsNAyAAKAIQIQQgAkEUaiADQQxqEG0gASABKAIAQX9qNgIAIAJBEGoiASAENgIAIAAgACgCAEF/ajYCACACIAYgBYEiBTcDCCACQThqIAJBGGopAwA3AgAgAkEwaiABKQMANwIAIAIgBTcCKEEgQQgQmgEiAEUNBCAAQQA2AgAgACACKQIkNwIEIABBDGogAkEsaikCADcCACAAQRRqIAJBNGopAgA3AgAgAEEcaiACQTxqKAIANgIAIAJBQGskACAADwsQqAEACxCpAQALQcCBwABBOUGwgsAAEHUAC0GAgsAAQTBBsILAABB1AAtBIEEIEK8BAAvxAgEBfyMAQTBrIgIkACACIAA2AhQCQEEIQQQQmgEiAARAIAAgATYCBCAAQQE2AgAgAEGUh8AAQQkQCSEBIAJBIGpBlIfAADYCACACIAA2AhwgAiABNgIYIAJBITYCKCACIAJBFGogAkEoahByIAIoAgQhAAJAIAIoAgBFBEAgAiAANgIsIAJBLGooAgAQBUUNASACIAIoAiw2AgggAkEIaigCACACQRhqKAIAEAYiAEEkTwRAIAAQAAsgAigCCCIAQSRJDQMgABAADAMLIABBJEkNAiAAEAAMAgsgAigCLCIAQSRJDQEgABAADAELQQhBBBCvAQALIAJBEGogAkEgaigCADYCACACIAIpAxg3AwggAigCKCIAQSRPBEAgABAACyACKAIUIgBBJE8EQCAAEAALQRBBBBCaASIABEAgAEEANgIAIAAgAikDCDcCBCAAQQxqIAJBEGooAgA2AgAgAkEwaiQAIAAPC0EQQQQQrwEAC9sCAgJ/BH4jAEHgAGsiAiQAIAIgATYCCCACIAE2AgQgAiAANgIAIAJBOGogAhAVAkAgAikDOCIEUEUEQCACQShqIAQgAigCQEEAIAIQIQwBCyACQQA2AjAgAkIBNwMoCyACQRhqIAIpAygiBDcDACACQRBqIAJByABqIgEpAwAiBTcDACACQQhqIAJBQGsiAykDACIGNwMAIAJBIGogAkEwaigCACIANgIAIAIgAikDOCIHNwMAIAJB3ABqIAA2AgAgAkHUAGogBDcCACACQcwAaiAFNwIAIAJBxABqIAY3AgAgAiAHNwI8QTBBCBCaASIARQRAQTBBCBCvAQALIABBADYCACAAIAIpAjg3AgQgAEEBOgAsIABBDGogAykCADcCACAAQRRqIAEpAgA3AgAgAEEcaiACQdAAaikCADcCACAAQSRqIAJB2ABqKQIANwIAIAJB4ABqJAAgAAvZAgEEfyMAQTBrIgQkAAJAAkAgAQRAIAEoAgAiBUF/Rg0BIAEgBUEBajYCACAEIAEpAwggAUEQaigCACIFQQEgAyAFIAIbECEgBEEoaiAEQQhqKAIAIgI2AgAgBCAEKQMANwMgIAQoAiQgAkYEQCAEQSBqIAJBARBIIAQoAighAgsgBCgCICACakEgOgAAIARBGGogAkEBaiICNgIAIAQgBCkDIDcDECABKAIUIQcgBCgCFCIFIAJrIAEoAhwiBkkEQCAEQRBqIAIgBhBIIAQoAhQhBSAEKAIYIQILIAQoAhAiAyACaiAHIAYQsQEaIAEgASgCAEF/ajYCAAJAIAUgAiAGaiIBTQRAIAMhAgwBCyABRQRAQQEhAiADEBAMAQsgAyAFQQEgARCWASICRQ0DCyAAIAE2AgQgACACNgIAIARBMGokAA8LEKgBAAsQqQEACyABQQEQrwEAC+8CAQN/IwBB0AtrIgckAAJAAkACQAJAAkACQAJAIAZBAEgNAAJAIAZFBEBBASEIDAELIAZBARCaASIIRQ0ECyAIIAUgBhCxASEIIARBEEcgAkEgR3INBCAHQeAHakEEciICIAEQDCAHQYAEaiACQeADELEBGiAHQeAHaiAHQYAEakHgAxCxARogB0HAC2oiAiADKQAANwAAIAJBCGogA0EIaikAADcAACAHQRBqIAdB4AdqQfADELEBGiAHQeAHaiAHQRBqQfADELEBGiAHQQhqIAdB4AdqIAggBhAKIAcoAggiCUUNBSAHKAIMIgJBAEgNACACDQFBASEEDAILEHkACyACQQEQmgEiBEUNBAsgBCAJIAIQsQEhBCAGBEAgCBAQIAUQEAsgAxAQIAEQECAAIAI2AgQgACAENgIAIAdB0AtqJAAPCyAGQQEQrwEAC0HyhsAAQQ8QqgEAC0GBh8AAQRIQqgEACyACQQEQrwEAC9ICAQZ/IwBBMGsiAiQAAkACQCABBEAgASgCACIDQX9GDQEgASADQQFqNgIAIAIgASkDCCABQRBqKAIAQQAgAhAhIAJBKGogAkEIaigCACIDNgIAIAIgAikDADcDICACKAIkIANGBEAgAkEgaiADQQEQSCACKAIoIQMLIAIoAiAgA2pBIDoAACACQRhqIANBAWoiAzYCACACIAIpAyA3AxAgASgCFCEHIAIoAhQiBCADayABKAIcIgVJBEAgAkEQaiADIAUQSCACKAIUIQQgAigCGCEDCyACKAIQIgYgA2ogByAFELEBGiABIAEoAgBBf2o2AgACQCAEIAMgBWoiAU0EQCAGIQMMAQsgAUUEQEEBIQMgBhAQDAELIAYgBEEBIAEQlgEiA0UNAwsgACABNgIEIAAgAzYCACACQTBqJAAPCxCoAQALEKkBAAsgAUEBEK8BAAvSAgEDfyMAQRBrIgIkAAJAAn8CQCABQYABTwRAIAJBADYCDCABQYAQTw0BIAIgAUE/cUGAAXI6AA0gAiABQQZ2QcABcjoADEECDAILIAAoAggiAyAAQQRqKAIARgRAIAAgAxBLIAAoAgghAwsgACADQQFqNgIIIAAoAgAgA2ogAToAAAwCCyABQYCABE8EQCACIAFBP3FBgAFyOgAPIAIgAUESdkHwAXI6AAwgAiABQQZ2QT9xQYABcjoADiACIAFBDHZBP3FBgAFyOgANQQQMAQsgAiABQT9xQYABcjoADiACIAFBDHZB4AFyOgAMIAIgAUEGdkE/cUGAAXI6AA1BAwshASAAQQRqKAIAIABBCGoiBCgCACIDayABSQRAIAAgAyABEEogBCgCACEDCyAAKAIAIANqIAJBDGogARCxARogBCABIANqNgIACyACQRBqJAALvAICBH8CfiMAQUBqIgIkAAJAAkACQCAARQ0AIAAoAgAiA0F/Rg0BIAAgA0EBajYCACABRQ0AIAEoAgAiA0F/Rg0BIAEgA0EBajYCACABQQhqIABBCGogACkDCCIGIAEpAwgiB1UiAxsiBCgCCCEFIAJBFGogBEEMahBtIAEgASgCAEF/ajYCACACQRBqIgEgBTYCACAAIAAoAgBBf2o2AgAgAiAHIAYgAxsiBjcDCCACQThqIAJBGGopAwA3AgAgAkEwaiABKQMANwIAIAIgBjcCKEEgQQgQmgEiAEUNAiAAQQA2AgAgACACKQIkNwIEIABBDGogAkEsaikCADcCACAAQRRqIAJBNGopAgA3AgAgAEEcaiACQTxqKAIANgIAIAJBQGskACAADwsQqAEACxCpAQALQSBBCBCvAQALvAICBH8CfiMAQUBqIgIkAAJAAkACQCAARQ0AIAAoAgAiA0F/Rg0BIAAgA0EBajYCACABRQ0AIAEoAgAiA0F/Rg0BIAEgA0EBajYCACABQQhqIABBCGogACkDCCIGIAEpAwgiB1MiAxsiBCgCCCEFIAJBFGogBEEMahBtIAEgASgCAEF/ajYCACACQRBqIgEgBTYCACAAIAAoAgBBf2o2AgAgAiAHIAYgAxsiBjcDCCACQThqIAJBGGopAwA3AgAgAkEwaiABKQMANwIAIAIgBjcCKEEgQQgQmgEiAEUNAiAAQQA2AgAgACACKQIkNwIEIABBDGogAkEsaikCADcCACAAQRRqIAJBNGopAgA3AgAgAEEcaiACQTxqKAIANgIAIAJBQGskACAADwsQqAEACxCpAQALQSBBCBCvAQALtgIBB38CQCACQQ9NBEAgACEDDAELIABBACAAa0EDcSIEaiEFIAQEQCAAIQMgASEGA0AgAyAGLQAAOgAAIAZBAWohBiADQQFqIgMgBUkNAAsLIAUgAiAEayIIQXxxIgdqIQMCQCABIARqIgRBA3EEQCAHQQFIDQEgBEEDdCICQRhxIQkgBEF8cSIGQQRqIQFBACACa0EYcSECIAYoAgAhBgNAIAUgBiAJdiABKAIAIgYgAnRyNgIAIAFBBGohASAFQQRqIgUgA0kNAAsMAQsgB0EBSA0AIAQhAQNAIAUgASgCADYCACABQQRqIQEgBUEEaiIFIANJDQALCyAIQQNxIQIgBCAHaiEBCyACBEAgAiADaiECA0AgAyABLQAAOgAAIAFBAWohASADQQFqIgMgAkkNAAsLIAALrwIBBX8CQAJAAkACQCABQQNqQXxxIAFrIgNFDQAgAiADIAMgAksbIgNFDQBBASEFA0AgASAEai0AAEEgRg0EIAMgBEEBaiIERw0ACyADIAJBeGoiBUsNAgwBCyACQXhqIQVBACEDC0GgwICBAiEEA0AgASADaiIGKAIAQaDAgIECcyIHQX9zIAdB//37d2pxIAZBBGooAgBBoMCAgQJzIgZBf3MgBkH//ft3anFyQYCBgoR4cUUEQCADQQhqIgMgBU0NAQsLIAMgAk0NACADIAIQZgALAkAgAiADRg0AIAMgAmshAiABIANqIQFBACEEA0AgASAEai0AAEEgRwRAIAIgBEEBaiIEag0BDAILCyADIARqIQRBASEFDAELQQAhBQsgACAENgIEIAAgBTYCAAvaAgIDfwF+IwBBQGoiAiQAAkACQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIABBEGooAgAhAyAAKQMIIQUgAkEUaiAAQRRqEG0gAkEQaiIEIAM2AgAgACAAKAIAQX9qNgIAIAFEAAAAAAAA4MNmIQAgAiAFQgBC////////////AAJ+IAGZRAAAAAAAAOBDYwRAIAGwDAELQoCAgICAgICAgH8LQoCAgICAgICAgH8gABsgAUT////////fQ2QbIAEgAWIbfCIFNwMIIAJBOGogAkEYaikDADcCACACQTBqIAQpAwA3AgAgAiAFNwIoQSBBCBCaASIARQ0CIABBADYCACAAIAIpAiQ3AgQgAEEMaiACQSxqKQIANwIAIABBFGogAkE0aikCADcCACAAQRxqIAJBPGooAgA2AgAgAkFAayQAIAAPCxCoAQALEKkBAAtBIEEIEK8BAAvaAgIDfwF+IwBBQGoiAiQAAkACQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIABBEGooAgAhAyAAKQMIIQUgAkEUaiAAQRRqEG0gAkEQaiIEIAM2AgAgACAAKAIAQX9qNgIAIAFEAAAAAAAA4MNmIQAgAiAFQgBC////////////AAJ+IAGZRAAAAAAAAOBDYwRAIAGwDAELQoCAgICAgICAgH8LQoCAgICAgICAgH8gABsgAUT////////fQ2QbIAEgAWIbfSIFNwMIIAJBOGogAkEYaikDADcCACACQTBqIAQpAwA3AgAgAiAFNwIoQSBBCBCaASIARQ0CIABBADYCACAAIAIpAiQ3AgQgAEEMaiACQSxqKQIANwIAIABBFGogAkE0aikCADcCACAAQRxqIAJBPGooAgA2AgAgAkFAayQAIAAPCxCoAQALEKkBAAtBIEEIEK8BAAvaAgIDfwF+IwBBQGoiAiQAAkACQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIABBEGooAgAhAyAAKQMIIQUgAkEUaiAAQRRqEG0gAkEQaiIEIAM2AgAgACAAKAIAQX9qNgIAIAFEAAAAAAAA4MNmIQAgAiAFQgBC////////////AAJ+IAGZRAAAAAAAAOBDYwRAIAGwDAELQoCAgICAgICAgH8LQoCAgICAgICAgH8gABsgAUT////////fQ2QbIAEgAWIbfiIFNwMIIAJBOGogAkEYaikDADcCACACQTBqIAQpAwA3AgAgAiAFNwIoQSBBCBCaASIARQ0CIABBADYCACAAIAIpAiQ3AgQgAEEMaiACQSxqKQIANwIAIABBFGogAkE0aikCADcCACAAQRxqIAJBPGooAgA2AgAgAkFAayQAIAAPCxCoAQALEKkBAAtBIEEIEK8BAAu3AgIFfwF+IwBBMGsiBCQAQSchAgJAIABCkM4AVARAIAAhBwwBCwNAIARBCWogAmoiA0F8aiAAIABCkM4AgCIHQpDOAH59pyIFQf//A3FB5ABuIgZBAXRBtI7AAGovAAA7AAAgA0F+aiAFIAZB5ABsa0H//wNxQQF0QbSOwABqLwAAOwAAIAJBfGohAiAAQv/B1y9WIAchAA0ACwsgB6ciA0HjAEsEQCACQX5qIgIgBEEJamogB6ciAyADQf//A3FB5ABuIgNB5ABsa0H//wNxQQF0QbSOwABqLwAAOwAACwJAIANBCk8EQCACQX5qIgIgBEEJamogA0EBdEG0jsAAai8AADsAAAwBCyACQX9qIgIgBEEJamogA0EwajoAAAsgASAEQQlqIAJqQScgAmsQEyAEQTBqJAALrAICAn8CfiMAQUBqIgIkAAJAAkACQCAARQ0AIAAoAgAiA0F/Rg0BIAAgA0EBajYCACABRQ0AIAEoAgAiA0F/Rg0BIAEgA0EBajYCACABKQMIIQQgACkDCCEFIAAoAhAhAyACQRRqIABBFGoQbSABIAEoAgBBf2o2AgAgAkEQaiIBIAM2AgAgACAAKAIAQX9qNgIAIAIgBCAFfCIENwMIIAJBOGogAkEYaikDADcCACACQTBqIAEpAwA3AgAgAiAENwIoQSBBCBCaASIARQ0CIABBADYCACAAIAIpAiQ3AgQgAEEMaiACQSxqKQIANwIAIABBFGogAkE0aikCADcCACAAQRxqIAJBPGooAgA2AgAgAkFAayQAIAAPCxCoAQALEKkBAAtBIEEIEK8BAAusAgICfwJ+IwBBQGoiAiQAAkACQAJAIABFDQAgACgCACIDQX9GDQEgACADQQFqNgIAIAFFDQAgASgCACIDQX9GDQEgASADQQFqNgIAIAEpAwghBCAAKQMIIQUgACgCECEDIAJBFGogAEEUahBtIAEgASgCAEF/ajYCACACQRBqIgEgAzYCACAAIAAoAgBBf2o2AgAgAiAFIAR9IgQ3AwggAkE4aiACQRhqKQMANwIAIAJBMGogASkDADcCACACIAQ3AihBIEEIEJoBIgBFDQIgAEEANgIAIAAgAikCJDcCBCAAQQxqIAJBLGopAgA3AgAgAEEUaiACQTRqKQIANwIAIABBHGogAkE8aigCADYCACACQUBrJAAgAA8LEKgBAAsQqQEAC0EgQQgQrwEAC6wCAgJ/An4jAEFAaiICJAACQAJAAkAgAEUNACAAKAIAIgNBf0YNASAAIANBAWo2AgAgAUUNACABKAIAIgNBf0YNASABIANBAWo2AgAgASkDCCEEIAApAwghBSAAKAIQIQMgAkEUaiAAQRRqEG0gASABKAIAQX9qNgIAIAJBEGoiASADNgIAIAAgACgCAEF/ajYCACACIAQgBX4iBDcDCCACQThqIAJBGGopAwA3AgAgAkEwaiABKQMANwIAIAIgBDcCKEEgQQgQmgEiAEUNAiAAQQA2AgAgACACKQIkNwIEIABBDGogAkEsaikCADcCACAAQRRqIAJBNGopAgA3AgAgAEEcaiACQTxqKAIANgIAIAJBQGskACAADwsQqAEACxCpAQALQSBBCBCvAQALpwIBBX8gAEIANwIQIAACf0EAIAFBgAJJDQAaQR8gAUH///8HSw0AGiABQQYgAUEIdmciAmt2QQFxIAJBAXRrQT5qCyICNgIcIAJBAnRBjJTAAGohAyAAIQQCQAJAAkACQEGAksAAKAIAIgVBASACdCIGcQRAIAMoAgAhAyACEJMBIQIgAxCrASABRw0BIAMhAgwCC0GAksAAIAUgBnI2AgAgAyAANgIADAMLIAEgAnQhBQNAIAMgBUEddkEEcWpBEGoiBigCACICRQ0CIAVBAXQhBSACIgMQqwEgAUcNAAsLIAIoAggiASAENgIMIAIgBDYCCCAEIAI2AgwgBCABNgIIIABBADYCGA8LIAYgADYCAAsgACADNgIYIAQgBDYCCCAEIAQ2AgwLtgIBBX8gACgCGCEEAkACQCAAIAAoAgxGBEAgAEEUQRAgAEEUaiIBKAIAIgMbaigCACICDQFBACEBDAILIAAoAggiAiAAKAIMIgE2AgwgASACNgIIDAELIAEgAEEQaiADGyEDA0AgAyEFIAIiAUEUaiIDKAIAIgJFBEAgAUEQaiEDIAEoAhAhAgsgAg0ACyAFQQA2AgALAkAgBEUNAAJAIAAgACgCHEECdEGMlMAAaiICKAIARwRAIARBEEEUIAQoAhAgAEYbaiABNgIAIAENAQwCCyACIAE2AgAgAQ0AQYCSwABBgJLAACgCAEF+IAAoAhx3cTYCAA8LIAEgBDYCGCAAKAIQIgIEQCABIAI2AhAgAiABNgIYCyAAQRRqKAIAIgBFDQAgAUEUaiAANgIAIAAgATYCGAsLbwEMf0GslcAAKAIAIgJFBEBBvJXAAEH/HzYCAEEADwtBpJXAACEGA0AgAiIBKAIIIQIgASgCBCEDIAEoAgAhBCABQQxqKAIAGiABIQYgBUEBaiEFIAINAAtBvJXAACAFQf8fIAVB/x9LGzYCACAIC/sBAgN/AX4jAEFAaiIBJAACQAJAIAAEQCAAKAIAIgJBf0YNASAAIAJBAWo2AgAgAEEgaikDACEEIABBKGooAgAhAiABQRRqIABBLGoQbSABQRBqIgMgAjYCACAAIAAoAgBBf2o2AgAgASAENwMIIAFBOGogAUEYaikDADcCACABQTBqIAMpAwA3AgAgASAENwIoQSBBCBCaASIARQ0CIABBADYCACAAIAEpAiQ3AgQgAEEMaiABQSxqKQIANwIAIABBFGogAUE0aikCADcCACAAQRxqIAFBPGooAgA2AgAgAUFAayQAIAAPCxCoAQALEKkBAAtBIEEIEK8BAAv4AQIDfwF+IwBBQGoiASQAAkACQCAABEAgACgCACICQX9GDQEgACACQQFqNgIAIABBEGooAgAhAiAAKQMIIQQgAUEUaiAAQRRqEG0gAUEQaiIDIAI2AgAgACAAKAIAQX9qNgIAIAEgBDcDCCABQThqIAFBGGopAwA3AgAgAUEwaiADKQMANwIAIAEgBDcCKEEgQQgQmgEiAEUNAiAAQQA2AgAgACABKQIkNwIEIABBDGogAUEsaikCADcCACAAQRRqIAFBNGopAgA3AgAgAEEcaiABQTxqKAIANgIAIAFBQGskACAADwsQqAEACxCpAQALQSBBCBCvAQALhAICBH8BfiMAQUBqIgMkACADQQA2AhwCQCACQQhqKAIAIgRBAE4EQEEBIQUgBARAIARBARCaASIFRQ0CCyADQQA2AiggAyAENgIkIAMgBTYCICADQTBqIAIQbSADQQhqIANBMGpBASABKAIIIANBHGogA0EgahAOAkAgAykDCKdFBEAgAykDECEHIAAgAykDIDcCBCABIAc3AwAgAEEMaiADQShqKAIANgIADAELIABBvIDAAEEDEAM2AgQgAygCJEUEQEEBIQYMAQtBASEGIAMoAiAQEAsgACAGNgIAIAJBBGooAgAEQCACKAIAEBALIANBQGskAA8LEHkACyAEQQEQrwEAC4YCAgR/AX4jAEEwayICJAAgAUEEaiEEIAEoAgRFBEAgASgCACEDIAJBEGoiBUEANgIAIAJCATcDCCACIAJBCGo2AhQgAkEoaiADQRBqKQIANwMAIAJBIGogA0EIaikCADcDACACIAMpAgA3AxggAkEUaiACQRhqEB0aIARBCGogBSgCADYCACAEIAIpAwg3AgALIAJBIGoiAyAEQQhqKAIANgIAIAFBDGpBADYCACAEKQIAIQYgAUIBNwIEIAIgBjcDGEEMQQQQmgEiAUUEQEEMQQQQrwEACyABIAIpAxg3AgAgAUEIaiADKAIANgIAIABBpIzAADYCBCAAIAE2AgAgAkEwaiQAC5kCAgN/AX4jAEEgayIFJAAgAEQAAAAAAADgw2YhBAJAQgBC////////////AAJ+IACZRAAAAAAAAOBDYwRAIACwDAELQoCAgICAgICAgH8LQoCAgICAgICAgH8gBBsgAET////////fQ2QbIAAgAGIbIgdQRQRAIAVBEGogByABQQAgBBAhDAELIAVBADYCGCAFQgE3AxALIAVBCGoiBiAFQRhqKAIANgIAIAUgBSkDEDcDAEEwQQgQmgEiBEUEQEEwQQgQrwEACyAEIAM2AhwgBCADNgIYIAQgAjYCFCAEIAE2AhAgBCAHNwMIIARBADYCACAEIAUpAwA3AyAgBEEBOgAsIARBKGogBigCADYCACAFQSBqJAAgBAvSAQIDfwF+IwBBIGsiAiQAAkACQCAARQ0AIAAoAgANASAAQX82AgAgAUUNACABKAIAIgNBf0YNASABIANBAWo2AgAgAUEQaigCACEDIAEpAwghBSACQRRqIAFBFGoQbSACIAM2AhAgAiAFNwMIIABBCGoiA0EQaiIEKAIABEAgAygCDBAQCyADIAIpAwg3AwAgBCACQRhqKQMANwMAIANBCGogAkEQaikDADcDACABIAEoAgBBf2o2AgAgAEEANgIAIAJBIGokAA8LEKgBAAsQqQEAC9UBAgN/AX4jAEEgayICJAACQAJAIABFDQAgACgCAA0BIABBfzYCACABRQ0AIAEoAgAiA0F/Rg0BIAEgA0EBajYCACABQRBqKAIAIQMgASkDCCEFIAJBFGogAUEUahBtIAIgAzYCECACIAU3AwggAEEIaiIDQShqIgQoAgAEQCADQSRqKAIAEBALIAMgAikDCDcDGCAEIAJBGGopAwA3AwAgA0EgaiACQRBqKQMANwMAIAEgASgCAEF/ajYCACAAQQA2AgAgAkEgaiQADwsQqAEACxCpAQALjwIBA38jAEEgayIFJABBASEGQfiRwABB+JHAACgCACIHQQFqNgIAAkBBwJXAAC0AAARAQciVwAAoAgBBAWohBgwBC0HAlcAAQQE6AAALQciVwAAgBjYCAAJAAkAgB0EASCAGQQJLcg0AIAUgBDoAGCAFIAM2AhQgBSACNgIQQeyRwAAoAgAiAkF/TA0AQeyRwAAgAkEBaiICNgIAQeyRwABB9JHAACgCACIDBH9B8JHAACgCACAFIAAgASgCEBEBACAFIAUpAwA3AwggBUEIaiADKAIUEQEAQeyRwAAoAgAFIAILQX9qNgIAIAZBAUsNACAEDQELAAsjAEEQayICJAAgAiABNgIMIAIgADYCCAALtwEBAX8jAEFAaiICJAAgAiABNgIoIAIgATYCJCACIAA2AiAgAkEIaiACQSBqEBUgAkE0aiACQRhqKQMANwIAIAJBLGogAkEQaikDADcCACACIAIpAwg3AiRBIEEIEJoBIgBFBEBBIEEIEK8BAAsgAEEANgIAIAAgAikCIDcCBCAAQQxqIAJBKGopAgA3AgAgAEEUaiACQTBqKQIANwIAIABBHGogAkE4aigCADYCACACQUBrJAAgAAvJAQIBfwF+IwBBIGsiBCQAAkACQAJAIAEEQCABKAIADQEgAUF/NgIAIAQgAzYCGCAEIAM2AhQgBCACNgIQIAQgAUEIaiAEQRBqEEAgAUEANgIAIAQoAgQhASAEKAIADQICQCAEQQhqKQMAIgWnIgMgBUIgiKciAk0NACACRQRAIAEQEEEBIQEMAQsgASADQQEgAhCWASIBRQ0ECyAAIAI2AgQgACABNgIAIARBIGokAA8LEKgBAAsQqQEACyABEAgACyACQQEQrwEAC7kBAQJ/IwBBIGsiAyQAAkAgASACaiICIAFJDQAgAEEEaigCACIBQQF0IgQgAiAEIAJLGyICQQggAkEISxshAgJAIAEEQCADQRhqQQE2AgAgAyABNgIUIAMgACgCADYCEAwBCyADQQA2AhALIAMgAiADQRBqEFcgAygCAARAIANBCGooAgAiAEUNASADKAIEIAAQrwEACyADKAIEIQEgAEEEaiACNgIAIAAgATYCACADQSBqJAAPCxB5AAu5AQEDfyMAQSBrIgIkAAJAIAFBAWoiAyABSQ0AIABBBGooAgAiAUEBdCIEIAMgBCADSxsiA0EIIANBCEsbIQMCQCABBEAgAkEYakEBNgIAIAIgATYCFCACIAAoAgA2AhAMAQsgAkEANgIQCyACIAMgAkEQahBXIAIoAgAEQCACQQhqKAIAIgBFDQEgAigCBCAAEK8BAAsgAigCBCEBIABBBGogAzYCACAAIAE2AgAgAkEgaiQADwsQeQALuQEBAn8jAEEgayIDJAACQCABIAJqIgIgAUkNACAAQQRqKAIAIgFBAXQiBCACIAQgAksbIgJBCCACQQhLGyECAkAgAQRAIANBGGpBATYCACADIAE2AhQgAyAAKAIANgIQDAELIANBADYCEAsgAyACIANBEGoQVSADKAIABEAgA0EIaigCACIARQ0BIAMoAgQgABCvAQALIAMoAgQhASAAQQRqIAI2AgAgACABNgIAIANBIGokAA8LEHkAC7kBAQN/IwBBIGsiAiQAAkAgAUEBaiIDIAFJDQAgAEEEaigCACIBQQF0IgQgAyAEIANLGyIDQQggA0EISxshAwJAIAEEQCACQRhqQQE2AgAgAiABNgIUIAIgACgCADYCEAwBCyACQQA2AhALIAIgAyACQRBqEFUgAigCAARAIAJBCGooAgAiAEUNASACKAIEIAAQrwEACyACKAIEIQEgAEEEaiADNgIAIAAgATYCACACQSBqJAAPCxB5AAu4AQEDfyMAQRBrIgMkAAJAAkAgAQRAIAEoAgAiAkF/Rg0BIAEgAkEBajYCACADIAEpAwggAUEQaigCAEEAIAEQISABIAEoAgBBf2o2AgAgAygCACEBAkAgAygCBCICIAMoAggiBE0EQCABIQIMAQsgBEUEQEEBIQIgARAQDAELIAEgAkEBIAQQlgEiAkUNAwsgACAENgIEIAAgAjYCACADQRBqJAAPCxCoAQALEKkBAAsgBEEBEK8BAAuLAQEEfyAAQQAgAGtBA3EiA2ohASADBEAgACECA0AgAkEAOgAAIAJBAWoiAiABSQ0ACwsgAUHgAyADayIDQXxxIgRqIQIgBEEBTgRAA0AgAUEANgIAIAFBBGoiASACSQ0ACwsgA0EDcSIBBEAgASACaiEBA0AgAkEAOgAAIAJBAWoiAiABSQ0ACwsgAAutAQEBfyMAQTBrIgMkAAJAAkAgAARAIAAoAgANASAAQX82AgAgAyACNgIYIAMgAjYCFCADIAE2AhAgA0EANgIcIANBIGogA0EQahBtIAMgA0EgakEBIABBEGooAgAgA0EcakEAEA4gAykDAKcNAiAAIAMpAwg3AwggAygCFARAIAMoAhAQEAsgAEEANgIAIANBMGokAA8LEKgBAAsQqQEACyADQSBqQayAwAAQXAALrAEBA38jAEEQayIDJAACQAJAIAEEQCABKAIAIgJBf0YNASABIAJBAWo2AgAgAyABQRRqEG0gASABKAIAQX9qNgIAIAMoAgAhAQJAIAMoAgQiAiADKAIIIgRNBEAgASECDAELIARFBEBBASECIAEQEAwBCyABIAJBASAEEJYBIgJFDQMLIAAgBDYCBCAAIAI2AgAgA0EQaiQADwsQqAEACxCpAQALIARBARCvAQALrAEBA38jAEEQayIDJAACQAJAIAEEQCABKAIAIgJBf0YNASABIAJBAWo2AgAgAyABQSBqEG0gASABKAIAQX9qNgIAIAMoAgAhAQJAIAMoAgQiAiADKAIIIgRNBEAgASECDAELIARFBEBBASECIAEQEAwBCyABIAJBASAEEJYBIgJFDQMLIAAgBDYCBCAAIAI2AgAgA0EQaiQADwsQqAEACxCpAQALIARBARCvAQALqAECAX8BfiMAQSBrIgIkACAAKQIAIQMgAEEANgIAIAOnBEAgAiADQiCIPgIUIAIgATYCGCACQSE2AhwgAkEIaiACQRRqIAJBHGogAkEYahBwIAIoAgwiAEEkTwRAIAAQAAsgAigCHCIAQSRPBEAgABAACyACKAIYIgBBJE8EQCAAEAALIAIoAhQiAEEkTwRAIAAQAAsgAkEgaiQADwtBqIfAAEEcEKoBAAunAQEDfyMAQTBrIgIkACABQQRqIQMgASgCBEUEQCABKAIAIQEgAkEQaiIEQQA2AgAgAkIBNwMIIAIgAkEIajYCFCACQShqIAFBEGopAgA3AwAgAkEgaiABQQhqKQIANwMAIAIgASkCADcDGCACQRRqIAJBGGoQHRogA0EIaiAEKAIANgIAIAMgAikDCDcCAAsgAEGkjMAANgIEIAAgAzYCACACQTBqJAALmgEBAX8jAEEgayIDJAACQCAABEAgACgCAA0BIABBfzYCACADIAI2AgggAyACNgIEIAMgATYCACAAQRRqIQEgA0EQaiADEG0gAEEYaigCAARAIAEoAgAQEAsgASADKQMQNwIAIAFBCGogA0EYaigCADYCACADKAIEBEAgAygCABAQCyAAQQA2AgAgA0EgaiQADwsQqAEACxCpAQALowEBAX8jAEEQayIGJAACQCABBEAgBiABIAMgBCAFIAIoAhARCQAgBigCACEBAkAgBigCBCICIAYoAggiA00EQCABIQIMAQsgAkECdCEEIANBAnQiBUUEQEEEIQIgBEUNASABEBAMAQsgASAEQQQgBRCWASICRQ0CCyAAIAM2AgQgACACNgIAIAZBEGokAA8LQfSHwABBMBCqAQALIAVBBBCvAQALmQEBAn8CQAJAAkACQAJ/AkACQAJ/QQEiAyABQQBIDQAaIAIoAgAiBEUNASACKAIEIgINBCABDQJBAQwDCyEDQQAhAQwGCyABDQBBAQwBCyABQQEQmgELIgJFDQEMAgsgBCACQQEgARCWASICDQELIAAgATYCBEEBIQEMAQsgACACNgIEQQAhAwsgACADNgIAIABBCGogATYCAAuaAQEBfyMAQSBrIgIkACAAKAIABEAgAiAAKAIENgIUIAIgATYCGCACQSE2AhwgAkEIaiACQRRqIAJBHGogAkEYahBwIAIoAgwiAEEkTwRAIAAQAAsgAigCHCIAQSRPBEAgABAACyACKAIYIgBBJE8EQCAAEAALIAIoAhQiAEEkTwRAIAAQAAsgAkEgaiQADwtBqIfAAEEcEKoBAAuYAQECfwJAAkACQAJAAkACQAJAAn9BASIDIAFBAEgNABogAigCACIERQ0CIAIoAgQiAg0BIAENAwwFCyEDQQAhAQwGCyAEIAJBASABEJYBIgJFDQIMBAsgAUUNAgsgAUEBEJoBIgINAgsgACABNgIEQQEhAQwCC0EBIQILIAAgAjYCBEEAIQMLIAAgAzYCACAAQQhqIAE2AgALhAEBBH8CQCACRQ0AIAEgAkF/aiIEai0AACIFRSAFIAJLcg0AIAQgAiAFayIGTwRAQQAgBWshAyABIAJqIQIDQCADQX9GBEAgASEDDAMLIAIgA2ogA0EBaiEDLQAAIAVGDQALQQAhAwwBCyAGIARB+IjAABBoAAsgACAGNgIEIAAgAzYCAAugAQEDfwJAIAAEQCAAKAIAIgFBf0YNAUEBIQMgACABQQFqNgIAIABBFGooAgAhAgJAAkACQAJAIABBHGooAgBBfWoOAwEDAAMLIAJBv4DAAEEFELABDQEgACABNgIAQQAPCyACQcSAwABBAxCwAQ0BIAAgATYCAEEADwsgAkHHgMAAQQUQsAFBAEchAwsgACABNgIAIAMPCxCoAQALEKkBAAueAQECfyMAQRBrIgMkACAAQRRqKAIAIQQCQAJ/AkACQCAAQQRqKAIADgIAAQMLIAQNAkEAIQBBvIvAAAwBCyAEDQEgACgCACIEKAIEIQAgBCgCAAshBCADIAA2AgQgAyAENgIAIANB2IzAACABKAIIIAIgAS0AEBBFAAsgA0EANgIEIAMgADYCACADQcSMwAAgASgCCCACIAEtABAQRQALogEBAX9BIEEIEJoBIgQEQCAEIAM2AhwgBCADNgIYIAQgAjYCFCAEIAE2AhAgBEEANgIAIABEAAAAAAAA4MNmIQEgBEIAQv///////////wACfiAAmUQAAAAAAADgQ2MEQCAAsAwBC0KAgICAgICAgIB/C0KAgICAgICAgIB/IAEbIABE////////30NkGyAAIABiGzcDCCAEDwtBIEEIEK8BAAuDAQEBfyMAQUBqIgIkACACQSs2AgwgAkGDhMAANgIIIAJBsITAADYCFCACIAA2AhAgAkEsakECNgIAIAJBPGpBJDYCACACQgI3AhwgAkGkjsAANgIYIAJBJTYCNCACIAJBMGo2AiggAiACQRBqNgI4IAIgAkEIajYCMCACQRhqIAEQegALagIBfwJ+AkACQCAARQ0AIAAoAgAiAkF/Rg0BIAAgAkEBajYCACABRQ0AIAEoAgAiAkF/Rg0BIAEgAkEBajYCACAAKQMIIAEgAjYCACABKQMIIAAgACgCAEF/ajYCAFEPCxCoAQALEKkBAAtqAgF/An4CQAJAIABFDQAgACgCACICQX9GDQEgACACQQFqNgIAIAFFDQAgASgCACICQX9GDQEgASACQQFqNgIAIAApAwggASACNgIAIAEpAwggACAAKAIAQX9qNgIAUg8LEKgBAAsQqQEAC2oCAX8CfgJAAkAgAEUNACAAKAIAIgJBf0YNASAAIAJBAWo2AgAgAUUNACABKAIAIgJBf0YNASABIAJBAWo2AgAgACkDCCABIAI2AgAgASkDCCAAIAAoAgBBf2o2AgBTDwsQqAEACxCpAQALagIBfwJ+AkACQCAARQ0AIAAoAgAiAkF/Rg0BIAAgAkEBajYCACABRQ0AIAEoAgAiAkF/Rg0BIAEgAkEBajYCACAAKQMIIAEgAjYCACABKQMIIAAgACgCAEF/ajYCAFcPCxCoAQALEKkBAAtqAgF/An4CQAJAIABFDQAgACgCACICQX9GDQEgACACQQFqNgIAIAFFDQAgASgCACICQX9GDQEgASACQQFqNgIAIAApAwggASACNgIAIAEpAwggACAAKAIAQX9qNgIAVQ8LEKgBAAsQqQEAC2oCAX8CfgJAAkAgAEUNACAAKAIAIgJBf0YNASAAIAJBAWo2AgAgAUUNACABKAIAIgJBf0YNASABIAJBAWo2AgAgACkDCCABIAI2AgAgASkDCCAAIAAoAgBBf2o2AgBZDwsQqAEACxCpAQALfAEDfyAAIAAQtAEiAEEIEJUBIABrIgIQsgEhAEGQlcAAIAEgAmsiATYCAEGYlcAAIAA2AgAgACABQQFyNgIEQQhBCBCVASECQRRBCBCVASEDQRBBCBCVASEEIAAgARCyASAEIAMgAkEIa2pqNgIEQbSVwABBgICAATYCAAuHAQEBfwJAIAAEQCAAKAIADQEgAEEANgIAIAFEAAAAAAAA4MNmIQIgAEIAQv///////////wACfiABmUQAAAAAAADgQ2MEQCABsAwBC0KAgICAgICAgIB/C0KAgICAgICAgIB/IAIbIAFE////////30NkGyABIAFiGzcDCA8LEKgBAAsQqQEAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEiNgIAIANCAjcCDCADQZCOwAA2AgggA0EiNgIkIAMgA0EgajYCGCADIAM2AiggAyADQQRqNgIgIANBCGogAhB6AAtvAQF/IwBBMGsiAiQAIAIgATYCBCACIAA2AgAgAkEcakECNgIAIAJBLGpBIjYCACACQgI3AgwgAkHgkMAANgIIIAJBIjYCJCACIAJBIGo2AhggAiACQQRqNgIoIAIgAjYCICACQQhqQZyQwAAQegALcAEBfyMAQTBrIgEkACABQfgANgIEIAEgADYCACABQRxqQQI2AgAgAUEsakEiNgIAIAFCAjcCDCABQYCRwAA2AgggAUEiNgIkIAEgAUEgajYCGCABIAFBBGo2AiggASABNgIgIAFBCGpB4InAABB6AAtsAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBIjYCACADQgI3AgwgA0G0kcAANgIIIANBIjYCJCADIANBIGo2AhggAyADQQRqNgIoIAMgAzYCICADQQhqIAIQegALUQEEfwJAIAAEQCAAKAIADQEgAEEANgIAIAAoAhQhASAAKAIYIAAoAiAhAyAAKAIkIQQgABAQBEAgARAQCyAEBEAgAxAQCw8LEKgBAAsQqQEAC1EBBH8CQCAABEAgACgCAA0BIABBADYCACAAKAIUIQEgACgCGCAAKAIsIQMgACgCMCEEIAAQEARAIAEQEAsgBARAIAMQEAsPCxCoAQALEKkBAAtiAQN/AkAgAARAIAAoAgANASAAQQA2AgAgACgCCCECIAAoAgwhASAAKAIEIQMgABAQAkAgAxABRQ0AIAIgASgCABEEACABKAIERQ0AIAEoAggaIAIQEAsPCxCoAQALEKkBAAtUAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqIAJBCGoQHSACQSBqJAALZgECfwJAAkACQCABQQhqKAIAIgJBAE4EQCABKAIAIQMgAg0BQQEhAQwCCxB5AAsgAkEBEJoBIgFFDQELIAEgAyACELEBIQEgACACNgIIIAAgAjYCBCAAIAE2AgAPCyACQQEQrwEAC0sBAn8gAEEEaigCACAAQQhqIgMoAgAiAmtBAUkEQCAAIAJBARBKCyAAKAIAIgBBAWogACACEBcgACABQQEQsQEaIAMgAkEBajYCAAtPAQJ/IAAoAgAiA0EEaigCACADQQhqIgQoAgAiAGsgAkkEQCADIAAgAhBKIAQoAgAhAAsgAygCACAAaiABIAIQsQEaIAQgACACajYCAEEAC1EBAX8jAEEQayIEJAAgASgCACACKAIAIAMoAgAQBCEBIARBCGoQggEgBCgCDCECIAAgBCgCCCIDQQBHNgIAIAAgAiABIAMbNgIEIARBEGokAAtDAQN/AkAgAkUNAANAIAAtAAAiBCABLQAAIgVGBEAgAEEBaiEAIAFBAWohASACQX9qIgINAQwCCwsgBCAFayEDCyADC0wBAn8jAEEQayIDJAAgASgCACACKAIAEAIhASADQQhqEIIBIAMoAgwhAiAAIAMoAggiBEEARzYCACAAIAIgASAEGzYCBCADQRBqJAALSwACQAJ/IAFBgIDEAEcEQEEBIAAoAhggASAAQRxqKAIAKAIQEQAADQEaCyACDQFBAAsPCyAAKAIYIAJBACAAQRxqKAIAKAIMEQMACzoBAn8CQCAABEAgACgCAA0BIABBADYCACAAKAIUIQEgACgCGCAAEBAEQCABEBALDwsQqAEACxCpAQALRwEBfyMAQSBrIgMkACADQRRqQQA2AgAgA0HMjcAANgIQIANCATcCBCADIAE2AhwgAyAANgIYIAMgA0EYajYCACADIAIQegALRgECfyABKAIEIQIgASgCACEDQQhBBBCaASIBRQRAQQhBBBCvAQALIAEgAjYCBCABIAM2AgAgAEG0jMAANgIEIAAgATYCAAs5AQF/IAFBEHZAACECIABBADYCCCAAQQAgAUGAgHxxIAJBf0YiARs2AgQgAEEAIAJBEHQgARs2AgALaAEDfyMAQRBrIgEkACAAKAIMIgJFBEBBvIvAAEErQYSMwAAQdQALIAAoAggiA0UEQEG8i8AAQStBlIzAABB1AAsgASACNgIIIAEgADYCBCABIAM2AgAgASgCACABKAIEIAEoAggQWgALPwEBfyMAQSBrIgAkACAAQRxqQQA2AgAgAEGgjcAANgIYIABCATcCDCAAQbSNwAA2AgggAEEIakG8jcAAEHoACz4BAX8jAEEgayICJAAgAkEBOgAYIAIgATYCFCACIAA2AhAgAkHMjcAANgIMIAJBzI3AADYCCCACQQhqEHgACysAAkAgAEF8Sw0AIABFBEBBBA8LIAAgAEF9SUECdBCaASIARQ0AIAAPCwALKwACQCAABEAgACgCAA0BIABBADYCACAAQRBqIAE2AgAPCxCoAQALEKkBAAsoAAJAIAAEQCAAKAIAQX9GDQEgAEEsai0AAEEARw8LEKgBAAsQqQEACyUAAkAgAARAIAAoAgBBf0YNASAAQRBqKAIADwsQqAEACxCpAQALJwAgACAAKAIEQQFxIAFyQQJyNgIEIAAgAWoiACAAKAIEQQFyNgIECyMAAkAgAARAIAAoAgBBf0YNASAAKQMIuQ8LEKgBAAsQqQEACyYAAkAgAEUNACAAIAEoAgARBAAgASgCBEUNACABKAIIGiAAEBALCzoBAn9B4JHAAC0AACEBQeCRwABBADoAAEHkkcAAKAIAIQJB5JHAAEEANgIAIAAgAjYCBCAAIAE2AgALHgACQCAAQQRqKAIARQ0AIAAoAgAiAEUNACAAEBALCyABAX8CQCAAKAIEIgFFDQAgAEEIaigCAEUNACABEBALCx8AAkAgAUF8TQRAIAAgAUEEIAIQlgEiAA0BCwALIAALIwAgAiACKAIEQX5xNgIEIAAgAUEBcjYCBCAAIAFqIAE2AgALJQAgAEUEQEH0h8AAQTAQqgEACyAAIAIgAyAEIAUgASgCEBENAAsjACAARQRAQfSHwABBMBCqAQALIAAgAiADIAQgASgCEBETAAsjACAARQRAQfSHwABBMBCqAQALIAAgAiADIAQgASgCEBEKAAsjACAARQRAQfSHwABBMBCqAQALIAAgAiADIAQgASgCEBEGAAsjACAARQRAQfSHwABBMBCqAQALIAAgAiADIAQgASgCEBEVAAseACAAIAFBA3I2AgQgACABaiIAIAAoAgRBAXI2AgQLHQACQCAAKAIARQ0AIAAoAgQiAEEkSQ0AIAAQAAsLIQAgAEUEQEH0h8AAQTAQqgEACyAAIAIgAyABKAIQEQUACx8AIABFBEBBwobAAEEwEKoBAAsgACACIAEoAhARAQALHwAgAEUEQEHEh8AAQTAQqgEACyAAIAIgASgCEBEBAAsfACAARQRAQfSHwABBMBCqAQALIAAgAiABKAIQEQAACxkBAX8gACgCECIBBH8gAQUgAEEUaigCAAsLEgBBAEEZIABBAXZrIABBH0YbCxYAIAAgAUEBcjYCBCAAIAFqIAE2AgALEAAgACABakF/akEAIAFrcQsMACAAIAEgAiADEBYLCwAgAQRAIAAQEAsLDwAgAEEBdCIAQQAgAGtyCxQAIAAoAgAgASAAKAIEKAIMEQAACwgAIAAgARAlCxYAQeSRwAAgADYCAEHgkcAAQQE6AAALEwAgAEG0jMAANgIEIAAgATYCAAsNACAAKAIAIAEQL0EACw0AIAAtAARBAnFBAXYLEAAgASAAKAIAIAAoAgQQEQsKAEEAIABrIABxCwsAIAAtAARBA3FFCwwAIAAgAUEDcjYCBAsNACAAKAIAIAAoAgRqCw4AIAAoAgAaA0AMAAsACwsAIAA1AgAgARA3CwsAIAAjAGokACMACxwAIAEoAhhBv4bAAEEDIAFBHGooAgAoAgwRAwALDQBB0IrAAEEbEKoBAAsOAEHrisAAQc8AEKoBAAsJACAAIAEQBwALCgAgACgCBEF4cQsKACAAKAIEQQFxCwoAIAAoAgxBAXELCgAgACgCDEEBdgsZACAAIAFB6JHAACgCACIAQRUgABsRAQAACwoAIAAgASACEHELCgAgACABIAIQMgsHACAAIAFqCwcAIAAgAWsLBwAgAEEIagsHACAAQXhqCwwAQvbi+LHy4a/nBQsNAELRrpjEmYOy94R/CwwAQoG4qpP18+XsFAsDAAELAwABCwvLEQEAQYCAwAALwRFzcmMvYXNzZXQucnMAABAADAAAABQAAAAuAAAAAAAQAAwAAAAZAAAAUwAAAAAAEAAMAAAAOQAAAGQAAABOYU5HT0xPU0dCR0dFU1RTAAAQAAwAAACTAAAAFAAAAAAAAABhdHRlbXB0IHRvIGRpdmlkZSBieSB6ZXJvAAAAAAAAAGF0dGVtcHQgdG8gZGl2aWRlIHdpdGggb3ZlcmZsb3cAAAAQAAwAAACXAAAAFAAAAAAAEAAMAAAAmwAAABQAAABhdHRlbXB0IHRvIGNhbGN1bGF0ZSB0aGUgcmVtYWluZGVyIHdpdGggYSBkaXZpc29yIG9mIHplcm8AAAAAAAAAYXR0ZW1wdCB0byBjYWxjdWxhdGUgdGhlIHJlbWFpbmRlciB3aXRoIG92ZXJmbG93AAAQAAwAAACfAAAAFAAAAAAAEAAMAAAAqwAAABwAAABhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkoYXQpL3J1c3RjLzc3MzdlMGI1YzQxMDMyMTZkNmZkOGNmOTQxYjdhYjliZGJhYWNlN2MvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAAB7ARAASwAAAEIGAAAJAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUAAAEAAAAAAAAAAQAAAAIAAAABAAAAAAAAAAoAAAAAAAAAZAAAAAAAAADoAwAAAAAAABAnAAAAAAAAoIYBAAAAAABAQg8AAAAAAICWmAAAAAAAAOH1BQAAAAAAypo7AAAAAADkC1QCAAAAAOh2SBcAAAAAEKXU6AAAAACgck4YCQAAAEB6EPNaAABzcmMvZml4ZWRfdXRpbHMucnMAALgCEAASAAAAcQAAABAAAAC4AhAAEgAAAHwAAAAUAAAAuAIQABIAAAB9AAAAEwAAAAAAAABhdHRlbXB0IHRvIGRpdmlkZSBieSB6ZXJvAAAAAAAAAGF0dGVtcHQgdG8gZGl2aWRlIHdpdGggb3ZlcmZsb3dOYU5jbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgZGVzdHJveWVkIGFscmVhZHlXcm9uZyBrZXkgb3IgaXZDYW5ub3QgZGVjcnlwdCBkdGEAAwAAAAgAAAAEAAAABAAAAAUAAABGbk9uY2UgY2FsbGVkIG1vcmUgdGhhbiBvbmNlY2xvc3VyZSBpbnZva2VkIHJlY3Vyc2l2ZWx5IG9yIGRlc3Ryb3llZCBhbHJlYWR5Y2xvc3VyZSBpbnZva2VkIHJlY3Vyc2l2ZWx5IG9yIGRlc3Ryb3llZCBhbHJlYWR5L3Jvb3QvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvYmxvY2stcGFkZGluZy0wLjIuMS9zcmMvbGliLnJzJAQQAFQAAACwAAAAEwAAAC9yb290Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Flcy0wLjcuNS9zcmMvc29mdC9maXhzbGljZTMyLnJzAACIBBAAVgAAAOcAAAAjAAAAiAQQAFYAAADTAQAAGwAAAIgEEABWAAAA0wEAACcAAACIBBAAVgAAAOQBAAAkAAAAiAQQAFYAAAD5AQAAKAAAAIgEEABWAAAAkQQAABIAAACIBBAAVgAAAJEEAAA9AAAAbnVsbCBwb2ludGVyIHBhc3NlZCB0byBydXN0cmVjdXJzaXZlIHVzZSBvZiBhbiBvYmplY3QgZGV0ZWN0ZWQgd2hpY2ggd291bGQgbGVhZCB0byB1bnNhZmUgYWxpYXNpbmcgaW4gcnVzdAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWxpYnJhcnkvc3RkL3NyYy9wYW5pY2tpbmcucnMA5wUQABwAAABGAgAAHwAAAOcFEAAcAAAARwIAAB4AAAAWAAAADAAAAAQAAAAXAAAAGAAAAAgAAAAEAAAAGQAAABoAAAAQAAAABAAAABsAAAAcAAAAGAAAAAgAAAAEAAAAHQAAAB4AAAAYAAAABAAAAAQAAAAfAAAAIAAAACEAAABsaWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjLnJzY2FwYWNpdHkgb3ZlcmZsb3cAAACgBhAAEQAAAIQGEAAcAAAABgIAAAUAAAAmAAAAAAAAAAEAAAAnAAAAaW5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyAAANwGEAAgAAAA/AYQABIAAAA6IAAAzAYQAAAAAAAgBxAAAgAAADAwMDEwMjAzMDQwNTA2MDcwODA5MTAxMTEyMTMxNDE1MTYxNzE4MTkyMDIxMjIyMzI0MjUyNjI3MjgyOTMwMzEzMjMzMzQzNTM2MzczODM5NDA0MTQyNDM0NDQ1NDY0NzQ4NDk1MDUxNTI1MzU0NTU1NjU3NTg1OTYwNjE2MjYzNjQ2NTY2Njc2ODY5NzA3MTcyNzM3NDc1NzY3Nzc4Nzk4MDgxODI4Mzg0ODU4Njg3ODg4OTkwOTE5MjkzOTQ5NTk2OTc5ODk5bGlicmFyeS9jb3JlL3NyYy9zbGljZS9tZW1jaHIucnP8BxAAIAAAAFsAAAAFAAAAcmFuZ2Ugc3RhcnQgaW5kZXggIG91dCBvZiByYW5nZSBmb3Igc2xpY2Ugb2YgbGVuZ3RoICwIEAASAAAAPggQACIAAAByYW5nZSBlbmQgaW5kZXggcAgQABAAAAA+CBAAIgAAAHNsaWNlIGluZGV4IHN0YXJ0cyBhdCAgYnV0IGVuZHMgYXQgAJAIEAAWAAAApggQAA0Aewlwcm9kdWNlcnMCCGxhbmd1YWdlAQRSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuNjAuMCAoNzczN2UwYjVjIDIwMjItMDQtMDQpBndhbHJ1cwYwLjE5LjAMd2FzbS1iaW5kZ2VuEjAuMi43NiAoYTg4MWE4M2M1KQ==';
exports["default"] = _default;

/***/ }),

/***/ 3200:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

__webpack_require__(3144);

__webpack_require__(3201);

__webpack_require__(3042);

__webpack_require__(3083);

__webpack_require__(3145);

__webpack_require__(3160);

__webpack_require__(3163);

__webpack_require__(3164);

__webpack_require__(3166);

__webpack_require__(3170);

__webpack_require__(3171);

__webpack_require__(3172);

__webpack_require__(3173);

__webpack_require__(3174);

__webpack_require__(3175);

__webpack_require__(3176);

__webpack_require__(3177);

__webpack_require__(3179);

__webpack_require__(3180);

__webpack_require__(3182);

__webpack_require__(3183);

__webpack_require__(3184);

__webpack_require__(3185);

__webpack_require__(3186);

__webpack_require__(3187);

__webpack_require__(3192);

__webpack_require__(3193);

__webpack_require__(3194);

__webpack_require__(3078);

__webpack_require__(3076);

__webpack_require__(3202);

__webpack_require__(3065);

__webpack_require__(3090);

__webpack_require__(3066);

__webpack_require__(3203);

__webpack_require__(3118);

__webpack_require__(3052);

__webpack_require__(3054);

__webpack_require__(3205);

__webpack_require__(3211);

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var wasm_bindgen;

(function () {
  var __exports = {};
  var wasm;
  var heap = new Array(32).fill(undefined);
  heap.push(undefined, null, true, false);

  function getObject(idx) {
    return heap[idx];
  }

  var heap_next = heap.length;

  function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
  }

  function takeObject(idx) {
    var ret = getObject(idx);
    dropObject(idx);
    return ret;
  }

  var cachedTextDecoder = new TextDecoder('utf-8', {
    ignoreBOM: true,
    fatal: true
  });
  cachedTextDecoder.decode();
  var cachegetUint8Memory0 = null;

  function getUint8Memory0() {
    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
      cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }

    return cachegetUint8Memory0;
  }

  function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
  }

  function makeMutClosure(arg0, arg1, dtor, f) {
    var state = {
      a: arg0,
      b: arg1,
      cnt: 1,
      dtor: dtor
    };

    var real = function real() {
      // First up with a closure we increment the internal reference
      // count. This ensures that the Rust closure environment won't
      // be deallocated while we're invoking it.
      state.cnt++;
      var a = state.a;
      state.a = 0;

      try {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return f.apply(void 0, [a, state.b].concat(args));
      } finally {
        if (--state.cnt === 0) {
          wasm.__wbindgen_export_0.get(state.dtor)(a, state.b);
        } else {
          state.a = a;
        }
      }
    };

    real.original = state;
    return real;
  }

  function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    var idx = heap_next;
    heap_next = heap[idx];
    heap[idx] = obj;
    return idx;
  }

  function __wbg_adapter_10(arg0, arg1, arg2) {
    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hce2ed387aa1c2b69(arg0, arg1, addHeapObject(arg2));
  }

  var WASM_VECTOR_LEN = 0;
  var cachedTextEncoder = new TextEncoder('utf-8');
  var encodeString = typeof cachedTextEncoder.encodeInto === 'function' ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
  } : function (arg, view) {
    var buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
      read: arg.length,
      written: buf.length
    };
  };

  function passStringToWasm0(arg, malloc, realloc) {
    if (realloc === undefined) {
      var buf = cachedTextEncoder.encode(arg);

      var _ptr = malloc(buf.length);

      getUint8Memory0().subarray(_ptr, _ptr + buf.length).set(buf);
      WASM_VECTOR_LEN = buf.length;
      return _ptr;
    }

    var len = arg.length;
    var ptr = malloc(len);
    var mem = getUint8Memory0();
    var offset = 0;

    for (; offset < len; offset++) {
      var code = arg.charCodeAt(offset);
      if (code > 0x7F) break;
      mem[ptr + offset] = code;
    }

    if (offset !== len) {
      if (offset !== 0) {
        arg = arg.slice(offset);
      }

      ptr = realloc(ptr, len, len = offset + arg.length * 3);
      var view = getUint8Memory0().subarray(ptr + offset, ptr + len);
      var ret = encodeString(arg, view);
      offset += ret.written;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
  }

  var cachegetInt32Memory0 = null;

  function getInt32Memory0() {
    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
      cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }

    return cachegetInt32Memory0;
  }

  function isLikeNone(x) {
    return x === undefined || x === null;
  }

  function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
      throw new Error("expected instance of ".concat(klass.name));
    }

    return instance.ptr;
  }
  /**
  * @param {Function} get_dgp
  * @param {Function} callback
  * @returns {StreamingHandle}
  */


  __exports.stream_block_number = function (get_dgp, callback) {
    var ret = wasm.stream_block_number(addHeapObject(get_dgp), addHeapObject(callback));
    return StreamingHandle.__wrap(ret);
  };

  function passArray8ToWasm0(arg, malloc) {
    var ptr = malloc(arg.length * 1);
    getUint8Memory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
  }

  function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
  }
  /**
  * @param {Uint8Array} key
  * @param {Uint8Array} iv
  * @param {Uint8Array} data
  * @returns {Uint8Array}
  */


  __exports.aes256_decrypt = function (key, iv, data) {
    try {
      var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);

      var ptr0 = passArray8ToWasm0(key, wasm.__wbindgen_malloc);
      var len0 = WASM_VECTOR_LEN;
      var ptr1 = passArray8ToWasm0(iv, wasm.__wbindgen_malloc);
      var len1 = WASM_VECTOR_LEN;
      var ptr2 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
      var len2 = WASM_VECTOR_LEN;
      wasm.aes256_decrypt(retptr, ptr0, len0, ptr1, len1, ptr2, len2);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var v3 = getArrayU8FromWasm0(r0, r1).slice();

      wasm.__wbindgen_free(r0, r1 * 1);

      return v3;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  };

  function handleError(f, args) {
    try {
      return f.apply(this, args);
    } catch (e) {
      wasm.__wbindgen_exn_store(addHeapObject(e));
    }
  }
  /**
  */


  var StreamingHandle = /*#__PURE__*/function () {
    function StreamingHandle() {
      _classCallCheck(this, StreamingHandle);
    }

    _createClass(StreamingHandle, [{
      key: "__destroy_into_raw",
      value: function __destroy_into_raw() {
        var ptr = this.ptr;
        this.ptr = 0;
        return ptr;
      }
    }, {
      key: "free",
      value: function free() {
        var ptr = this.__destroy_into_raw();

        wasm.__wbg_streaminghandle_free(ptr);
      }
    }], [{
      key: "__wrap",
      value: function __wrap(ptr) {
        var obj = Object.create(StreamingHandle.prototype);
        obj.ptr = ptr;
        return obj;
      }
    }]);

    return StreamingHandle;
  }();

  __exports.StreamingHandle = StreamingHandle;
  /**
  */

  var _Asset = /*#__PURE__*/function () {
    function _Asset() {
      _classCallCheck(this, _Asset);
    }

    _createClass(_Asset, [{
      key: "__destroy_into_raw",
      value: function __destroy_into_raw() {
        var ptr = this.ptr;
        this.ptr = 0;
        return ptr;
      }
    }, {
      key: "free",
      value: function free() {
        var ptr = this.__destroy_into_raw();

        wasm.__wbg__asset_free(ptr);
      }
      /**
      * @param {string} value
      * @returns {_Asset}
      */

    }, {
      key: "clone",
      value:
      /**
      * @returns {_Asset}
      */
      function clone() {
        var ret = wasm._asset_clone(this.ptr);

        return _Asset.__wrap(ret);
      }
      /**
      * @returns {number}
      */

    }, {
      key: "amount",
      get: function get() {
        var ret = wasm._asset_amount(this.ptr);

        return ret;
      }
      /**
      * @param {number} value
      */
      ,
      set: function set(value) {
        wasm._asset_set_amount(this.ptr, value);
      }
      /**
      * @returns {string}
      */

    }, {
      key: "amountFloat",
      get: function get() {
        try {
          var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);

          wasm._asset_amount_float(retptr, this.ptr);

          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);

          wasm.__wbindgen_free(r0, r1);
        }
      }
      /**
      * @param {string} amount_str
      */
      ,
      set: function set(amount_str) {
        var ptr0 = passStringToWasm0(amount_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;

        wasm._asset_set_amount_float(this.ptr, ptr0, len0);
      }
      /**
      * @param {string} amount_str
      * @returns {string}
      */

    }, {
      key: "updateAmountFloat",
      value: function updateAmountFloat(amount_str) {
        try {
          var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);

          var ptr0 = passStringToWasm0(amount_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          var len0 = WASM_VECTOR_LEN;

          wasm._asset_updateAmountFloat(retptr, this.ptr, ptr0, len0);

          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);

          wasm.__wbindgen_free(r0, r1);
        }
      }
      /**
      * @returns {number}
      */

    }, {
      key: "precision",
      get: function get() {
        var ret = wasm._asset_precision(this.ptr);

        return ret >>> 0;
      }
      /**
      * @param {number} value
      */
      ,
      set: function set(value) {
        wasm._asset_set_precision(this.ptr, value);
      }
      /**
      * @returns {string}
      */

    }, {
      key: "symbol",
      get: function get() {
        try {
          var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);

          wasm._asset_symbol(retptr, this.ptr);

          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);

          wasm.__wbindgen_free(r0, r1);
        }
      }
      /**
      * @param {string} value
      */
      ,
      set: function set(value) {
        var ptr0 = passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;

        wasm._asset_set_symbol(this.ptr, ptr0, len0);
      }
      /**
      * @returns {boolean}
      */

    }, {
      key: "isUIA",
      get: function get() {
        var ret = wasm._asset_is_uia(this.ptr);

        return ret !== 0;
      }
      /**
      * @param {number | undefined} dec_places
      * @returns {string}
      */

    }, {
      key: "toString",
      value: function toString(dec_places) {
        try {
          var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);

          wasm._asset_toString(retptr, this.ptr, !isLikeNone(dec_places), isLikeNone(dec_places) ? 0 : dec_places);

          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);

          wasm.__wbindgen_free(r0, r1);
        }
      }
      /**
      * @returns {string}
      */

    }, {
      key: "floatString",
      get: function get() {
        try {
          var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);

          wasm._asset_float_string(retptr, this.ptr);

          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);

          wasm.__wbindgen_free(r0, r1);
        }
      }
      /**
      * @param {number} num
      * @returns {_Asset}
      */

    }, {
      key: "_plus_num",
      value: function _plus_num(num) {
        var ret = wasm._asset__plus_num(this.ptr, num);

        return _Asset.__wrap(ret);
      }
      /**
      * @param {_Asset} a
      * @returns {_Asset}
      */

    }, {
      key: "_plus",
      value: function _plus(a) {
        _assertClass(a, _Asset);

        var ret = wasm._asset__plus(this.ptr, a.ptr);

        return _Asset.__wrap(ret);
      }
      /**
      * @param {number} num
      * @returns {_Asset}
      */

    }, {
      key: "_minus_num",
      value: function _minus_num(num) {
        var ret = wasm._asset__minus_num(this.ptr, num);

        return _Asset.__wrap(ret);
      }
      /**
      * @param {_Asset} a
      * @returns {_Asset}
      */

    }, {
      key: "_minus",
      value: function _minus(a) {
        _assertClass(a, _Asset);

        var ret = wasm._asset__minus(this.ptr, a.ptr);

        return _Asset.__wrap(ret);
      }
      /**
      * @param {number} num
      * @returns {_Asset}
      */

    }, {
      key: "_mul_num",
      value: function _mul_num(num) {
        var ret = wasm._asset__mul_num(this.ptr, num);

        return _Asset.__wrap(ret);
      }
      /**
      * @param {_Asset} a
      * @returns {_Asset}
      */

    }, {
      key: "_mul",
      value: function _mul(a) {
        _assertClass(a, _Asset);

        var ret = wasm._asset__mul(this.ptr, a.ptr);

        return _Asset.__wrap(ret);
      }
      /**
      * @param {number} num
      * @returns {_Asset}
      */

    }, {
      key: "_div_num",
      value: function _div_num(num) {
        var ret = wasm._asset__div_num(this.ptr, num);

        return _Asset.__wrap(ret);
      }
      /**
      * @param {_Asset} a
      * @returns {_Asset}
      */

    }, {
      key: "_div",
      value: function _div(a) {
        _assertClass(a, _Asset);

        var ret = wasm._asset__div(this.ptr, a.ptr);

        return _Asset.__wrap(ret);
      }
      /**
      * @param {number} num
      * @returns {_Asset}
      */

    }, {
      key: "_mod_num",
      value: function _mod_num(num) {
        var ret = wasm._asset__mod_num(this.ptr, num);

        return _Asset.__wrap(ret);
      }
      /**
      * @param {_Asset} a
      * @returns {_Asset}
      */

    }, {
      key: "_mod",
      value: function _mod(a) {
        _assertClass(a, _Asset);

        var ret = wasm._asset__mod(this.ptr, a.ptr);

        return _Asset.__wrap(ret);
      }
      /**
      * @param {_Price} p
      * @param {_Asset} remain
      * @returns {_Asset}
      */

    }, {
      key: "_mul_price",
      value: function _mul_price(p, remain) {
        _assertClass(p, _Price);

        _assertClass(remain, _Asset);

        var ret = wasm._asset__mul_price(this.ptr, p.ptr, remain.ptr);

        return _Asset.__wrap(ret);
      }
      /**
      * @param {_Asset} a
      * @returns {boolean}
      */

    }, {
      key: "eq",
      value: function eq(a) {
        _assertClass(a, _Asset);

        var ret = wasm._asset_eq(this.ptr, a.ptr);

        return ret !== 0;
      }
      /**
      * @param {_Asset} a
      * @returns {boolean}
      */

    }, {
      key: "ne",
      value: function ne(a) {
        _assertClass(a, _Asset);

        var ret = wasm._asset_ne(this.ptr, a.ptr);

        return ret !== 0;
      }
      /**
      * @param {_Asset} a
      * @returns {boolean}
      */

    }, {
      key: "lt",
      value: function lt(a) {
        _assertClass(a, _Asset);

        var ret = wasm._asset_lt(this.ptr, a.ptr);

        return ret !== 0;
      }
      /**
      * @param {_Asset} a
      * @returns {boolean}
      */

    }, {
      key: "lte",
      value: function lte(a) {
        _assertClass(a, _Asset);

        var ret = wasm._asset_lte(this.ptr, a.ptr);

        return ret !== 0;
      }
      /**
      * @param {_Asset} a
      * @returns {boolean}
      */

    }, {
      key: "gt",
      value: function gt(a) {
        _assertClass(a, _Asset);

        var ret = wasm._asset_gt(this.ptr, a.ptr);

        return ret !== 0;
      }
      /**
      * @param {_Asset} a
      * @returns {boolean}
      */

    }, {
      key: "gte",
      value: function gte(a) {
        _assertClass(a, _Asset);

        var ret = wasm._asset_gte(this.ptr, a.ptr);

        return ret !== 0;
      }
      /**
      * @param {_Asset} a
      * @returns {_Asset}
      */

    }, {
      key: "min",
      value: function min(a) {
        _assertClass(a, _Asset);

        var ret = wasm._asset_min(this.ptr, a.ptr);

        return _Asset.__wrap(ret);
      }
      /**
      * @param {_Asset} a
      * @returns {_Asset}
      */

    }, {
      key: "max",
      value: function max(a) {
        _assertClass(a, _Asset);

        var ret = wasm._asset_max(this.ptr, a.ptr);

        return _Asset.__wrap(ret);
      }
    }], [{
      key: "__wrap",
      value: function __wrap(ptr) {
        var obj = Object.create(_Asset.prototype);
        obj.ptr = ptr;
        return obj;
      }
    }, {
      key: "fromString",
      value: function fromString(value) {
        var ptr0 = passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;

        var ret = wasm._asset_fromString(ptr0, len0);

        return _Asset.__wrap(ret);
      }
      /**
      * @param {number} amount
      * @param {number} precision
      * @param {string} symbol
      * @returns {_Asset}
      */

    }, {
      key: "new",
      value: function _new(amount, precision, symbol) {
        var ptr0 = passStringToWasm0(symbol, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;

        var ret = wasm._asset_new(amount, precision, ptr0, len0);

        return _Asset.__wrap(ret);
      }
    }]);

    return _Asset;
  }();

  __exports._Asset = _Asset;
  /**
  */

  var _AssetEditor = /*#__PURE__*/function () {
    function _AssetEditor() {
      _classCallCheck(this, _AssetEditor);
    }

    _createClass(_AssetEditor, [{
      key: "__destroy_into_raw",
      value: function __destroy_into_raw() {
        var ptr = this.ptr;
        this.ptr = 0;
        return ptr;
      }
    }, {
      key: "free",
      value: function free() {
        var ptr = this.__destroy_into_raw();

        wasm.__wbg__asseteditor_free(ptr);
      }
      /**
      * @param {_Asset} asset
      * @returns {_AssetEditor}
      */

    }, {
      key: "withChange",
      value:
      /**
      * @param {string} str
      * @returns {_AssetEditor}
      */
      function withChange(str) {
        var ptr0 = passStringToWasm0(str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;

        var ret = wasm._asseteditor_withChange(this.ptr, ptr0, len0);

        return _AssetEditor.__wrap(ret);
      }
      /**
      * @returns {_Asset}
      */

    }, {
      key: "asset",
      get: function get() {
        var ret = wasm._asseteditor_asset(this.ptr);

        return _Asset.__wrap(ret);
      }
      /**
      * @returns {string}
      */

    }, {
      key: "amountStr",
      get: function get() {
        try {
          var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);

          wasm._asseteditor_amount_str(retptr, this.ptr);

          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);

          wasm.__wbindgen_free(r0, r1);
        }
      }
      /**
      * @returns {boolean}
      */

    }, {
      key: "hasChange",
      get: function get() {
        var ret = wasm._asseteditor_has_change(this.ptr);

        return ret !== 0;
      }
    }], [{
      key: "__wrap",
      value: function __wrap(ptr) {
        var obj = Object.create(_AssetEditor.prototype);
        obj.ptr = ptr;
        return obj;
      }
    }, {
      key: "fromAsset",
      value: function fromAsset(asset) {
        _assertClass(asset, _Asset);

        var ret = wasm._asseteditor_fromAsset(asset.ptr);

        return _AssetEditor.__wrap(ret);
      }
      /**
      * @param {string} value
      * @returns {_AssetEditor}
      */

    }, {
      key: "fromString",
      value: function fromString(value) {
        var ptr0 = passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;

        var ret = wasm._asseteditor_fromString(ptr0, len0);

        return _AssetEditor.__wrap(ret);
      }
      /**
      * @param {number} amount
      * @param {number} precision
      * @param {string} symbol
      * @returns {_AssetEditor}
      */

    }, {
      key: "new",
      value: function _new(amount, precision, symbol) {
        var ptr0 = passStringToWasm0(symbol, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;

        var ret = wasm._asseteditor_new(amount, precision, ptr0, len0);

        return _AssetEditor.__wrap(ret);
      }
    }]);

    return _AssetEditor;
  }();

  __exports._AssetEditor = _AssetEditor;
  /**
  */

  var _Price = /*#__PURE__*/function () {
    function _Price() {
      _classCallCheck(this, _Price);
    }

    _createClass(_Price, [{
      key: "__destroy_into_raw",
      value: function __destroy_into_raw() {
        var ptr = this.ptr;
        this.ptr = 0;
        return ptr;
      }
    }, {
      key: "free",
      value: function free() {
        var ptr = this.__destroy_into_raw();

        wasm.__wbg__price_free(ptr);
      }
      /**
      * @param {_Asset} base
      * @param {_Asset} quote
      * @returns {_Price}
      */

    }, {
      key: "clone",
      value:
      /**
      * @returns {_Price}
      */
      function clone() {
        var ret = wasm._price_clone(this.ptr);

        return _Price.__wrap(ret);
      }
      /**
      * @returns {_Asset}
      */

    }, {
      key: "base",
      get: function get() {
        var ret = wasm._price_base(this.ptr);

        return _Asset.__wrap(ret);
      }
      /**
      * @param {_Asset} value
      */
      ,
      set: function set(value) {
        _assertClass(value, _Asset);

        wasm._price_set_base(this.ptr, value.ptr);
      }
      /**
      * @returns {_Asset}
      */

    }, {
      key: "quote",
      get: function get() {
        var ret = wasm._price_quote(this.ptr);

        return _Asset.__wrap(ret);
      }
      /**
      * @param {_Asset} value
      */
      ,
      set: function set(value) {
        _assertClass(value, _Asset);

        wasm._price_set_quote(this.ptr, value.ptr);
      }
    }], [{
      key: "__wrap",
      value: function __wrap(ptr) {
        var obj = Object.create(_Price.prototype);
        obj.ptr = ptr;
        return obj;
      }
    }, {
      key: "new",
      value: function _new(base, quote) {
        _assertClass(base, _Asset);

        _assertClass(quote, _Asset);

        var ret = wasm._price_new(base.ptr, quote.ptr);

        return _Price.__wrap(ret);
      }
    }]);

    return _Price;
  }();

  __exports._Price = _Price;

  function load(_x, _x2) {
    return _load.apply(this, arguments);
  }

  function _load() {
    _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(module, imports) {
      var bytes, instance;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(typeof Response === 'function' && module instanceof Response)) {
                _context.next = 23;
                break;
              }

              if (!(typeof WebAssembly.instantiateStreaming === 'function')) {
                _context.next = 15;
                break;
              }

              _context.prev = 2;
              _context.next = 5;
              return WebAssembly.instantiateStreaming(module, imports);

            case 5:
              return _context.abrupt("return", _context.sent);

            case 8:
              _context.prev = 8;
              _context.t0 = _context["catch"](2);

              if (!(module.headers.get('Content-Type') != 'application/wasm')) {
                _context.next = 14;
                break;
              }

              console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", _context.t0);
              _context.next = 15;
              break;

            case 14:
              throw _context.t0;

            case 15:
              _context.next = 17;
              return module.arrayBuffer();

            case 17:
              bytes = _context.sent;
              _context.next = 20;
              return WebAssembly.instantiate(bytes, imports);

            case 20:
              return _context.abrupt("return", _context.sent);

            case 23:
              _context.next = 25;
              return WebAssembly.instantiate(module, imports);

            case 25:
              instance = _context.sent;

              if (!(instance instanceof WebAssembly.Instance)) {
                _context.next = 30;
                break;
              }

              return _context.abrupt("return", {
                instance: instance,
                module: module
              });

            case 30:
              return _context.abrupt("return", instance);

            case 31:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[2, 8]]);
    }));
    return _load.apply(this, arguments);
  }

  function init(_x3) {
    return _init.apply(this, arguments);
  }

  function _init() {
    _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(input) {
      var src, imports, _yield$load, instance, module;

      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (typeof input === 'undefined') {
                if (typeof document === 'undefined') {
                  src = location.href;
                } else {
                  src = document.currentScript.src;
                }

                input = src.replace(/\.js$/, '_bg.wasm');
              }

              imports = {};
              imports.wbg = {};

              imports.wbg.__wbindgen_object_drop_ref = function (arg0) {
                takeObject(arg0);
              };

              imports.wbg.__wbindgen_cb_drop = function (arg0) {
                var obj = takeObject(arg0).original;

                if (obj.cnt-- == 1) {
                  obj.a = 0;
                  return true;
                }

                var ret = false;
                return ret;
              };

              imports.wbg.__wbg_call_e91f71ddf1f45cff = function () {
                return handleError(function (arg0, arg1) {
                  var ret = getObject(arg0).call(getObject(arg1));
                  return addHeapObject(ret);
                }, arguments);
              };

              imports.wbg.__wbg_new_80811dcb66d1b53f = function (arg0, arg1) {
                var ret = new Error(getStringFromWasm0(arg0, arg1));
                return addHeapObject(ret);
              };

              imports.wbg.__wbg_call_e3c72355d091d5d4 = function () {
                return handleError(function (arg0, arg1, arg2) {
                  var ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
                  return addHeapObject(ret);
                }, arguments);
              };

              imports.wbg.__wbg_instanceof_Promise_0fb5d7e26ca83626 = function (arg0) {
                var ret = getObject(arg0) instanceof Promise;
                return ret;
              };

              imports.wbg.__wbg_then_6d5072fec3fdb237 = function (arg0, arg1) {
                var ret = getObject(arg0).then(getObject(arg1));
                return addHeapObject(ret);
              };

              imports.wbg.__wbindgen_throw = function (arg0, arg1) {
                throw new Error(getStringFromWasm0(arg0, arg1));
              };

              imports.wbg.__wbindgen_rethrow = function (arg0) {
                throw takeObject(arg0);
              };

              imports.wbg.__wbindgen_closure_wrapper113 = function (arg0, arg1, arg2) {
                var ret = makeMutClosure(arg0, arg1, 7, __wbg_adapter_10);
                return addHeapObject(ret);
              };

              if (typeof input === 'string' || typeof Request === 'function' && input instanceof Request || typeof URL === 'function' && input instanceof URL) {
                input = fetch(input);
              }

              _context2.t0 = load;
              _context2.next = 17;
              return input;

            case 17:
              _context2.t1 = _context2.sent;
              _context2.t2 = imports;
              _context2.next = 21;
              return (0, _context2.t0)(_context2.t1, _context2.t2);

            case 21:
              _yield$load = _context2.sent;
              instance = _yield$load.instance;
              module = _yield$load.module;
              wasm = instance.exports;
              init.__wbindgen_wasm_module = module;
              return _context2.abrupt("return", wasm);

            case 27:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _init.apply(this, arguments);
  }

  wasm_bindgen = Object.assign(init, __exports);
})();

var _default = wasm_bindgen;
exports["default"] = _default;

/***/ }),

/***/ 3117:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];


__webpack_require__(3118);

__webpack_require__(3019);

__webpack_require__(3040);

__webpack_require__(3041);

__webpack_require__(3052);

__webpack_require__(3054);

__webpack_require__(3057);

__webpack_require__(3065);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.aes_decrypt = exports._Price = exports._AssetEditor = exports._Asset = exports.Price = exports.NativeLibContext = exports.AssetEditor = exports.Asset = void 0;
exports.assertNativeLib = assertNativeLib;
exports.importNativeLib = importNativeLib;
exports.importNativeLibCtx = importNativeLibCtx;
exports.isNativeLibLoaded = isNativeLibLoaded;
exports.unloadNativeLib = unloadNativeLib;

__webpack_require__(3144);

__webpack_require__(3042);

__webpack_require__(3083);

__webpack_require__(3145);

__webpack_require__(3160);

__webpack_require__(3163);

__webpack_require__(3164);

__webpack_require__(3166);

__webpack_require__(3170);

__webpack_require__(3171);

__webpack_require__(3172);

__webpack_require__(3173);

__webpack_require__(3174);

__webpack_require__(3175);

__webpack_require__(3176);

__webpack_require__(3177);

__webpack_require__(3179);

__webpack_require__(3180);

__webpack_require__(3182);

__webpack_require__(3183);

__webpack_require__(3184);

__webpack_require__(3185);

__webpack_require__(3186);

__webpack_require__(3187);

__webpack_require__(3192);

__webpack_require__(3193);

__webpack_require__(3194);

__webpack_require__(3089);

__webpack_require__(3066);

__webpack_require__(3072);

__webpack_require__(3195);

__webpack_require__(3078);

__webpack_require__(3076);

__webpack_require__(3196);

__webpack_require__(3197);

var _code = _interopRequireDefault(__webpack_require__(3199));

var _golos_lib = _interopRequireDefault(__webpack_require__(3200));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _Asset = _golos_lib.default._Asset,
    _AssetEditor = _golos_lib.default._AssetEditor,
    _Price = _golos_lib.default._Price,
    aes256_decrypt = _golos_lib.default.aes256_decrypt;
exports._Price = _Price;
exports._AssetEditor = _AssetEditor;
exports._Asset = _Asset;

var NativeLibContext = function NativeLibContext() {
  _classCallCheck(this, NativeLibContext);
};

exports.NativeLibContext = NativeLibContext;

var fromHexString = function fromHexString(str) {
  return new Uint8Array(str.match(/.{1,2}/g).map(function (byte) {
    return parseInt(byte, 16);
  }));
};

var fromBase64String = function fromBase64String(str) {
  if (typeof atob !== 'undefined') {
    return Uint8Array.from(atob(str), function (c) {
      return c.charCodeAt(0);
    });
  } else {
    return Buffer.from(str, 'base64');
  }
};

function importNativeLibCtx() {
  return _importNativeLibCtx.apply(this, arguments);
}

function _importNativeLibCtx() {
  _importNativeLibCtx = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var what;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(!_code.default || !_golos_lib.default || !_Asset)) {
              _context.next = 3;
              break;
            }

            what = !_code.default ? 'wasm code' : 'init()';
            throw new Error("Native golos-lib core is not included into this golos-lib-js library. There is no ".concat(what, "."));

          case 3:
            _context.next = 5;
            return (0, _golos_lib.default)(fromBase64String(_code.default));

          case 5:
            return _context.abrupt("return", new NativeLibContext());

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _importNativeLibCtx.apply(this, arguments);
}

var globalNativeCtx = null;

function importNativeLib() {
  return _importNativeLib.apply(this, arguments);
}

function _importNativeLib() {
  _importNativeLib = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!globalNativeCtx) {
              _context2.next = 2;
              break;
            }

            return _context2.abrupt("return", globalNativeCtx);

          case 2:
            _context2.next = 4;
            return importNativeLibCtx();

          case 4:
            globalNativeCtx = _context2.sent;
            return _context2.abrupt("return", globalNativeCtx);

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _importNativeLib.apply(this, arguments);
}

function unloadNativeLib() {
  globalNativeCtx = null;
}

function isNativeLibLoaded() {
  return !!globalNativeCtx;
}

function assertNativeLib(forWhat) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '0.9.0';

  if (!isNativeLibLoaded()) {
    throw new Error("Starting from ".concat(version, ", golos-lib-js requires \"await golos.importNativeLib()\" before calling ").concat(forWhat));
  }
}

function wrapNative(orig) {
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var hasContext = args[0] instanceof NativeLibContext;

    if (!hasContext && !isNativeLibLoaded()) {
      return importNativeLib().then(function () {
        return orig.apply(void 0, _toConsumableArray(args));
      });
    }

    if (hasContext) {
      args = args.slice(1, args.length);
    }

    return orig.apply(void 0, _toConsumableArray(args));
  };
}

var Asset = wrapNative(function (amount, precision, symbol) {
  var a = null;

  if (precision !== undefined && symbol) {
    a = _Asset.new(amount, precision, symbol);
  } else {
    var str = amount;
    a = _Asset.fromString(str);
  }

  var wrapBinOp = function wrapBinOp(op) {
    return function (asset2) {
      if (!(asset2 instanceof _Asset)) return this["_".concat(op, "_num")](asset2);
      return this["_".concat(op)](asset2);
    };
  };

  _Asset.prototype.plus = wrapBinOp('plus');
  _Asset.prototype.minus = wrapBinOp('minus');

  _Asset.prototype.mul = function (price, remainderAsset) {
    if (price instanceof _Price) {
      if (!remainderAsset) {
        remainderAsset = this.clone();
      }

      return this._mul_price(price, remainderAsset);
    }

    var asset2 = price;
    if (!(asset2 instanceof _Asset)) return this._mul_num(asset2);
    return this._mul(asset2);
  };

  _Asset.prototype.div = wrapBinOp('div');
  _Asset.prototype.mod = wrapBinOp('mod');

  _Asset.prototype.toJSON = function () {
    return this.toString();
  };

  return a;
});
exports.Asset = Asset;
var AssetEditor = wrapNative(function (amount, precision, symbol) {
  var ae = null;

  if (amount instanceof _Asset) {
    ae = _AssetEditor.fromAsset(amount);
  } else if (precision !== undefined && symbol) {
    ae = _AssetEditor.new(amount, precision, symbol);
  } else {
    var str = amount;
    ae = _AssetEditor.fromString(str);
  }

  _AssetEditor.prototype.toJSON = function () {
    return this.asset.toString();
  };

  _AssetEditor.prototype.toString = function () {
    return JSON.stringify({
      asset: this.asset,
      amount_str: this.amountStr
    });
  };

  return ae;
});
exports.AssetEditor = AssetEditor;
var Price = wrapNative(function (base, quote) {
  var pr = null;

  if (!quote) {
    pr = _Price.new(Asset(base.base), Asset(base.quote));
  } else {
    pr = _Price.new(base, quote);
  }

  _Price.prototype.toJSON = function () {
    return {
      base: this.base.toJSON(),
      quote: this.quote.toJSON()
    };
  };

  _Price.prototype.toString = function () {
    return this.toJSON().toString();
  };

  return pr;
});
exports.Price = Price;
var aes_decrypt = wrapNative(function (key, iv, data) {
  return aes256_decrypt(key, iv, data);
});
exports.aes_decrypt = aes_decrypt;

/***/ }),

/***/ 3331:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(3019);

__webpack_require__(3040);

__webpack_require__(3041);

__webpack_require__(3076);

__webpack_require__(3057);

__webpack_require__(3066);

__webpack_require__(3203);

__webpack_require__(3080);

__webpack_require__(3083);

__webpack_require__(3085);

__webpack_require__(3065);

__webpack_require__(3042);

__webpack_require__(3118);

__webpack_require__(3052);

__webpack_require__(3054);

__webpack_require__(3332);

var _get = _interopRequireDefault(__webpack_require__(1180));

var _ecc = __webpack_require__(3250);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

module.exports = function (steemAPI) {
  function numberWithCommas(x) {
    return x.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }

  function vestingGolos(account, gprops) {
    var vests = parseFloat(account.vesting_shares.split(" ")[0]);
    var total_vests = parseFloat(gprops.total_vesting_shares.split(" ")[0]);
    var total_vest_steem = parseFloat(gprops.total_vesting_fund_steem.split(" ")[0]);
    var vesting_steemf = total_vest_steem * (vests / total_vests);
    return vesting_steemf;
  }

  function processOrders(open_orders, assetPrecision) {
    var sbdOrders = !open_orders ? 0 : open_orders.reduce(function (o, order) {
      if (order.sell_price.base.indexOf("GBG") !== -1) {
        o += order.for_sale;
      }

      return o;
    }, 0) / assetPrecision;
    var steemOrders = !open_orders ? 0 : open_orders.reduce(function (o, order) {
      if (order.sell_price.base.indexOf("GOLOS") !== -1) {
        o += order.for_sale;
      }

      return o;
    }, 0) / assetPrecision;
    return {
      steemOrders: steemOrders,
      sbdOrders: sbdOrders
    };
  }

  function calculateSaving(savings_withdraws) {
    var savings_pending = 0;
    var savings_sbd_pending = 0;
    savings_withdraws.forEach(function (withdraw) {
      var _withdraw$amount$spli = withdraw.amount.split(" "),
          _withdraw$amount$spli2 = _slicedToArray(_withdraw$amount$spli, 2),
          amount = _withdraw$amount$spli2[0],
          asset = _withdraw$amount$spli2[1];

      if (asset === "GOLOS") savings_pending += parseFloat(amount);else {
        if (asset === "GBG") savings_sbd_pending += parseFloat(amount);
      }
    });
    return {
      savings_pending: savings_pending,
      savings_sbd_pending: savings_sbd_pending
    };
  }

  function estimateAccountValue(account) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        gprops = _ref.gprops,
        feed_price = _ref.feed_price,
        open_orders = _ref.open_orders,
        savings_withdraws = _ref.savings_withdraws,
        vesting_steem = _ref.vesting_steem;

    var promises = [];
    var username = account.name;
    var assetPrecision = 1000;
    var orders, savings;

    if (!vesting_steem || !feed_price) {
      if (!gprops || !feed_price) {
        promises.push(steemAPI.getStateAsync("/@{username}").then(function (data) {
          gprops = data.props;
          feed_price = data.feed_price;
          vesting_steem = vestingGolos(account, gprops);
        }));
      } else {
        vesting_steem = vestingGolos(account, gprops);
      }
    }

    if (!open_orders) {
      promises.push(steemAPI.getOpenOrdersAsync(username).then(function (open_orders) {
        orders = processOrders(open_orders, assetPrecision);
      }));
    } else {
      orders = processOrders(open_orders, assetPrecision);
    }

    if (!savings_withdraws) {
      promises.push(steemAPI.getSavingsWithdrawFromAsync(username).then(function (savings_withdraws) {
        savings = calculateSaving(savings_withdraws);
      }));
    } else {
      savings = calculateSaving(savings_withdraws);
    }

    return Promise.all(promises).then(function () {
      var price_per_steem = undefined;
      var _feed_price = feed_price,
          base = _feed_price.base,
          quote = _feed_price.quote;
      if (/ GBG$/.test(base) && / GOLOS$/.test(quote)) price_per_steem = parseFloat(base.split(" ")[0]);
      var savings_balance = account.savings_balance;
      var savings_sbd_balance = account.savings_sbd_balance;
      var balance_steem = parseFloat(account.balance.split(" ")[0]);
      var saving_balance_steem = parseFloat(savings_balance.split(" ")[0]);
      var sbd_balance = parseFloat(account.sbd_balance);
      var sbd_balance_savings = parseFloat(savings_sbd_balance.split(" ")[0]);
      var conversionValue = 0;
      var currentTime = new Date().getTime();
      (account.other_history || []).reduce(function (out, item) {
        if ((0, _get.default)(item, [1, "op", 0], "") !== "convert") return out;
        var timestamp = new Date((0, _get.default)(item, [1, "timestamp"])).getTime();
        var finishTime = timestamp + 86400000 * 3.5; // add 3.5day conversion delay

        if (finishTime < currentTime) return out;
        var amount = parseFloat((0, _get.default)(item, [1, "op", 1, "amount"]).replace(" GBG", ""));
        conversionValue += amount;
      }, []);
      var total_sbd = sbd_balance + sbd_balance_savings + savings.savings_sbd_pending + orders.sbdOrders + conversionValue;
      var total_steem = vesting_steem + balance_steem + saving_balance_steem + savings.savings_pending + orders.steemOrders;
      return (total_steem * price_per_steem + total_sbd).toFixed(2);
    });
  }

  function createSuggestedPassword() {
    var PASSWORD_LENGTH = 32;

    var privateKey = _ecc.key_utils.get_random_key();

    return privateKey.toWif().substring(3, 3 + PASSWORD_LENGTH);
  }

  return {
    reputation: function reputation(_reputation) {
      var withDecimal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (_reputation == null) return _reputation;
      _reputation = parseInt(_reputation);
      var rep = String(_reputation);
      var neg = rep.charAt(0) === "-";
      rep = neg ? rep.substring(1) : rep;
      var str = rep;
      var leadingDigits = parseInt(str.substring(0, 4));
      var log = Math.log(leadingDigits) / Math.LN10 + 0.00000001;
      var n = str.length - 1;
      var out = n + (log - parseInt(log));
      if (isNaN(out)) out = 0;
      out = Math.max(out - 9, 0);
      out = (neg ? -1 : 1) * out;
      out = out * 9 + (neg ? 0 : 25);
      if (neg && out === 0) out = -1;

      if (!withDecimal) {
        out = parseInt(out);
      }

      return out;
    },
    vestToGolos: function vestToGolos(vestingShares, totalVestingShares, totalVestingFundGolos) {
      return parseFloat(totalVestingFundGolos) * (parseFloat(vestingShares) / parseFloat(totalVestingShares));
    },
    commentPermlink: function commentPermlink(parentAuthor, parentPermlink) {
      var timeStr = new Date().toISOString().replace(/[^a-zA-Z0-9]+/g, "").toLowerCase();
      parentPermlink = parentPermlink.replace(/(-\d{8}t\d{9}z)/g, "");
      return "re-" + parentAuthor + "-" + parentPermlink + "-" + timeStr;
    },
    amount: function amount(_amount, asset) {
      return _amount.toFixed(3) + " " + asset;
    },
    numberWithCommas: numberWithCommas,
    vestingGolos: vestingGolos,
    estimateAccountValue: estimateAccountValue,
    createSuggestedPassword: createSuggestedPassword
  };
};

/***/ }),

/***/ 2941:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var api = __webpack_require__(2942);

var auth = __webpack_require__(3239);

var oauth = __webpack_require__(3319);

var middlewares = __webpack_require__(3323);

var broadcast = __webpack_require__(3328);

var formatter = __webpack_require__(3331)(api);

var memo = __webpack_require__(3336);

var messages = __webpack_require__(3339);

var config = __webpack_require__(3112);

var utils = __webpack_require__(3115);

var ecc = __webpack_require__(3250);

var _require = __webpack_require__(3117),
    importNativeLibCtx = _require.importNativeLibCtx,
    importNativeLib = _require.importNativeLib,
    isNativeLibLoaded = _require.isNativeLibLoaded,
    assertNativeLib = _require.assertNativeLib;

module.exports = {
  importNativeLibCtx: importNativeLibCtx,
  importNativeLib: importNativeLib,
  isNativeLibLoaded: isNativeLibLoaded,
  assertNativeLib: assertNativeLib,
  api: api,
  auth: auth,
  oauth: oauth,
  broadcast: broadcast,
  formatter: formatter,
  memo: memo,
  messages: messages,
  middlewares: middlewares,
  config: config,
  use: middlewares.use,
  utils: utils,
  ecc: ecc
};

/***/ }),

/***/ 3324:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(3083);

__webpack_require__(3118);

__webpack_require__(3144);

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var EmptyMiddleware = /*#__PURE__*/function () {
  function EmptyMiddleware() {
    _classCallCheck(this, EmptyMiddleware);
  }

  _createClass(EmptyMiddleware, [{
    key: "broadcast",
    value: function () {
      var _broadcast = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
        var tx, privKeys, orig;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                tx = _ref.tx, privKeys = _ref.privKeys, orig = _ref.orig;
                _context.next = 3;
                return orig(tx);

              case 3:
                return _context.abrupt("return", _context.sent);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function broadcast(_x) {
        return _broadcast.apply(this, arguments);
      }

      return broadcast;
    }()
  }]);

  return EmptyMiddleware;
}();

module.exports = EmptyMiddleware;

/***/ }),

/***/ 3325:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

__webpack_require__(2943);

__webpack_require__(3326);

__webpack_require__(3228);

__webpack_require__(3118);

__webpack_require__(3019);

__webpack_require__(3040);

__webpack_require__(3041);

__webpack_require__(3144);

__webpack_require__(3042);

__webpack_require__(3083);

__webpack_require__(3052);

__webpack_require__(3054);

__webpack_require__(3205);

__webpack_require__(3211);

__webpack_require__(3197);

__webpack_require__(3065);

__webpack_require__(3088);

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var EmptyMiddleware = __webpack_require__(3324);

var oauth = __webpack_require__(3319);

var _require = __webpack_require__(3115),
    delay = _require.delay;

var _require2 = __webpack_require__(3236),
    RPCError = _require2.RPCError;

var OAuthMiddleware = /*#__PURE__*/function (_EmptyMiddleware) {
  _inherits(OAuthMiddleware, _EmptyMiddleware);

  var _super = _createSuper(OAuthMiddleware);

  function OAuthMiddleware() {
    _classCallCheck(this, OAuthMiddleware);

    return _super.apply(this, arguments);
  }

  _createClass(OAuthMiddleware, [{
    key: "_checkPendingAllowed",
    value: function _checkPendingAllowed(tx) {
      var url = new URL('/api/oauth/check/' + oauth.clientId(), oauth.apiHost());
      var xhr = new XMLHttpRequest();
      xhr.open('POST', url.toString(), false);
      xhr.withCredentials = true;
      xhr.send(JSON.stringify({
        tx: tx
      }));
      var res = JSON.parse(xhr.responseText);
      var requiredPerms = res.requiredPerms;
      var ret = {
        allowed: true
      };

      if (requiredPerms && requiredPerms.length) {
        ret.allowed = false;
        ret.txHash = oauth._hashOps(tx.operations);
        ret.win = oauth.login([], '?ops_hash=' + ret.txHash);
      }

      return ret;
    }
  }, {
    key: "_preparePending",
    value: function () {
      var _preparePending2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(tx, txHash) {
        var res;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return oauth._callApi('/api/oauth/prepare_pending', {
                  tx: tx,
                  txHash: txHash
                });

              case 2:
                res = _context.sent;
                _context.next = 5;
                return res.json();

              case 5:
                res = _context.sent;

                if (!(res.status === 'ok')) {
                  _context.next = 10;
                  break;
                }

                return _context.abrupt("return");

              case 10:
                if (!res.error) {
                  _context.next = 14;
                  break;
                }

                throw new Error(json.error);

              case 14:
                throw new Error('Internal Server Error');

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function _preparePending(_x, _x2) {
        return _preparePending2.apply(this, arguments);
      }

      return _preparePending;
    }()
  }, {
    key: "_waitForPending",
    value: function () {
      var _waitForPending2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(txHash) {
        var interval, max, loop;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                interval = 2 * 1000;
                max = interval * 30;

                loop = /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                    var waited,
                        res,
                        json,
                        forbidden,
                        err,
                        _res,
                        _args2 = arguments;

                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            waited = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 0;
                            _context2.next = 3;
                            return delay(interval);

                          case 3:
                            _context2.next = 5;
                            return oauth._callApi('/api/oauth/wait_for_pending/' + txHash);

                          case 5:
                            res = _context2.sent;
                            _context2.next = 8;
                            return res.json();

                          case 8:
                            json = _context2.sent;

                            if (!(json.status === 'ok')) {
                              _context2.next = 16;
                              break;
                            }

                            forbidden = json.forbidden, err = json.err, _res = json.res;

                            if (!forbidden) {
                              _context2.next = 13;
                              break;
                            }

                            throw new Error('Transaction forbidden');

                          case 13:
                            return _context2.abrupt("return", {
                              err: err,
                              res: _res
                            });

                          case 16:
                            waited += interval;

                            if (!(waited >= max)) {
                              _context2.next = 21;
                              break;
                            }

                            throw new Error('Transaction timeouted');

                          case 21:
                            _context2.next = 23;
                            return loop(waited);

                          case 23:
                            return _context2.abrupt("return", _context2.sent);

                          case 24:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function loop() {
                    return _ref.apply(this, arguments);
                  };
                }();

                _context3.next = 5;
                return loop();

              case 5:
                return _context3.abrupt("return", _context3.sent);

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function _waitForPending(_x3) {
        return _waitForPending2.apply(this, arguments);
      }

      return _waitForPending;
    }()
  }, {
    key: "_processPending",
    value: function () {
      var _processPending2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(tx) {
        var _this$_checkPendingAl, allowed, win, txHash, closeWin, res, err, result;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _this$_checkPendingAl = this._checkPendingAllowed(tx), allowed = _this$_checkPendingAl.allowed, win = _this$_checkPendingAl.win, txHash = _this$_checkPendingAl.txHash;

                if (allowed) {
                  _context4.next = 29;
                  break;
                }

                closeWin = function closeWin() {
                  if (win && !win.closed) {
                    win.close();
                  }

                  ;
                };

                _context4.prev = 3;
                _context4.next = 6;
                return this._preparePending(tx, txHash);

              case 6:
                _context4.next = 13;
                break;

              case 8:
                _context4.prev = 8;
                _context4.t0 = _context4["catch"](3);
                console.error('_preparePending', _context4.t0);
                closeWin();
                throw _context4.t0;

              case 13:
                _context4.prev = 13;
                _context4.next = 16;
                return this._waitForPending(txHash);

              case 16:
                result = _context4.sent;
                res = result.res;
                err = result.err;
                _context4.next = 26;
                break;

              case 21:
                _context4.prev = 21;
                _context4.t1 = _context4["catch"](13);
                console.error('_waitForPending', _context4.t1);
                closeWin();
                throw _context4.t1;

              case 26:
                return _context4.abrupt("return", {
                  broadcast: false,
                  res: res,
                  err: err
                });

              case 29:
                return _context4.abrupt("return", {
                  broadcast: true
                });

              case 30:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[3, 8], [13, 21]]);
      }));

      function _processPending(_x4) {
        return _processPending2.apply(this, arguments);
      }

      return _processPending;
    }()
  }, {
    key: "broadcast",
    value: function () {
      var _broadcast = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_ref2) {
        var tx, privKeys, orig, result, _result, err, t;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                tx = _ref2.tx, privKeys = _ref2.privKeys, orig = _ref2.orig;
                result = {
                  broadcast: true
                };

                if (!(tx._meta && tx._meta._keys)) {
                  _context5.next = 6;
                  break;
                }

                _context5.next = 5;
                return this._processPending(tx);

              case 5:
                result = _context5.sent;

              case 6:
                if (!result.broadcast) {
                  _context5.next = 12;
                  break;
                }

                _context5.next = 9;
                return _get(_getPrototypeOf(OAuthMiddleware.prototype), "broadcast", this).call(this, {
                  tx: tx,
                  privKeys: privKeys,
                  orig: orig
                });

              case 9:
                return _context5.abrupt("return", _context5.sent);

              case 12:
                if (!result.res) {
                  _context5.next = 14;
                  break;
                }

                return _context5.abrupt("return", result.res);

              case 14:
                _result = result, err = _result.err; // http

                if (!(err && err.name === 'RPCError')) {
                  _context5.next = 17;
                  break;
                }

                throw new RPCError(err, err);

              case 17:
                if (!(err && err.message)) {
                  _context5.next = 21;
                  break;
                }

                t = new Error(err.message);
                t.payload = err.payload;
                throw t;

              case 21:
                console.error('OAuthMiddleware broadcast', err);

              case 22:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function broadcast(_x5) {
        return _broadcast.apply(this, arguments);
      }

      return broadcast;
    }()
  }]);

  return OAuthMiddleware;
}(EmptyMiddleware);

module.exports = OAuthMiddleware;

/***/ }),

/***/ 3323:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var EmptyMiddleware = __webpack_require__(3324);

var OAuthMiddleware = __webpack_require__(3325);

var current = new EmptyMiddleware();

function use(middleware) {
  current = middleware;
}

function mw() {
  return current;
}

module.exports = {
  EmptyMiddleware: EmptyMiddleware,
  OAuthMiddleware: OAuthMiddleware,
  use: use,
  mw: mw
};

/***/ }),

/***/ 3319:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(3118);

__webpack_require__(3144);

__webpack_require__(3320);

__webpack_require__(3042);

__webpack_require__(3083);

__webpack_require__(3052);

__webpack_require__(3054);

__webpack_require__(3205);

__webpack_require__(3211);

__webpack_require__(3242);

var _debug = _interopRequireDefault(__webpack_require__(3110));

var _config = _interopRequireDefault(__webpack_require__(3112));

var _ecc = __webpack_require__(3250);

var _fetchEx = _interopRequireDefault(__webpack_require__(3214));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _apiHost;

var _uiHost;

var _clientId;

var debug = (0, _debug.default)('golos:oauth');

function apiHost() {
  if (_apiHost) return _apiHost;
  var KEY = 'oauth.host';

  var host = _config.default.get(KEY);

  if (!host) throw new Error(KEY + ' is not set in golos.config');
  if (!host.startsWith('http://') && !host.startsWith('https://')) host = 'https://' + host;

  try {
    _apiHost = new URL(host).origin;
  } catch (err) {
    throw new Error(KEY + ' cannot be parsed as URL: ' + host);
  }

  return _apiHost;
}

function uiHost() {
  if (_uiHost) return _uiHost;
  var KEY = 'oauth.ui_host';

  var host = _config.default.get(KEY);

  if (!host) {
    _uiHost = apiHost();
    return _uiHost;
  }

  if (!host.startsWith('http://') && !host.startsWith('https://')) host = 'https://' + host;

  try {
    _uiHost = new URL(host).origin;
  } catch (err) {
    throw new Error(KEY + ' cannot be parsed as URL: ' + host);
  }

  return _uiHost;
}

function clientId() {
  if (_clientId) return _clientId;
  var KEY = 'oauth.client';

  var client = _config.default.get(KEY);

  if (!client) throw new Error(KEY + ' is not set in golos.config');
  _clientId = client;
  return _clientId;
}

function _callApi(url, data) {
  var getHost = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : apiHost;
  var request = {
    method: data ? 'post' : 'get',
    credentials: 'include',
    headers: {
      Accept: 'application/json',
      'Content-type': data ? 'application/json' : undefined
    },
    body: data ? JSON.stringify(data) : undefined
  };
  return (0, _fetchEx.default)(new URL(url, getHost()), request);
}

function check() {
  return _check.apply(this, arguments);
}

function _check() {
  _check = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var res;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return _callApi('/api/oauth/check/' + clientId());

          case 2:
            res = _context.sent;
            _context.next = 5;
            return res.json();

          case 5:
            return _context.abrupt("return", _context.sent);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _check.apply(this, arguments);
}

function checkReliable() {
  return _checkReliable.apply(this, arguments);
}

function _checkReliable() {
  _checkReliable = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
    var onError,
        retry,
        res,
        _args2 = arguments;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            onError = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : undefined;
            retry = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 1;
            res = null;
            _context2.prev = 3;
            _context2.next = 6;
            return check();

          case 6:
            res = _context2.sent;
            return _context2.abrupt("return", res);

          case 10:
            _context2.prev = 10;
            _context2.t0 = _context2["catch"](3);

            if (!(onError && onError({
              retry: retry
            }))) {
              _context2.next = 14;
              break;
            }

            throw _context2.t0;

          case 14:
            if (!onError) console.error('oauth.check error:', _context2.t0, 'retrying...');
            setTimeout(function () {
              checkReliable(onError, ++retry);
            }, 3000);

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 10]]);
  }));
  return _checkReliable.apply(this, arguments);
}

function waitForLogin(_x, _x2) {
  return _waitForLogin.apply(this, arguments);
}

function _waitForLogin() {
  _waitForLogin = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(onFinish, onFail) {
    var retries,
        onRetry,
        res,
        _args3 = arguments;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            retries = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : 180;
            onRetry = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : undefined;

            if (retries) {
              _context3.next = 6;
              break;
            }

            console.error('waiting for login is timeouted');
            onFail();
            return _context3.abrupt("return");

          case 6:
            _context3.next = 8;
            return checkReliable();

          case 8:
            res = _context3.sent;

            if (!res.authorized) {
              _context3.next = 13;
              break;
            }

            onFinish(res);
            _context3.next = 18;
            break;

          case 13:
            if (!(onRetry && onRetry({
              retriesLeft: retries
            }))) {
              _context3.next = 16;
              break;
            }

            onFail();
            return _context3.abrupt("return");

          case 16:
            debug('waiting for login...');
            setTimeout(function () {
              waitForLogin(onFinish, onFail, --retries, onRetry);
            }, 1000);

          case 18:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _waitForLogin.apply(this, arguments);
}

function login() {
  var permissions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var extraParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  if (typeof window === 'undefined') {
    throw new Error('OAuth works only in browser environment (window should be defined)');
  }

  return window.open(uiHost() + '/oauth/' + clientId() + '/' + permissions.join(',') + extraParams);
}

function logout() {
  return _logout.apply(this, arguments);
}

function _logout() {
  _logout = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
    var res;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return _callApi('/api/oauth/logout/' + clientId());

          case 2:
            res = _context4.sent;

          case 3:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _logout.apply(this, arguments);
}

function _hashOps(operations) {
  var json = JSON.stringify(operations);

  var idHash = _ecc.hash.sha256(json, 'hex');

  return idHash;
}

module.exports = {
  clientId: clientId,
  apiHost: apiHost,
  uiHost: uiHost,
  _callApi: _callApi,
  check: check,
  checkReliable: checkReliable,
  login: login,
  waitForLogin: waitForLogin,
  logout: logout,
  _hashOps: _hashOps
};

/***/ }),

/***/ 3218:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(3076);

__webpack_require__(3057);

__webpack_require__(3066);

__webpack_require__(3019);

__webpack_require__(3040);

__webpack_require__(3041);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.nodeify = nodeify;
exports.promisify = promisify;
exports.promisifyAll = promisifyAll;

__webpack_require__(3065);

__webpack_require__(3083);

__webpack_require__(3118);

__webpack_require__(3078);

__webpack_require__(3219);

__webpack_require__(3042);

__webpack_require__(3220);

__webpack_require__(3052);

__webpack_require__(3054);

__webpack_require__(3228);

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PromiseError = function PromiseError(error) {
  _classCallCheck(this, PromiseError);

  this.cause = error;
  this.message = error.message;
  this.name = error.name || 'Error';
  if (error.payload) this.payload = error.payload;
  this.stack = error.stack;
};

function promisify(fn) {
  return function () {
    var _this = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new Promise(function (resolve, reject) {
      fn.call.apply(fn, [_this].concat(args, [function (err, res) {
        if (err) reject(err);else resolve(res);
      }]));
    });
  };
}

function promisifyAll(obj) {
  var suffix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Async';
  var keys = Object.getOwnPropertyNames(obj);
  var ret = new Set();

  var _iterator = _createForOfIteratorHelper(keys),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var key = _step.value;
      if (key === 'constructor') continue;
      var desc = Object.getOwnPropertyDescriptor(obj, key);

      if (desc != null && desc.get == null && desc.set == null) {
        ret.add(key);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var _iterator2 = _createForOfIteratorHelper(ret),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _key2 = _step2.value;
      obj[_key2 + suffix] = promisify(obj[_key2]);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
}

function nodeify(promise, callback) {
  return promise.then(function (res) {
    if (callback) callback(null, res);
    return res;
  }).catch(function (err) {
    if (callback) callback(err, null);else throw err;
  });
}

/***/ }),

/***/ 3116:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Asset", ({
  enumerable: true,
  get: function get() {
    return _core.Asset;
  }
}));
Object.defineProperty(exports, "AssetEditor", ({
  enumerable: true,
  get: function get() {
    return _core.AssetEditor;
  }
}));
Object.defineProperty(exports, "Price", ({
  enumerable: true,
  get: function get() {
    return _core.Price;
  }
}));
Object.defineProperty(exports, "_Asset", ({
  enumerable: true,
  get: function get() {
    return _core._Asset;
  }
}));
Object.defineProperty(exports, "_AssetEditor", ({
  enumerable: true,
  get: function get() {
    return _core._AssetEditor;
  }
}));
Object.defineProperty(exports, "_Price", ({
  enumerable: true,
  get: function get() {
    return _core._Price;
  }
}));

var _core = __webpack_require__(3117);

/***/ }),

/***/ 3214:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(3215);

__webpack_require__(3019);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

__webpack_require__(3144);

__webpack_require__(3083);

__webpack_require__(3118);

var _crossFetch = _interopRequireDefault(__webpack_require__(3216));

var _abortController = _interopRequireDefault(__webpack_require__(3217));

var _excluded = ["timeout"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var COMMON_TIMEOUT = 10000;

function fetchEx(_x, _x2) {
  return _fetchEx.apply(this, arguments);
}

function _fetchEx() {
  _fetchEx = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(url, opts) {
    var timeout, restOpts, controller;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            timeout = opts.timeout, restOpts = _objectWithoutProperties(opts, _excluded);

            if (!restOpts.signal) {
              if (timeout === 0 || timeout === undefined) {
                timeout = COMMON_TIMEOUT;
              }

              if (timeout !== null) {
                controller = new _abortController.default();
                setTimeout(function () {
                  return controller.abort();
                }, timeout);
                restOpts.signal = controller.signal;
              }
            }

            _context.next = 4;
            return (0, _crossFetch.default)(url, restOpts);

          case 4:
            return _context.abrupt("return", _context.sent);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _fetchEx.apply(this, arguments);
}

fetchEx.COMMON_TIMEOUT = COMMON_TIMEOUT;
fetchEx.AbortController = _abortController.default;
var _default = fetchEx;
exports["default"] = _default;

/***/ }),

/***/ 3115:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Asset", ({
  enumerable: true,
  get: function get() {
    return _Asset.Asset;
  }
}));
Object.defineProperty(exports, "AssetEditor", ({
  enumerable: true,
  get: function get() {
    return _Asset.AssetEditor;
  }
}));
Object.defineProperty(exports, "Price", ({
  enumerable: true,
  get: function get() {
    return _Asset.Price;
  }
}));
Object.defineProperty(exports, "_Asset", ({
  enumerable: true,
  get: function get() {
    return _Asset._Asset;
  }
}));
Object.defineProperty(exports, "_AssetEditor", ({
  enumerable: true,
  get: function get() {
    return _Asset._AssetEditor;
  }
}));
Object.defineProperty(exports, "_Price", ({
  enumerable: true,
  get: function get() {
    return _Asset._Price;
  }
}));
Object.defineProperty(exports, "camelCase", ({
  enumerable: true,
  get: function get() {
    return _misc.camelCase;
  }
}));
Object.defineProperty(exports, "delay", ({
  enumerable: true,
  get: function get() {
    return _misc.delay;
  }
}));
Object.defineProperty(exports, "fetchEx", ({
  enumerable: true,
  get: function get() {
    return _fetchEx.default;
  }
}));
Object.defineProperty(exports, "fitImageToSize", ({
  enumerable: true,
  get: function get() {
    return _misc.fitImageToSize;
  }
}));
Object.defineProperty(exports, "validateAccountName", ({
  enumerable: true,
  get: function get() {
    return _misc.validateAccountName;
  }
}));

var _Asset = __webpack_require__(3116);

var _misc = __webpack_require__(3213);

var _fetchEx = _interopRequireDefault(__webpack_require__(3214));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ 3213:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.camelCase = camelCase;
exports.delay = delay;
exports.fitImageToSize = fitImageToSize;
exports.validateAccountName = validateAccountName;

__webpack_require__(3144);

__webpack_require__(3066);

__webpack_require__(3203);

__webpack_require__(3080);

__webpack_require__(3083);

__webpack_require__(3118);

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function delay(_x) {
  return _delay.apply(this, arguments);
}

function _delay() {
  _delay = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(msec) {
    var getTimeoutId,
        _args = arguments;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            getTimeoutId = _args.length > 1 && _args[1] !== undefined ? _args[1] : undefined;
            _context.next = 3;
            return new Promise(function (resolve, reject) {
              var id = setTimeout(resolve, msec);
              if (getTimeoutId) getTimeoutId(id);
            });

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _delay.apply(this, arguments);
}

var snakeCaseRe = /_([a-z])/g;

function camelCase(str) {
  return str.replace(snakeCaseRe, function (_m, l) {
    return l.toUpperCase();
  });
}

function validateAccountName(value) {
  var i, label, len, suffix;
  var res = {
    error: null,
    msg: ''
  };
  suffix = "Account name should ";

  if (!value) {
    res.msg = suffix + "not be empty.";
    res.error = 'account_name_should_not_be_empty';
    return res;
  }

  var length = value.length;

  if (length < 3) {
    res.msg = suffix + "be longer.";
    res.error = 'account_name_should_be_longer';
    return res;
  }

  if (length > 16) {
    res.msg = suffix + "be shorter.";
    res.error = 'account_name_should_be_shorter';
    return res;
  }

  if (/\./.test(value)) {
    suffix = "Each account segment should ";
  }

  var ref = value.split(".");

  for (i = 0, len = ref.length; i < len; i++) {
    label = ref[i];

    if (!/^[a-z]/.test(label)) {
      res.msg = suffix + "start with a letter.";
      res.error = 'each_account_segment_should_start_with_a_letter';
      return res;
    }

    if (!/^[a-z0-9-]*$/.test(label)) {
      res.msg = suffix + "have only letters, digits, or dashes.";
      res.error = 'each_account_segment_should_have_only_letters_digits_or_dashes';
      return res;
    }

    if (/--/.test(label)) {
      res.msg = suffix + "have only one dash in a row.";
      res.error = 'each_account_segment_should_have_only_one_dash_in_a_row';
      return res;
    }

    if (!/[a-z0-9]$/.test(label)) {
      res.msg = suffix + "end with a letter or digit.";
      res.error = 'each_account_segment_should_end_with_a_letter_or_digit';
      return res;
    }

    if (!(label.length >= 3)) {
      res.msg = suffix + "be longer";
      res.error = 'each_account_segment_should_be_longer';
      return res;
    }
  }

  return res;
}

function fitImageToSize(width, height, goodWidth, goodHeight) {
  var overWidth = width / goodWidth;
  var overHeight = height / goodHeight;

  if (overWidth <= 1 && overHeight <= 1) {
    return {
      width: width,
      height: height
    };
  }

  var proportion = width / height;

  if (overWidth > overHeight) {
    width = goodWidth;
    height = Math.round(width / proportion);
  } else {
    height = goodHeight;
    width = Math.round(height * proportion);
  }

  return {
    width: width,
    height: height
  };
}

/***/ }),

/***/ 3252:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(454)["process"];
// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = __webpack_require__(3253),
    _require$codes = _require.codes,
    ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,
    ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;

var AssertionError = __webpack_require__(3267);

var _require2 = __webpack_require__(3254),
    inspect = _require2.inspect;

var _require$types = (__webpack_require__(3254).types),
    isPromise = _require$types.isPromise,
    isRegExp = _require$types.isRegExp;

var objectAssign = Object.assign ? Object.assign : (__webpack_require__(3268).assign);
var objectIs = Object.is ? Object.is : __webpack_require__(3269);
var errorCache = new Map();
var isDeepEqual;
var isDeepStrictEqual;
var parseExpressionAt;
var findNodeAround;
var decoder;

function lazyLoadComparison() {
  var comparison = __webpack_require__(3273);

  isDeepEqual = comparison.isDeepEqual;
  isDeepStrictEqual = comparison.isDeepStrictEqual;
} // Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex


var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
var meta = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", '\\b', '', '', "\\u000b", '\\f', '', "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f"];

var escapeFn = function escapeFn(str) {
  return meta[str.charCodeAt(0)];
};

var warned = false; // The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;
var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function innerFail(obj) {
  if (obj.message instanceof Error) throw obj.message;
  throw new AssertionError(obj);
}

function fail(actual, expected, message, operator, stackStartFn) {
  var argsLen = arguments.length;
  var internalMessage;

  if (argsLen === 0) {
    internalMessage = 'Failed';
  } else if (argsLen === 1) {
    message = actual;
    actual = undefined;
  } else {
    if (warned === false) {
      warned = true;
      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
    }

    if (argsLen === 2) operator = '!=';
  }

  if (message instanceof Error) throw message;
  var errArgs = {
    actual: actual,
    expected: expected,
    operator: operator === undefined ? 'fail' : operator,
    stackStartFn: stackStartFn || fail
  };

  if (message !== undefined) {
    errArgs.message = message;
  }

  var err = new AssertionError(errArgs);

  if (internalMessage) {
    err.message = internalMessage;
    err.generatedMessage = true;
  }

  throw err;
}

assert.fail = fail; // The AssertionError is defined in internal/error.

assert.AssertionError = AssertionError;

function innerOk(fn, argLen, value, message) {
  if (!value) {
    var generatedMessage = false;

    if (argLen === 0) {
      generatedMessage = true;
      message = 'No value argument passed to `assert.ok()`';
    } else if (message instanceof Error) {
      throw message;
    }

    var err = new AssertionError({
      actual: value,
      expected: true,
      message: message,
      operator: '==',
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
} // Pure assertion tests whether a value is truthy, as determined
// by !!value.


function ok() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  innerOk.apply(void 0, [ok, args.length].concat(args));
}

assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.

/* eslint-disable no-restricted-properties */

assert.equal = function equal(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  } // eslint-disable-next-line eqeqeq


  if (actual != expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '==',
      stackStartFn: equal
    });
  }
}; // The non-equality assertion tests for whether two objects are not
// equal with !=.


assert.notEqual = function notEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  } // eslint-disable-next-line eqeqeq


  if (actual == expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '!=',
      stackStartFn: notEqual
    });
  }
}; // The equivalence assertion tests a deep equality relation.


assert.deepEqual = function deepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (!isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepEqual',
      stackStartFn: deepEqual
    });
  }
}; // The non-equivalence assertion tests for any deep inequality.


assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepEqual',
      stackStartFn: notDeepEqual
    });
  }
};
/* eslint-enable */


assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (!isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepStrictEqual',
      stackStartFn: deepStrictEqual
    });
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;

function notDeepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepStrictEqual',
      stackStartFn: notDeepStrictEqual
    });
  }
}

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (!objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'strictEqual',
      stackStartFn: strictEqual
    });
  }
};

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notStrictEqual',
      stackStartFn: notStrictEqual
    });
  }
};

var Comparison = function Comparison(obj, keys, actual) {
  var _this = this;

  _classCallCheck(this, Comparison);

  keys.forEach(function (key) {
    if (key in obj) {
      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {
        _this[key] = actual[key];
      } else {
        _this[key] = obj[key];
      }
    }
  });
};

function compareExceptionKey(actual, expected, key, message, keys, fn) {
  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      // Create placeholder objects to create a nice output.
      var a = new Comparison(actual, keys);
      var b = new Comparison(expected, keys, actual);
      var err = new AssertionError({
        actual: a,
        expected: b,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.actual = actual;
      err.expected = expected;
      err.operator = fn.name;
      throw err;
    }

    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}

function expectedException(actual, expected, msg, fn) {
  if (typeof expected !== 'function') {
    if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.

    if (arguments.length === 2) {
      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);
    } // Handle primitives properly.


    if (_typeof(actual) !== 'object' || actual === null) {
      var err = new AssertionError({
        actual: actual,
        expected: expected,
        message: msg,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.operator = fn.name;
      throw err;
    }

    var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
    // as well.

    if (expected instanceof Error) {
      keys.push('name', 'message');
    } else if (keys.length === 0) {
      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
    }

    if (isDeepEqual === undefined) lazyLoadComparison();
    keys.forEach(function (key) {
      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {
        return;
      }

      compareExceptionKey(actual, expected, key, msg, keys, fn);
    });
    return true;
  } // Guard instanceof against arrow functions as they don't have a prototype.


  if (expected.prototype !== undefined && actual instanceof expected) {
    return true;
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function getActual(fn) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
  }

  try {
    fn();
  } catch (e) {
    return e;
  }

  return NO_EXCEPTION_SENTINEL;
}

function checkIsPromise(obj) {
  // Accept native ES6 promises and promises that are implemented in a similar
  // way. Do not accept thenables that use a function as `obj` and that have no
  // `catch` handler.
  // TODO: thenables are checked up until they have the correct methods,
  // but according to documentation, the `then` method should receive
  // the `fulfill` and `reject` arguments as well or it may be never resolved.
  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
}

function waitForActual(promiseFn) {
  return Promise.resolve().then(function () {
    var resultPromise;

    if (typeof promiseFn === 'function') {
      // Return a rejected promise if `promiseFn` throws synchronously.
      resultPromise = promiseFn(); // Fail in case no promise is returned.

      if (!checkIsPromise(resultPromise)) {
        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
      }
    } else if (checkIsPromise(promiseFn)) {
      resultPromise = promiseFn;
    } else {
      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);
    }

    return Promise.resolve().then(function () {
      return resultPromise;
    }).then(function () {
      return NO_EXCEPTION_SENTINEL;
    }).catch(function (e) {
      return e;
    });
  });
}

function expectsError(stackStartFn, actual, error, message) {
  if (typeof error === 'string') {
    if (arguments.length === 4) {
      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
    }

    if (_typeof(actual) === 'object' && actual !== null) {
      if (actual.message === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
      }
    } else if (actual === error) {
      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
    }

    message = error;
    error = undefined;
  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
  }

  if (actual === NO_EXCEPTION_SENTINEL) {
    var details = '';

    if (error && error.name) {
      details += " (".concat(error.name, ")");
    }

    details += message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
    innerFail({
      actual: undefined,
      expected: error,
      operator: stackStartFn.name,
      message: "Missing expected ".concat(fnType).concat(details),
      stackStartFn: stackStartFn
    });
  }

  if (error && !expectedException(actual, error, message, stackStartFn)) {
    throw actual;
  }
}

function expectsNoError(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL) return;

  if (typeof error === 'string') {
    message = error;
    error = undefined;
  }

  if (!error || expectedException(actual, error)) {
    var details = message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
    innerFail({
      actual: actual,
      expected: error,
      operator: stackStartFn.name,
      message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
      stackStartFn: stackStartFn
    });
  }

  throw actual;
}

assert.throws = function throws(promiseFn) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
};

assert.rejects = function rejects(promiseFn) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return waitForActual(promiseFn).then(function (result) {
    return expectsError.apply(void 0, [rejects, result].concat(args));
  });
};

assert.doesNotThrow = function doesNotThrow(fn) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }

  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
};

assert.doesNotReject = function doesNotReject(fn) {
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }

  return waitForActual(fn).then(function (result) {
    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
  });
};

assert.ifError = function ifError(err) {
  if (err !== null && err !== undefined) {
    var message = 'ifError got unwanted exception: ';

    if (_typeof(err) === 'object' && typeof err.message === 'string') {
      if (err.message.length === 0 && err.constructor) {
        message += err.constructor.name;
      } else {
        message += err.message;
      }
    } else {
      message += inspect(err);
    }

    var newErr = new AssertionError({
      actual: err,
      expected: null,
      operator: 'ifError',
      message: message,
      stackStartFn: ifError
    }); // Make sure we actually have a stack trace!

    var origStack = err.stack;

    if (typeof origStack === 'string') {
      // This will remove any duplicated frames from the error frames taken
      // from within `ifError` and add the original error frames to the newly
      // created ones.
      var tmp2 = origStack.split('\n');
      tmp2.shift(); // Filter all frames existing in err.stack.

      var tmp1 = newErr.stack.split('\n');

      for (var i = 0; i < tmp2.length; i++) {
        // Find the first occurrence of the frame.
        var pos = tmp1.indexOf(tmp2[i]);

        if (pos !== -1) {
          // Only keep new frames.
          tmp1 = tmp1.slice(0, pos);
          break;
        }
      }

      newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
    }

    throw newErr;
  }
}; // Expose a strict only variant of assert


function strict() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }

  innerOk.apply(void 0, [strict, args.length].concat(args));
}

assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

/***/ }),

/***/ 3267:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(454)["process"];
// Currently in sync with Node.js lib/internal/assert/assertion_error.js
// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c


function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = __webpack_require__(3254),
    inspect = _require.inspect;

var _require2 = __webpack_require__(3253),
    ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat


function repeat(str, count) {
  count = Math.floor(count);
  if (str.length == 0 || count == 0) return '';
  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));

  while (count) {
    str += str;
    count--;
  }

  str += str.substring(0, maxCount - str.length);
  return str;
}

var blue = '';
var green = '';
var red = '';
var white = '';
var kReadableOperator = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:',
  notIdentical: 'Values identical but not reference-equal:'
}; // Comparing short primitives should just show === / !== instead of using the
// diff.

var kMaxShortLength = 10;

function copyError(source) {
  var keys = Object.keys(source);
  var target = Object.create(Object.getPrototypeOf(source));
  keys.forEach(function (key) {
    target[key] = source[key];
  });
  Object.defineProperty(target, 'message', {
    value: source.message
  });
  return target;
}

function inspectValue(val) {
  // The util.inspect default values could be changed. This makes sure the
  // error messages contain the necessary information nevertheless.
  return inspect(val, {
    compact: false,
    customInspect: false,
    depth: 1000,
    maxArrayLength: Infinity,
    // Assert compares only enumerable properties (with a few exceptions).
    showHidden: false,
    // Having a long line as error is better than wrapping the line for
    // comparison for now.
    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
    // have meta information about the inspected properties (i.e., know where
    // in what line the property starts and ends).
    breakLength: Infinity,
    // Assert does not detect proxies currently.
    showProxy: false,
    sorted: true,
    // Inspect getters as we also check them when comparing entries.
    getters: true
  });
}

function createErrDiff(actual, expected, operator) {
  var other = '';
  var res = '';
  var lastPos = 0;
  var end = '';
  var skipped = false;
  var actualInspected = inspectValue(actual);
  var actualLines = actualInspected.split('\n');
  var expectedLines = inspectValue(expected).split('\n');
  var i = 0;
  var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
  // for the `strictEqual` operator.

  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
    operator = 'strictEqualObject';
  } // If "actual" and "expected" fit on a single line and they are not strictly
  // equal, check further special handling.


  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
    var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
    // kMaxShortLength and if neither is an object and at least one of them is
    // not `zero`, use the strict equal comparison to visualize the output.

    if (inputLength <= kMaxShortLength) {
      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
        // -0 === +0
        return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
      }
    } else if (operator !== 'strictEqualObject') {
      // If the stderr is a tty and the input length is lower than the current
      // columns per line, add a mismatch indicator below the output. If it is
      // not a tty, use a default value of 80 characters.
      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;

      if (inputLength < maxLength) {
        while (actualLines[0][i] === expectedLines[0][i]) {
          i++;
        } // Ignore the first characters.


        if (i > 2) {
          // Add position indicator for the first mismatch in case it is a
          // single line and the input length is less than the column length.
          indicator = "\n  ".concat(repeat(' ', i), "^");
          i = 0;
        }
      }
    }
  } // Remove all ending lines that match (this optimizes the output for
  // readability by reducing the number of total changed lines).


  var a = actualLines[actualLines.length - 1];
  var b = expectedLines[expectedLines.length - 1];

  while (a === b) {
    if (i++ < 2) {
      end = "\n  ".concat(a).concat(end);
    } else {
      other = a;
    }

    actualLines.pop();
    expectedLines.pop();
    if (actualLines.length === 0 || expectedLines.length === 0) break;
    a = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }

  var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })

  if (maxLines === 0) {
    // We have to get the result again. The lines were all removed before.
    var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
    // TODO: Accept env to always show the full error.


    if (_actualLines.length > 30) {
      _actualLines[26] = "".concat(blue, "...").concat(white);

      while (_actualLines.length > 27) {
        _actualLines.pop();
      }
    }

    return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
  }

  if (i > 3) {
    end = "\n".concat(blue, "...").concat(white).concat(end);
    skipped = true;
  }

  if (other !== '') {
    end = "\n  ".concat(other).concat(end);
    other = '';
  }

  var printedLines = 0;
  var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
  var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");

  for (i = 0; i < maxLines; i++) {
    // Only extra expected lines exist
    var cur = i - lastPos;

    if (actualLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(expectedLines[i - 2]);
          printedLines++;
        }

        res += "\n  ".concat(expectedLines[i - 1]);
        printedLines++;
      } // Mark the current line as the last diverging one.


      lastPos = i; // Add the expected line to the cache.

      other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
      printedLines++; // Only extra actual lines exist
    } else if (expectedLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(actualLines[i - 2]);
          printedLines++;
        }

        res += "\n  ".concat(actualLines[i - 1]);
        printedLines++;
      } // Mark the current line as the last diverging one.


      lastPos = i; // Add the actual line to the result.

      res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
      printedLines++; // Lines diverge
    } else {
      var expectedLine = expectedLines[i];
      var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
      // a trailing comma. In that case it is actually identical and we should
      // mark it as such.

      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
      // add a comma at the end of the actual line. Otherwise the output could
      // look weird as in:
      //
      //   [
      //     1         // No comma at the end!
      // +   2
      //   ]
      //

      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ',';
      }

      if (divergingLines) {
        // If the last diverging line is more than one line above and the
        // current line is at least line three, add some of the former lines and
        // also add dots to indicate skipped entries.
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }

          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        } // Mark the current line as the last diverging one.


        lastPos = i; // Add the actual line to the result and cache the expected diverging
        // line so consecutive diverging lines show up as +++--- and not +-+-+-.

        res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
        printedLines += 2; // Lines are identical
      } else {
        // Add all cached information to the result before adding other things
        // and reset the cache.
        res += other;
        other = ''; // If the last diverging line is exactly one line above or if it is the
        // very first line, add the line to the result.

        if (cur === 1 || i === 0) {
          res += "\n  ".concat(actualLine);
          printedLines++;
        }
      }
    } // Inspected object to big (Show ~20 rows max)


    if (printedLines > 20 && i < maxLines - 2) {
      return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
    }
  }

  return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
}

var AssertionError =
/*#__PURE__*/
function (_Error) {
  _inherits(AssertionError, _Error);

  function AssertionError(options) {
    var _this;

    _classCallCheck(this, AssertionError);

    if (_typeof(options) !== 'object' || options === null) {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }

    var message = options.message,
        operator = options.operator,
        stackStartFn = options.stackStartFn;
    var actual = options.actual,
        expected = options.expected;
    var limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;

    if (message != null) {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
    } else {
      if (process.stderr && process.stderr.isTTY) {
        // Reset on each call to make sure we handle dynamically set environment
        // variables correct.
        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
          blue = "\x1B[34m";
          green = "\x1B[32m";
          white = "\x1B[39m";
          red = "\x1B[31m";
        } else {
          blue = '';
          green = '';
          white = '';
          red = '';
        }
      } // Prevent the error stack from being visible by duplicating the error
      // in a very close way to the original in case both sides are actually
      // instances of Error.


      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
        actual = copyError(actual);
        expected = copyError(expected);
      }

      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
        // In case the objects are equal but the operator requires unequal, show
        // the first object and say A equals B
        var base = kReadableOperator[operator];
        var res = inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.

        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
          base = kReadableOperator.notStrictEqualObject;
        } // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.


        if (res.length > 30) {
          res[26] = "".concat(blue, "...").concat(white);

          while (res.length > 27) {
            res.pop();
          }
        } // Only print a single input.


        if (res.length === 1) {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
        } else {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
        }
      } else {
        var _res = inspectValue(actual);

        var other = '';
        var knownOperators = kReadableOperator[operator];

        if (operator === 'notDeepEqual' || operator === 'notEqual') {
          _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);

          if (_res.length > 1024) {
            _res = "".concat(_res.slice(0, 1021), "...");
          }
        } else {
          other = "".concat(inspectValue(expected));

          if (_res.length > 512) {
            _res = "".concat(_res.slice(0, 509), "...");
          }

          if (other.length > 512) {
            other = "".concat(other.slice(0, 509), "...");
          }

          if (operator === 'deepEqual' || operator === 'equal') {
            _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
          } else {
            other = " ".concat(operator, " ").concat(other);
          }
        }

        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
      }
    }

    Error.stackTraceLimit = limit;
    _this.generatedMessage = !message;
    Object.defineProperty(_assertThisInitialized(_this), 'name', {
      value: 'AssertionError [ERR_ASSERTION]',
      enumerable: false,
      writable: true,
      configurable: true
    });
    _this.code = 'ERR_ASSERTION';
    _this.actual = actual;
    _this.expected = expected;
    _this.operator = operator;

    if (Error.captureStackTrace) {
      // eslint-disable-next-line no-restricted-syntax
      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
    } // Create error message including the error code in the name.


    _this.stack; // Reset the name.

    _this.name = 'AssertionError';
    return _possibleConstructorReturn(_this);
  }

  _createClass(AssertionError, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    }
  }, {
    key: inspect.custom,
    value: function value(recurseTimes, ctx) {
      // This limits the `actual` and `expected` property default inspection to
      // the minimum depth. Otherwise those values would be too verbose compared
      // to the actual error message which contains a combined view of these two
      // input values.
      return inspect(this, _objectSpread({}, ctx, {
        customInspect: false,
        depth: 0
      }));
    }
  }]);

  return AssertionError;
}(_wrapNativeSuper(Error));

module.exports = AssertionError;

/***/ }),

/***/ 3253:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/errors.js
// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f

/* eslint node-core/documented-errors: "error" */

/* eslint node-core/alphabetize-errors: "error" */

/* eslint node-core/prefer-util-format-errors: "error" */
 // The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var codes = {}; // Lazy loaded

var assert;
var util;

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inherits(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      var _this;

      _classCallCheck(this, NodeError);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
      _this.code = code;
      return _this;
    }

    return NodeError;
  }(Base);

  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  if (assert === undefined) assert = __webpack_require__(3252);
  assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'

  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } // TODO(BridgeAR): Improve the output by showing `null` and similar.


  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {
  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
  if (util === undefined) util = __webpack_require__(3254);
  var inspected = util.inspect(value);

  if (inspected.length > 128) {
    inspected = "".concat(inspected.slice(0, 128), "...");
  }

  return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError, RangeError);
createErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {
  var type;

  if (value && value.constructor && value.constructor.name) {
    type = "instance of ".concat(value.constructor.name);
  } else {
    type = "type ".concat(_typeof(value));
  }

  return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
}, TypeError);
createErrorType('ERR_MISSING_ARGS', function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (assert === undefined) assert = __webpack_require__(3252);
  assert(args.length > 0, 'At least one arg needs to be specified');
  var msg = 'The ';
  var len = args.length;
  args = args.map(function (a) {
    return "\"".concat(a, "\"");
  });

  switch (len) {
    case 1:
      msg += "".concat(args[0], " argument");
      break;

    case 2:
      msg += "".concat(args[0], " and ").concat(args[1], " arguments");
      break;

    default:
      msg += args.slice(0, len - 1).join(', ');
      msg += ", and ".concat(args[len - 1], " arguments");
      break;
  }

  return "".concat(msg, " must be specified");
}, TypeError);
module.exports.codes = codes;

/***/ }),

/***/ 3273:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/comparisons.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var regexFlagsSupported = /a/g.flags !== undefined;

var arrayFromSet = function arrayFromSet(set) {
  var array = [];
  set.forEach(function (value) {
    return array.push(value);
  });
  return array;
};

var arrayFromMap = function arrayFromMap(map) {
  var array = [];
  map.forEach(function (value, key) {
    return array.push([key, value]);
  });
  return array;
};

var objectIs = Object.is ? Object.is : __webpack_require__(3269);
var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {
  return [];
};
var numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__(3274);

function uncurryThis(f) {
  return f.call.bind(f);
}

var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
var objectToString = uncurryThis(Object.prototype.toString);

var _require$types = (__webpack_require__(3254).types),
    isAnyArrayBuffer = _require$types.isAnyArrayBuffer,
    isArrayBufferView = _require$types.isArrayBufferView,
    isDate = _require$types.isDate,
    isMap = _require$types.isMap,
    isRegExp = _require$types.isRegExp,
    isSet = _require$types.isSet,
    isNativeError = _require$types.isNativeError,
    isBoxedPrimitive = _require$types.isBoxedPrimitive,
    isNumberObject = _require$types.isNumberObject,
    isStringObject = _require$types.isStringObject,
    isBooleanObject = _require$types.isBooleanObject,
    isBigIntObject = _require$types.isBigIntObject,
    isSymbolObject = _require$types.isSymbolObject,
    isFloat32Array = _require$types.isFloat32Array,
    isFloat64Array = _require$types.isFloat64Array;

function isNonIndex(key) {
  if (key.length === 0 || key.length > 10) return true;

  for (var i = 0; i < key.length; i++) {
    var code = key.charCodeAt(i);
    if (code < 48 || code > 57) return true;
  } // The maximum size for an array is 2 ** 32 -1.


  return key.length === 10 && key >= Math.pow(2, 32);
}

function getOwnNonIndexProperties(value) {
  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
} // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */


function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }

  if (y < x) {
    return 1;
  }

  return 0;
}

var ONLY_ENUMERABLE = undefined;
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3; // Check if they have the same source and flags

function areSimilarRegExps(a, b) {
  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}

function areSimilarFloatArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }

  for (var offset = 0; offset < a.byteLength; offset++) {
    if (a[offset] !== b[offset]) {
      return false;
    }
  }

  return true;
}

function areSimilarTypedArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }

  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}

function areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}

function isEqualBoxedPrimitive(val1, val2) {
  if (isNumberObject(val1)) {
    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
  }

  if (isStringObject(val1)) {
    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
  }

  if (isBooleanObject(val1)) {
    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
  }

  if (isBigIntObject(val1)) {
    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
  }

  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
} // Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.


function innerDeepEqual(val1, val2, strict, memos) {
  // All identical values are equivalent, as determined by ===.
  if (val1 === val2) {
    if (val1 !== 0) return true;
    return strict ? objectIs(val1, val2) : true;
  } // Check more closely if val1 and val2 are equal.


  if (strict) {
    if (_typeof(val1) !== 'object') {
      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
    }

    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
      return false;
    }

    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || _typeof(val1) !== 'object') {
      if (val2 === null || _typeof(val2) !== 'object') {
        // eslint-disable-next-line eqeqeq
        return val1 == val2;
      }

      return false;
    }

    if (val2 === null || _typeof(val2) !== 'object') {
      return false;
    }
  }

  var val1Tag = objectToString(val1);
  var val2Tag = objectToString(val2);

  if (val1Tag !== val2Tag) {
    return false;
  }

  if (Array.isArray(val1)) {
    // Check for sparse arrays and general fast path
    if (val1.length !== val2.length) {
      return false;
    }

    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);

    if (keys1.length !== keys2.length) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
  } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
  // wan't to early return out of the rest of the checks. However we can check
  // if the second value is one of these values and the first isn't.


  if (val1Tag === '[object Object]') {
    // return keyCheck(val1, val2, strict, memos, kNoIterator);
    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
      return false;
    }
  }

  if (isDate(val1)) {
    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
      return false;
    }
  } else if (isRegExp(val1)) {
    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError(val1) || val1 instanceof Error) {
    // Do not compare the stack as it might differ even though the error itself
    // is otherwise identical.
    if (val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView(val1)) {
    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    } // Buffer.compare returns true, so val1.length === val2.length. If they both
    // only contain numeric keys, we don't need to exam further than checking
    // the symbols.


    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);

    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);

    if (_keys.length !== _keys2.length) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
  } else if (isSet(val1)) {
    if (!isSet(val2) || val1.size !== val2.size) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kIsSet);
  } else if (isMap(val1)) {
    if (!isMap(val2) || val1.size !== val2.size) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kIsMap);
  } else if (isAnyArrayBuffer(val1)) {
    if (!areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
    return false;
  }

  return keyCheck(val1, val2, strict, memos, kNoIterator);
}

function getEnumerables(val, keys) {
  return keys.filter(function (k) {
    return propertyIsEnumerable(val, k);
  });
}

function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
  // For all remaining Object pairs, including Array, objects and Maps,
  // equivalence is determined by having:
  // a) The same number of owned enumerable properties
  // b) The same set of keys/indexes (although not necessarily the same order)
  // c) Equivalent values for every corresponding key/index
  // d) For Sets and Maps, equal contents
  // Note: this accounts for both named and indexed properties on Arrays.
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.

    if (aKeys.length !== bKeys.length) {
      return false;
    }
  } // Cheap key test


  var i = 0;

  for (; i < aKeys.length; i++) {
    if (!hasOwnProperty(val2, aKeys[i])) {
      return false;
    }
  }

  if (strict && arguments.length === 5) {
    var symbolKeysA = objectGetOwnPropertySymbols(val1);

    if (symbolKeysA.length !== 0) {
      var count = 0;

      for (i = 0; i < symbolKeysA.length; i++) {
        var key = symbolKeysA[i];

        if (propertyIsEnumerable(val1, key)) {
          if (!propertyIsEnumerable(val2, key)) {
            return false;
          }

          aKeys.push(key);
          count++;
        } else if (propertyIsEnumerable(val2, key)) {
          return false;
        }
      }

      var symbolKeysB = objectGetOwnPropertySymbols(val2);

      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      var _symbolKeysB = objectGetOwnPropertySymbols(val2);

      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
        return false;
      }
    }
  }

  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
    return true;
  } // Use memos to handle cycles.


  if (memos === undefined) {
    memos = {
      val1: new Map(),
      val2: new Map(),
      position: 0
    };
  } else {
    // We prevent up to two map.has(x) calls by directly retrieving the value
    // and checking for undefined. The map can only contain numbers, so it is
    // safe to check for undefined only.
    var val2MemoA = memos.val1.get(val1);

    if (val2MemoA !== undefined) {
      var val2MemoB = memos.val2.get(val2);

      if (val2MemoB !== undefined) {
        return val2MemoA === val2MemoB;
      }
    }

    memos.position++;
  }

  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}

function setHasEqualElement(set, val1, strict, memo) {
  // Go looking.
  var setValues = arrayFromSet(set);

  for (var i = 0; i < setValues.length; i++) {
    var val2 = setValues[i];

    if (innerDeepEqual(val1, val2, strict, memo)) {
      // Remove the matching element to make sure we do not check that again.
      set.delete(val2);
      return true;
    }
  }

  return false;
} // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').


function findLooseMatchingPrimitives(prim) {
  switch (_typeof(prim)) {
    case 'undefined':
      return null;

    case 'object':
      // Only pass in null as object!
      return undefined;

    case 'symbol':
      return false;

    case 'string':
      prim = +prim;
    // Loose equal entries exist only if the string is possible to convert to
    // a regular number and not NaN.
    // Fall through

    case 'number':
      if (numberIsNaN(prim)) {
        return false;
      }

  }

  return true;
}

function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) return altValue;
  return b.has(altValue) && !a.has(altValue);
}

function mapMightHaveLoosePrim(a, b, prim, item, memo) {
  var altValue = findLooseMatchingPrimitives(prim);

  if (altValue != null) {
    return altValue;
  }

  var curB = b.get(altValue);

  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
    return false;
  }

  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}

function setEquiv(a, b, strict, memo) {
  // This is a lazily initiated Set of entries which have to be compared
  // pairwise.
  var set = null;
  var aValues = arrayFromSet(a);

  for (var i = 0; i < aValues.length; i++) {
    var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
    // heavy sets but it is a minor slow down for primitives. As they are fast
    // to check this improves the worst case scenario instead.

    if (_typeof(val) === 'object' && val !== null) {
      if (set === null) {
        set = new Set();
      } // If the specified value doesn't exist in the second set its an not null
      // object (or non strict only: a not matching primitive) we'll need to go
      // hunting for something thats deep-(strict-)equal to it. To make this
      // O(n log n) complexity we have to copy these values in a new set first.


      set.add(val);
    } else if (!b.has(val)) {
      if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.

      if (!setMightHaveLoosePrim(a, b, val)) {
        return false;
      }

      if (set === null) {
        set = new Set();
      }

      set.add(val);
    }
  }

  if (set !== null) {
    var bValues = arrayFromSet(b);

    for (var _i = 0; _i < bValues.length; _i++) {
      var _val = bValues[_i]; // We have to check if a primitive value is already
      // matching and only if it's not, go hunting for it.

      if (_typeof(_val) === 'object' && _val !== null) {
        if (!setHasEqualElement(set, _val, strict, memo)) return false;
      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
        return false;
      }
    }

    return set.size === 0;
  }

  return true;
}

function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
  // To be able to handle cases like:
  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
  // ... we need to consider *all* matching keys, not just the first we find.
  var setValues = arrayFromSet(set);

  for (var i = 0; i < setValues.length; i++) {
    var key2 = setValues[i];

    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
      set.delete(key2);
      return true;
    }
  }

  return false;
}

function mapEquiv(a, b, strict, memo) {
  var set = null;
  var aEntries = arrayFromMap(a);

  for (var i = 0; i < aEntries.length; i++) {
    var _aEntries$i = _slicedToArray(aEntries[i], 2),
        key = _aEntries$i[0],
        item1 = _aEntries$i[1];

    if (_typeof(key) === 'object' && key !== null) {
      if (set === null) {
        set = new Set();
      }

      set.add(key);
    } else {
      // By directly retrieving the value we prevent another b.has(key) check in
      // almost all possible cases.
      var item2 = b.get(key);

      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
        if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
        // keys.

        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;

        if (set === null) {
          set = new Set();
        }

        set.add(key);
      }
    }
  }

  if (set !== null) {
    var bEntries = arrayFromMap(b);

    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),
          key = _bEntries$_i[0],
          item = _bEntries$_i[1];

      if (_typeof(key) === 'object' && key !== null) {
        if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
      } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
        return false;
      }
    }

    return set.size === 0;
  }

  return true;
}

function objEquiv(a, b, strict, keys, memos, iterationType) {
  // Sets and maps don't have their entries accessible via normal object
  // properties.
  var i = 0;

  if (iterationType === kIsSet) {
    if (!setEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsMap) {
    if (!mapEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsArray) {
    for (; i < a.length; i++) {
      if (hasOwnProperty(a, i)) {
        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
          return false;
        }
      } else if (hasOwnProperty(b, i)) {
        return false;
      } else {
        // Array is sparse.
        var keysA = Object.keys(a);

        for (; i < keysA.length; i++) {
          var key = keysA[i];

          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
            return false;
          }
        }

        if (keysA.length !== Object.keys(b).length) {
          return false;
        }

        return true;
      }
    }
  } // The pair must have equivalent values for every corresponding key.
  // Possibly expensive deep test:


  for (i = 0; i < keys.length; i++) {
    var _key = keys[i];

    if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
      return false;
    }
  }

  return true;
}

function isDeepEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kLoose);
}

function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kStrict);
}

module.exports = {
  isDeepEqual: isDeepEqual,
  isDeepStrictEqual: isDeepStrictEqual
};

/***/ }),

/***/ 3212:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__(444)
const ieee754 = __webpack_require__(445)
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


/***/ }),

/***/ 2970:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(2961);
var tryToString = __webpack_require__(2971);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 3011:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isConstructor = __webpack_require__(3012);
var tryToString = __webpack_require__(2971);

var $TypeError = TypeError;

// `Assert: IsConstructor(argument) is true`
module.exports = function (argument) {
  if (isConstructor(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a constructor');
};


/***/ }),

/***/ 3051:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(2961);

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (typeof argument == 'object' || isCallable(argument)) return argument;
  throw $TypeError("Can't set " + $String(argument) + ' as a prototype');
};


/***/ }),

/***/ 3043:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(2973);
var create = __webpack_require__(3015);
var defineProperty = (__webpack_require__(2984).f);

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  defineProperty(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ 3074:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var charAt = (__webpack_require__(3053).charAt);

// `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};


/***/ }),

/***/ 3122:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototypeOf = __webpack_require__(2964);

var $TypeError = TypeError;

module.exports = function (it, Prototype) {
  if (isPrototypeOf(Prototype, it)) return it;
  throw $TypeError('Incorrect invocation');
};


/***/ }),

/***/ 2986:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(2960);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 3149:
/***/ ((module) => {

// eslint-disable-next-line es-x/no-typed-arrays -- safe
module.exports = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';


/***/ }),

/***/ 3225:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it
var fails = __webpack_require__(2948);

module.exports = fails(function () {
  if (typeof ArrayBuffer == 'function') {
    var buffer = new ArrayBuffer(8);
    // eslint-disable-next-line es-x/no-object-isextensible, es-x/no-object-defineproperty -- safe
    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });
  }
});


/***/ }),

/***/ 3148:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_ARRAY_BUFFER = __webpack_require__(3149);
var DESCRIPTORS = __webpack_require__(2947);
var global = __webpack_require__(2945);
var isCallable = __webpack_require__(2961);
var isObject = __webpack_require__(2960);
var hasOwn = __webpack_require__(2978);
var classof = __webpack_require__(3013);
var tryToString = __webpack_require__(2971);
var createNonEnumerableProperty = __webpack_require__(2983);
var defineBuiltIn = __webpack_require__(2987);
var defineProperty = (__webpack_require__(2984).f);
var isPrototypeOf = __webpack_require__(2964);
var getPrototypeOf = __webpack_require__(3048);
var setPrototypeOf = __webpack_require__(3050);
var wellKnownSymbol = __webpack_require__(2973);
var uid = __webpack_require__(2980);

var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var TypeError = global.TypeError;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
var TYPED_ARRAY_CONSTRUCTOR = uid('TYPED_ARRAY_CONSTRUCTOR');
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQUIRED = false;
var NAME, Constructor, Prototype;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var BigIntArrayConstructorsList = {
  BigInt64Array: 8,
  BigUint64Array: 8
};

var isView = function isView(it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return klass === 'DataView'
    || hasOwn(TypedArrayConstructorsList, klass)
    || hasOwn(BigIntArrayConstructorsList, klass);
};

var isTypedArray = function (it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return hasOwn(TypedArrayConstructorsList, klass)
    || hasOwn(BigIntArrayConstructorsList, klass);
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
  throw TypeError(tryToString(C) + ' is not a typed array constructor');
};

var exportTypedArrayMethod = function (KEY, property, forced, options) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
      delete TypedArrayConstructor.prototype[KEY];
    } catch (error) {
      // old WebKit bug - some methods are non-configurable
      try {
        TypedArrayConstructor.prototype[KEY] = property;
      } catch (error2) { /* empty */ }
    }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    defineBuiltIn(TypedArrayPrototype, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
  }
};

var exportTypedArrayStaticMethod = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;
  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global[ARRAY];
      if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
        delete TypedArrayConstructor[KEY];
      } catch (error) { /* empty */ }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      defineBuiltIn(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  Constructor = global[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);
  else NATIVE_ARRAY_BUFFER_VIEWS = false;
}

for (NAME in BigIntArrayConstructorsList) {
  Constructor = global[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow -- safe
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQUIRED = true;
  defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function () {
    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
  } });
  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
  }
}

module.exports = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_CONSTRUCTOR: TYPED_ARRAY_CONSTRUCTOR,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};


/***/ }),

/***/ 3150:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(2945);
var uncurryThis = __webpack_require__(2955);
var DESCRIPTORS = __webpack_require__(2947);
var NATIVE_ARRAY_BUFFER = __webpack_require__(3149);
var FunctionName = __webpack_require__(2989);
var createNonEnumerableProperty = __webpack_require__(2983);
var defineBuiltIns = __webpack_require__(3151);
var fails = __webpack_require__(2948);
var anInstance = __webpack_require__(3122);
var toIntegerOrInfinity = __webpack_require__(3001);
var toLength = __webpack_require__(3004);
var toIndex = __webpack_require__(3152);
var IEEE754 = __webpack_require__(3153);
var getPrototypeOf = __webpack_require__(3048);
var setPrototypeOf = __webpack_require__(3050);
var getOwnPropertyNames = (__webpack_require__(2997).f);
var defineProperty = (__webpack_require__(2984).f);
var arrayFill = __webpack_require__(3154);
var arraySlice = __webpack_require__(3023);
var setToStringTag = __webpack_require__(3029);
var InternalStateModule = __webpack_require__(2991);

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
var $DataView = global[DATA_VIEW];
var DataViewPrototype = $DataView && $DataView[PROTOTYPE];
var ObjectPrototype = Object.prototype;
var Array = global.Array;
var RangeError = global.RangeError;
var fill = uncurryThis(arrayFill);
var reverse = uncurryThis([].reverse);

var packIEEE754 = IEEE754.pack;
var unpackIEEE754 = IEEE754.unpack;

var packInt8 = function (number) {
  return [number & 0xFF];
};

var packInt16 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var unpackInt32 = function (buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packFloat32 = function (number) {
  return packIEEE754(number, 23, 4);
};

var packFloat64 = function (number) {
  return packIEEE754(number, 52, 8);
};

var addGetter = function (Constructor, key) {
  defineProperty(Constructor[PROTOTYPE], key, { get: function () { return getInternalState(this)[key]; } });
};

var get = function (view, count, index, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = arraySlice(bytes, start, start + count);
  return isLittleEndian ? pack : reverse(pack);
};

var set = function (view, count, index, conversion, value, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = conversion(+value);
  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};

if (!NATIVE_ARRAY_BUFFER) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, ArrayBufferPrototype);
    var byteLength = toIndex(length);
    setInternalState(this, {
      bytes: fill(Array(byteLength), 0),
      byteLength: byteLength
    });
    if (!DESCRIPTORS) this.byteLength = byteLength;
  };

  ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE];

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, DataViewPrototype);
    anInstance(buffer, ArrayBufferPrototype);
    var bufferLength = getInternalState(buffer).byteLength;
    var offset = toIntegerOrInfinity(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    setInternalState(this, {
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset
    });
    if (!DESCRIPTORS) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  DataViewPrototype = $DataView[PROTOTYPE];

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, 'byteLength');
    addGetter($DataView, 'buffer');
    addGetter($DataView, 'byteLength');
    addGetter($DataView, 'byteOffset');
  }

  defineBuiltIns(DataViewPrototype, {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
    }
  });
} else {
  var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;
  /* eslint-disable no-new -- required for testing */
  if (!fails(function () {
    NativeArrayBuffer(1);
  }) || !fails(function () {
    new NativeArrayBuffer(-1);
  }) || fails(function () {
    new NativeArrayBuffer();
    new NativeArrayBuffer(1.5);
    new NativeArrayBuffer(NaN);
    return INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
  })) {
  /* eslint-enable no-new -- required for testing */
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, ArrayBufferPrototype);
      return new NativeArrayBuffer(toIndex(length));
    };

    $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype;

    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) {
        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
      }
    }

    ArrayBufferPrototype.constructor = $ArrayBuffer;
  } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
    createNonEnumerableProperty(NativeArrayBuffer, 'name', ARRAY_BUFFER);
  }

  // WebKit bug - the same parent prototype for typed arrays and data view
  if (setPrototypeOf && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) {
    setPrototypeOf(DataViewPrototype, ObjectPrototype);
  }

  // iOS Safari 7.x bug
  var testView = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = uncurryThis(DataViewPrototype.setInt8);
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns(DataViewPrototype, {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8(this, byteOffset, value << 24 >> 24);
    }
  }, { unsafe: true });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);

module.exports = {
  ArrayBuffer: $ArrayBuffer,
  DataView: $DataView
};


/***/ }),

/***/ 3161:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toObject = __webpack_require__(2979);
var toAbsoluteIndex = __webpack_require__(3000);
var lengthOfArrayLike = __webpack_require__(3003);
var deletePropertyOrThrow = __webpack_require__(3162);

var min = Math.min;

// `Array.prototype.copyWithin` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.copywithin
// eslint-disable-next-line es-x/no-array-prototype-copywithin -- safe
module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = lengthOfArrayLike(O);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else deletePropertyOrThrow(O, to);
    to += inc;
    from += inc;
  } return O;
};


/***/ }),

/***/ 3154:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toObject = __webpack_require__(2979);
var toAbsoluteIndex = __webpack_require__(3000);
var lengthOfArrayLike = __webpack_require__(3003);

// `Array.prototype.fill` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = lengthOfArrayLike(O);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ 3086:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $forEach = (__webpack_require__(3030).forEach);
var arrayMethodIsStrict = __webpack_require__(3087);

var STRICT_METHOD = arrayMethodIsStrict('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach
module.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
// eslint-disable-next-line es-x/no-array-prototype-foreach -- safe
} : [].forEach;


/***/ }),

/***/ 3168:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var lengthOfArrayLike = __webpack_require__(3003);

module.exports = function (Constructor, list) {
  var index = 0;
  var length = lengthOfArrayLike(list);
  var result = new Constructor(length);
  while (length > index) result[index] = list[index++];
  return result;
};


/***/ }),

/***/ 3058:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var bind = __webpack_require__(3031);
var call = __webpack_require__(2949);
var toObject = __webpack_require__(2979);
var callWithSafeIterationClosing = __webpack_require__(3059);
var isArrayIteratorMethod = __webpack_require__(3061);
var isConstructor = __webpack_require__(3012);
var lengthOfArrayLike = __webpack_require__(3003);
var createProperty = __webpack_require__(3024);
var getIterator = __webpack_require__(3062);
var getIteratorMethod = __webpack_require__(3063);

var $Array = Array;

// `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var IS_CONSTRUCTOR = isConstructor(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = getIterator(O, iteratorMethod);
    next = iterator.next;
    result = IS_CONSTRUCTOR ? new this() : [];
    for (;!(step = call(next, iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = lengthOfArrayLike(O);
    result = IS_CONSTRUCTOR ? new this(length) : $Array(length);
    for (;length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};


/***/ }),

/***/ 2999:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIndexedObject = __webpack_require__(2953);
var toAbsoluteIndex = __webpack_require__(3000);
var lengthOfArrayLike = __webpack_require__(3003);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 3030:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var bind = __webpack_require__(3031);
var uncurryThis = __webpack_require__(2955);
var IndexedObject = __webpack_require__(2954);
var toObject = __webpack_require__(2979);
var lengthOfArrayLike = __webpack_require__(3003);
var arraySpeciesCreate = __webpack_require__(3032);

var push = uncurryThis([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that);
    var length = lengthOfArrayLike(self);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push(target, value);      // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push(target, value);      // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod(7)
};


/***/ }),

/***/ 3178:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es-x/no-array-prototype-lastindexof -- safe */
var apply = __webpack_require__(3008);
var toIndexedObject = __webpack_require__(2953);
var toIntegerOrInfinity = __webpack_require__(3001);
var lengthOfArrayLike = __webpack_require__(3003);
var arrayMethodIsStrict = __webpack_require__(3087);

var min = Math.min;
var $lastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;

// `Array.prototype.lastIndexOf` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.lastindexof
module.exports = FORCED ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
  // convert -0 to +0
  if (NEGATIVE_ZERO) return apply($lastIndexOf, this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = lengthOfArrayLike(O);
  var index = length - 1;
  if (arguments.length > 1) index = min(index, toIntegerOrInfinity(arguments[1]));
  if (index < 0) index = length + index;
  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
  return -1;
} : $lastIndexOf;


/***/ }),

/***/ 3077:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(2948);
var wellKnownSymbol = __webpack_require__(2973);
var V8_VERSION = __webpack_require__(2967);

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ 3087:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(2948);

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call -- required for testing
    method.call(null, argument || function () { return 1; }, 1);
  });
};


/***/ }),

/***/ 3181:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aCallable = __webpack_require__(2970);
var toObject = __webpack_require__(2979);
var IndexedObject = __webpack_require__(2954);
var lengthOfArrayLike = __webpack_require__(3003);

var $TypeError = TypeError;

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aCallable(callbackfn);
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = lengthOfArrayLike(O);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw $TypeError('Reduce of empty array with no initial value');
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};


/***/ }),

/***/ 3023:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toAbsoluteIndex = __webpack_require__(3000);
var lengthOfArrayLike = __webpack_require__(3003);
var createProperty = __webpack_require__(3024);

var $Array = Array;
var max = Math.max;

module.exports = function (O, start, end) {
  var length = lengthOfArrayLike(O);
  var k = toAbsoluteIndex(start, length);
  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
  var result = $Array(max(fin - k, 0));
  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
  result.length = n;
  return result;
};


/***/ }),

/***/ 3010:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(2955);

module.exports = uncurryThis([].slice);


/***/ }),

/***/ 3188:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arraySlice = __webpack_require__(3023);

var floor = Math.floor;

var mergeSort = function (array, comparefn) {
  var length = array.length;
  var middle = floor(length / 2);
  return length < 8 ? insertionSort(array, comparefn) : merge(
    array,
    mergeSort(arraySlice(array, 0, middle), comparefn),
    mergeSort(arraySlice(array, middle), comparefn),
    comparefn
  );
};

var insertionSort = function (array, comparefn) {
  var length = array.length;
  var i = 1;
  var element, j;

  while (i < length) {
    j = i;
    element = array[i];
    while (j && comparefn(array[j - 1], element) > 0) {
      array[j] = array[--j];
    }
    if (j !== i++) array[j] = element;
  } return array;
};

var merge = function (array, left, right, comparefn) {
  var llength = left.length;
  var rlength = right.length;
  var lindex = 0;
  var rindex = 0;

  while (lindex < llength || rindex < rlength) {
    array[lindex + rindex] = (lindex < llength && rindex < rlength)
      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]
      : lindex < llength ? left[lindex++] : right[rindex++];
  } return array;
};

module.exports = mergeSort;


/***/ }),

/***/ 3033:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(3034);
var isConstructor = __webpack_require__(3012);
var isObject = __webpack_require__(2960);
var wellKnownSymbol = __webpack_require__(2973);

var SPECIES = wellKnownSymbol('species');
var $Array = Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? $Array : C;
};


/***/ }),

/***/ 3032:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arraySpeciesConstructor = __webpack_require__(3033);

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};


/***/ }),

/***/ 3059:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var anObject = __webpack_require__(2986);
var iteratorClose = __webpack_require__(3060);

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose(iterator, 'throw', error);
  }
};


/***/ }),

/***/ 3064:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(2973);

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ 2956:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(2955);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 3013:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var TO_STRING_TAG_SUPPORT = __webpack_require__(3014);
var isCallable = __webpack_require__(2961);
var classofRaw = __webpack_require__(2956);
var wellKnownSymbol = __webpack_require__(2973);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 3227:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineProperty = (__webpack_require__(2984).f);
var create = __webpack_require__(3015);
var defineBuiltIns = __webpack_require__(3151);
var bind = __webpack_require__(3031);
var anInstance = __webpack_require__(3122);
var iterate = __webpack_require__(3137);
var defineIterator = __webpack_require__(3045);
var setSpecies = __webpack_require__(3121);
var DESCRIPTORS = __webpack_require__(2947);
var fastKey = (__webpack_require__(3223).fastKey);
var InternalStateModule = __webpack_require__(2991);

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
    });

    var Prototype = Constructor.prototype;

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
      // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;
        else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      } return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    defineBuiltIns(Prototype, {
      // `{ Map, Set }.prototype.clear()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.clear
      // https://tc39.es/ecma262/#sec-set.prototype.clear
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }
        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;
        else that.size = 0;
      },
      // `{ Map, Set }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.delete
      // https://tc39.es/ecma262/#sec-set.prototype.delete
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS) state.size--;
          else that.size--;
        } return !!entry;
      },
      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.foreach
      // https://tc39.es/ecma262/#sec-set.prototype.foreach
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // `{ Map, Set}.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.has
      // https://tc39.es/ecma262/#sec-set.prototype.has
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });

    defineBuiltIns(Prototype, IS_MAP ? {
      // `Map.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-map.prototype.get
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // `Map.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-map.prototype.set
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // `Set.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-set.prototype.add
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineProperty(Prototype, 'size', {
      get: function () {
        return getInternalState(this).size;
      }
    });
    return Constructor;
  },
  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
    // https://tc39.es/ecma262/#sec-map.prototype.entries
    // https://tc39.es/ecma262/#sec-map.prototype.keys
    // https://tc39.es/ecma262/#sec-map.prototype.values
    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
    // https://tc39.es/ecma262/#sec-set.prototype.entries
    // https://tc39.es/ecma262/#sec-set.prototype.keys
    // https://tc39.es/ecma262/#sec-set.prototype.values
    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator
    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return { value: undefined, done: true };
      }
      // return step by kind
      if (kind == 'keys') return { value: entry.key, done: false };
      if (kind == 'values') return { value: entry.value, done: false };
      return { value: [entry.key, entry.value], done: false };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // `{ Map, Set }.prototype[@@species]` accessors
    // https://tc39.es/ecma262/#sec-get-map-@@species
    // https://tc39.es/ecma262/#sec-get-set-@@species
    setSpecies(CONSTRUCTOR_NAME);
  }
};


/***/ }),

/***/ 3222:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var global = __webpack_require__(2945);
var uncurryThis = __webpack_require__(2955);
var isForced = __webpack_require__(3007);
var defineBuiltIn = __webpack_require__(2987);
var InternalMetadataModule = __webpack_require__(3223);
var iterate = __webpack_require__(3137);
var anInstance = __webpack_require__(3122);
var isCallable = __webpack_require__(2961);
var isObject = __webpack_require__(2960);
var fails = __webpack_require__(2948);
var checkCorrectnessOfIteration = __webpack_require__(3064);
var setToStringTag = __webpack_require__(3029);
var inheritIfRequired = __webpack_require__(3159);

module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};

  var fixMethod = function (KEY) {
    var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
    defineBuiltIn(NativePrototype, KEY,
      KEY == 'add' ? function add(value) {
        uncurriedNativeMethod(this, value === 0 ? 0 : value);
        return this;
      } : KEY == 'delete' ? function (key) {
        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY == 'get' ? function get(key) {
        return IS_WEAK && !isObject(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY == 'has' ? function has(key) {
        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : function set(key, value) {
        uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };

  var REPLACE = isForced(
    CONSTRUCTOR_NAME,
    !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
      new NativeConstructor().entries().next();
    }))
  );

  if (REPLACE) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.enable();
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new -- required for testing
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, NativePrototype);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  $({ global: true, constructor: true, forced: Constructor != NativeConstructor }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);

  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

  return Constructor;
};


/***/ }),

/***/ 2995:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasOwn = __webpack_require__(2978);
var ownKeys = __webpack_require__(2996);
var getOwnPropertyDescriptorModule = __webpack_require__(2946);
var definePropertyModule = __webpack_require__(2984);

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ 3322:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(2973);

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) { /* empty */ }
  } return false;
};


/***/ }),

/***/ 3049:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(2948);

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ 3046:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IteratorPrototype = (__webpack_require__(3047).IteratorPrototype);
var create = __webpack_require__(3015);
var createPropertyDescriptor = __webpack_require__(2952);
var setToStringTag = __webpack_require__(3029);
var Iterators = __webpack_require__(3044);

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ 2983:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(2947);
var definePropertyModule = __webpack_require__(2984);
var createPropertyDescriptor = __webpack_require__(2952);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 2952:
/***/ ((module) => {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 3024:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPropertyKey = __webpack_require__(2958);
var definePropertyModule = __webpack_require__(2984);
var createPropertyDescriptor = __webpack_require__(2952);

module.exports = function (object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ 3208:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var makeBuiltIn = __webpack_require__(2988);
var defineProperty = __webpack_require__(2984);

module.exports = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ 2987:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(2961);
var createNonEnumerableProperty = __webpack_require__(2983);
var makeBuiltIn = __webpack_require__(2988);
var defineGlobalProperty = __webpack_require__(2977);

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    if (!options.unsafe) delete O[key];
    else if (O[key]) simple = true;
    if (simple) O[key] = value;
    else createNonEnumerableProperty(O, key, value);
  } return O;
};


/***/ }),

/***/ 3151:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineBuiltIn = __webpack_require__(2987);

module.exports = function (target, src, options) {
  for (var key in src) defineBuiltIn(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ 2977:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(2945);

// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 3045:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var call = __webpack_require__(2949);
var IS_PURE = __webpack_require__(2975);
var FunctionName = __webpack_require__(2989);
var isCallable = __webpack_require__(2961);
var createIteratorConstructor = __webpack_require__(3046);
var getPrototypeOf = __webpack_require__(3048);
var setPrototypeOf = __webpack_require__(3050);
var setToStringTag = __webpack_require__(3029);
var createNonEnumerableProperty = __webpack_require__(2983);
var defineBuiltIn = __webpack_require__(2987);
var wellKnownSymbol = __webpack_require__(2973);
var Iterators = __webpack_require__(3044);
var IteratorsCore = __webpack_require__(3047);

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
          defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() { return call(nativeIterator, this); };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
  }
  Iterators[NAME] = defaultIterator;

  return methods;
};


/***/ }),

/***/ 3026:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(3027);
var hasOwn = __webpack_require__(2978);
var wrappedWellKnownSymbolModule = __webpack_require__(3025);
var defineProperty = (__webpack_require__(2984).f);

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!hasOwn(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ 3162:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var tryToString = __webpack_require__(2971);

var $TypeError = TypeError;

module.exports = function (O, P) {
  if (!delete O[P]) throw $TypeError('Cannot delete property ' + tryToString(P) + ' of ' + tryToString(O));
};


/***/ }),

/***/ 2947:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(2948);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ 2982:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(2945);
var isObject = __webpack_require__(2960);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 3079:
/***/ ((module) => {

var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ 3055:
/***/ ((module) => {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ 3056:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`
var documentCreateElement = __webpack_require__(2982);

var classList = documentCreateElement('span').classList;
var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;

module.exports = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;


/***/ }),

/***/ 3189:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var userAgent = __webpack_require__(2968);

var firefox = userAgent.match(/firefox\/(\d+)/i);

module.exports = !!firefox && +firefox[1];


/***/ }),

/***/ 3134:
/***/ ((module) => {

module.exports = typeof window == 'object' && typeof Deno != 'object';


/***/ }),

/***/ 3190:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var UA = __webpack_require__(2968);

module.exports = /MSIE|Trident/.test(UA);


/***/ }),

/***/ 3127:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var userAgent = __webpack_require__(2968);
var global = __webpack_require__(2945);

module.exports = /ipad|iphone|ipod/i.test(userAgent) && global.Pebble !== undefined;


/***/ }),

/***/ 3125:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var userAgent = __webpack_require__(2968);

module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);


/***/ }),

/***/ 3120:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(2956);
var global = __webpack_require__(2945);

module.exports = classof(global.process) == 'process';


/***/ }),

/***/ 3128:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var userAgent = __webpack_require__(2968);

module.exports = /web0s(?!.*chrome)/i.test(userAgent);


/***/ }),

/***/ 2968:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(2963);

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ 2967:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(2945);
var userAgent = __webpack_require__(2968);

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 3191:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var userAgent = __webpack_require__(2968);

var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);

module.exports = !!webkit && +webkit[1];


/***/ }),

/***/ 3005:
/***/ ((module) => {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 2944:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(2945);
var getOwnPropertyDescriptor = (__webpack_require__(2946).f);
var createNonEnumerableProperty = __webpack_require__(2983);
var defineBuiltIn = __webpack_require__(2987);
var defineGlobalProperty = __webpack_require__(2977);
var copyConstructorProperties = __webpack_require__(2995);
var isForced = __webpack_require__(3007);

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 2948:
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 3073:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4` since it's moved to entry points
__webpack_require__(3066);
var uncurryThis = __webpack_require__(2955);
var defineBuiltIn = __webpack_require__(2987);
var regexpExec = __webpack_require__(3067);
var fails = __webpack_require__(2948);
var wellKnownSymbol = __webpack_require__(2973);
var createNonEnumerableProperty = __webpack_require__(2983);

var SPECIES = wellKnownSymbol('species');
var RegExpPrototype = RegExp.prototype;

module.exports = function (KEY, exec, FORCED, SHAM) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () { execCalled = true; return null; };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    FORCED
  ) {
    var uncurriedNativeRegExpMethod = uncurryThis(/./[SYMBOL]);
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      var uncurriedNativeMethod = uncurryThis(nativeMethod);
      var $exec = regexp.exec;
      if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
        }
        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
      }
      return { done: false };
    });

    defineBuiltIn(String.prototype, KEY, methods[0]);
    defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
  }

  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);
};


/***/ }),

/***/ 3226:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(2948);

module.exports = !fails(function () {
  // eslint-disable-next-line es-x/no-object-isextensible, es-x/no-object-preventextensions -- required for testing
  return Object.isExtensible(Object.preventExtensions({}));
});


/***/ }),

/***/ 3008:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(2950);

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es-x/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),

/***/ 3031:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(2955);
var aCallable = __webpack_require__(2970);
var NATIVE_BIND = __webpack_require__(2950);

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 2950:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(2948);

module.exports = !fails(function () {
  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 3009:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(2955);
var aCallable = __webpack_require__(2970);
var isObject = __webpack_require__(2960);
var hasOwn = __webpack_require__(2978);
var arraySlice = __webpack_require__(3010);
var NATIVE_BIND = __webpack_require__(2950);

var $Function = Function;
var concat = uncurryThis([].concat);
var join = uncurryThis([].join);
var factories = {};

var construct = function (C, argsLength, args) {
  if (!hasOwn(factories, argsLength)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
    factories[argsLength] = $Function('C,a', 'return new C(' + join(list, ',') + ')');
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind
module.exports = NATIVE_BIND ? $Function.bind : function bind(that /* , ...args */) {
  var F = aCallable(this);
  var Prototype = F.prototype;
  var partArgs = arraySlice(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = concat(partArgs, arraySlice(arguments));
    return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
  };
  if (isObject(Prototype)) boundFunction.prototype = Prototype;
  return boundFunction;
};


/***/ }),

/***/ 2949:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(2950);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 2989:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(2947);
var hasOwn = __webpack_require__(2978);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 2955:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(2950);

var FunctionPrototype = Function.prototype;
var bind = FunctionPrototype.bind;
var call = FunctionPrototype.call;
var uncurryThis = NATIVE_BIND && bind.bind(call, call);

module.exports = NATIVE_BIND ? function (fn) {
  return fn && uncurryThis(fn);
} : function (fn) {
  return fn && function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 2963:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(2945);
var isCallable = __webpack_require__(2961);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 3063:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(3013);
var getMethod = __webpack_require__(2969);
var Iterators = __webpack_require__(3044);
var wellKnownSymbol = __webpack_require__(2973);

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return getMethod(it, ITERATOR)
    || getMethod(it, '@@iterator')
    || Iterators[classof(it)];
};


/***/ }),

/***/ 3062:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(2949);
var aCallable = __webpack_require__(2970);
var anObject = __webpack_require__(2986);
var tryToString = __webpack_require__(2971);
var getIteratorMethod = __webpack_require__(3063);

var $TypeError = TypeError;

module.exports = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
  throw $TypeError(tryToString(argument) + ' is not iterable');
};


/***/ }),

/***/ 2969:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aCallable = __webpack_require__(2970);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable(func);
};


/***/ }),

/***/ 3204:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(2955);
var toObject = __webpack_require__(2979);

var floor = Math.floor;
var charAt = uncurryThis(''.charAt);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

// `GetSubstitution` abstract operation
// https://tc39.es/ecma262/#sec-getsubstitution
module.exports = function (matched, str, position, captures, namedCaptures, replacement) {
  var tailPos = position + matched.length;
  var m = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== undefined) {
    namedCaptures = toObject(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace(replacement, symbols, function (match, ch) {
    var capture;
    switch (charAt(ch, 0)) {
      case '$': return '$';
      case '&': return matched;
      case '`': return stringSlice(str, 0, position);
      case "'": return stringSlice(str, tailPos);
      case '<':
        capture = namedCaptures[stringSlice(ch, 1, -1)];
        break;
      default: // \d\d?
        var n = +ch;
        if (n === 0) return match;
        if (n > m) {
          var f = floor(n / 10);
          if (f === 0) return match;
          if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
          return match;
        }
        capture = captures[n - 1];
    }
    return capture === undefined ? '' : capture;
  });
};


/***/ }),

/***/ 2945:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es-x/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 2978:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(2955);
var toObject = __webpack_require__(2979);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es-x/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 2994:
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ 3129:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(2945);

module.exports = function (a, b) {
  var console = global.console;
  if (console && console.error) {
    arguments.length == 1 ? console.error(a) : console.error(a, b);
  }
};


/***/ }),

/***/ 3018:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(2963);

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ 2981:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(2947);
var fails = __webpack_require__(2948);
var createElement = __webpack_require__(2982);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ 3153:
/***/ ((module) => {

// IEEE754 conversions based on https://github.com/feross/ieee754
var $Array = Array;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

var pack = function (number, mantissaLength, bytes) {
  var buffer = $Array(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number);
  // eslint-disable-next-line no-self-compare -- NaN check
  if (number != number || number === Infinity) {
    // eslint-disable-next-line no-self-compare -- NaN check
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor(log(number) / LN2);
    c = pow(2, -exponent);
    if (number * c < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }
  while (mantissaLength >= 8) {
    buffer[index++] = mantissa & 255;
    mantissa /= 256;
    mantissaLength -= 8;
  }
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  while (exponentLength > 0) {
    buffer[index++] = exponent & 255;
    exponent /= 256;
    exponentLength -= 8;
  }
  buffer[--index] |= sign * 128;
  return buffer;
};

var unpack = function (buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;
  while (nBits > 0) {
    exponent = exponent * 256 + buffer[index--];
    nBits -= 8;
  }
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  while (nBits > 0) {
    mantissa = mantissa * 256 + buffer[index--];
    nBits -= 8;
  }
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity : Infinity;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

module.exports = {
  pack: pack,
  unpack: unpack
};


/***/ }),

/***/ 2954:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(2955);
var fails = __webpack_require__(2948);
var classof = __webpack_require__(2956);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 3159:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(2961);
var isObject = __webpack_require__(2960);
var setPrototypeOf = __webpack_require__(3050);

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable(NewTarget = dummy.constructor) &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ 2990:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(2955);
var isCallable = __webpack_require__(2961);
var store = __webpack_require__(2976);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 3223:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(2944);
var uncurryThis = __webpack_require__(2955);
var hiddenKeys = __webpack_require__(2994);
var isObject = __webpack_require__(2960);
var hasOwn = __webpack_require__(2978);
var defineProperty = (__webpack_require__(2984).f);
var getOwnPropertyNamesModule = __webpack_require__(2997);
var getOwnPropertyNamesExternalModule = __webpack_require__(3022);
var isExtensible = __webpack_require__(3224);
var uid = __webpack_require__(2980);
var FREEZING = __webpack_require__(3226);

var REQUIRED = false;
var METADATA = uid('meta');
var id = 0;

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + id++, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey = function (it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!hasOwn(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!hasOwn(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);
  return it;
};

var enable = function () {
  meta.enable = function () { /* empty */ };
  REQUIRED = true;
  var getOwnPropertyNames = getOwnPropertyNamesModule.f;
  var splice = uncurryThis([].splice);
  var test = {};
  test[METADATA] = 1;

  // prevent exposing of metadata key
  if (getOwnPropertyNames(test).length) {
    getOwnPropertyNamesModule.f = function (it) {
      var result = getOwnPropertyNames(it);
      for (var i = 0, length = result.length; i < length; i++) {
        if (result[i] === METADATA) {
          splice(result, i, 1);
          break;
        }
      } return result;
    };

    $({ target: 'Object', stat: true, forced: true }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};

var meta = module.exports = {
  enable: enable,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;


/***/ }),

/***/ 2991:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_WEAK_MAP = __webpack_require__(2992);
var global = __webpack_require__(2945);
var uncurryThis = __webpack_require__(2955);
var isObject = __webpack_require__(2960);
var createNonEnumerableProperty = __webpack_require__(2983);
var hasOwn = __webpack_require__(2978);
var shared = __webpack_require__(2976);
var sharedKey = __webpack_require__(2993);
var hiddenKeys = __webpack_require__(2994);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = uncurryThis(store.get);
  var wmhas = uncurryThis(store.has);
  var wmset = uncurryThis(store.set);
  set = function (it, metadata) {
    if (wmhas(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget(store, it) || {};
  };
  has = function (it) {
    return wmhas(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 3061:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(2973);
var Iterators = __webpack_require__(3044);

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ 3034:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(2956);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es-x/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) == 'Array';
};


/***/ }),

/***/ 2961:
/***/ ((module) => {

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 3012:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(2955);
var fails = __webpack_require__(2948);
var isCallable = __webpack_require__(2961);
var classof = __webpack_require__(3013);
var getBuiltIn = __webpack_require__(2963);
var inspectSource = __webpack_require__(2990);

var noop = function () { /* empty */ };
var empty = [];
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ }),

/***/ 3327:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasOwn = __webpack_require__(2978);

module.exports = function (descriptor) {
  return descriptor !== undefined && (hasOwn(descriptor, 'value') || hasOwn(descriptor, 'writable'));
};


/***/ }),

/***/ 3007:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(2948);
var isCallable = __webpack_require__(2961);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 3155:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(2960);

var floor = Math.floor;

// `IsIntegralNumber` abstract operation
// https://tc39.es/ecma262/#sec-isintegralnumber
// eslint-disable-next-line es-x/no-number-isinteger -- safe
module.exports = Number.isInteger || function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),

/***/ 2960:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(2961);

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 2975:
/***/ ((module) => {

module.exports = false;


/***/ }),

/***/ 3081:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(2960);
var classof = __webpack_require__(2956);
var wellKnownSymbol = __webpack_require__(2973);

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};


/***/ }),

/***/ 2962:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(2963);
var isCallable = __webpack_require__(2961);
var isPrototypeOf = __webpack_require__(2964);
var USE_SYMBOL_AS_UID = __webpack_require__(2965);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 3137:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var bind = __webpack_require__(3031);
var call = __webpack_require__(2949);
var anObject = __webpack_require__(2986);
var tryToString = __webpack_require__(2971);
var isArrayIteratorMethod = __webpack_require__(3061);
var lengthOfArrayLike = __webpack_require__(3003);
var isPrototypeOf = __webpack_require__(2964);
var getIterator = __webpack_require__(3062);
var getIteratorMethod = __webpack_require__(3063);
var iteratorClose = __webpack_require__(3060);

var $TypeError = TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw $TypeError(tryToString(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf(ResultPrototype, result)) return result;
      } return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }

  next = iterator.next;
  while (!(step = call(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
  } return new Result(false);
};


/***/ }),

/***/ 3060:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(2949);
var anObject = __webpack_require__(2986);
var getMethod = __webpack_require__(2969);

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};


/***/ }),

/***/ 3047:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(2948);
var isCallable = __webpack_require__(2961);
var create = __webpack_require__(3015);
var getPrototypeOf = __webpack_require__(3048);
var defineBuiltIn = __webpack_require__(2987);
var wellKnownSymbol = __webpack_require__(2973);
var IS_PURE = __webpack_require__(2975);

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es-x/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ 3044:
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ 3003:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toLength = __webpack_require__(3004);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 2988:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(2948);
var isCallable = __webpack_require__(2961);
var hasOwn = __webpack_require__(2978);
var DESCRIPTORS = __webpack_require__(2947);
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(2989).CONFIGURABLE);
var inspectSource = __webpack_require__(2990);
var InternalStateModule = __webpack_require__(2991);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (String(name).slice(0, 7) === 'Symbol(') {
    name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    defineProperty(value, 'name', { value: name, configurable: true });
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ 3002:
/***/ ((module) => {

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es-x/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 3126:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(2945);
var bind = __webpack_require__(3031);
var getOwnPropertyDescriptor = (__webpack_require__(2946).f);
var macrotask = (__webpack_require__(3123).set);
var IS_IOS = __webpack_require__(3125);
var IS_IOS_PEBBLE = __webpack_require__(3127);
var IS_WEBOS_WEBKIT = __webpack_require__(3128);
var IS_NODE = __webpack_require__(3120);

var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var document = global.document;
var process = global.process;
var Promise = global.Promise;
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

var flush, head, last, notify, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify();
        else last = undefined;
        throw error;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
  if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true });
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (!IS_IOS_PEBBLE && Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    // workaround of WebKit ~ iOS Safari 10.1 bug
    promise.constructor = Promise;
    then = bind(promise.then, promise);
    notify = function () {
      then(flush);
    };
  // Node.js without promises
  } else if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessage
  // - onreadystatechange
  // - setTimeout
  } else {
    // strange IE + webpack dev server bug - use .bind(global)
    macrotask = bind(macrotask, global);
    notify = function () {
      macrotask(flush);
    };
  }
}

module.exports = queueMicrotask || function (fn) {
  var task = { fn: fn, next: undefined };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify();
  } last = task;
};


/***/ }),

/***/ 3036:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_SYMBOL = __webpack_require__(2966);

/* eslint-disable es-x/no-symbol -- safe */
module.exports = NATIVE_SYMBOL && !!Symbol['for'] && !!Symbol.keyFor;


/***/ }),

/***/ 2966:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es-x/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(2967);
var fails = __webpack_require__(2948);

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 3207:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(2948);
var wellKnownSymbol = __webpack_require__(2973);
var IS_PURE = __webpack_require__(2975);

var ITERATOR = wellKnownSymbol('iterator');

module.exports = !fails(function () {
  // eslint-disable-next-line unicorn/relative-url-style -- required for testing
  var url = new URL('b?a=1&b=2&c=3', 'http://a');
  var searchParams = url.searchParams;
  var result = '';
  url.pathname = 'c%20d';
  searchParams.forEach(function (value, key) {
    searchParams['delete']('b');
    result += key + value;
  });
  return (IS_PURE && !url.toJSON)
    || !searchParams.sort
    || url.href !== 'http://a/c%20d?a=1&c=3'
    || searchParams.get('c') !== '3'
    || String(new URLSearchParams('?a=1')) !== 'a=1'
    || !searchParams[ITERATOR]
    // throws in Edge
    || new URL('https://a@b').username !== 'a'
    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
    // not punycoded in Edge
    || new URL('http://тест').host !== 'xn--e1aybc'
    // not escaped in Chrome 62-
    || new URL('http://a#б').hash !== '#%D0%B1'
    // fails in Chrome 66-
    || result !== 'a1c3'
    // throws in Safari
    || new URL('http://x', undefined).host !== 'x';
});


/***/ }),

/***/ 2992:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(2945);
var isCallable = __webpack_require__(2961);
var inspectSource = __webpack_require__(2990);

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ 3135:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aCallable = __webpack_require__(2970);

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aCallable(resolve);
  this.reject = aCallable(reject);
};

// `NewPromiseCapability` abstract operation
// https://tc39.es/ecma262/#sec-newpromisecapability
module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ 3321:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isRegExp = __webpack_require__(3081);

var $TypeError = TypeError;

module.exports = function (it) {
  if (isRegExp(it)) {
    throw $TypeError("The method doesn't accept regular expressions");
  } return it;
};


/***/ }),

/***/ 3091:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(2947);
var uncurryThis = __webpack_require__(2955);
var call = __webpack_require__(2949);
var fails = __webpack_require__(2948);
var objectKeys = __webpack_require__(3017);
var getOwnPropertySymbolsModule = __webpack_require__(3006);
var propertyIsEnumerableModule = __webpack_require__(2951);
var toObject = __webpack_require__(2979);
var IndexedObject = __webpack_require__(2954);

// eslint-disable-next-line es-x/no-object-assign -- safe
var $assign = Object.assign;
// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
var defineProperty = Object.defineProperty;
var concat = uncurryThis([].concat);

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
module.exports = !$assign || fails(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1) return true;
  // should work with symbols and should have deterministic property order (V8 bug)
  var A = {};
  var B = {};
  // eslint-disable-next-line es-x/no-symbol -- safe
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || call(propertyIsEnumerable, S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ 3015:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(2986);
var definePropertiesModule = __webpack_require__(3016);
var enumBugKeys = __webpack_require__(3005);
var hiddenKeys = __webpack_require__(2994);
var html = __webpack_require__(3018);
var documentCreateElement = __webpack_require__(2982);
var sharedKey = __webpack_require__(2993);

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es-x/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),

/***/ 3016:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(2947);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(2985);
var definePropertyModule = __webpack_require__(2984);
var anObject = __webpack_require__(2986);
var toIndexedObject = __webpack_require__(2953);
var objectKeys = __webpack_require__(3017);

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es-x/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ 2984:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(2947);
var IE8_DOM_DEFINE = __webpack_require__(2981);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(2985);
var anObject = __webpack_require__(2986);
var toPropertyKey = __webpack_require__(2958);

var $TypeError = TypeError;
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 2946:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(2947);
var call = __webpack_require__(2949);
var propertyIsEnumerableModule = __webpack_require__(2951);
var createPropertyDescriptor = __webpack_require__(2952);
var toIndexedObject = __webpack_require__(2953);
var toPropertyKey = __webpack_require__(2958);
var hasOwn = __webpack_require__(2978);
var IE8_DOM_DEFINE = __webpack_require__(2981);

// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 3022:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es-x/no-object-getownpropertynames -- safe */
var classof = __webpack_require__(2956);
var toIndexedObject = __webpack_require__(2953);
var $getOwnPropertyNames = (__webpack_require__(2997).f);
var arraySlice = __webpack_require__(3023);

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return arraySlice(windowNames);
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && classof(it) == 'Window'
    ? getWindowNames(it)
    : $getOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ 2997:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(2998);
var enumBugKeys = __webpack_require__(3005);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 3006:
/***/ ((__unused_webpack_module, exports) => {

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 3048:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasOwn = __webpack_require__(2978);
var isCallable = __webpack_require__(2961);
var toObject = __webpack_require__(2979);
var sharedKey = __webpack_require__(2993);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(3049);

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es-x/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ }),

/***/ 3224:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(2948);
var isObject = __webpack_require__(2960);
var classof = __webpack_require__(2956);
var ARRAY_BUFFER_NON_EXTENSIBLE = __webpack_require__(3225);

// eslint-disable-next-line es-x/no-object-isextensible -- safe
var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails(function () { $isExtensible(1); });

// `Object.isExtensible` method
// https://tc39.es/ecma262/#sec-object.isextensible
module.exports = (FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE) ? function isExtensible(it) {
  if (!isObject(it)) return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == 'ArrayBuffer') return false;
  return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;


/***/ }),

/***/ 2964:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(2955);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 2998:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(2955);
var hasOwn = __webpack_require__(2978);
var toIndexedObject = __webpack_require__(2953);
var indexOf = (__webpack_require__(2999).indexOf);
var hiddenKeys = __webpack_require__(2994);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 3017:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(2998);
var enumBugKeys = __webpack_require__(3005);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es-x/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 2951:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 3050:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable no-proto -- safe */
var uncurryThis = __webpack_require__(2955);
var anObject = __webpack_require__(2986);
var aPossiblePrototype = __webpack_require__(3051);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es-x/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
    setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ 3232:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(2947);
var uncurryThis = __webpack_require__(2955);
var objectKeys = __webpack_require__(3017);
var toIndexedObject = __webpack_require__(2953);
var $propertyIsEnumerable = (__webpack_require__(2951).f);

var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
var push = uncurryThis([].push);

// `Object.{ entries, values }` methods implementation
var createMethod = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || propertyIsEnumerable(O, key)) {
        push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

module.exports = {
  // `Object.entries` method
  // https://tc39.es/ecma262/#sec-object.entries
  entries: createMethod(true),
  // `Object.values` method
  // https://tc39.es/ecma262/#sec-object.values
  values: createMethod(false)
};


/***/ }),

/***/ 3084:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(3014);
var classof = __webpack_require__(3013);

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ 2972:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(2949);
var isCallable = __webpack_require__(2961);
var isObject = __webpack_require__(2960);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 2996:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(2963);
var uncurryThis = __webpack_require__(2955);
var getOwnPropertyNamesModule = __webpack_require__(2997);
var getOwnPropertySymbolsModule = __webpack_require__(3006);
var anObject = __webpack_require__(2986);

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 3027:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(2945);

module.exports = global;


/***/ }),

/***/ 3130:
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};


/***/ }),

/***/ 3133:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(2945);
var NativePromiseConstructor = __webpack_require__(3132);
var isCallable = __webpack_require__(2961);
var isForced = __webpack_require__(3007);
var inspectSource = __webpack_require__(2990);
var wellKnownSymbol = __webpack_require__(2973);
var IS_BROWSER = __webpack_require__(3134);
var IS_PURE = __webpack_require__(2975);
var V8_VERSION = __webpack_require__(2967);

var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
var SPECIES = wellKnownSymbol('species');
var SUBCLASSING = false;
var NATIVE_PROMISE_REJECTION_EVENT = isCallable(global.PromiseRejectionEvent);

var FORCED_PROMISE_CONSTRUCTOR = isForced('Promise', function () {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
  // We can't detect it synchronously, so just check versions
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
  // We need Promise#{ catch, finally } in the pure version for preventing prototype pollution
  if (IS_PURE && !(NativePromisePrototype['catch'] && NativePromisePrototype['finally'])) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;
  // Detect correctness of subclassing with @@species support
  var promise = new NativePromiseConstructor(function (resolve) { resolve(1); });
  var FakePromise = function (exec) {
    exec(function () { /* empty */ }, function () { /* empty */ });
  };
  var constructor = promise.constructor = {};
  constructor[SPECIES] = FakePromise;
  SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;
  if (!SUBCLASSING) return true;
  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT;
});

module.exports = {
  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
  SUBCLASSING: SUBCLASSING
};


/***/ }),

/***/ 3132:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(2945);

module.exports = global.Promise;


/***/ }),

/***/ 3143:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var anObject = __webpack_require__(2986);
var isObject = __webpack_require__(2960);
var newPromiseCapability = __webpack_require__(3135);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ 3138:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NativePromiseConstructor = __webpack_require__(3132);
var checkCorrectnessOfIteration = __webpack_require__(3064);
var FORCED_PROMISE_CONSTRUCTOR = (__webpack_require__(3133).CONSTRUCTOR);

module.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function (iterable) {
  NativePromiseConstructor.all(iterable).then(undefined, function () { /* empty */ });
});


/***/ }),

/***/ 3312:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = (__webpack_require__(2984).f);

module.exports = function (Target, Source, key) {
  key in Target || defineProperty(Target, key, {
    configurable: true,
    get: function () { return Source[key]; },
    set: function (it) { Source[key] = it; }
  });
};


/***/ }),

/***/ 3131:
/***/ ((module) => {

var Queue = function () {
  this.head = null;
  this.tail = null;
};

Queue.prototype = {
  add: function (item) {
    var entry = { item: item, next: null };
    if (this.head) this.tail.next = entry;
    else this.head = entry;
    this.tail = entry;
  },
  get: function () {
    var entry = this.head;
    if (entry) {
      this.head = entry.next;
      if (this.tail === entry) this.tail = null;
      return entry.item;
    }
  }
};

module.exports = Queue;


/***/ }),

/***/ 3075:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(2949);
var anObject = __webpack_require__(2986);
var isCallable = __webpack_require__(2961);
var classof = __webpack_require__(2956);
var regexpExec = __webpack_require__(3067);

var $TypeError = TypeError;

// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (isCallable(exec)) {
    var result = call(exec, R, S);
    if (result !== null) anObject(result);
    return result;
  }
  if (classof(R) === 'RegExp') return call(regexpExec, R, S);
  throw $TypeError('RegExp#exec called on incompatible receiver');
};


/***/ }),

/***/ 3067:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
/* eslint-disable regexp/no-useless-quantifier -- testing */
var call = __webpack_require__(2949);
var uncurryThis = __webpack_require__(2955);
var toString = __webpack_require__(3021);
var regexpFlags = __webpack_require__(3068);
var stickyHelpers = __webpack_require__(3069);
var shared = __webpack_require__(2974);
var create = __webpack_require__(3015);
var getInternalState = (__webpack_require__(2991).get);
var UNSUPPORTED_DOT_ALL = __webpack_require__(3070);
var UNSUPPORTED_NCG = __webpack_require__(3071);

var nativeReplace = shared('native-string-replace', String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt = uncurryThis(''.charAt);
var indexOf = uncurryThis(''.indexOf);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  call(nativeExec, re1, 'a');
  call(nativeExec, re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;

if (PATCH) {
  patchedExec = function exec(string) {
    var re = this;
    var state = getInternalState(re);
    var str = toString(string);
    var raw = state.raw;
    var result, reCopy, lastIndex, match, i, object, group;

    if (raw) {
      raw.lastIndex = re.lastIndex;
      result = call(patchedExec, raw, str);
      re.lastIndex = raw.lastIndex;
      return result;
    }

    var groups = state.groups;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = call(regexpFlags, re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = replace(flags, 'y', '');
      if (indexOf(flags, 'g') === -1) {
        flags += 'g';
      }

      strCopy = stringSlice(str, re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = call(nativeExec, sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = stringSlice(match.input, charsAdded);
        match[0] = stringSlice(match[0], charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      call(nativeReplace, match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    if (match && groups) {
      match.groups = object = create(null);
      for (i = 0; i < groups.length; i++) {
        group = groups[i];
        object[group[0]] = match[group[1]];
      }
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ 3068:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(2986);

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.hasIndices) result += 'd';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ 3198:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(2949);
var hasOwn = __webpack_require__(2978);
var isPrototypeOf = __webpack_require__(2964);
var regExpFlags = __webpack_require__(3068);

var RegExpPrototype = RegExp.prototype;

module.exports = function (R) {
  var flags = R.flags;
  return flags === undefined && !('flags' in RegExpPrototype) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype, R)
    ? call(regExpFlags, R) : flags;
};


/***/ }),

/***/ 3069:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(2948);
var global = __webpack_require__(2945);

// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
var $RegExp = global.RegExp;

var UNSUPPORTED_Y = fails(function () {
  var re = $RegExp('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});

// UC Browser bug
// https://github.com/zloirock/core-js/issues/1008
var MISSED_STICKY = UNSUPPORTED_Y || fails(function () {
  return !$RegExp('a', 'y').sticky;
});

var BROKEN_CARET = UNSUPPORTED_Y || fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = $RegExp('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});

module.exports = {
  BROKEN_CARET: BROKEN_CARET,
  MISSED_STICKY: MISSED_STICKY,
  UNSUPPORTED_Y: UNSUPPORTED_Y
};


/***/ }),

/***/ 3070:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(2948);
var global = __webpack_require__(2945);

// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
var $RegExp = global.RegExp;

module.exports = fails(function () {
  var re = $RegExp('.', 's');
  return !(re.dotAll && re.exec('\n') && re.flags === 's');
});


/***/ }),

/***/ 3071:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(2948);
var global = __webpack_require__(2945);

// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
var $RegExp = global.RegExp;

module.exports = fails(function () {
  var re = $RegExp('(?<a>b)', 'g');
  return re.exec('b').groups.a !== 'b' ||
    'b'.replace(re, '$<a>c') !== 'bc';
});


/***/ }),

/***/ 2957:
/***/ ((module) => {

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 3121:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(2963);
var definePropertyModule = __webpack_require__(2984);
var wellKnownSymbol = __webpack_require__(2973);
var DESCRIPTORS = __webpack_require__(2947);

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ 3029:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = (__webpack_require__(2984).f);
var hasOwn = __webpack_require__(2978);
var wellKnownSymbol = __webpack_require__(2973);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn(target, TO_STRING_TAG)) {
    defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ 2993:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var shared = __webpack_require__(2974);
var uid = __webpack_require__(2980);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 2976:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(2945);
var defineGlobalProperty = __webpack_require__(2977);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || defineGlobalProperty(SHARED, {});

module.exports = store;


/***/ }),

/***/ 2974:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var IS_PURE = __webpack_require__(2975);
var store = __webpack_require__(2976);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.22.8',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.22.8/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 3082:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var anObject = __webpack_require__(2986);
var aConstructor = __webpack_require__(3011);
var wellKnownSymbol = __webpack_require__(2973);

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aConstructor(S);
};


/***/ }),

/***/ 3053:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(2955);
var toIntegerOrInfinity = __webpack_require__(3001);
var toString = __webpack_require__(3021);
var requireObjectCoercible = __webpack_require__(2957);

var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var stringSlice = uncurryThis(''.slice);

var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString(requireObjectCoercible($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ 3209:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
var uncurryThis = __webpack_require__(2955);

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'
var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
var baseMinusTMin = base - tMin;

var $RangeError = RangeError;
var exec = uncurryThis(regexSeparators.exec);
var floor = Math.floor;
var fromCharCode = String.fromCharCode;
var charCodeAt = uncurryThis(''.charCodeAt);
var join = uncurryThis([].join);
var push = uncurryThis([].push);
var replace = uncurryThis(''.replace);
var split = uncurryThis(''.split);
var toLowerCase = uncurryThis(''.toLowerCase);

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 */
var ucs2decode = function (string) {
  var output = [];
  var counter = 0;
  var length = string.length;
  while (counter < length) {
    var value = charCodeAt(string, counter++);
    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // It's a high surrogate, and there is a next character.
      var extra = charCodeAt(string, counter++);
      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
        push(output, ((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // It's an unmatched surrogate; only append this code unit, in case the
        // next code unit is the high surrogate of a surrogate pair.
        push(output, value);
        counter--;
      }
    } else {
      push(output, value);
    }
  }
  return output;
};

/**
 * Converts a digit/integer into a basic code point.
 */
var digitToBasic = function (digit) {
  //  0..25 map to ASCII a..z or A..Z
  // 26..35 map to ASCII 0..9
  return digit + 22 + 75 * (digit < 26);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 */
var adapt = function (delta, numPoints, firstTime) {
  var k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  while (delta > baseMinusTMin * tMax >> 1) {
    delta = floor(delta / baseMinusTMin);
    k += base;
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 */
var encode = function (input) {
  var output = [];

  // Convert the input in UCS-2 to an array of Unicode code points.
  input = ucs2decode(input);

  // Cache the length.
  var inputLength = input.length;

  // Initialize the state.
  var n = initialN;
  var delta = 0;
  var bias = initialBias;
  var i, currentValue;

  // Handle the basic code points.
  for (i = 0; i < input.length; i++) {
    currentValue = input[i];
    if (currentValue < 0x80) {
      push(output, fromCharCode(currentValue));
    }
  }

  var basicLength = output.length; // number of basic code points.
  var handledCPCount = basicLength; // number of code points that have been handled;

  // Finish the basic string with a delimiter unless it's empty.
  if (basicLength) {
    push(output, delimiter);
  }

  // Main encoding loop:
  while (handledCPCount < inputLength) {
    // All non-basic code points < n have been handled already. Find the next larger one:
    var m = maxInt;
    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }

    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
    var handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      throw $RangeError(OVERFLOW_ERROR);
    }

    delta += (m - n) * handledCPCountPlusOne;
    n = m;

    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue < n && ++delta > maxInt) {
        throw $RangeError(OVERFLOW_ERROR);
      }
      if (currentValue == n) {
        // Represent delta as a generalized variable-length integer.
        var q = delta;
        var k = base;
        while (true) {
          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
          if (q < t) break;
          var qMinusT = q - t;
          var baseMinusT = base - t;
          push(output, fromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
          q = floor(qMinusT / baseMinusT);
          k += base;
        }

        push(output, fromCharCode(digitToBasic(q)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        handledCPCount++;
      }
    }

    delta++;
    n++;
  }
  return join(output, '');
};

module.exports = function (input) {
  var encoded = [];
  var labels = split(replace(toLowerCase(input), regexSeparators, '\u002E'), '.');
  var i, label;
  for (i = 0; i < labels.length; i++) {
    label = labels[i];
    push(encoded, exec(regexNonASCII, label) ? 'xn--' + encode(label) : label);
  }
  return join(encoded, '.');
};


/***/ }),

/***/ 3334:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(3001);
var toString = __webpack_require__(3021);
var requireObjectCoercible = __webpack_require__(2957);

var $RangeError = RangeError;

// `String.prototype.repeat` method implementation
// https://tc39.es/ecma262/#sec-string.prototype.repeat
module.exports = function repeat(count) {
  var str = toString(requireObjectCoercible(this));
  var result = '';
  var n = toIntegerOrInfinity(count);
  if (n < 0 || n == Infinity) throw $RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};


/***/ }),

/***/ 3246:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var PROPER_FUNCTION_NAME = (__webpack_require__(2989).PROPER);
var fails = __webpack_require__(2948);
var whitespaces = __webpack_require__(3245);

var non = '\u200B\u0085\u180E';

// check that a method works with the correct list
// of whitespaces and has a correct name
module.exports = function (METHOD_NAME) {
  return fails(function () {
    return !!whitespaces[METHOD_NAME]()
      || non[METHOD_NAME]() !== non
      || (PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME);
  });
};


/***/ }),

/***/ 3244:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(2955);
var requireObjectCoercible = __webpack_require__(2957);
var toString = __webpack_require__(3021);
var whitespaces = __webpack_require__(3245);

var replace = uncurryThis(''.replace);
var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = toString(requireObjectCoercible($this));
    if (TYPE & 1) string = replace(string, ltrim, '');
    if (TYPE & 2) string = replace(string, rtrim, '');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ 3028:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(2949);
var getBuiltIn = __webpack_require__(2963);
var wellKnownSymbol = __webpack_require__(2973);
var defineBuiltIn = __webpack_require__(2987);

module.exports = function () {
  var Symbol = getBuiltIn('Symbol');
  var SymbolPrototype = Symbol && Symbol.prototype;
  var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
  var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

  if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
    // `Symbol.prototype[@@toPrimitive]` method
    // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
    // eslint-disable-next-line no-unused-vars -- required for .length
    defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function (hint) {
      return call(valueOf, this);
    }, { arity: 1 });
  }
};


/***/ }),

/***/ 3123:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(2945);
var apply = __webpack_require__(3008);
var bind = __webpack_require__(3031);
var isCallable = __webpack_require__(2961);
var hasOwn = __webpack_require__(2978);
var fails = __webpack_require__(2948);
var html = __webpack_require__(3018);
var arraySlice = __webpack_require__(3010);
var createElement = __webpack_require__(2982);
var validateArgumentsLength = __webpack_require__(3124);
var IS_IOS = __webpack_require__(3125);
var IS_NODE = __webpack_require__(3120);

var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var Dispatch = global.Dispatch;
var Function = global.Function;
var MessageChannel = global.MessageChannel;
var String = global.String;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var location, defer, channel, port;

try {
  // Deno throws a ReferenceError on `location` access without `--location` flag
  location = global.location;
} catch (error) { /* empty */ }

var run = function (id) {
  if (hasOwn(queue, id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global.postMessage(String(id), location.protocol + '//' + location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(handler) {
    validateArgumentsLength(arguments.length, 1);
    var fn = isCallable(handler) ? handler : Function(handler);
    var args = arraySlice(arguments, 1);
    queue[++counter] = function () {
      apply(fn, undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (IS_NODE) {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind(port.postMessage, port);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    global.addEventListener &&
    isCallable(global.postMessage) &&
    !global.importScripts &&
    location && location.protocol !== 'file:' &&
    !fails(post)
  ) {
    defer = post;
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};


/***/ }),

/***/ 3333:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(2955);

// `thisNumberValue` abstract operation
// https://tc39.es/ecma262/#sec-thisnumbervalue
module.exports = uncurryThis(1.0.valueOf);


/***/ }),

/***/ 3000:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(3001);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 3165:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPrimitive = __webpack_require__(2959);

var $TypeError = TypeError;

// `ToBigInt` abstract operation
// https://tc39.es/ecma262/#sec-tobigint
module.exports = function (argument) {
  var prim = toPrimitive(argument, 'number');
  if (typeof prim == 'number') throw $TypeError("Can't convert number to bigint");
  // eslint-disable-next-line es-x/no-bigint -- safe
  return BigInt(prim);
};


/***/ }),

/***/ 3152:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(3001);
var toLength = __webpack_require__(3004);

var $RangeError = RangeError;

// `ToIndex` abstract operation
// https://tc39.es/ecma262/#sec-toindex
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toIntegerOrInfinity(it);
  var length = toLength(number);
  if (number !== length) throw $RangeError('Wrong length or index');
  return length;
};


/***/ }),

/***/ 2953:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(2954);
var requireObjectCoercible = __webpack_require__(2957);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 3001:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trunc = __webpack_require__(3002);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 3004:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(3001);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 2979:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var requireObjectCoercible = __webpack_require__(2957);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 3156:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPositiveInteger = __webpack_require__(3157);

var $RangeError = RangeError;

module.exports = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw $RangeError('Wrong offset');
  return offset;
};


/***/ }),

/***/ 3157:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(3001);

var $RangeError = RangeError;

module.exports = function (it) {
  var result = toIntegerOrInfinity(it);
  if (result < 0) throw $RangeError("The argument can't be less than 0");
  return result;
};


/***/ }),

/***/ 2959:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(2949);
var isObject = __webpack_require__(2960);
var isSymbol = __webpack_require__(2962);
var getMethod = __webpack_require__(2969);
var ordinaryToPrimitive = __webpack_require__(2972);
var wellKnownSymbol = __webpack_require__(2973);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 2958:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPrimitive = __webpack_require__(2959);
var isSymbol = __webpack_require__(2962);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 3014:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(2973);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 3021:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(3013);

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ 2971:
/***/ ((module) => {

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 3146:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var global = __webpack_require__(2945);
var call = __webpack_require__(2949);
var DESCRIPTORS = __webpack_require__(2947);
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__(3147);
var ArrayBufferViewCore = __webpack_require__(3148);
var ArrayBufferModule = __webpack_require__(3150);
var anInstance = __webpack_require__(3122);
var createPropertyDescriptor = __webpack_require__(2952);
var createNonEnumerableProperty = __webpack_require__(2983);
var isIntegralNumber = __webpack_require__(3155);
var toLength = __webpack_require__(3004);
var toIndex = __webpack_require__(3152);
var toOffset = __webpack_require__(3156);
var toPropertyKey = __webpack_require__(2958);
var hasOwn = __webpack_require__(2978);
var classof = __webpack_require__(3013);
var isObject = __webpack_require__(2960);
var isSymbol = __webpack_require__(2962);
var create = __webpack_require__(3015);
var isPrototypeOf = __webpack_require__(2964);
var setPrototypeOf = __webpack_require__(3050);
var getOwnPropertyNames = (__webpack_require__(2997).f);
var typedArrayFrom = __webpack_require__(3158);
var forEach = (__webpack_require__(3030).forEach);
var setSpecies = __webpack_require__(3121);
var definePropertyModule = __webpack_require__(2984);
var getOwnPropertyDescriptorModule = __webpack_require__(2946);
var InternalStateModule = __webpack_require__(2991);
var inheritIfRequired = __webpack_require__(3159);

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var round = Math.round;
var RangeError = global.RangeError;
var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var ArrayBufferPrototype = ArrayBuffer.prototype;
var DataView = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore.TypedArray;
var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var isTypedArray = ArrayBufferViewCore.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';

var fromList = function (C, list) {
  aTypedArrayConstructor(C);
  var index = 0;
  var length = list.length;
  var result = new C(length);
  while (length > index) result[index] = list[index++];
  return result;
};

var addGetter = function (it, key) {
  nativeDefineProperty(it, key, { get: function () {
    return getInternalState(this)[key];
  } });
};

var isArrayBuffer = function (it) {
  var klass;
  return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
};

var isTypedArrayIndex = function (target, key) {
  return isTypedArray(target)
    && !isSymbol(key)
    && key in target
    && isIntegralNumber(+key)
    && key >= 0;
};

var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
  key = toPropertyKey(key);
  return isTypedArrayIndex(target, key)
    ? createPropertyDescriptor(2, target[key])
    : nativeGetOwnPropertyDescriptor(target, key);
};

var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
  key = toPropertyKey(key);
  if (isTypedArrayIndex(target, key)
    && isObject(descriptor)
    && hasOwn(descriptor, 'value')
    && !hasOwn(descriptor, 'get')
    && !hasOwn(descriptor, 'set')
    // TODO: add validation descriptor w/o calling accessors
    && !descriptor.configurable
    && (!hasOwn(descriptor, 'writable') || descriptor.writable)
    && (!hasOwn(descriptor, 'enumerable') || descriptor.enumerable)
  ) {
    target[key] = descriptor.value;
    return target;
  } return nativeDefineProperty(target, key, descriptor);
};

if (DESCRIPTORS) {
  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule.f = wrappedDefineProperty;
    addGetter(TypedArrayPrototype, 'buffer');
    addGetter(TypedArrayPrototype, 'byteOffset');
    addGetter(TypedArrayPrototype, 'byteLength');
    addGetter(TypedArrayPrototype, 'length');
  }

  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });

  module.exports = function (TYPE, wrapper, CLAMPED) {
    var BYTES = TYPE.match(/\d+$/)[0] / 8;
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + TYPE;
    var SETTER = 'set' + TYPE;
    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};

    var getter = function (that, index) {
      var data = getInternalState(that);
      return data.view[GETTER](index * BYTES + data.byteOffset, true);
    };

    var setter = function (that, index, value) {
      var data = getInternalState(that);
      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
    };

    var addElement = function (that, index) {
      nativeDefineProperty(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
        anInstance(that, TypedArrayConstructorPrototype);
        var index = 0;
        var byteOffset = 0;
        var buffer, byteLength, length;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new ArrayBuffer(byteLength);
        } else if (isArrayBuffer(data)) {
          buffer = data;
          byteOffset = toOffset(offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (isTypedArray(data)) {
          return fromList(TypedArrayConstructor, data);
        } else {
          return call(typedArrayFrom, TypedArrayConstructor, data);
        }
        setInternalState(that, {
          buffer: buffer,
          byteOffset: byteOffset,
          byteLength: byteLength,
          length: length,
          view: new DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
        anInstance(dummy, TypedArrayConstructorPrototype);
        return inheritIfRequired(function () {
          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
          if (isArrayBuffer(data)) return $length !== undefined
            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
            : typedArrayOffset !== undefined
              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
              : new NativeTypedArrayConstructor(data);
          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
          return call(typedArrayFrom, TypedArrayConstructor, data);
        }(), dummy, TypedArrayConstructor);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
        if (!(key in TypedArrayConstructor)) {
          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
        }
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }

    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
    }

    createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_CONSTRUCTOR, TypedArrayConstructor);

    if (TYPED_ARRAY_TAG) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
    }

    var FORCED = TypedArrayConstructor != NativeTypedArrayConstructor;

    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

    $({ global: true, constructor: true, forced: FORCED, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }

    setSpecies(CONSTRUCTOR_NAME);
  };
} else module.exports = function () { /* empty */ };


/***/ }),

/***/ 3147:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable no-new -- required for testing */
var global = __webpack_require__(2945);
var fails = __webpack_require__(2948);
var checkCorrectnessOfIteration = __webpack_require__(3064);
var NATIVE_ARRAY_BUFFER_VIEWS = (__webpack_require__(3148).NATIVE_ARRAY_BUFFER_VIEWS);

var ArrayBuffer = global.ArrayBuffer;
var Int8Array = global.Int8Array;

module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
  Int8Array(1);
}) || !fails(function () {
  new Int8Array(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array();
  new Int8Array(null);
  new Int8Array(1.5);
  new Int8Array(iterable);
}, true) || fails(function () {
  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
  return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
});


/***/ }),

/***/ 3167:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFromConstructorAndList = __webpack_require__(3168);
var typedArraySpeciesConstructor = __webpack_require__(3169);

module.exports = function (instance, list) {
  return arrayFromConstructorAndList(typedArraySpeciesConstructor(instance), list);
};


/***/ }),

/***/ 3158:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var bind = __webpack_require__(3031);
var call = __webpack_require__(2949);
var aConstructor = __webpack_require__(3011);
var toObject = __webpack_require__(2979);
var lengthOfArrayLike = __webpack_require__(3003);
var getIterator = __webpack_require__(3062);
var getIteratorMethod = __webpack_require__(3063);
var isArrayIteratorMethod = __webpack_require__(3061);
var aTypedArrayConstructor = (__webpack_require__(3148).aTypedArrayConstructor);

module.exports = function from(source /* , mapfn, thisArg */) {
  var C = aConstructor(this);
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, step, iterator, next;
  if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = getIterator(O, iteratorMethod);
    next = iterator.next;
    O = [];
    while (!(step = call(next, iterator)).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bind(mapfn, arguments[2]);
  }
  length = lengthOfArrayLike(O);
  result = new (aTypedArrayConstructor(C))(length);
  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }
  return result;
};


/***/ }),

/***/ 3169:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ArrayBufferViewCore = __webpack_require__(3148);
var speciesConstructor = __webpack_require__(3082);

var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;

// a part of `TypedArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#typedarray-species-create
module.exports = function (originalArray) {
  return aTypedArrayConstructor(speciesConstructor(originalArray, originalArray[TYPED_ARRAY_CONSTRUCTOR]));
};


/***/ }),

/***/ 2980:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(2955);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 2965:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es-x/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(2966);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 2985:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(2947);
var fails = __webpack_require__(2948);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});


/***/ }),

/***/ 3124:
/***/ ((module) => {

var $TypeError = TypeError;

module.exports = function (passed, required) {
  if (passed < required) throw $TypeError('Not enough arguments');
  return passed;
};


/***/ }),

/***/ 3025:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(2973);

exports.f = wellKnownSymbol;


/***/ }),

/***/ 2973:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(2945);
var shared = __webpack_require__(2974);
var hasOwn = __webpack_require__(2978);
var uid = __webpack_require__(2980);
var NATIVE_SYMBOL = __webpack_require__(2966);
var USE_SYMBOL_AS_UID = __webpack_require__(2965);

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var symbolFor = Symbol && Symbol['for'];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    var description = 'Symbol.' + name;
    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 3245:
/***/ ((module) => {

// a string of all valid unicode whitespaces
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ 3078:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var fails = __webpack_require__(2948);
var isArray = __webpack_require__(3034);
var isObject = __webpack_require__(2960);
var toObject = __webpack_require__(2979);
var lengthOfArrayLike = __webpack_require__(3003);
var doesNotExceedSafeInteger = __webpack_require__(3079);
var createProperty = __webpack_require__(3024);
var arraySpeciesCreate = __webpack_require__(3032);
var arrayMethodHasSpeciesSupport = __webpack_require__(3077);
var wellKnownSymbol = __webpack_require__(2973);
var V8_VERSION = __webpack_require__(2967);

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike(E);
        doesNotExceedSafeInteger(n + len);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        doesNotExceedSafeInteger(n + 1);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ 3201:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(2944);
var fill = __webpack_require__(3154);
var addToUnscopables = __webpack_require__(3043);

// `Array.prototype.fill` method
// https://tc39.es/ecma262/#sec-array.prototype.fill
$({ target: 'Array', proto: true }, {
  fill: fill
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('fill');


/***/ }),

/***/ 3240:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var $filter = (__webpack_require__(3030).filter);
var arrayMethodHasSpeciesSupport = __webpack_require__(3077);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');

// `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ 3057:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(2944);
var from = __webpack_require__(3058);
var checkCorrectnessOfIteration = __webpack_require__(3064);

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  // eslint-disable-next-line es-x/no-array-from -- required for testing
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.es/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});


/***/ }),

/***/ 3233:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var $includes = (__webpack_require__(2999).includes);
var fails = __webpack_require__(2948);
var addToUnscopables = __webpack_require__(3043);

// FF99+ bug
var BROKEN_ON_SPARSE = fails(function () {
  return !Array(1).includes();
});

// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ }),

/***/ 3042:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIndexedObject = __webpack_require__(2953);
var addToUnscopables = __webpack_require__(3043);
var Iterators = __webpack_require__(3044);
var InternalStateModule = __webpack_require__(2991);
var defineProperty = (__webpack_require__(2984).f);
var defineIterator = __webpack_require__(3045);
var IS_PURE = __webpack_require__(2975);
var DESCRIPTORS = __webpack_require__(2947);

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

// V8 ~ Chrome 45- bug
if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
  defineProperty(values, 'name', { value: 'values' });
} catch (error) { /* empty */ }


/***/ }),

/***/ 3242:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var uncurryThis = __webpack_require__(2955);
var IndexedObject = __webpack_require__(2954);
var toIndexedObject = __webpack_require__(2953);
var arrayMethodIsStrict = __webpack_require__(3087);

var un$Join = uncurryThis([].join);

var ES3_STRINGS = IndexedObject != Object;
var STRICT_METHOD = arrayMethodIsStrict('join', ',');

// `Array.prototype.join` method
// https://tc39.es/ecma262/#sec-array.prototype.join
$({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {
  join: function join(separator) {
    return un$Join(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),

/***/ 3089:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var $map = (__webpack_require__(3030).map);
var arrayMethodHasSpeciesSupport = __webpack_require__(3077);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');

// `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ 3076:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var isArray = __webpack_require__(3034);
var isConstructor = __webpack_require__(3012);
var isObject = __webpack_require__(2960);
var toAbsoluteIndex = __webpack_require__(3000);
var lengthOfArrayLike = __webpack_require__(3003);
var toIndexedObject = __webpack_require__(2953);
var createProperty = __webpack_require__(3024);
var wellKnownSymbol = __webpack_require__(2973);
var arrayMethodHasSpeciesSupport = __webpack_require__(3077);
var un$Slice = __webpack_require__(3010);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');

var SPECIES = wellKnownSymbol('species');
var $Array = Array;
var max = Math.max;

// `Array.prototype.slice` method
// https://tc39.es/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = lengthOfArrayLike(O);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (isConstructor(Constructor) && (Constructor === $Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === $Array || Constructor === undefined) {
        return un$Slice(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? $Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});


/***/ }),

/***/ 3249:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var uncurryThis = __webpack_require__(2955);
var aCallable = __webpack_require__(2970);
var toObject = __webpack_require__(2979);
var lengthOfArrayLike = __webpack_require__(3003);
var deletePropertyOrThrow = __webpack_require__(3162);
var toString = __webpack_require__(3021);
var fails = __webpack_require__(2948);
var internalSort = __webpack_require__(3188);
var arrayMethodIsStrict = __webpack_require__(3087);
var FF = __webpack_require__(3189);
var IE_OR_EDGE = __webpack_require__(3190);
var V8 = __webpack_require__(2967);
var WEBKIT = __webpack_require__(3191);

var test = [];
var un$Sort = uncurryThis(test.sort);
var push = uncurryThis(test.push);

// IE8-
var FAILS_ON_UNDEFINED = fails(function () {
  test.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function () {
  test.sort(null);
});
// Old WebKit
var STRICT_METHOD = arrayMethodIsStrict('sort');

var STABLE_SORT = !fails(function () {
  // feature detection can be too slow, so check engines versions
  if (V8) return V8 < 70;
  if (FF && FF > 3) return;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 603;

  var result = '';
  var code, chr, value, index;

  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)
  for (code = 65; code < 76; code++) {
    chr = String.fromCharCode(code);

    switch (code) {
      case 66: case 69: case 70: case 72: value = 3; break;
      case 68: case 71: value = 4; break;
      default: value = 2;
    }

    for (index = 0; index < 47; index++) {
      test.push({ k: chr + index, v: value });
    }
  }

  test.sort(function (a, b) { return b.v - a.v; });

  for (index = 0; index < test.length; index++) {
    chr = test[index].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr) result += chr;
  }

  return result !== 'DGBEFHACIJK';
});

var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;

var getSortCompare = function (comparefn) {
  return function (x, y) {
    if (y === undefined) return -1;
    if (x === undefined) return 1;
    if (comparefn !== undefined) return +comparefn(x, y) || 0;
    return toString(x) > toString(y) ? 1 : -1;
  };
};

// `Array.prototype.sort` method
// https://tc39.es/ecma262/#sec-array.prototype.sort
$({ target: 'Array', proto: true, forced: FORCED }, {
  sort: function sort(comparefn) {
    if (comparefn !== undefined) aCallable(comparefn);

    var array = toObject(this);

    if (STABLE_SORT) return comparefn === undefined ? un$Sort(array) : un$Sort(array, comparefn);

    var items = [];
    var arrayLength = lengthOfArrayLike(array);
    var itemsLength, index;

    for (index = 0; index < arrayLength; index++) {
      if (index in array) push(items, array[index]);
    }

    internalSort(items, getSortCompare(comparefn));

    itemsLength = items.length;
    index = 0;

    while (index < itemsLength) array[index] = items[index++];
    while (index < arrayLength) deletePropertyOrThrow(array, index++);

    return array;
  }
});


/***/ }),

/***/ 3330:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var toObject = __webpack_require__(2979);
var toAbsoluteIndex = __webpack_require__(3000);
var toIntegerOrInfinity = __webpack_require__(3001);
var lengthOfArrayLike = __webpack_require__(3003);
var doesNotExceedSafeInteger = __webpack_require__(3079);
var arraySpeciesCreate = __webpack_require__(3032);
var createProperty = __webpack_require__(3024);
var deletePropertyOrThrow = __webpack_require__(3162);
var arrayMethodHasSpeciesSupport = __webpack_require__(3077);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');

var max = Math.max;
var min = Math.min;

// `Array.prototype.splice` method
// https://tc39.es/ecma262/#sec-array.prototype.splice
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  splice: function splice(start, deleteCount /* , ...items */) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
    }
    doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];
        else deletePropertyOrThrow(O, to);
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) deletePropertyOrThrow(O, k - 1);
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];
        else deletePropertyOrThrow(O, to);
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});


/***/ }),

/***/ 3065:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(2947);
var FUNCTION_NAME_EXISTS = (__webpack_require__(2989).EXISTS);
var uncurryThis = __webpack_require__(2955);
var defineProperty = (__webpack_require__(2984).f);

var FunctionPrototype = Function.prototype;
var functionToString = uncurryThis(FunctionPrototype.toString);
var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
var regExpExec = uncurryThis(nameRE.exec);
var NAME = 'name';

// Function instances `.name` property
// https://tc39.es/ecma262/#sec-function-instances-name
if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
  defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function () {
      try {
        return regExpExec(nameRE, functionToString(this))[1];
      } catch (error) {
        return '';
      }
    }
  });
}


/***/ }),

/***/ 3038:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(2944);
var getBuiltIn = __webpack_require__(2963);
var apply = __webpack_require__(3008);
var call = __webpack_require__(2949);
var uncurryThis = __webpack_require__(2955);
var fails = __webpack_require__(2948);
var isArray = __webpack_require__(3034);
var isCallable = __webpack_require__(2961);
var isObject = __webpack_require__(2960);
var isSymbol = __webpack_require__(2962);
var arraySlice = __webpack_require__(3010);
var NATIVE_SYMBOL = __webpack_require__(2966);

var $stringify = getBuiltIn('JSON', 'stringify');
var exec = uncurryThis(/./.exec);
var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var replace = uncurryThis(''.replace);
var numberToString = uncurryThis(1.0.toString);

var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;

var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function () {
  var symbol = getBuiltIn('Symbol')();
  // MS Edge converts symbol values to JSON as {}
  return $stringify([symbol]) != '[null]'
    // WebKit converts symbol values to JSON as null
    || $stringify({ a: symbol }) != '{}'
    // V8 throws on boxed symbols
    || $stringify(Object(symbol)) != '{}';
});

// https://github.com/tc39/proposal-well-formed-stringify
var ILL_FORMED_UNICODE = fails(function () {
  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
    || $stringify('\uDEAD') !== '"\\udead"';
});

var stringifyWithSymbolsFix = function (it, replacer) {
  var args = arraySlice(arguments);
  var $replacer = replacer;
  if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
  if (!isArray(replacer)) replacer = function (key, value) {
    if (isCallable($replacer)) value = call($replacer, this, key, value);
    if (!isSymbol(value)) return value;
  };
  args[1] = replacer;
  return apply($stringify, null, args);
};

var fixIllFormed = function (match, offset, string) {
  var prev = charAt(string, offset - 1);
  var next = charAt(string, offset + 1);
  if ((exec(low, match) && !exec(hi, next)) || (exec(hi, match) && !exec(low, prev))) {
    return '\\u' + numberToString(charCodeAt(match, 0), 16);
  } return match;
};

if ($stringify) {
  // `JSON.stringify` method
  // https://tc39.es/ecma262/#sec-json.stringify
  $({ target: 'JSON', stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = arraySlice(arguments);
      var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
      return ILL_FORMED_UNICODE && typeof result == 'string' ? replace(result, tester, fixIllFormed) : result;
    }
  });
}


/***/ }),

/***/ 3238:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var collection = __webpack_require__(3222);
var collectionStrong = __webpack_require__(3227);

// `Map` constructor
// https://tc39.es/ecma262/#sec-map-objects
collection('Map', function (init) {
  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),

/***/ 3237:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(3238);


/***/ }),

/***/ 3341:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(2947);
var global = __webpack_require__(2945);
var uncurryThis = __webpack_require__(2955);
var isForced = __webpack_require__(3007);
var defineBuiltIn = __webpack_require__(2987);
var hasOwn = __webpack_require__(2978);
var inheritIfRequired = __webpack_require__(3159);
var isPrototypeOf = __webpack_require__(2964);
var isSymbol = __webpack_require__(2962);
var toPrimitive = __webpack_require__(2959);
var fails = __webpack_require__(2948);
var getOwnPropertyNames = (__webpack_require__(2997).f);
var getOwnPropertyDescriptor = (__webpack_require__(2946).f);
var defineProperty = (__webpack_require__(2984).f);
var thisNumberValue = __webpack_require__(3333);
var trim = (__webpack_require__(3244).trim);

var NUMBER = 'Number';
var NativeNumber = global[NUMBER];
var NumberPrototype = NativeNumber.prototype;
var TypeError = global.TypeError;
var arraySlice = uncurryThis(''.slice);
var charCodeAt = uncurryThis(''.charCodeAt);

// `ToNumeric` abstract operation
// https://tc39.es/ecma262/#sec-tonumeric
var toNumeric = function (value) {
  var primValue = toPrimitive(value, 'number');
  return typeof primValue == 'bigint' ? primValue : toNumber(primValue);
};

// `ToNumber` abstract operation
// https://tc39.es/ecma262/#sec-tonumber
var toNumber = function (argument) {
  var it = toPrimitive(argument, 'number');
  var first, third, radix, maxCode, digits, length, index, code;
  if (isSymbol(it)) throw TypeError('Cannot convert a Symbol value to a number');
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = charCodeAt(it, 0);
    if (first === 43 || first === 45) {
      third = charCodeAt(it, 2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (charCodeAt(it, 1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
        default: return +it;
      }
      digits = arraySlice(it, 2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = charCodeAt(digits, index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

// `Number` constructor
// https://tc39.es/ecma262/#sec-number-constructor
if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
    var dummy = this;
    // check on 1..constructor(foo) case
    return isPrototypeOf(NumberPrototype, dummy) && fails(function () { thisNumberValue(dummy); })
      ? inheritIfRequired(Object(n), dummy, NumberWrapper) : n;
  };
  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,' +
    // ESNext
    'fromString,range'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (hasOwn(NativeNumber, key = keys[j]) && !hasOwn(NumberWrapper, key)) {
      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
    }
  }
  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  defineBuiltIn(global, NUMBER, NumberWrapper, { constructor: true });
}


/***/ }),

/***/ 3340:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(2944);
var isIntegralNumber = __webpack_require__(3155);

// `Number.isInteger` method
// https://tc39.es/ecma262/#sec-number.isinteger
$({ target: 'Number', stat: true }, {
  isInteger: isIntegralNumber
});


/***/ }),

/***/ 3332:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var uncurryThis = __webpack_require__(2955);
var toIntegerOrInfinity = __webpack_require__(3001);
var thisNumberValue = __webpack_require__(3333);
var $repeat = __webpack_require__(3334);
var fails = __webpack_require__(2948);

var $RangeError = RangeError;
var $String = String;
var floor = Math.floor;
var repeat = uncurryThis($repeat);
var stringSlice = uncurryThis(''.slice);
var un$ToFixed = uncurryThis(1.0.toFixed);

var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

var multiply = function (data, n, c) {
  var index = -1;
  var c2 = c;
  while (++index < 6) {
    c2 += n * data[index];
    data[index] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};

var divide = function (data, n) {
  var index = 6;
  var c = 0;
  while (--index >= 0) {
    c += data[index];
    data[index] = floor(c / n);
    c = (c % n) * 1e7;
  }
};

var dataToString = function (data) {
  var index = 6;
  var s = '';
  while (--index >= 0) {
    if (s !== '' || index === 0 || data[index] !== 0) {
      var t = $String(data[index]);
      s = s === '' ? t : s + repeat('0', 7 - t.length) + t;
    }
  } return s;
};

var FORCED = fails(function () {
  return un$ToFixed(0.00008, 3) !== '0.000' ||
    un$ToFixed(0.9, 0) !== '1' ||
    un$ToFixed(1.255, 2) !== '1.25' ||
    un$ToFixed(1000000000000000128.0, 0) !== '1000000000000000128';
}) || !fails(function () {
  // V8 ~ Android 4.3-
  un$ToFixed({});
});

// `Number.prototype.toFixed` method
// https://tc39.es/ecma262/#sec-number.prototype.tofixed
$({ target: 'Number', proto: true, forced: FORCED }, {
  toFixed: function toFixed(fractionDigits) {
    var number = thisNumberValue(this);
    var fractDigits = toIntegerOrInfinity(fractionDigits);
    var data = [0, 0, 0, 0, 0, 0];
    var sign = '';
    var result = '0';
    var e, z, j, k;

    // TODO: ES2018 increased the maximum number of fraction digits to 100, need to improve the implementation
    if (fractDigits < 0 || fractDigits > 20) throw $RangeError('Incorrect fraction digits');
    // eslint-disable-next-line no-self-compare -- NaN check
    if (number != number) return 'NaN';
    if (number <= -1e21 || number >= 1e21) return $String(number);
    if (number < 0) {
      sign = '-';
      number = -number;
    }
    if (number > 1e-21) {
      e = log(number * pow(2, 69, 1)) - 69;
      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(data, 0, z);
        j = fractDigits;
        while (j >= 7) {
          multiply(data, 1e7, 0);
          j -= 7;
        }
        multiply(data, pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(data, 1 << 23);
          j -= 23;
        }
        divide(data, 1 << j);
        multiply(data, 1, 1);
        divide(data, 2);
        result = dataToString(data);
      } else {
        multiply(data, 0, z);
        multiply(data, 1 << -e, 0);
        result = dataToString(data) + repeat('0', fractDigits);
      }
    }
    if (fractDigits > 0) {
      k = result.length;
      result = sign + (k <= fractDigits
        ? '0.' + repeat('0', fractDigits - k) + result
        : stringSlice(result, 0, k - fractDigits) + '.' + stringSlice(result, k - fractDigits));
    } else {
      result = sign + result;
    } return result;
  }
});


/***/ }),

/***/ 3090:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(2944);
var assign = __webpack_require__(3091);

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
// eslint-disable-next-line es-x/no-object-assign -- required for testing
$({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign }, {
  assign: assign
});


/***/ }),

/***/ 3231:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(2944);
var $entries = (__webpack_require__(3232).entries);

// `Object.entries` method
// https://tc39.es/ecma262/#sec-object.entries
$({ target: 'Object', stat: true }, {
  entries: function entries(O) {
    return $entries(O);
  }
});


/***/ }),

/***/ 3228:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(2944);
var fails = __webpack_require__(2948);
var toIndexedObject = __webpack_require__(2953);
var nativeGetOwnPropertyDescriptor = (__webpack_require__(2946).f);
var DESCRIPTORS = __webpack_require__(2947);

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetOwnPropertyDescriptor(1); });
var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});


/***/ }),

/***/ 3241:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(2944);
var DESCRIPTORS = __webpack_require__(2947);
var ownKeys = __webpack_require__(2996);
var toIndexedObject = __webpack_require__(2953);
var getOwnPropertyDescriptorModule = __webpack_require__(2946);
var createProperty = __webpack_require__(3024);

// `Object.getOwnPropertyDescriptors` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }
    return result;
  }
});


/***/ }),

/***/ 3219:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(2944);
var fails = __webpack_require__(2948);
var getOwnPropertyNames = (__webpack_require__(3022).f);

// eslint-disable-next-line es-x/no-object-getownpropertynames -- required for testing
var FAILS_ON_PRIMITIVES = fails(function () { return !Object.getOwnPropertyNames(1); });

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  getOwnPropertyNames: getOwnPropertyNames
});


/***/ }),

/***/ 3039:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(2944);
var NATIVE_SYMBOL = __webpack_require__(2966);
var fails = __webpack_require__(2948);
var getOwnPropertySymbolsModule = __webpack_require__(3006);
var toObject = __webpack_require__(2979);

// V8 ~ Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FORCED = !NATIVE_SYMBOL || fails(function () { getOwnPropertySymbolsModule.f(1); });

// `Object.getOwnPropertySymbols` method
// https://tc39.es/ecma262/#sec-object.getownpropertysymbols
$({ target: 'Object', stat: true, forced: FORCED }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
  }
});


/***/ }),

/***/ 3088:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(2944);
var fails = __webpack_require__(2948);
var toObject = __webpack_require__(2979);
var nativeGetPrototypeOf = __webpack_require__(3048);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(3049);

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetPrototypeOf(1); });

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});



/***/ }),

/***/ 3215:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(2944);
var toObject = __webpack_require__(2979);
var nativeKeys = __webpack_require__(3017);
var fails = __webpack_require__(2948);

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ 3083:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var TO_STRING_TAG_SUPPORT = __webpack_require__(3014);
var defineBuiltIn = __webpack_require__(2987);
var toString = __webpack_require__(3084);

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  defineBuiltIn(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ 3136:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var call = __webpack_require__(2949);
var aCallable = __webpack_require__(2970);
var newPromiseCapabilityModule = __webpack_require__(3135);
var perform = __webpack_require__(3130);
var iterate = __webpack_require__(3137);
var PROMISE_STATICS_INCORRECT_ITERATION = __webpack_require__(3138);

// `Promise.all` method
// https://tc39.es/ecma262/#sec-promise.all
$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aCallable(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        remaining++;
        call($promiseResolve, C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ 3139:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var IS_PURE = __webpack_require__(2975);
var FORCED_PROMISE_CONSTRUCTOR = (__webpack_require__(3133).CONSTRUCTOR);
var NativePromiseConstructor = __webpack_require__(3132);
var getBuiltIn = __webpack_require__(2963);
var isCallable = __webpack_require__(2961);
var defineBuiltIn = __webpack_require__(2987);

var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;

// `Promise.prototype.catch` method
// https://tc39.es/ecma262/#sec-promise.prototype.catch
$({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
  'catch': function (onRejected) {
    return this.then(undefined, onRejected);
  }
});

// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
if (!IS_PURE && isCallable(NativePromiseConstructor)) {
  var method = getBuiltIn('Promise').prototype['catch'];
  if (NativePromisePrototype['catch'] !== method) {
    defineBuiltIn(NativePromisePrototype, 'catch', method, { unsafe: true });
  }
}


/***/ }),

/***/ 3119:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var IS_PURE = __webpack_require__(2975);
var IS_NODE = __webpack_require__(3120);
var global = __webpack_require__(2945);
var call = __webpack_require__(2949);
var defineBuiltIn = __webpack_require__(2987);
var setPrototypeOf = __webpack_require__(3050);
var setToStringTag = __webpack_require__(3029);
var setSpecies = __webpack_require__(3121);
var aCallable = __webpack_require__(2970);
var isCallable = __webpack_require__(2961);
var isObject = __webpack_require__(2960);
var anInstance = __webpack_require__(3122);
var speciesConstructor = __webpack_require__(3082);
var task = (__webpack_require__(3123).set);
var microtask = __webpack_require__(3126);
var hostReportErrors = __webpack_require__(3129);
var perform = __webpack_require__(3130);
var Queue = __webpack_require__(3131);
var InternalStateModule = __webpack_require__(2991);
var NativePromiseConstructor = __webpack_require__(3132);
var PromiseConstructorDetection = __webpack_require__(3133);
var newPromiseCapabilityModule = __webpack_require__(3135);

var PROMISE = 'Promise';
var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var setInternalState = InternalStateModule.set;
var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
var PromiseConstructor = NativePromiseConstructor;
var PromisePrototype = NativePromisePrototype;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;

var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;

var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && isCallable(then = it.then) ? then : false;
};

var callReaction = function (reaction, state) {
  var value = state.value;
  var ok = state.state == FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve = reaction.resolve;
  var reject = reaction.reject;
  var domain = reaction.domain;
  var result, then, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true) result = value;
      else {
        if (domain) domain.enter();
        result = handler(value); // can throw
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject(TypeError('Promise-chain cycle'));
      } else if (then = isThenable(result)) {
        call(then, result, resolve, reject);
      } else resolve(result);
    } else reject(value);
  } catch (error) {
    if (domain && !exited) domain.exit();
    reject(error);
  }
};

var notify = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  microtask(function () {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global['on' + name])) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (state) {
  call(task, global, function () {
    var promise = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (state) {
  call(task, global, function () {
    var promise = state.facade;
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};

var internalReject = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};

var internalResolve = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          call(then, value,
            bind(internalResolve, wrapper, state),
            bind(internalReject, wrapper, state)
          );
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED_PROMISE_CONSTRUCTOR) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromisePrototype);
    aCallable(executor);
    call(Internal, this);
    var state = getInternalPromiseState(this);
    try {
      executor(bind(internalResolve, state), bind(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };

  PromisePrototype = PromiseConstructor.prototype;

  // eslint-disable-next-line no-unused-vars -- required for `.length`
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue(),
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };

  // `Promise.prototype.then` method
  // https://tc39.es/ecma262/#sec-promise.prototype.then
  Internal.prototype = defineBuiltIn(PromisePrototype, 'then', function then(onFulfilled, onRejected) {
    var state = getInternalPromiseState(this);
    var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
    state.parent = true;
    reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
    reaction.fail = isCallable(onRejected) && onRejected;
    reaction.domain = IS_NODE ? process.domain : undefined;
    if (state.state == PENDING) state.reactions.add(reaction);
    else microtask(function () {
      callReaction(reaction, state);
    });
    return reaction.promise;
  });

  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalPromiseState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, state);
    this.reject = bind(internalReject, state);
  };

  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
    nativeThen = NativePromisePrototype.then;

    if (!NATIVE_PROMISE_SUBCLASSING) {
      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
      defineBuiltIn(NativePromisePrototype, 'then', function then(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function (resolve, reject) {
          call(nativeThen, that, resolve, reject);
        }).then(onFulfilled, onRejected);
      // https://github.com/zloirock/core-js/issues/640
      }, { unsafe: true });
    }

    // make `.constructor === Promise` work for native promise-based APIs
    try {
      delete NativePromisePrototype.constructor;
    } catch (error) { /* empty */ }

    // make `instanceof Promise` work for native promise-based APIs
    if (setPrototypeOf) {
      setPrototypeOf(NativePromisePrototype, PromisePrototype);
    }
  }
}

$({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);


/***/ }),

/***/ 3118:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__(3119);
__webpack_require__(3136);
__webpack_require__(3139);
__webpack_require__(3140);
__webpack_require__(3141);
__webpack_require__(3142);


/***/ }),

/***/ 3140:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var call = __webpack_require__(2949);
var aCallable = __webpack_require__(2970);
var newPromiseCapabilityModule = __webpack_require__(3135);
var perform = __webpack_require__(3130);
var iterate = __webpack_require__(3137);
var PROMISE_STATICS_INCORRECT_ITERATION = __webpack_require__(3138);

// `Promise.race` method
// https://tc39.es/ecma262/#sec-promise.race
$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aCallable(C.resolve);
      iterate(iterable, function (promise) {
        call($promiseResolve, C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ 3141:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var call = __webpack_require__(2949);
var newPromiseCapabilityModule = __webpack_require__(3135);
var FORCED_PROMISE_CONSTRUCTOR = (__webpack_require__(3133).CONSTRUCTOR);

// `Promise.reject` method
// https://tc39.es/ecma262/#sec-promise.reject
$({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
  reject: function reject(r) {
    var capability = newPromiseCapabilityModule.f(this);
    call(capability.reject, undefined, r);
    return capability.promise;
  }
});


/***/ }),

/***/ 3142:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var getBuiltIn = __webpack_require__(2963);
var IS_PURE = __webpack_require__(2975);
var NativePromiseConstructor = __webpack_require__(3132);
var FORCED_PROMISE_CONSTRUCTOR = (__webpack_require__(3133).CONSTRUCTOR);
var promiseResolve = __webpack_require__(3143);

var PromiseConstructorWrapper = getBuiltIn('Promise');
var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;

// `Promise.resolve` method
// https://tc39.es/ecma262/#sec-promise.resolve
$({ target: 'Promise', stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
  resolve: function resolve(x) {
    return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x);
  }
});


/***/ }),

/***/ 2943:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(2944);
var getBuiltIn = __webpack_require__(2963);
var apply = __webpack_require__(3008);
var bind = __webpack_require__(3009);
var aConstructor = __webpack_require__(3011);
var anObject = __webpack_require__(2986);
var isObject = __webpack_require__(2960);
var create = __webpack_require__(3015);
var fails = __webpack_require__(2948);

var nativeConstruct = getBuiltIn('Reflect', 'construct');
var ObjectPrototype = Object.prototype;
var push = [].push;

// `Reflect.construct` method
// https://tc39.es/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
});

var ARGS_BUG = !fails(function () {
  nativeConstruct(function () { /* empty */ });
});

var FORCED = NEW_TARGET_BUG || ARGS_BUG;

$({ target: 'Reflect', stat: true, forced: FORCED, sham: FORCED }, {
  construct: function construct(Target, args /* , newTarget */) {
    aConstructor(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      apply(push, $args, args);
      return new (apply(bind, Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : ObjectPrototype);
    var result = apply(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),

/***/ 3326:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(2944);
var call = __webpack_require__(2949);
var isObject = __webpack_require__(2960);
var anObject = __webpack_require__(2986);
var isDataDescriptor = __webpack_require__(3327);
var getOwnPropertyDescriptorModule = __webpack_require__(2946);
var getPrototypeOf = __webpack_require__(3048);

// `Reflect.get` method
// https://tc39.es/ecma262/#sec-reflect.get
function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject(target) === receiver) return target[propertyKey];
  descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey);
  if (descriptor) return isDataDescriptor(descriptor)
    ? descriptor.value
    : descriptor.get === undefined ? undefined : call(descriptor.get, receiver);
  if (isObject(prototype = getPrototypeOf(target))) return get(prototype, propertyKey, receiver);
}

$({ target: 'Reflect', stat: true }, {
  get: get
});


/***/ }),

/***/ 3311:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(2947);
var global = __webpack_require__(2945);
var uncurryThis = __webpack_require__(2955);
var isForced = __webpack_require__(3007);
var inheritIfRequired = __webpack_require__(3159);
var createNonEnumerableProperty = __webpack_require__(2983);
var getOwnPropertyNames = (__webpack_require__(2997).f);
var isPrototypeOf = __webpack_require__(2964);
var isRegExp = __webpack_require__(3081);
var toString = __webpack_require__(3021);
var getRegExpFlags = __webpack_require__(3198);
var stickyHelpers = __webpack_require__(3069);
var proxyAccessor = __webpack_require__(3312);
var defineBuiltIn = __webpack_require__(2987);
var fails = __webpack_require__(2948);
var hasOwn = __webpack_require__(2978);
var enforceInternalState = (__webpack_require__(2991).enforce);
var setSpecies = __webpack_require__(3121);
var wellKnownSymbol = __webpack_require__(2973);
var UNSUPPORTED_DOT_ALL = __webpack_require__(3070);
var UNSUPPORTED_NCG = __webpack_require__(3071);

var MATCH = wellKnownSymbol('match');
var NativeRegExp = global.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
var SyntaxError = global.SyntaxError;
var exec = uncurryThis(RegExpPrototype.exec);
var charAt = uncurryThis(''.charAt);
var replace = uncurryThis(''.replace);
var stringIndexOf = uncurryThis(''.indexOf);
var stringSlice = uncurryThis(''.slice);
// TODO: Use only propper RegExpIdentifierName
var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
var re1 = /a/g;
var re2 = /a/g;

// "new" should create a new object, old webkit bug
var CORRECT_NEW = new NativeRegExp(re1) !== re1;

var MISSED_STICKY = stickyHelpers.MISSED_STICKY;
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;

var BASE_FORCED = DESCRIPTORS &&
  (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function () {
    re2[MATCH] = false;
    // RegExp constructor can alter flags and IsRegExp works correct with @@match
    return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
  }));

var handleDotAll = function (string) {
  var length = string.length;
  var index = 0;
  var result = '';
  var brackets = false;
  var chr;
  for (; index <= length; index++) {
    chr = charAt(string, index);
    if (chr === '\\') {
      result += chr + charAt(string, ++index);
      continue;
    }
    if (!brackets && chr === '.') {
      result += '[\\s\\S]';
    } else {
      if (chr === '[') {
        brackets = true;
      } else if (chr === ']') {
        brackets = false;
      } result += chr;
    }
  } return result;
};

var handleNCG = function (string) {
  var length = string.length;
  var index = 0;
  var result = '';
  var named = [];
  var names = {};
  var brackets = false;
  var ncg = false;
  var groupid = 0;
  var groupname = '';
  var chr;
  for (; index <= length; index++) {
    chr = charAt(string, index);
    if (chr === '\\') {
      chr = chr + charAt(string, ++index);
    } else if (chr === ']') {
      brackets = false;
    } else if (!brackets) switch (true) {
      case chr === '[':
        brackets = true;
        break;
      case chr === '(':
        if (exec(IS_NCG, stringSlice(string, index + 1))) {
          index += 2;
          ncg = true;
        }
        result += chr;
        groupid++;
        continue;
      case chr === '>' && ncg:
        if (groupname === '' || hasOwn(names, groupname)) {
          throw new SyntaxError('Invalid capture group name');
        }
        names[groupname] = true;
        named[named.length] = [groupname, groupid];
        ncg = false;
        groupname = '';
        continue;
    }
    if (ncg) groupname += chr;
    else result += chr;
  } return [result, named];
};

// `RegExp` constructor
// https://tc39.es/ecma262/#sec-regexp-constructor
if (isForced('RegExp', BASE_FORCED)) {
  var RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);
    var patternIsRegExp = isRegExp(pattern);
    var flagsAreUndefined = flags === undefined;
    var groups = [];
    var rawPattern = pattern;
    var rawFlags, dotAll, sticky, handled, result, state;

    if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
      return pattern;
    }

    if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {
      pattern = pattern.source;
      if (flagsAreUndefined) flags = getRegExpFlags(rawPattern);
    }

    pattern = pattern === undefined ? '' : toString(pattern);
    flags = flags === undefined ? '' : toString(flags);
    rawPattern = pattern;

    if (UNSUPPORTED_DOT_ALL && 'dotAll' in re1) {
      dotAll = !!flags && stringIndexOf(flags, 's') > -1;
      if (dotAll) flags = replace(flags, /s/g, '');
    }

    rawFlags = flags;

    if (MISSED_STICKY && 'sticky' in re1) {
      sticky = !!flags && stringIndexOf(flags, 'y') > -1;
      if (sticky && UNSUPPORTED_Y) flags = replace(flags, /y/g, '');
    }

    if (UNSUPPORTED_NCG) {
      handled = handleNCG(pattern);
      pattern = handled[0];
      groups = handled[1];
    }

    result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);

    if (dotAll || sticky || groups.length) {
      state = enforceInternalState(result);
      if (dotAll) {
        state.dotAll = true;
        state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
      }
      if (sticky) state.sticky = true;
      if (groups.length) state.groups = groups;
    }

    if (pattern !== rawPattern) try {
      // fails in old engines, but we have no alternatives for unsupported regex syntax
      createNonEnumerableProperty(result, 'source', rawPattern === '' ? '(?:)' : rawPattern);
    } catch (error) { /* empty */ }

    return result;
  };

  for (var keys = getOwnPropertyNames(NativeRegExp), index = 0; keys.length > index;) {
    proxyAccessor(RegExpWrapper, NativeRegExp, keys[index++]);
  }

  RegExpPrototype.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype;
  defineBuiltIn(global, 'RegExp', RegExpWrapper, { constructor: true });
}

// https://tc39.es/ecma262/#sec-get-regexp-@@species
setSpecies('RegExp');


/***/ }),

/***/ 3066:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var exec = __webpack_require__(3067);

// `RegExp.prototype.exec` method
// https://tc39.es/ecma262/#sec-regexp.prototype.exec
$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});


/***/ }),

/***/ 3197:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var PROPER_FUNCTION_NAME = (__webpack_require__(2989).PROPER);
var defineBuiltIn = __webpack_require__(2987);
var anObject = __webpack_require__(2986);
var $toString = __webpack_require__(3021);
var fails = __webpack_require__(2948);
var getRegExpFlags = __webpack_require__(3198);

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var n$ToString = RegExpPrototype[TO_STRING];

var NOT_GENERIC = fails(function () { return n$ToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.es/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  defineBuiltIn(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    var pattern = $toString(R.source);
    var flags = $toString(getRegExpFlags(R));
    return '/' + pattern + '/' + flags;
  }, { unsafe: true });
}


/***/ }),

/***/ 3221:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var collection = __webpack_require__(3222);
var collectionStrong = __webpack_require__(3227);

// `Set` constructor
// https://tc39.es/ecma262/#sec-set-objects
collection('Set', function (init) {
  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),

/***/ 3220:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(3221);


/***/ }),

/***/ 3052:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var charAt = (__webpack_require__(3053).charAt);
var toString = __webpack_require__(3021);
var InternalStateModule = __webpack_require__(2991);
var defineIterator = __webpack_require__(3045);

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: toString(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ 3072:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(2949);
var fixRegExpWellKnownSymbolLogic = __webpack_require__(3073);
var anObject = __webpack_require__(2986);
var toLength = __webpack_require__(3004);
var toString = __webpack_require__(3021);
var requireObjectCoercible = __webpack_require__(2957);
var getMethod = __webpack_require__(2969);
var advanceStringIndex = __webpack_require__(3074);
var regExpExec = __webpack_require__(3075);

// @@match logic
fixRegExpWellKnownSymbolLogic('match', function (MATCH, nativeMatch, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.es/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = requireObjectCoercible(this);
      var matcher = regexp == undefined ? undefined : getMethod(regexp, MATCH);
      return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
    function (string) {
      var rx = anObject(this);
      var S = toString(string);
      var res = maybeCallNative(nativeMatch, rx, S);

      if (res.done) return res.value;

      if (!rx.global) return regExpExec(rx, S);

      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = toString(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),

/***/ 3203:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var apply = __webpack_require__(3008);
var call = __webpack_require__(2949);
var uncurryThis = __webpack_require__(2955);
var fixRegExpWellKnownSymbolLogic = __webpack_require__(3073);
var fails = __webpack_require__(2948);
var anObject = __webpack_require__(2986);
var isCallable = __webpack_require__(2961);
var toIntegerOrInfinity = __webpack_require__(3001);
var toLength = __webpack_require__(3004);
var toString = __webpack_require__(3021);
var requireObjectCoercible = __webpack_require__(2957);
var advanceStringIndex = __webpack_require__(3074);
var getMethod = __webpack_require__(2969);
var getSubstitution = __webpack_require__(3204);
var regExpExec = __webpack_require__(3075);
var wellKnownSymbol = __webpack_require__(2973);

var REPLACE = wellKnownSymbol('replace');
var max = Math.max;
var min = Math.min;
var concat = uncurryThis([].concat);
var push = uncurryThis([].push);
var stringIndexOf = uncurryThis(''.indexOf);
var stringSlice = uncurryThis(''.slice);

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = (function () {
  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
  return 'a'.replace(/./, '$0') === '$0';
})();

// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
})();

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
  return ''.replace(re, '$<a>') !== '7';
});

// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible(this);
      var replacer = searchValue == undefined ? undefined : getMethod(searchValue, REPLACE);
      return replacer
        ? call(replacer, searchValue, O, replaceValue)
        : call(nativeReplace, toString(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function (string, replaceValue) {
      var rx = anObject(this);
      var S = toString(string);

      if (
        typeof replaceValue == 'string' &&
        stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&
        stringIndexOf(replaceValue, '$<') === -1
      ) {
        var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
        if (res.done) return res.value;
      }

      var functionalReplace = isCallable(replaceValue);
      if (!functionalReplace) replaceValue = toString(replaceValue);

      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;

        push(results, result);
        if (!global) break;

        var matchStr = toString(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];

        var matched = toString(result[0]);
        var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = concat([matched], captures, position, S);
          if (namedCaptures !== undefined) push(replacerArgs, namedCaptures);
          var replacement = toString(apply(replaceValue, undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + stringSlice(S, nextSourcePosition);
    }
  ];
}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);


/***/ }),

/***/ 3080:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var apply = __webpack_require__(3008);
var call = __webpack_require__(2949);
var uncurryThis = __webpack_require__(2955);
var fixRegExpWellKnownSymbolLogic = __webpack_require__(3073);
var isRegExp = __webpack_require__(3081);
var anObject = __webpack_require__(2986);
var requireObjectCoercible = __webpack_require__(2957);
var speciesConstructor = __webpack_require__(3082);
var advanceStringIndex = __webpack_require__(3074);
var toLength = __webpack_require__(3004);
var toString = __webpack_require__(3021);
var getMethod = __webpack_require__(2969);
var arraySlice = __webpack_require__(3023);
var callRegExpExec = __webpack_require__(3075);
var regexpExec = __webpack_require__(3067);
var stickyHelpers = __webpack_require__(3069);
var fails = __webpack_require__(2948);

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var MAX_UINT32 = 0xFFFFFFFF;
var min = Math.min;
var $push = [].push;
var exec = uncurryThis(/./.exec);
var push = uncurryThis($push);
var stringSlice = uncurryThis(''.slice);

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  // eslint-disable-next-line regexp/no-empty-group -- required for testing
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

// @@split logic
fixRegExpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'.split(/(b)*/)[1] == 'c' ||
    // eslint-disable-next-line regexp/no-empty-group -- required for testing
    'test'.split(/(?:)/, -1).length != 4 ||
    'ab'.split(/(?:ab)*/).length != 2 ||
    '.'.split(/(.?)(.?)/).length != 4 ||
    // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
    '.'.split(/()()/).length > 1 ||
    ''.split(/.?/).length
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = toString(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) {
        return call(nativeSplit, string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = call(regexpExec, separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          push(output, stringSlice(string, lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) apply($push, output, arraySlice(match, 1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }
        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }
      if (lastLastIndex === string.length) {
        if (lastLength || !exec(separatorCopy, '')) push(output, '');
      } else push(output, stringSlice(string, lastLastIndex));
      return output.length > lim ? arraySlice(output, 0, lim) : output;
    };
  // Chakra, V8
  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
    };
  } else internalSplit = nativeSplit;

  return [
    // `String.prototype.split` method
    // https://tc39.es/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = requireObjectCoercible(this);
      var splitter = separator == undefined ? undefined : getMethod(separator, SPLIT);
      return splitter
        ? call(splitter, separator, O, limit)
        : call(internalSplit, toString(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (string, limit) {
      var rx = anObject(this);
      var S = toString(string);
      var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);

      if (res.done) return res.value;

      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (UNSUPPORTED_Y ? 'g' : 'y');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
        var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
        var e;
        if (
          z === null ||
          (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          push(A, stringSlice(S, p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            push(A, z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      push(A, stringSlice(S, p));
      return A;
    }
  ];
}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);


/***/ }),

/***/ 3320:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var uncurryThis = __webpack_require__(2955);
var getOwnPropertyDescriptor = (__webpack_require__(2946).f);
var toLength = __webpack_require__(3004);
var toString = __webpack_require__(3021);
var notARegExp = __webpack_require__(3321);
var requireObjectCoercible = __webpack_require__(2957);
var correctIsRegExpLogic = __webpack_require__(3322);
var IS_PURE = __webpack_require__(2975);

// eslint-disable-next-line es-x/no-string-prototype-startswith -- safe
var un$StartsWith = uncurryThis(''.startsWith);
var stringSlice = uncurryThis(''.slice);
var min = Math.min;

var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith');
// https://github.com/zloirock/core-js/pull/702
var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
  var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');
  return descriptor && !descriptor.writable;
}();

// `String.prototype.startsWith` method
// https://tc39.es/ecma262/#sec-string.prototype.startswith
$({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = toString(requireObjectCoercible(this));
    notARegExp(searchString);
    var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = toString(searchString);
    return un$StartsWith
      ? un$StartsWith(that, search, index)
      : stringSlice(that, index, index + search.length) === search;
  }
});


/***/ }),

/***/ 3243:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var $trim = (__webpack_require__(3244).trim);
var forcedStringTrimMethod = __webpack_require__(3246);

// `String.prototype.trim` method
// https://tc39.es/ecma262/#sec-string.prototype.trim
$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
  trim: function trim() {
    return $trim(this);
  }
});


/***/ }),

/***/ 3020:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var global = __webpack_require__(2945);
var call = __webpack_require__(2949);
var uncurryThis = __webpack_require__(2955);
var IS_PURE = __webpack_require__(2975);
var DESCRIPTORS = __webpack_require__(2947);
var NATIVE_SYMBOL = __webpack_require__(2966);
var fails = __webpack_require__(2948);
var hasOwn = __webpack_require__(2978);
var isPrototypeOf = __webpack_require__(2964);
var anObject = __webpack_require__(2986);
var toIndexedObject = __webpack_require__(2953);
var toPropertyKey = __webpack_require__(2958);
var $toString = __webpack_require__(3021);
var createPropertyDescriptor = __webpack_require__(2952);
var nativeObjectCreate = __webpack_require__(3015);
var objectKeys = __webpack_require__(3017);
var getOwnPropertyNamesModule = __webpack_require__(2997);
var getOwnPropertyNamesExternal = __webpack_require__(3022);
var getOwnPropertySymbolsModule = __webpack_require__(3006);
var getOwnPropertyDescriptorModule = __webpack_require__(2946);
var definePropertyModule = __webpack_require__(2984);
var definePropertiesModule = __webpack_require__(3016);
var propertyIsEnumerableModule = __webpack_require__(2951);
var defineBuiltIn = __webpack_require__(2987);
var shared = __webpack_require__(2974);
var sharedKey = __webpack_require__(2993);
var hiddenKeys = __webpack_require__(2994);
var uid = __webpack_require__(2980);
var wellKnownSymbol = __webpack_require__(2973);
var wrappedWellKnownSymbolModule = __webpack_require__(3025);
var defineWellKnownSymbol = __webpack_require__(3026);
var defineSymbolToPrimitive = __webpack_require__(3028);
var setToStringTag = __webpack_require__(3029);
var InternalStateModule = __webpack_require__(2991);
var $forEach = (__webpack_require__(3030).forEach);

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';

var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);

var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var TypeError = global.TypeError;
var QObject = global.QObject;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var push = uncurryThis([].push);

var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var WellKnownSymbolsStore = shared('wks');

// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPropertyKey(P);
  anObject(Attributes);
  if (hasOwn(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPropertyKey(V);
  var enumerable = call(nativePropertyIsEnumerable, this, P);
  if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P]
    ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPropertyKey(P);
  if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
  });
  return result;
};

var $getOwnPropertySymbols = function (O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
      push(result, AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (isPrototypeOf(SymbolPrototype, this)) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
      if (hasOwn(this, HIDDEN) && hasOwn(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  SymbolPrototype = $Symbol[PROTOTYPE];

  defineBuiltIn(SymbolPrototype, 'toString', function toString() {
    return getInternalState(this).tag;
  });

  defineBuiltIn($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty(SymbolPrototype, 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      defineBuiltIn(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames
});

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ 3040:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.es/ecma262/#sec-symbol.prototype.description

var $ = __webpack_require__(2944);
var DESCRIPTORS = __webpack_require__(2947);
var global = __webpack_require__(2945);
var uncurryThis = __webpack_require__(2955);
var hasOwn = __webpack_require__(2978);
var isCallable = __webpack_require__(2961);
var isPrototypeOf = __webpack_require__(2964);
var toString = __webpack_require__(3021);
var defineProperty = (__webpack_require__(2984).f);
var copyConstructorProperties = __webpack_require__(2995);

var NativeSymbol = global.Symbol;
var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;

if (DESCRIPTORS && isCallable(NativeSymbol) && (!('description' in SymbolPrototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : toString(arguments[0]);
    var result = isPrototypeOf(SymbolPrototype, this)
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };

  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  SymbolWrapper.prototype = SymbolPrototype;
  SymbolPrototype.constructor = SymbolWrapper;

  var NATIVE_SYMBOL = String(NativeSymbol('test')) == 'Symbol(test)';
  var symbolToString = uncurryThis(SymbolPrototype.toString);
  var symbolValueOf = uncurryThis(SymbolPrototype.valueOf);
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  var replace = uncurryThis(''.replace);
  var stringSlice = uncurryThis(''.slice);

  defineProperty(SymbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = symbolValueOf(this);
      var string = symbolToString(symbol);
      if (hasOwn(EmptyStringDescriptionStore, symbol)) return '';
      var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  $({ global: true, constructor: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}


/***/ }),

/***/ 3035:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(2944);
var getBuiltIn = __webpack_require__(2963);
var hasOwn = __webpack_require__(2978);
var toString = __webpack_require__(3021);
var shared = __webpack_require__(2974);
var NATIVE_SYMBOL_REGISTRY = __webpack_require__(3036);

var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.for` method
// https://tc39.es/ecma262/#sec-symbol.for
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  'for': function (key) {
    var string = toString(key);
    if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = getBuiltIn('Symbol')(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  }
});


/***/ }),

/***/ 3041:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineWellKnownSymbol = __webpack_require__(3026);

// `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');


/***/ }),

/***/ 3019:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__(3020);
__webpack_require__(3035);
__webpack_require__(3037);
__webpack_require__(3038);
__webpack_require__(3039);


/***/ }),

/***/ 3037:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(2944);
var hasOwn = __webpack_require__(2978);
var isSymbol = __webpack_require__(2962);
var tryToString = __webpack_require__(2971);
var shared = __webpack_require__(2974);
var NATIVE_SYMBOL_REGISTRY = __webpack_require__(3036);

var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.keyFor` method
// https://tc39.es/ecma262/#sec-symbol.keyfor
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(tryToString(sym) + ' is not a symbol');
    if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  }
});


/***/ }),

/***/ 3160:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(2955);
var ArrayBufferViewCore = __webpack_require__(3148);
var $ArrayCopyWithin = __webpack_require__(3161);

var u$ArrayCopyWithin = uncurryThis($ArrayCopyWithin);
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.copyWithin` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
exportTypedArrayMethod('copyWithin', function copyWithin(target, start /* , end */) {
  return u$ArrayCopyWithin(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});


/***/ }),

/***/ 3163:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(3148);
var $every = (__webpack_require__(3030).every);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.every` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
exportTypedArrayMethod('every', function every(callbackfn /* , thisArg */) {
  return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 3164:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(3148);
var $fill = __webpack_require__(3154);
var toBigInt = __webpack_require__(3165);
var classof = __webpack_require__(3013);
var call = __webpack_require__(2949);
var uncurryThis = __webpack_require__(2955);
var fails = __webpack_require__(2948);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var slice = uncurryThis(''.slice);

// V8 ~ Chrome < 59, Safari < 14.1, FF < 55, Edge <=18
var CONVERSION_BUG = fails(function () {
  var count = 0;
  // eslint-disable-next-line es-x/no-typed-arrays -- safe
  new Int8Array(2).fill({ valueOf: function () { return count++; } });
  return count !== 1;
});

// `%TypedArray%.prototype.fill` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
exportTypedArrayMethod('fill', function fill(value /* , start, end */) {
  var length = arguments.length;
  aTypedArray(this);
  var actualValue = slice(classof(this), 0, 3) === 'Big' ? toBigInt(value) : +value;
  return call($fill, this, actualValue, length > 1 ? arguments[1] : undefined, length > 2 ? arguments[2] : undefined);
}, CONVERSION_BUG);


/***/ }),

/***/ 3166:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(3148);
var $filter = (__webpack_require__(3030).filter);
var fromSpeciesAndList = __webpack_require__(3167);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.filter` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
exportTypedArrayMethod('filter', function filter(callbackfn /* , thisArg */) {
  var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  return fromSpeciesAndList(this, list);
});


/***/ }),

/***/ 3171:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(3148);
var $findIndex = (__webpack_require__(3030).findIndex);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
exportTypedArrayMethod('findIndex', function findIndex(predicate /* , thisArg */) {
  return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 3170:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(3148);
var $find = (__webpack_require__(3030).find);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.find` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
exportTypedArrayMethod('find', function find(predicate /* , thisArg */) {
  return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 3172:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(3148);
var $forEach = (__webpack_require__(3030).forEach);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.forEach` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
exportTypedArrayMethod('forEach', function forEach(callbackfn /* , thisArg */) {
  $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 3195:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__(3147);
var exportTypedArrayStaticMethod = (__webpack_require__(3148).exportTypedArrayStaticMethod);
var typedArrayFrom = __webpack_require__(3158);

// `%TypedArray%.from` method
// https://tc39.es/ecma262/#sec-%typedarray%.from
exportTypedArrayStaticMethod('from', typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);


/***/ }),

/***/ 3173:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(3148);
var $includes = (__webpack_require__(2999).includes);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.includes` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
exportTypedArrayMethod('includes', function includes(searchElement /* , fromIndex */) {
  return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 3174:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(3148);
var $indexOf = (__webpack_require__(2999).indexOf);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
exportTypedArrayMethod('indexOf', function indexOf(searchElement /* , fromIndex */) {
  return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 3202:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var createTypedArrayConstructor = __webpack_require__(3146);

// `Int32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Int32', function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 3175:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(2945);
var fails = __webpack_require__(2948);
var uncurryThis = __webpack_require__(2955);
var ArrayBufferViewCore = __webpack_require__(3148);
var ArrayIterators = __webpack_require__(3042);
var wellKnownSymbol = __webpack_require__(2973);

var ITERATOR = wellKnownSymbol('iterator');
var Uint8Array = global.Uint8Array;
var arrayValues = uncurryThis(ArrayIterators.values);
var arrayKeys = uncurryThis(ArrayIterators.keys);
var arrayEntries = uncurryThis(ArrayIterators.entries);
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var TypedArrayPrototype = Uint8Array && Uint8Array.prototype;

var GENERIC = !fails(function () {
  TypedArrayPrototype[ITERATOR].call([1]);
});

var ITERATOR_IS_VALUES = !!TypedArrayPrototype
  && TypedArrayPrototype.values
  && TypedArrayPrototype[ITERATOR] === TypedArrayPrototype.values
  && TypedArrayPrototype.values.name === 'values';

var typedArrayValues = function values() {
  return arrayValues(aTypedArray(this));
};

// `%TypedArray%.prototype.entries` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
exportTypedArrayMethod('entries', function entries() {
  return arrayEntries(aTypedArray(this));
}, GENERIC);
// `%TypedArray%.prototype.keys` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
exportTypedArrayMethod('keys', function keys() {
  return arrayKeys(aTypedArray(this));
}, GENERIC);
// `%TypedArray%.prototype.values` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
exportTypedArrayMethod('values', typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: 'values' });
// `%TypedArray%.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
exportTypedArrayMethod(ITERATOR, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: 'values' });


/***/ }),

/***/ 3176:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(3148);
var uncurryThis = __webpack_require__(2955);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $join = uncurryThis([].join);

// `%TypedArray%.prototype.join` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
exportTypedArrayMethod('join', function join(separator) {
  return $join(aTypedArray(this), separator);
});


/***/ }),

/***/ 3177:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(3148);
var apply = __webpack_require__(3008);
var $lastIndexOf = __webpack_require__(3178);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
exportTypedArrayMethod('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
  var length = arguments.length;
  return apply($lastIndexOf, aTypedArray(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
});


/***/ }),

/***/ 3179:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(3148);
var $map = (__webpack_require__(3030).map);
var typedArraySpeciesConstructor = __webpack_require__(3169);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.map` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
exportTypedArrayMethod('map', function map(mapfn /* , thisArg */) {
  return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
    return new (typedArraySpeciesConstructor(O))(length);
  });
});


/***/ }),

/***/ 3182:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(3148);
var $reduceRight = (__webpack_require__(3181).right);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduceRicht` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
exportTypedArrayMethod('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
  var length = arguments.length;
  return $reduceRight(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 3180:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(3148);
var $reduce = (__webpack_require__(3181).left);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduce` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
exportTypedArrayMethod('reduce', function reduce(callbackfn /* , initialValue */) {
  var length = arguments.length;
  return $reduce(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 3183:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(3148);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var floor = Math.floor;

// `%TypedArray%.prototype.reverse` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
exportTypedArrayMethod('reverse', function reverse() {
  var that = this;
  var length = aTypedArray(that).length;
  var middle = floor(length / 2);
  var index = 0;
  var value;
  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  } return that;
});


/***/ }),

/***/ 3184:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(2945);
var call = __webpack_require__(2949);
var ArrayBufferViewCore = __webpack_require__(3148);
var lengthOfArrayLike = __webpack_require__(3003);
var toOffset = __webpack_require__(3156);
var toIndexedObject = __webpack_require__(2979);
var fails = __webpack_require__(2948);

var RangeError = global.RangeError;
var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

var WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS = !fails(function () {
  // eslint-disable-next-line es-x/no-typed-arrays -- required for testing
  var array = new Uint8ClampedArray(2);
  call($set, array, { length: 1, 0: 3 }, 1);
  return array[1] !== 3;
});

// https://bugs.chromium.org/p/v8/issues/detail?id=11294 and other
var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function () {
  var array = new Int8Array(2);
  array.set(1);
  array.set('2', 1);
  return array[0] !== 0 || array[1] !== 2;
});

// `%TypedArray%.prototype.set` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
exportTypedArrayMethod('set', function set(arrayLike /* , offset */) {
  aTypedArray(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var src = toIndexedObject(arrayLike);
  if (WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS) return call($set, this, src, offset);
  var length = this.length;
  var len = lengthOfArrayLike(src);
  var index = 0;
  if (len + offset > length) throw RangeError('Wrong length');
  while (index < len) this[offset + index] = src[index++];
}, !WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);


/***/ }),

/***/ 3185:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(3148);
var typedArraySpeciesConstructor = __webpack_require__(3169);
var fails = __webpack_require__(2948);
var arraySlice = __webpack_require__(3010);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

var FORCED = fails(function () {
  // eslint-disable-next-line es-x/no-typed-arrays -- required for testing
  new Int8Array(1).slice();
});

// `%TypedArray%.prototype.slice` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
exportTypedArrayMethod('slice', function slice(start, end) {
  var list = arraySlice(aTypedArray(this), start, end);
  var C = typedArraySpeciesConstructor(this);
  var index = 0;
  var length = list.length;
  var result = new C(length);
  while (length > index) result[index] = list[index++];
  return result;
}, FORCED);


/***/ }),

/***/ 3186:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(3148);
var $some = (__webpack_require__(3030).some);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.some` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
exportTypedArrayMethod('some', function some(callbackfn /* , thisArg */) {
  return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 3187:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(2945);
var uncurryThis = __webpack_require__(2955);
var fails = __webpack_require__(2948);
var aCallable = __webpack_require__(2970);
var internalSort = __webpack_require__(3188);
var ArrayBufferViewCore = __webpack_require__(3148);
var FF = __webpack_require__(3189);
var IE_OR_EDGE = __webpack_require__(3190);
var V8 = __webpack_require__(2967);
var WEBKIT = __webpack_require__(3191);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var Uint16Array = global.Uint16Array;
var un$Sort = Uint16Array && uncurryThis(Uint16Array.prototype.sort);

// WebKit
var ACCEPT_INCORRECT_ARGUMENTS = !!un$Sort && !(fails(function () {
  un$Sort(new Uint16Array(2), null);
}) && fails(function () {
  un$Sort(new Uint16Array(2), {});
}));

var STABLE_SORT = !!un$Sort && !fails(function () {
  // feature detection can be too slow, so check engines versions
  if (V8) return V8 < 74;
  if (FF) return FF < 67;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 602;

  var array = new Uint16Array(516);
  var expected = Array(516);
  var index, mod;

  for (index = 0; index < 516; index++) {
    mod = index % 4;
    array[index] = 515 - index;
    expected[index] = index - 2 * mod + 3;
  }

  un$Sort(array, function (a, b) {
    return (a / 4 | 0) - (b / 4 | 0);
  });

  for (index = 0; index < 516; index++) {
    if (array[index] !== expected[index]) return true;
  }
});

var getSortCompare = function (comparefn) {
  return function (x, y) {
    if (comparefn !== undefined) return +comparefn(x, y) || 0;
    // eslint-disable-next-line no-self-compare -- NaN check
    if (y !== y) return -1;
    // eslint-disable-next-line no-self-compare -- NaN check
    if (x !== x) return 1;
    if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
    return x > y;
  };
};

// `%TypedArray%.prototype.sort` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
exportTypedArrayMethod('sort', function sort(comparefn) {
  if (comparefn !== undefined) aCallable(comparefn);
  if (STABLE_SORT) return un$Sort(this, comparefn);

  return internalSort(aTypedArray(this), getSortCompare(comparefn));
}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);


/***/ }),

/***/ 3192:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ArrayBufferViewCore = __webpack_require__(3148);
var toLength = __webpack_require__(3004);
var toAbsoluteIndex = __webpack_require__(3000);
var typedArraySpeciesConstructor = __webpack_require__(3169);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.subarray` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
exportTypedArrayMethod('subarray', function subarray(begin, end) {
  var O = aTypedArray(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex(begin, length);
  var C = typedArraySpeciesConstructor(O);
  return new C(
    O.buffer,
    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
  );
});


/***/ }),

/***/ 3193:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(2945);
var apply = __webpack_require__(3008);
var ArrayBufferViewCore = __webpack_require__(3148);
var fails = __webpack_require__(2948);
var arraySlice = __webpack_require__(3010);

var Int8Array = global.Int8Array;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;

// iOS Safari 6.x fails here
var TO_LOCALE_STRING_BUG = !!Int8Array && fails(function () {
  $toLocaleString.call(new Int8Array(1));
});

var FORCED = fails(function () {
  return [1, 2].toLocaleString() != new Int8Array([1, 2]).toLocaleString();
}) || !fails(function () {
  Int8Array.prototype.toLocaleString.call([1, 2]);
});

// `%TypedArray%.prototype.toLocaleString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
exportTypedArrayMethod('toLocaleString', function toLocaleString() {
  return apply(
    $toLocaleString,
    TO_LOCALE_STRING_BUG ? arraySlice(aTypedArray(this)) : aTypedArray(this),
    arraySlice(arguments)
  );
}, FORCED);


/***/ }),

/***/ 3194:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var exportTypedArrayMethod = (__webpack_require__(3148).exportTypedArrayMethod);
var fails = __webpack_require__(2948);
var global = __webpack_require__(2945);
var uncurryThis = __webpack_require__(2955);

var Uint8Array = global.Uint8Array;
var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype || {};
var arrayToString = [].toString;
var join = uncurryThis([].join);

if (fails(function () { arrayToString.call({}); })) {
  arrayToString = function toString() {
    return join(this);
  };
}

var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;

// `%TypedArray%.prototype.toString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring
exportTypedArrayMethod('toString', arrayToString, IS_NOT_ARRAY_METHOD);


/***/ }),

/***/ 3145:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var createTypedArrayConstructor = __webpack_require__(3146);

// `Uint8Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint8', function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 3085:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(2945);
var DOMIterables = __webpack_require__(3055);
var DOMTokenListPrototype = __webpack_require__(3056);
var forEach = __webpack_require__(3086);
var createNonEnumerableProperty = __webpack_require__(2983);

var handlePrototype = function (CollectionPrototype) {
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
};

for (var COLLECTION_NAME in DOMIterables) {
  if (DOMIterables[COLLECTION_NAME]) {
    handlePrototype(global[COLLECTION_NAME] && global[COLLECTION_NAME].prototype);
  }
}

handlePrototype(DOMTokenListPrototype);


/***/ }),

/***/ 3054:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(2945);
var DOMIterables = __webpack_require__(3055);
var DOMTokenListPrototype = __webpack_require__(3056);
var ArrayIteratorMethods = __webpack_require__(3042);
var createNonEnumerableProperty = __webpack_require__(2983);
var wellKnownSymbol = __webpack_require__(2973);

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

var handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
};

for (var COLLECTION_NAME in DOMIterables) {
  handlePrototype(global[COLLECTION_NAME] && global[COLLECTION_NAME].prototype, COLLECTION_NAME);
}

handlePrototype(DOMTokenListPrototype, 'DOMTokenList');


/***/ }),

/***/ 3210:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
__webpack_require__(3042);
var $ = __webpack_require__(2944);
var global = __webpack_require__(2945);
var call = __webpack_require__(2949);
var uncurryThis = __webpack_require__(2955);
var DESCRIPTORS = __webpack_require__(2947);
var USE_NATIVE_URL = __webpack_require__(3207);
var defineBuiltIn = __webpack_require__(2987);
var defineBuiltIns = __webpack_require__(3151);
var setToStringTag = __webpack_require__(3029);
var createIteratorConstructor = __webpack_require__(3046);
var InternalStateModule = __webpack_require__(2991);
var anInstance = __webpack_require__(3122);
var isCallable = __webpack_require__(2961);
var hasOwn = __webpack_require__(2978);
var bind = __webpack_require__(3031);
var classof = __webpack_require__(3013);
var anObject = __webpack_require__(2986);
var isObject = __webpack_require__(2960);
var $toString = __webpack_require__(3021);
var create = __webpack_require__(3015);
var createPropertyDescriptor = __webpack_require__(2952);
var getIterator = __webpack_require__(3062);
var getIteratorMethod = __webpack_require__(3063);
var validateArgumentsLength = __webpack_require__(3124);
var wellKnownSymbol = __webpack_require__(2973);
var arraySort = __webpack_require__(3188);

var ITERATOR = wellKnownSymbol('iterator');
var URL_SEARCH_PARAMS = 'URLSearchParams';
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
var setInternalState = InternalStateModule.set;
var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Avoid NodeJS experimental warning
var safeGetBuiltIn = function (name) {
  if (!DESCRIPTORS) return global[name];
  var descriptor = getOwnPropertyDescriptor(global, name);
  return descriptor && descriptor.value;
};

var nativeFetch = safeGetBuiltIn('fetch');
var NativeRequest = safeGetBuiltIn('Request');
var Headers = safeGetBuiltIn('Headers');
var RequestPrototype = NativeRequest && NativeRequest.prototype;
var HeadersPrototype = Headers && Headers.prototype;
var RegExp = global.RegExp;
var TypeError = global.TypeError;
var decodeURIComponent = global.decodeURIComponent;
var encodeURIComponent = global.encodeURIComponent;
var charAt = uncurryThis(''.charAt);
var join = uncurryThis([].join);
var push = uncurryThis([].push);
var replace = uncurryThis(''.replace);
var shift = uncurryThis([].shift);
var splice = uncurryThis([].splice);
var split = uncurryThis(''.split);
var stringSlice = uncurryThis(''.slice);

var plus = /\+/g;
var sequences = Array(4);

var percentSequence = function (bytes) {
  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
};

var percentDecode = function (sequence) {
  try {
    return decodeURIComponent(sequence);
  } catch (error) {
    return sequence;
  }
};

var deserialize = function (it) {
  var result = replace(it, plus, ' ');
  var bytes = 4;
  try {
    return decodeURIComponent(result);
  } catch (error) {
    while (bytes) {
      result = replace(result, percentSequence(bytes--), percentDecode);
    }
    return result;
  }
};

var find = /[!'()~]|%20/g;

var replacements = {
  '!': '%21',
  "'": '%27',
  '(': '%28',
  ')': '%29',
  '~': '%7E',
  '%20': '+'
};

var replacer = function (match) {
  return replacements[match];
};

var serialize = function (it) {
  return replace(encodeURIComponent(it), find, replacer);
};

var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
  setInternalState(this, {
    type: URL_SEARCH_PARAMS_ITERATOR,
    iterator: getIterator(getInternalParamsState(params).entries),
    kind: kind
  });
}, 'Iterator', function next() {
  var state = getInternalIteratorState(this);
  var kind = state.kind;
  var step = state.iterator.next();
  var entry = step.value;
  if (!step.done) {
    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
  } return step;
}, true);

var URLSearchParamsState = function (init) {
  this.entries = [];
  this.url = null;

  if (init !== undefined) {
    if (isObject(init)) this.parseObject(init);
    else this.parseQuery(typeof init == 'string' ? charAt(init, 0) === '?' ? stringSlice(init, 1) : init : $toString(init));
  }
};

URLSearchParamsState.prototype = {
  type: URL_SEARCH_PARAMS,
  bindURL: function (url) {
    this.url = url;
    this.update();
  },
  parseObject: function (object) {
    var iteratorMethod = getIteratorMethod(object);
    var iterator, next, step, entryIterator, entryNext, first, second;

    if (iteratorMethod) {
      iterator = getIterator(object, iteratorMethod);
      next = iterator.next;
      while (!(step = call(next, iterator)).done) {
        entryIterator = getIterator(anObject(step.value));
        entryNext = entryIterator.next;
        if (
          (first = call(entryNext, entryIterator)).done ||
          (second = call(entryNext, entryIterator)).done ||
          !call(entryNext, entryIterator).done
        ) throw TypeError('Expected sequence with length 2');
        push(this.entries, { key: $toString(first.value), value: $toString(second.value) });
      }
    } else for (var key in object) if (hasOwn(object, key)) {
      push(this.entries, { key: key, value: $toString(object[key]) });
    }
  },
  parseQuery: function (query) {
    if (query) {
      var attributes = split(query, '&');
      var index = 0;
      var attribute, entry;
      while (index < attributes.length) {
        attribute = attributes[index++];
        if (attribute.length) {
          entry = split(attribute, '=');
          push(this.entries, {
            key: deserialize(shift(entry)),
            value: deserialize(join(entry, '='))
          });
        }
      }
    }
  },
  serialize: function () {
    var entries = this.entries;
    var result = [];
    var index = 0;
    var entry;
    while (index < entries.length) {
      entry = entries[index++];
      push(result, serialize(entry.key) + '=' + serialize(entry.value));
    } return join(result, '&');
  },
  update: function () {
    this.entries.length = 0;
    this.parseQuery(this.url.query);
  },
  updateURL: function () {
    if (this.url) this.url.update();
  }
};

// `URLSearchParams` constructor
// https://url.spec.whatwg.org/#interface-urlsearchparams
var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
  anInstance(this, URLSearchParamsPrototype);
  var init = arguments.length > 0 ? arguments[0] : undefined;
  setInternalState(this, new URLSearchParamsState(init));
};

var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;

defineBuiltIns(URLSearchParamsPrototype, {
  // `URLSearchParams.prototype.append` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
  append: function append(name, value) {
    validateArgumentsLength(arguments.length, 2);
    var state = getInternalParamsState(this);
    push(state.entries, { key: $toString(name), value: $toString(value) });
    state.updateURL();
  },
  // `URLSearchParams.prototype.delete` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
  'delete': function (name) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var key = $toString(name);
    var index = 0;
    while (index < entries.length) {
      if (entries[index].key === key) splice(entries, index, 1);
      else index++;
    }
    state.updateURL();
  },
  // `URLSearchParams.prototype.get` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
  get: function get(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = $toString(name);
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) return entries[index].value;
    }
    return null;
  },
  // `URLSearchParams.prototype.getAll` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
  getAll: function getAll(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = $toString(name);
    var result = [];
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) push(result, entries[index].value);
    }
    return result;
  },
  // `URLSearchParams.prototype.has` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
  has: function has(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = $toString(name);
    var index = 0;
    while (index < entries.length) {
      if (entries[index++].key === key) return true;
    }
    return false;
  },
  // `URLSearchParams.prototype.set` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
  set: function set(name, value) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var found = false;
    var key = $toString(name);
    var val = $toString(value);
    var index = 0;
    var entry;
    for (; index < entries.length; index++) {
      entry = entries[index];
      if (entry.key === key) {
        if (found) splice(entries, index--, 1);
        else {
          found = true;
          entry.value = val;
        }
      }
    }
    if (!found) push(entries, { key: key, value: val });
    state.updateURL();
  },
  // `URLSearchParams.prototype.sort` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
  sort: function sort() {
    var state = getInternalParamsState(this);
    arraySort(state.entries, function (a, b) {
      return a.key > b.key ? 1 : -1;
    });
    state.updateURL();
  },
  // `URLSearchParams.prototype.forEach` method
  forEach: function forEach(callback /* , thisArg */) {
    var entries = getInternalParamsState(this).entries;
    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined);
    var index = 0;
    var entry;
    while (index < entries.length) {
      entry = entries[index++];
      boundFunction(entry.value, entry.key, this);
    }
  },
  // `URLSearchParams.prototype.keys` method
  keys: function keys() {
    return new URLSearchParamsIterator(this, 'keys');
  },
  // `URLSearchParams.prototype.values` method
  values: function values() {
    return new URLSearchParamsIterator(this, 'values');
  },
  // `URLSearchParams.prototype.entries` method
  entries: function entries() {
    return new URLSearchParamsIterator(this, 'entries');
  }
}, { enumerable: true });

// `URLSearchParams.prototype[@@iterator]` method
defineBuiltIn(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: 'entries' });

// `URLSearchParams.prototype.toString` method
// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
defineBuiltIn(URLSearchParamsPrototype, 'toString', function toString() {
  return getInternalParamsState(this).serialize();
}, { enumerable: true });

setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);

$({ global: true, constructor: true, forced: !USE_NATIVE_URL }, {
  URLSearchParams: URLSearchParamsConstructor
});

// Wrap `fetch` and `Request` for correct work with polyfilled `URLSearchParams`
if (!USE_NATIVE_URL && isCallable(Headers)) {
  var headersHas = uncurryThis(HeadersPrototype.has);
  var headersSet = uncurryThis(HeadersPrototype.set);

  var wrapRequestOptions = function (init) {
    if (isObject(init)) {
      var body = init.body;
      var headers;
      if (classof(body) === URL_SEARCH_PARAMS) {
        headers = init.headers ? new Headers(init.headers) : new Headers();
        if (!headersHas(headers, 'content-type')) {
          headersSet(headers, 'content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
        return create(init, {
          body: createPropertyDescriptor(0, $toString(body)),
          headers: createPropertyDescriptor(0, headers)
        });
      }
    } return init;
  };

  if (isCallable(nativeFetch)) {
    $({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, {
      fetch: function fetch(input /* , init */) {
        return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
      }
    });
  }

  if (isCallable(NativeRequest)) {
    var RequestConstructor = function Request(input /* , init */) {
      anInstance(this, RequestPrototype);
      return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
    };

    RequestPrototype.constructor = RequestConstructor;
    RequestConstructor.prototype = RequestPrototype;

    $({ global: true, constructor: true, dontCallGetSet: true, forced: true }, {
      Request: RequestConstructor
    });
  }
}

module.exports = {
  URLSearchParams: URLSearchParamsConstructor,
  getState: getInternalParamsState
};


/***/ }),

/***/ 3211:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(3210);


/***/ }),

/***/ 3206:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
__webpack_require__(3052);
var $ = __webpack_require__(2944);
var DESCRIPTORS = __webpack_require__(2947);
var USE_NATIVE_URL = __webpack_require__(3207);
var global = __webpack_require__(2945);
var bind = __webpack_require__(3031);
var uncurryThis = __webpack_require__(2955);
var defineBuiltIn = __webpack_require__(2987);
var defineBuiltInAccessor = __webpack_require__(3208);
var anInstance = __webpack_require__(3122);
var hasOwn = __webpack_require__(2978);
var assign = __webpack_require__(3091);
var arrayFrom = __webpack_require__(3058);
var arraySlice = __webpack_require__(3023);
var codeAt = (__webpack_require__(3053).codeAt);
var toASCII = __webpack_require__(3209);
var $toString = __webpack_require__(3021);
var setToStringTag = __webpack_require__(3029);
var validateArgumentsLength = __webpack_require__(3124);
var URLSearchParamsModule = __webpack_require__(3210);
var InternalStateModule = __webpack_require__(2991);

var setInternalState = InternalStateModule.set;
var getInternalURLState = InternalStateModule.getterFor('URL');
var URLSearchParams = URLSearchParamsModule.URLSearchParams;
var getInternalSearchParamsState = URLSearchParamsModule.getState;

var NativeURL = global.URL;
var TypeError = global.TypeError;
var parseInt = global.parseInt;
var floor = Math.floor;
var pow = Math.pow;
var charAt = uncurryThis(''.charAt);
var exec = uncurryThis(/./.exec);
var join = uncurryThis([].join);
var numberToString = uncurryThis(1.0.toString);
var pop = uncurryThis([].pop);
var push = uncurryThis([].push);
var replace = uncurryThis(''.replace);
var shift = uncurryThis([].shift);
var split = uncurryThis(''.split);
var stringSlice = uncurryThis(''.slice);
var toLowerCase = uncurryThis(''.toLowerCase);
var unshift = uncurryThis([].unshift);

var INVALID_AUTHORITY = 'Invalid authority';
var INVALID_SCHEME = 'Invalid scheme';
var INVALID_HOST = 'Invalid host';
var INVALID_PORT = 'Invalid port';

var ALPHA = /[a-z]/i;
// eslint-disable-next-line regexp/no-obscure-range -- safe
var ALPHANUMERIC = /[\d+-.a-z]/i;
var DIGIT = /\d/;
var HEX_START = /^0x/i;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[\da-f]+$/i;
/* eslint-disable regexp/no-control-character -- safe */
var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+|[\u0000-\u0020]+$/g;
var TAB_AND_NEW_LINE = /[\t\n\r]/g;
/* eslint-enable regexp/no-control-character -- safe */
var EOF;

// https://url.spec.whatwg.org/#ipv4-number-parser
var parseIPv4 = function (input) {
  var parts = split(input, '.');
  var partsLength, numbers, index, part, radix, number, ipv4;
  if (parts.length && parts[parts.length - 1] == '') {
    parts.length--;
  }
  partsLength = parts.length;
  if (partsLength > 4) return input;
  numbers = [];
  for (index = 0; index < partsLength; index++) {
    part = parts[index];
    if (part == '') return input;
    radix = 10;
    if (part.length > 1 && charAt(part, 0) == '0') {
      radix = exec(HEX_START, part) ? 16 : 8;
      part = stringSlice(part, radix == 8 ? 1 : 2);
    }
    if (part === '') {
      number = 0;
    } else {
      if (!exec(radix == 10 ? DEC : radix == 8 ? OCT : HEX, part)) return input;
      number = parseInt(part, radix);
    }
    push(numbers, number);
  }
  for (index = 0; index < partsLength; index++) {
    number = numbers[index];
    if (index == partsLength - 1) {
      if (number >= pow(256, 5 - partsLength)) return null;
    } else if (number > 255) return null;
  }
  ipv4 = pop(numbers);
  for (index = 0; index < numbers.length; index++) {
    ipv4 += numbers[index] * pow(256, 3 - index);
  }
  return ipv4;
};

// https://url.spec.whatwg.org/#concept-ipv6-parser
// eslint-disable-next-line max-statements -- TODO
var parseIPv6 = function (input) {
  var address = [0, 0, 0, 0, 0, 0, 0, 0];
  var pieceIndex = 0;
  var compress = null;
  var pointer = 0;
  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

  var chr = function () {
    return charAt(input, pointer);
  };

  if (chr() == ':') {
    if (charAt(input, 1) != ':') return;
    pointer += 2;
    pieceIndex++;
    compress = pieceIndex;
  }
  while (chr()) {
    if (pieceIndex == 8) return;
    if (chr() == ':') {
      if (compress !== null) return;
      pointer++;
      pieceIndex++;
      compress = pieceIndex;
      continue;
    }
    value = length = 0;
    while (length < 4 && exec(HEX, chr())) {
      value = value * 16 + parseInt(chr(), 16);
      pointer++;
      length++;
    }
    if (chr() == '.') {
      if (length == 0) return;
      pointer -= length;
      if (pieceIndex > 6) return;
      numbersSeen = 0;
      while (chr()) {
        ipv4Piece = null;
        if (numbersSeen > 0) {
          if (chr() == '.' && numbersSeen < 4) pointer++;
          else return;
        }
        if (!exec(DIGIT, chr())) return;
        while (exec(DIGIT, chr())) {
          number = parseInt(chr(), 10);
          if (ipv4Piece === null) ipv4Piece = number;
          else if (ipv4Piece == 0) return;
          else ipv4Piece = ipv4Piece * 10 + number;
          if (ipv4Piece > 255) return;
          pointer++;
        }
        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
        numbersSeen++;
        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
      }
      if (numbersSeen != 4) return;
      break;
    } else if (chr() == ':') {
      pointer++;
      if (!chr()) return;
    } else if (chr()) return;
    address[pieceIndex++] = value;
  }
  if (compress !== null) {
    swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex != 0 && swaps > 0) {
      swap = address[pieceIndex];
      address[pieceIndex--] = address[compress + swaps - 1];
      address[compress + --swaps] = swap;
    }
  } else if (pieceIndex != 8) return;
  return address;
};

var findLongestZeroSequence = function (ipv6) {
  var maxIndex = null;
  var maxLength = 1;
  var currStart = null;
  var currLength = 0;
  var index = 0;
  for (; index < 8; index++) {
    if (ipv6[index] !== 0) {
      if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
      }
      currStart = null;
      currLength = 0;
    } else {
      if (currStart === null) currStart = index;
      ++currLength;
    }
  }
  if (currLength > maxLength) {
    maxIndex = currStart;
    maxLength = currLength;
  }
  return maxIndex;
};

// https://url.spec.whatwg.org/#host-serializing
var serializeHost = function (host) {
  var result, index, compress, ignore0;
  // ipv4
  if (typeof host == 'number') {
    result = [];
    for (index = 0; index < 4; index++) {
      unshift(result, host % 256);
      host = floor(host / 256);
    } return join(result, '.');
  // ipv6
  } else if (typeof host == 'object') {
    result = '';
    compress = findLongestZeroSequence(host);
    for (index = 0; index < 8; index++) {
      if (ignore0 && host[index] === 0) continue;
      if (ignore0) ignore0 = false;
      if (compress === index) {
        result += index ? ':' : '::';
        ignore0 = true;
      } else {
        result += numberToString(host[index], 16);
        if (index < 7) result += ':';
      }
    }
    return '[' + result + ']';
  } return host;
};

var C0ControlPercentEncodeSet = {};
var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
  ' ': 1, '"': 1, '<': 1, '>': 1, '`': 1
});
var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
  '#': 1, '?': 1, '{': 1, '}': 1
});
var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\': 1, ']': 1, '^': 1, '|': 1
});

var percentEncode = function (chr, set) {
  var code = codeAt(chr, 0);
  return code > 0x20 && code < 0x7F && !hasOwn(set, chr) ? chr : encodeURIComponent(chr);
};

// https://url.spec.whatwg.org/#special-scheme
var specialSchemes = {
  ftp: 21,
  file: null,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};

// https://url.spec.whatwg.org/#windows-drive-letter
var isWindowsDriveLetter = function (string, normalized) {
  var second;
  return string.length == 2 && exec(ALPHA, charAt(string, 0))
    && ((second = charAt(string, 1)) == ':' || (!normalized && second == '|'));
};

// https://url.spec.whatwg.org/#start-with-a-windows-drive-letter
var startsWithWindowsDriveLetter = function (string) {
  var third;
  return string.length > 1 && isWindowsDriveLetter(stringSlice(string, 0, 2)) && (
    string.length == 2 ||
    ((third = charAt(string, 2)) === '/' || third === '\\' || third === '?' || third === '#')
  );
};

// https://url.spec.whatwg.org/#single-dot-path-segment
var isSingleDot = function (segment) {
  return segment === '.' || toLowerCase(segment) === '%2e';
};

// https://url.spec.whatwg.org/#double-dot-path-segment
var isDoubleDot = function (segment) {
  segment = toLowerCase(segment);
  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
};

// States:
var SCHEME_START = {};
var SCHEME = {};
var NO_SCHEME = {};
var SPECIAL_RELATIVE_OR_AUTHORITY = {};
var PATH_OR_AUTHORITY = {};
var RELATIVE = {};
var RELATIVE_SLASH = {};
var SPECIAL_AUTHORITY_SLASHES = {};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
var AUTHORITY = {};
var HOST = {};
var HOSTNAME = {};
var PORT = {};
var FILE = {};
var FILE_SLASH = {};
var FILE_HOST = {};
var PATH_START = {};
var PATH = {};
var CANNOT_BE_A_BASE_URL_PATH = {};
var QUERY = {};
var FRAGMENT = {};

var URLState = function (url, isBase, base) {
  var urlString = $toString(url);
  var baseState, failure, searchParams;
  if (isBase) {
    failure = this.parse(urlString);
    if (failure) throw TypeError(failure);
    this.searchParams = null;
  } else {
    if (base !== undefined) baseState = new URLState(base, true);
    failure = this.parse(urlString, null, baseState);
    if (failure) throw TypeError(failure);
    searchParams = getInternalSearchParamsState(new URLSearchParams());
    searchParams.bindURL(this);
    this.searchParams = searchParams;
  }
};

URLState.prototype = {
  type: 'URL',
  // https://url.spec.whatwg.org/#url-parsing
  // eslint-disable-next-line max-statements -- TODO
  parse: function (input, stateOverride, base) {
    var url = this;
    var state = stateOverride || SCHEME_START;
    var pointer = 0;
    var buffer = '';
    var seenAt = false;
    var seenBracket = false;
    var seenPasswordToken = false;
    var codePoints, chr, bufferCodePoints, failure;

    input = $toString(input);

    if (!stateOverride) {
      url.scheme = '';
      url.username = '';
      url.password = '';
      url.host = null;
      url.port = null;
      url.path = [];
      url.query = null;
      url.fragment = null;
      url.cannotBeABaseURL = false;
      input = replace(input, LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
    }

    input = replace(input, TAB_AND_NEW_LINE, '');

    codePoints = arrayFrom(input);

    while (pointer <= codePoints.length) {
      chr = codePoints[pointer];
      switch (state) {
        case SCHEME_START:
          if (chr && exec(ALPHA, chr)) {
            buffer += toLowerCase(chr);
            state = SCHEME;
          } else if (!stateOverride) {
            state = NO_SCHEME;
            continue;
          } else return INVALID_SCHEME;
          break;

        case SCHEME:
          if (chr && (exec(ALPHANUMERIC, chr) || chr == '+' || chr == '-' || chr == '.')) {
            buffer += toLowerCase(chr);
          } else if (chr == ':') {
            if (stateOverride && (
              (url.isSpecial() != hasOwn(specialSchemes, buffer)) ||
              (buffer == 'file' && (url.includesCredentials() || url.port !== null)) ||
              (url.scheme == 'file' && !url.host)
            )) return;
            url.scheme = buffer;
            if (stateOverride) {
              if (url.isSpecial() && specialSchemes[url.scheme] == url.port) url.port = null;
              return;
            }
            buffer = '';
            if (url.scheme == 'file') {
              state = FILE;
            } else if (url.isSpecial() && base && base.scheme == url.scheme) {
              state = SPECIAL_RELATIVE_OR_AUTHORITY;
            } else if (url.isSpecial()) {
              state = SPECIAL_AUTHORITY_SLASHES;
            } else if (codePoints[pointer + 1] == '/') {
              state = PATH_OR_AUTHORITY;
              pointer++;
            } else {
              url.cannotBeABaseURL = true;
              push(url.path, '');
              state = CANNOT_BE_A_BASE_URL_PATH;
            }
          } else if (!stateOverride) {
            buffer = '';
            state = NO_SCHEME;
            pointer = 0;
            continue;
          } else return INVALID_SCHEME;
          break;

        case NO_SCHEME:
          if (!base || (base.cannotBeABaseURL && chr != '#')) return INVALID_SCHEME;
          if (base.cannotBeABaseURL && chr == '#') {
            url.scheme = base.scheme;
            url.path = arraySlice(base.path);
            url.query = base.query;
            url.fragment = '';
            url.cannotBeABaseURL = true;
            state = FRAGMENT;
            break;
          }
          state = base.scheme == 'file' ? FILE : RELATIVE;
          continue;

        case SPECIAL_RELATIVE_OR_AUTHORITY:
          if (chr == '/' && codePoints[pointer + 1] == '/') {
            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
            pointer++;
          } else {
            state = RELATIVE;
            continue;
          } break;

        case PATH_OR_AUTHORITY:
          if (chr == '/') {
            state = AUTHORITY;
            break;
          } else {
            state = PATH;
            continue;
          }

        case RELATIVE:
          url.scheme = base.scheme;
          if (chr == EOF) {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.query = base.query;
          } else if (chr == '/' || (chr == '\\' && url.isSpecial())) {
            state = RELATIVE_SLASH;
          } else if (chr == '?') {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.query = '';
            state = QUERY;
          } else if (chr == '#') {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.query = base.query;
            url.fragment = '';
            state = FRAGMENT;
          } else {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.path.length--;
            state = PATH;
            continue;
          } break;

        case RELATIVE_SLASH:
          if (url.isSpecial() && (chr == '/' || chr == '\\')) {
            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          } else if (chr == '/') {
            state = AUTHORITY;
          } else {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            state = PATH;
            continue;
          } break;

        case SPECIAL_AUTHORITY_SLASHES:
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          if (chr != '/' || charAt(buffer, pointer + 1) != '/') continue;
          pointer++;
          break;

        case SPECIAL_AUTHORITY_IGNORE_SLASHES:
          if (chr != '/' && chr != '\\') {
            state = AUTHORITY;
            continue;
          } break;

        case AUTHORITY:
          if (chr == '@') {
            if (seenAt) buffer = '%40' + buffer;
            seenAt = true;
            bufferCodePoints = arrayFrom(buffer);
            for (var i = 0; i < bufferCodePoints.length; i++) {
              var codePoint = bufferCodePoints[i];
              if (codePoint == ':' && !seenPasswordToken) {
                seenPasswordToken = true;
                continue;
              }
              var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
              if (seenPasswordToken) url.password += encodedCodePoints;
              else url.username += encodedCodePoints;
            }
            buffer = '';
          } else if (
            chr == EOF || chr == '/' || chr == '?' || chr == '#' ||
            (chr == '\\' && url.isSpecial())
          ) {
            if (seenAt && buffer == '') return INVALID_AUTHORITY;
            pointer -= arrayFrom(buffer).length + 1;
            buffer = '';
            state = HOST;
          } else buffer += chr;
          break;

        case HOST:
        case HOSTNAME:
          if (stateOverride && url.scheme == 'file') {
            state = FILE_HOST;
            continue;
          } else if (chr == ':' && !seenBracket) {
            if (buffer == '') return INVALID_HOST;
            failure = url.parseHost(buffer);
            if (failure) return failure;
            buffer = '';
            state = PORT;
            if (stateOverride == HOSTNAME) return;
          } else if (
            chr == EOF || chr == '/' || chr == '?' || chr == '#' ||
            (chr == '\\' && url.isSpecial())
          ) {
            if (url.isSpecial() && buffer == '') return INVALID_HOST;
            if (stateOverride && buffer == '' && (url.includesCredentials() || url.port !== null)) return;
            failure = url.parseHost(buffer);
            if (failure) return failure;
            buffer = '';
            state = PATH_START;
            if (stateOverride) return;
            continue;
          } else {
            if (chr == '[') seenBracket = true;
            else if (chr == ']') seenBracket = false;
            buffer += chr;
          } break;

        case PORT:
          if (exec(DIGIT, chr)) {
            buffer += chr;
          } else if (
            chr == EOF || chr == '/' || chr == '?' || chr == '#' ||
            (chr == '\\' && url.isSpecial()) ||
            stateOverride
          ) {
            if (buffer != '') {
              var port = parseInt(buffer, 10);
              if (port > 0xFFFF) return INVALID_PORT;
              url.port = (url.isSpecial() && port === specialSchemes[url.scheme]) ? null : port;
              buffer = '';
            }
            if (stateOverride) return;
            state = PATH_START;
            continue;
          } else return INVALID_PORT;
          break;

        case FILE:
          url.scheme = 'file';
          if (chr == '/' || chr == '\\') state = FILE_SLASH;
          else if (base && base.scheme == 'file') {
            if (chr == EOF) {
              url.host = base.host;
              url.path = arraySlice(base.path);
              url.query = base.query;
            } else if (chr == '?') {
              url.host = base.host;
              url.path = arraySlice(base.path);
              url.query = '';
              state = QUERY;
            } else if (chr == '#') {
              url.host = base.host;
              url.path = arraySlice(base.path);
              url.query = base.query;
              url.fragment = '';
              state = FRAGMENT;
            } else {
              if (!startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ''))) {
                url.host = base.host;
                url.path = arraySlice(base.path);
                url.shortenPath();
              }
              state = PATH;
              continue;
            }
          } else {
            state = PATH;
            continue;
          } break;

        case FILE_SLASH:
          if (chr == '/' || chr == '\\') {
            state = FILE_HOST;
            break;
          }
          if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ''))) {
            if (isWindowsDriveLetter(base.path[0], true)) push(url.path, base.path[0]);
            else url.host = base.host;
          }
          state = PATH;
          continue;

        case FILE_HOST:
          if (chr == EOF || chr == '/' || chr == '\\' || chr == '?' || chr == '#') {
            if (!stateOverride && isWindowsDriveLetter(buffer)) {
              state = PATH;
            } else if (buffer == '') {
              url.host = '';
              if (stateOverride) return;
              state = PATH_START;
            } else {
              failure = url.parseHost(buffer);
              if (failure) return failure;
              if (url.host == 'localhost') url.host = '';
              if (stateOverride) return;
              buffer = '';
              state = PATH_START;
            } continue;
          } else buffer += chr;
          break;

        case PATH_START:
          if (url.isSpecial()) {
            state = PATH;
            if (chr != '/' && chr != '\\') continue;
          } else if (!stateOverride && chr == '?') {
            url.query = '';
            state = QUERY;
          } else if (!stateOverride && chr == '#') {
            url.fragment = '';
            state = FRAGMENT;
          } else if (chr != EOF) {
            state = PATH;
            if (chr != '/') continue;
          } break;

        case PATH:
          if (
            chr == EOF || chr == '/' ||
            (chr == '\\' && url.isSpecial()) ||
            (!stateOverride && (chr == '?' || chr == '#'))
          ) {
            if (isDoubleDot(buffer)) {
              url.shortenPath();
              if (chr != '/' && !(chr == '\\' && url.isSpecial())) {
                push(url.path, '');
              }
            } else if (isSingleDot(buffer)) {
              if (chr != '/' && !(chr == '\\' && url.isSpecial())) {
                push(url.path, '');
              }
            } else {
              if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
                if (url.host) url.host = '';
                buffer = charAt(buffer, 0) + ':'; // normalize windows drive letter
              }
              push(url.path, buffer);
            }
            buffer = '';
            if (url.scheme == 'file' && (chr == EOF || chr == '?' || chr == '#')) {
              while (url.path.length > 1 && url.path[0] === '') {
                shift(url.path);
              }
            }
            if (chr == '?') {
              url.query = '';
              state = QUERY;
            } else if (chr == '#') {
              url.fragment = '';
              state = FRAGMENT;
            }
          } else {
            buffer += percentEncode(chr, pathPercentEncodeSet);
          } break;

        case CANNOT_BE_A_BASE_URL_PATH:
          if (chr == '?') {
            url.query = '';
            state = QUERY;
          } else if (chr == '#') {
            url.fragment = '';
            state = FRAGMENT;
          } else if (chr != EOF) {
            url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
          } break;

        case QUERY:
          if (!stateOverride && chr == '#') {
            url.fragment = '';
            state = FRAGMENT;
          } else if (chr != EOF) {
            if (chr == "'" && url.isSpecial()) url.query += '%27';
            else if (chr == '#') url.query += '%23';
            else url.query += percentEncode(chr, C0ControlPercentEncodeSet);
          } break;

        case FRAGMENT:
          if (chr != EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
          break;
      }

      pointer++;
    }
  },
  // https://url.spec.whatwg.org/#host-parsing
  parseHost: function (input) {
    var result, codePoints, index;
    if (charAt(input, 0) == '[') {
      if (charAt(input, input.length - 1) != ']') return INVALID_HOST;
      result = parseIPv6(stringSlice(input, 1, -1));
      if (!result) return INVALID_HOST;
      this.host = result;
    // opaque host
    } else if (!this.isSpecial()) {
      if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;
      result = '';
      codePoints = arrayFrom(input);
      for (index = 0; index < codePoints.length; index++) {
        result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
      }
      this.host = result;
    } else {
      input = toASCII(input);
      if (exec(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;
      result = parseIPv4(input);
      if (result === null) return INVALID_HOST;
      this.host = result;
    }
  },
  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port
  cannotHaveUsernamePasswordPort: function () {
    return !this.host || this.cannotBeABaseURL || this.scheme == 'file';
  },
  // https://url.spec.whatwg.org/#include-credentials
  includesCredentials: function () {
    return this.username != '' || this.password != '';
  },
  // https://url.spec.whatwg.org/#is-special
  isSpecial: function () {
    return hasOwn(specialSchemes, this.scheme);
  },
  // https://url.spec.whatwg.org/#shorten-a-urls-path
  shortenPath: function () {
    var path = this.path;
    var pathSize = path.length;
    if (pathSize && (this.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
      path.length--;
    }
  },
  // https://url.spec.whatwg.org/#concept-url-serializer
  serialize: function () {
    var url = this;
    var scheme = url.scheme;
    var username = url.username;
    var password = url.password;
    var host = url.host;
    var port = url.port;
    var path = url.path;
    var query = url.query;
    var fragment = url.fragment;
    var output = scheme + ':';
    if (host !== null) {
      output += '//';
      if (url.includesCredentials()) {
        output += username + (password ? ':' + password : '') + '@';
      }
      output += serializeHost(host);
      if (port !== null) output += ':' + port;
    } else if (scheme == 'file') output += '//';
    output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';
    if (query !== null) output += '?' + query;
    if (fragment !== null) output += '#' + fragment;
    return output;
  },
  // https://url.spec.whatwg.org/#dom-url-href
  setHref: function (href) {
    var failure = this.parse(href);
    if (failure) throw TypeError(failure);
    this.searchParams.update();
  },
  // https://url.spec.whatwg.org/#dom-url-origin
  getOrigin: function () {
    var scheme = this.scheme;
    var port = this.port;
    if (scheme == 'blob') try {
      return new URLConstructor(scheme.path[0]).origin;
    } catch (error) {
      return 'null';
    }
    if (scheme == 'file' || !this.isSpecial()) return 'null';
    return scheme + '://' + serializeHost(this.host) + (port !== null ? ':' + port : '');
  },
  // https://url.spec.whatwg.org/#dom-url-protocol
  getProtocol: function () {
    return this.scheme + ':';
  },
  setProtocol: function (protocol) {
    this.parse($toString(protocol) + ':', SCHEME_START);
  },
  // https://url.spec.whatwg.org/#dom-url-username
  getUsername: function () {
    return this.username;
  },
  setUsername: function (username) {
    var codePoints = arrayFrom($toString(username));
    if (this.cannotHaveUsernamePasswordPort()) return;
    this.username = '';
    for (var i = 0; i < codePoints.length; i++) {
      this.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
    }
  },
  // https://url.spec.whatwg.org/#dom-url-password
  getPassword: function () {
    return this.password;
  },
  setPassword: function (password) {
    var codePoints = arrayFrom($toString(password));
    if (this.cannotHaveUsernamePasswordPort()) return;
    this.password = '';
    for (var i = 0; i < codePoints.length; i++) {
      this.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
    }
  },
  // https://url.spec.whatwg.org/#dom-url-host
  getHost: function () {
    var host = this.host;
    var port = this.port;
    return host === null ? ''
      : port === null ? serializeHost(host)
      : serializeHost(host) + ':' + port;
  },
  setHost: function (host) {
    if (this.cannotBeABaseURL) return;
    this.parse(host, HOST);
  },
  // https://url.spec.whatwg.org/#dom-url-hostname
  getHostname: function () {
    var host = this.host;
    return host === null ? '' : serializeHost(host);
  },
  setHostname: function (hostname) {
    if (this.cannotBeABaseURL) return;
    this.parse(hostname, HOSTNAME);
  },
  // https://url.spec.whatwg.org/#dom-url-port
  getPort: function () {
    var port = this.port;
    return port === null ? '' : $toString(port);
  },
  setPort: function (port) {
    if (this.cannotHaveUsernamePasswordPort()) return;
    port = $toString(port);
    if (port == '') this.port = null;
    else this.parse(port, PORT);
  },
  // https://url.spec.whatwg.org/#dom-url-pathname
  getPathname: function () {
    var path = this.path;
    return this.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';
  },
  setPathname: function (pathname) {
    if (this.cannotBeABaseURL) return;
    this.path = [];
    this.parse(pathname, PATH_START);
  },
  // https://url.spec.whatwg.org/#dom-url-search
  getSearch: function () {
    var query = this.query;
    return query ? '?' + query : '';
  },
  setSearch: function (search) {
    search = $toString(search);
    if (search == '') {
      this.query = null;
    } else {
      if ('?' == charAt(search, 0)) search = stringSlice(search, 1);
      this.query = '';
      this.parse(search, QUERY);
    }
    this.searchParams.update();
  },
  // https://url.spec.whatwg.org/#dom-url-searchparams
  getSearchParams: function () {
    return this.searchParams.facade;
  },
  // https://url.spec.whatwg.org/#dom-url-hash
  getHash: function () {
    var fragment = this.fragment;
    return fragment ? '#' + fragment : '';
  },
  setHash: function (hash) {
    hash = $toString(hash);
    if (hash == '') {
      this.fragment = null;
      return;
    }
    if ('#' == charAt(hash, 0)) hash = stringSlice(hash, 1);
    this.fragment = '';
    this.parse(hash, FRAGMENT);
  },
  update: function () {
    this.query = this.searchParams.serialize() || null;
  }
};

// `URL` constructor
// https://url.spec.whatwg.org/#url-class
var URLConstructor = function URL(url /* , base */) {
  var that = anInstance(this, URLPrototype);
  var base = validateArgumentsLength(arguments.length, 1) > 1 ? arguments[1] : undefined;
  var state = setInternalState(that, new URLState(url, false, base));
  if (!DESCRIPTORS) {
    that.href = state.serialize();
    that.origin = state.getOrigin();
    that.protocol = state.getProtocol();
    that.username = state.getUsername();
    that.password = state.getPassword();
    that.host = state.getHost();
    that.hostname = state.getHostname();
    that.port = state.getPort();
    that.pathname = state.getPathname();
    that.search = state.getSearch();
    that.searchParams = state.getSearchParams();
    that.hash = state.getHash();
  }
};

var URLPrototype = URLConstructor.prototype;

var accessorDescriptor = function (getter, setter) {
  return {
    get: function () {
      return getInternalURLState(this)[getter]();
    },
    set: setter && function (value) {
      return getInternalURLState(this)[setter](value);
    },
    configurable: true,
    enumerable: true
  };
};

if (DESCRIPTORS) {
  // `URL.prototype.href` accessors pair
  // https://url.spec.whatwg.org/#dom-url-href
  defineBuiltInAccessor(URLPrototype, 'href', accessorDescriptor('serialize', 'setHref'));
  // `URL.prototype.origin` getter
  // https://url.spec.whatwg.org/#dom-url-origin
  defineBuiltInAccessor(URLPrototype, 'origin', accessorDescriptor('getOrigin'));
  // `URL.prototype.protocol` accessors pair
  // https://url.spec.whatwg.org/#dom-url-protocol
  defineBuiltInAccessor(URLPrototype, 'protocol', accessorDescriptor('getProtocol', 'setProtocol'));
  // `URL.prototype.username` accessors pair
  // https://url.spec.whatwg.org/#dom-url-username
  defineBuiltInAccessor(URLPrototype, 'username', accessorDescriptor('getUsername', 'setUsername'));
  // `URL.prototype.password` accessors pair
  // https://url.spec.whatwg.org/#dom-url-password
  defineBuiltInAccessor(URLPrototype, 'password', accessorDescriptor('getPassword', 'setPassword'));
  // `URL.prototype.host` accessors pair
  // https://url.spec.whatwg.org/#dom-url-host
  defineBuiltInAccessor(URLPrototype, 'host', accessorDescriptor('getHost', 'setHost'));
  // `URL.prototype.hostname` accessors pair
  // https://url.spec.whatwg.org/#dom-url-hostname
  defineBuiltInAccessor(URLPrototype, 'hostname', accessorDescriptor('getHostname', 'setHostname'));
  // `URL.prototype.port` accessors pair
  // https://url.spec.whatwg.org/#dom-url-port
  defineBuiltInAccessor(URLPrototype, 'port', accessorDescriptor('getPort', 'setPort'));
  // `URL.prototype.pathname` accessors pair
  // https://url.spec.whatwg.org/#dom-url-pathname
  defineBuiltInAccessor(URLPrototype, 'pathname', accessorDescriptor('getPathname', 'setPathname'));
  // `URL.prototype.search` accessors pair
  // https://url.spec.whatwg.org/#dom-url-search
  defineBuiltInAccessor(URLPrototype, 'search', accessorDescriptor('getSearch', 'setSearch'));
  // `URL.prototype.searchParams` getter
  // https://url.spec.whatwg.org/#dom-url-searchparams
  defineBuiltInAccessor(URLPrototype, 'searchParams', accessorDescriptor('getSearchParams'));
  // `URL.prototype.hash` accessors pair
  // https://url.spec.whatwg.org/#dom-url-hash
  defineBuiltInAccessor(URLPrototype, 'hash', accessorDescriptor('getHash', 'setHash'));
}

// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
defineBuiltIn(URLPrototype, 'toJSON', function toJSON() {
  return getInternalURLState(this).serialize();
}, { enumerable: true });

// `URL.prototype.toString` method
// https://url.spec.whatwg.org/#URL-stringification-behavior
defineBuiltIn(URLPrototype, 'toString', function toString() {
  return getInternalURLState(this).serialize();
}, { enumerable: true });

if (NativeURL) {
  var nativeCreateObjectURL = NativeURL.createObjectURL;
  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
  // `URL.createObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
  if (nativeCreateObjectURL) defineBuiltIn(URLConstructor, 'createObjectURL', bind(nativeCreateObjectURL, NativeURL));
  // `URL.revokeObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
  if (nativeRevokeObjectURL) defineBuiltIn(URLConstructor, 'revokeObjectURL', bind(nativeRevokeObjectURL, NativeURL));
}

setToStringTag(URLConstructor, 'URL');

$({ global: true, constructor: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
  URL: URLConstructor
});


/***/ }),

/***/ 3205:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(3206);


/***/ }),

/***/ 3196:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(2944);
var call = __webpack_require__(2949);

// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
$({ target: 'URL', proto: true, enumerable: true }, {
  toJSON: function toJSON() {
    return call(URL.prototype.toString, this);
  }
});


/***/ }),

/***/ 3216:
/***/ (function(module, exports) {

var global = typeof self !== 'undefined' ? self : this;
var __self__ = (function () {
function F() {
this.fetch = false;
this.DOMException = global.DOMException
}
F.prototype = global;
return new F();
})();
(function(self) {

var irrelevant = (function (exports) {

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
})(__self__);
__self__.fetch.ponyfill = true;
// Remove "polyfill" property added by whatwg-fetch
delete __self__.fetch.polyfill;
// Choose between native implementation (global) or custom implementation (__self__)
// var ctx = global.fetch ? global : __self__;
var ctx = __self__; // this line disable service worker support temporarily
exports = ctx.fetch // To enable: import fetch from 'cross-fetch'
exports["default"] = ctx.fetch // For TypeScript consumers without esModuleInterop.
exports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'
exports.Headers = ctx.Headers
exports.Request = ctx.Request
exports.Response = ctx.Response
module.exports = exports


/***/ }),

/***/ 3110:
/***/ ((module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(454)["process"];
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(3111);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = ({"NODE_ENV":"production"}).DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ 3111:
/***/ ((module, exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(2423);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ 3280:
/***/ (function(module, exports, __webpack_require__) {

/* provided dependency */ var process = __webpack_require__(454)["process"];
/* provided dependency */ var Buffer = __webpack_require__(3212)["Buffer"];
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(globals){
'use strict'

//*** UMD BEGIN
if (true) { //require.js / AMD
  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
    return secureRandom
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
} else {}
//*** UMD END

//options.type is the only valid option
function secureRandom(count, options) {
  options = options || {type: 'Array'}
  //we check for process.pid to prevent browserify from tricking us
  if (
    typeof process != 'undefined'
    && typeof process.pid == 'number'
    && process.versions
    && process.versions.node
  ) {
    return nodeRandom(count, options)
  } else {
    var crypto = window.crypto || window.msCrypto
    if (!crypto) throw new Error("Your browser does not support window.crypto.")
    return browserRandom(count, options)
  }
}

function nodeRandom(count, options) {
  var crypto = __webpack_require__(3281)
  var buf = crypto.randomBytes(count)

  switch (options.type) {
    case 'Array':
      return [].slice.call(buf)
    case 'Buffer':
      return buf
    case 'Uint8Array':
      var arr = new Uint8Array(count)
      for (var i = 0; i < count; ++i) { arr[i] = buf.readUInt8(i) }
      return arr
    default:
      throw new Error(options.type + " is unsupported.")
  }
}

function browserRandom(count, options) {
  var nativeArr = new Uint8Array(count)
  var crypto = window.crypto || window.msCrypto
  crypto.getRandomValues(nativeArr)

  switch (options.type) {
    case 'Array':
      return [].slice.call(nativeArr)
    case 'Buffer':
      try { var b = new Buffer(1) } catch(e) { throw new Error('Buffer not supported in this environment. Use Node.js or Browserify for browser support.')}
      return new Buffer(nativeArr)
    case 'Uint8Array':
      return nativeArr
    default:
      throw new Error(options.type + " is unsupported.")
  }
}

secureRandom.randomArray = function(byteCount) {
  return secureRandom(byteCount, {type: 'Array'})
}

secureRandom.randomUint8Array = function(byteCount) {
  return secureRandom(byteCount, {type: 'Uint8Array'})
}

secureRandom.randomBuffer = function(byteCount) {
  return secureRandom(byteCount, {type: 'Buffer'})
}


}(this);


/***/ }),

/***/ 3266:
/***/ ((module) => {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ 3255:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



var isArgumentsObject = __webpack_require__(3256);
var isGeneratorFunction = __webpack_require__(3258);
var whichTypedArray = __webpack_require__(3259);
var isTypedArray = __webpack_require__(3264);

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});


/***/ }),

/***/ 3254:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(454)["process"];
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (({"NODE_ENV":"production"}).NODE_DEBUG) {
  var debugEnv = ({"NODE_ENV":"production"}).NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = __webpack_require__(3255);

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(3266);

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(466);

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;


/***/ }),

/***/ 3257:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(1955);

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


/***/ }),

/***/ 3256:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasToStringTag = __webpack_require__(3257)();
var callBound = __webpack_require__(1958);

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


/***/ }),

/***/ 3261:
/***/ ((module) => {

"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`
/* globals document: false */
var documentDotAll = typeof document === 'object' && typeof document.all === 'undefined' && document.all !== undefined ? document.all : {};

module.exports = reflectApply
	? function isCallable(value) {
		if (value === documentDotAll) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (typeof value === 'function' && !value.prototype) { return true; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value);
	}
	: function isCallable(value) {
		if (value === documentDotAll) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (typeof value === 'function' && !value.prototype) { return true; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		return strClass === fnClass || strClass === genClass;
	};


/***/ }),

/***/ 3258:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = __webpack_require__(3257)();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var GeneratorFunction;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
	}
	return getProto(fn) === GeneratorFunction;
};


/***/ }),

/***/ 3275:
/***/ ((module) => {

"use strict";


/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function isNaN(value) {
	return value !== value;
};


/***/ }),

/***/ 3274:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(1950);
var define = __webpack_require__(1946);

var implementation = __webpack_require__(3275);
var getPolyfill = __webpack_require__(3276);
var shim = __webpack_require__(3277);

var polyfill = callBind(getPolyfill(), Number);

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ 3276:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(3275);

module.exports = function getPolyfill() {
	if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
		return Number.isNaN;
	}
	return implementation;
};


/***/ }),

/***/ 3277:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(1946);
var getPolyfill = __webpack_require__(3276);

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function shimNumberIsNaN() {
	var polyfill = getPolyfill();
	define(Number, { isNaN: polyfill }, {
		isNaN: function testIsNaN() {
			return Number.isNaN !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ 3264:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(3260);
var availableTypedArrays = __webpack_require__(3262);
var callBound = __webpack_require__(1958);

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __webpack_require__(3257)();

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = __webpack_require__(3265);
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr) {
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			toStrTags[typedArray] = descriptor.get;
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) {
		var tag = $slice($toString(value), 8, -1);
		return $indexOf(typedArrays, tag) > -1;
	}
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};


/***/ }),

/***/ 2924:
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),

/***/ 3094:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(1347),
    keys = __webpack_require__(1631);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),

/***/ 3095:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(1347),
    keysIn = __webpack_require__(1348);

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),

/***/ 3093:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(1316),
    arrayEach = __webpack_require__(2924),
    assignValue = __webpack_require__(1184),
    baseAssign = __webpack_require__(3094),
    baseAssignIn = __webpack_require__(3095),
    cloneBuffer = __webpack_require__(1326),
    copyArray = __webpack_require__(1330),
    copySymbols = __webpack_require__(3096),
    copySymbolsIn = __webpack_require__(3097),
    getAllKeys = __webpack_require__(1673),
    getAllKeysIn = __webpack_require__(3099),
    getTag = __webpack_require__(1620),
    initCloneArray = __webpack_require__(3100),
    initCloneByTag = __webpack_require__(3101),
    initCloneObject = __webpack_require__(1331),
    isArray = __webpack_require__(1098),
    isBuffer = __webpack_require__(1338),
    isMap = __webpack_require__(3105),
    isObject = __webpack_require__(991),
    isSet = __webpack_require__(3107),
    keys = __webpack_require__(1631),
    keysIn = __webpack_require__(1348);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),

/***/ 2925:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseForOwn = __webpack_require__(2926),
    createBaseEach = __webpack_require__(2927);

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;


/***/ }),

/***/ 2926:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFor = __webpack_require__(1323),
    keys = __webpack_require__(1631);

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),

/***/ 3106:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(1620),
    isObjectLike = __webpack_require__(1003);

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),

/***/ 3344:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(999),
    isObjectLike = __webpack_require__(1003);

/** `Object#toString` result references. */
var regexpTag = '[object RegExp]';

/**
 * The base implementation of `_.isRegExp` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 */
function baseIsRegExp(value) {
  return isObjectLike(value) && baseGetTag(value) == regexpTag;
}

module.exports = baseIsRegExp;


/***/ }),

/***/ 3108:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(1620),
    isObjectLike = __webpack_require__(1003);

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),

/***/ 2928:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(1355);

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;


/***/ }),

/***/ 3102:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(1328);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),

/***/ 3103:
/***/ ((module) => {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),

/***/ 3104:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(1000);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),

/***/ 3096:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(1347),
    getSymbols = __webpack_require__(1676);

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),

/***/ 3097:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(1347),
    getSymbolsIn = __webpack_require__(3098);

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),

/***/ 2927:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(1337);

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;


/***/ }),

/***/ 3099:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(1674),
    getSymbolsIn = __webpack_require__(3098),
    keysIn = __webpack_require__(1348);

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),

/***/ 3098:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(1675),
    getPrototype = __webpack_require__(1333),
    getSymbols = __webpack_require__(1676),
    stubArray = __webpack_require__(1678);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),

/***/ 3100:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),

/***/ 3101:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(1328),
    cloneDataView = __webpack_require__(3102),
    cloneRegExp = __webpack_require__(3103),
    cloneSymbol = __webpack_require__(3104),
    cloneTypedArray = __webpack_require__(1327);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),

/***/ 3092:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__(3093);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),

/***/ 3109:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__(1354),
    eq = __webpack_require__(1123),
    isIterateeCall = __webpack_require__(1362),
    keysIn = __webpack_require__(1348);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults = baseRest(function(object, sources) {
  object = Object(object);

  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = keysIn(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined ||
          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        object[key] = source[key];
      }
    }
  }

  return object;
});

module.exports = defaults;


/***/ }),

/***/ 2922:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(2923);


/***/ }),

/***/ 2923:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayEach = __webpack_require__(2924),
    baseEach = __webpack_require__(2925),
    castFunction = __webpack_require__(2928),
    isArray = __webpack_require__(1098);

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;


/***/ }),

/***/ 3105:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMap = __webpack_require__(3106),
    baseUnary = __webpack_require__(1343),
    nodeUtil = __webpack_require__(1344);

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),

/***/ 3343:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsRegExp = __webpack_require__(3344),
    baseUnary = __webpack_require__(1343),
    nodeUtil = __webpack_require__(1344);

/* Node.js helper references. */
var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;

/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */
var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

module.exports = isRegExp;


/***/ }),

/***/ 3107:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsSet = __webpack_require__(3108),
    baseUnary = __webpack_require__(1343),
    nodeUtil = __webpack_require__(1344);

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),

/***/ 3342:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseToString = __webpack_require__(1135),
    castSlice = __webpack_require__(1240),
    hasUnicode = __webpack_require__(1242),
    isObject = __webpack_require__(991),
    isRegExp = __webpack_require__(3343),
    stringSize = __webpack_require__(1243),
    stringToArray = __webpack_require__(1247),
    toInteger = __webpack_require__(1250),
    toString = __webpack_require__(1134);

/** Used as default options for `_.truncate`. */
var DEFAULT_TRUNC_LENGTH = 30,
    DEFAULT_TRUNC_OMISSION = '...';

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Truncates `string` if it's longer than the given maximum string length.
 * The last characters of the truncated string are replaced with the omission
 * string which defaults to "...".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to truncate.
 * @param {Object} [options={}] The options object.
 * @param {number} [options.length=30] The maximum string length.
 * @param {string} [options.omission='...'] The string to indicate text is omitted.
 * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
 * @returns {string} Returns the truncated string.
 * @example
 *
 * _.truncate('hi-diddly-ho there, neighborino');
 * // => 'hi-diddly-ho there, neighbo...'
 *
 * _.truncate('hi-diddly-ho there, neighborino', {
 *   'length': 24,
 *   'separator': ' '
 * });
 * // => 'hi-diddly-ho there,...'
 *
 * _.truncate('hi-diddly-ho there, neighborino', {
 *   'length': 24,
 *   'separator': /,? +/
 * });
 * // => 'hi-diddly-ho there...'
 *
 * _.truncate('hi-diddly-ho there, neighborino', {
 *   'omission': ' [...]'
 * });
 * // => 'hi-diddly-ho there, neig [...]'
 */
function truncate(string, options) {
  var length = DEFAULT_TRUNC_LENGTH,
      omission = DEFAULT_TRUNC_OMISSION;

  if (isObject(options)) {
    var separator = 'separator' in options ? options.separator : separator;
    length = 'length' in options ? toInteger(options.length) : length;
    omission = 'omission' in options ? baseToString(options.omission) : omission;
  }
  string = toString(string);

  var strLength = string.length;
  if (hasUnicode(string)) {
    var strSymbols = stringToArray(string);
    strLength = strSymbols.length;
  }
  if (length >= strLength) {
    return string;
  }
  var end = length - stringSize(omission);
  if (end < 1) {
    return omission;
  }
  var result = strSymbols
    ? castSlice(strSymbols, 0, end).join('')
    : string.slice(0, end);

  if (separator === undefined) {
    return result + omission;
  }
  if (strSymbols) {
    end += (result.length - end);
  }
  if (isRegExp(separator)) {
    if (string.slice(end).search(separator)) {
      var match,
          substring = result;

      if (!separator.global) {
        separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
      }
      separator.lastIndex = 0;
      while ((match = separator.exec(substring))) {
        var newEnd = match.index;
      }
      result = result.slice(0, newEnd === undefined ? end : newEnd);
    }
  } else if (string.indexOf(baseToString(separator), end) != end) {
    var index = result.lastIndexOf(separator);
    if (index > -1) {
      result = result.slice(0, index);
    }
  }
  return result + omission;
}

module.exports = truncate;


/***/ }),

/***/ 3270:
/***/ ((module) => {

"use strict";


var numberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	}
	if (a === b) {
		return true;
	}
	if (numberIsNaN(a) && numberIsNaN(b)) {
		return true;
	}
	return false;
};



/***/ }),

/***/ 3269:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(1946);
var callBind = __webpack_require__(1950);

var implementation = __webpack_require__(3270);
var getPolyfill = __webpack_require__(3271);
var shim = __webpack_require__(3272);

var polyfill = callBind(getPolyfill(), Object);

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ 3271:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(3270);

module.exports = function getPolyfill() {
	return typeof Object.is === 'function' ? Object.is : implementation;
};


/***/ }),

/***/ 3272:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(3271);
var define = __webpack_require__(1946);

module.exports = function shimObjectIs() {
	var polyfill = getPolyfill();
	define(Object, { is: polyfill }, {
		is: function testObjectIs() {
			return Object.is !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ 3144:
/***/ ((module) => {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : 0
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),

/***/ 2920:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(471);

var _events2 = _interopRequireDefault(_events);

var _config = __webpack_require__(2921);

var _config2 = _interopRequireDefault(_config);

var _methods = __webpack_require__(2930);

var _methods2 = _interopRequireDefault(_methods);

var _transports = __webpack_require__(2931);

var _transports2 = _interopRequireDefault(_transports);

var _utils = __webpack_require__(2940);

var _http = __webpack_require__(2932);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
// import Promise from 'bluebird';

// import {
//     hash
// } from '../auth/ecc';
// import {
//     ops
// } from '../auth/serializer';


var Steem = function (_EventEmitter) {
    _inherits(Steem, _EventEmitter);

    function Steem() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Steem);

        var _this = _possibleConstructorReturn(this, (Steem.__proto__ || Object.getPrototypeOf(Steem)).call(this, options));

        _this._setTransport(options);
        _this._setLogger(options);
        _this.options = options;
        _this.seqNo = 0; // used for rpc calls
        _methods2.default.forEach(function (method) {
            var methodName = method.method_name || (0, _utils.camelCase)(method.method);
            var methodParams = method.params || [];

            _this[methodName + 'With'] = function (options, callback) {
                return new Promise(function (resolve, reject) {
                    _this.send(method.api, {
                        method: method.method,
                        params: methodParams.map(function (param) {
                            return options[param];
                        })
                    }, function (err, res) {
                        if (err) reject(err);else {
                            resolve(res);
                        }
                    });
                });
            };

            _this[methodName] = function () {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }

                var options = methodParams.reduce(function (memo, param, i) {
                    memo[param] = args[i]; // eslint-disable-line no-param-reassign
                    return memo;
                }, {});
                var callback = args[methodParams.length];
                return _this[methodName + 'With'](options, callback);
            };

            //   this[`${methodName}WithAsync`] = Promise.promisify(this[`${methodName}With`]);
            // this[`${methodName}Async`] = Promise.promisify(this[methodName]);
        });
        // this.callAsync = Promise.promisify(this.call);
        return _this;
    }

    _createClass(Steem, [{
        key: '_setTransport',
        value: function _setTransport(options) {
            if (options.url && options.url.match('^((http|https)?:\/\/)')) {
                options.uri = options.url;
                options.transport = 'http';
                this._transportType = options.transport;
                this.options = options;
                this.transport = new _transports2.default.http(options);
            } else if (options.url && options.url.match('^((ws|wss)?:\/\/)')) {
                options.websocket = options.url;
                options.transport = 'ws';
                this._transportType = options.transport;
                this.options = options;
                this.transport = new _transports2.default.ws(options);
            } else if (options.transport) {
                if (this.transport && this._transportType !== options.transport) {
                    this.transport.stop();
                }

                this._transportType = options.transport;

                if (typeof options.transport === 'string') {
                    if (!_transports2.default[options.transport]) {
                        throw new TypeError('Invalid `transport`, valid values are `http`, `ws` or a class');
                    }
                    this.transport = new _transports2.default[options.transport](options);
                } else {
                    this.transport = new options.transport(options);
                }
            } else {
                this.transport = new _transports2.default.ws(options);
            }
        }
    }, {
        key: '_setLogger',
        value: function _setLogger(options) {
            if (options.hasOwnProperty('logger')) {
                switch (_typeof(options.logger)) {
                    case 'function':
                        this.__logger = {
                            log: options.logger
                        };
                        break;
                    case 'object':
                        if (typeof options.logger.log !== 'function') {
                            throw new Error('setOptions({logger:{}}) must have a property .log of type function');
                        }
                        this.__logger = options.logger;
                        break;
                    case 'undefined':
                        if (this.__logger) break;
                    default:
                        this.__logger = false;
                }
            }
        }
    }, {
        key: 'log',
        value: function log(logLevel) {
            if (this.__logger) {
                if (arguments.length > 1 && typeof this.__logger[logLevel] === 'function') {
                    var args = Array.prototype.slice.call(arguments, 1);
                    this.__logger[logLevel].apply(this.__logger, args);
                } else {
                    this.__logger.log.apply(this.__logger, arguments);
                }
            }
        }
    }, {
        key: 'start',
        value: function start() {
            return this.transport.start();
        }
    }, {
        key: 'stop',
        value: function stop() {
            return this.transport.stop();
        }
    }, {
        key: 'send',
        value: function send(api, data, callback) {
            var cb = callback;
            if (this.__logger) {
                var id = Math.random();
                var self = this;
                this.log('xmit:' + id + ':', data);
                cb = function cb(e, d) {
                    if (e) {
                        self.log('error', 'rsp:' + id + ':\n\n', e, d);
                    } else {
                        self.log('rsp:' + id + ':', d);
                    }
                    if (callback) {
                        callback.apply(self, arguments);
                    }
                };
            }
            return this.transport.send(api, data, cb);
        }
    }, {
        key: 'call',
        value: function call(method, params, callback) {
            if (this._transportType !== 'http') {
                callback(new Error('RPC methods can only be called when using http transport'));
                return;
            }
            var id = ++this.seqNo;
            (0, _http.jsonRpc)(this.options.uri, { method: method, params: params, id: id }).then(function (res) {
                callback(null, res);
            }, function (err) {
                callback(err);
            });
        }
    }, {
        key: 'setOptions',
        value: function setOptions(options) {
            Object.assign(this.options, options);
            this._setLogger(options);
            this._setTransport(options);
            this.transport.setOptions(options);
        }
    }, {
        key: 'setWebSocket',
        value: function setWebSocket(url) {
            this.setOptions({
                websocket: url
            });
        }
    }, {
        key: 'setUri',
        value: function setUri(url) {
            this.setOptions({
                uri: url
            });
        }

        // broadcastTransactionSynchronousWith(options, callback) {
        // const trx = options.trx;
        // return this.send(
        //     'network_broadcast_api', {
        //         method: 'broadcast_transaction_synchronous',
        //         params: [trx],
        //     },
        //     (err, result) => {
        //         if (err) {
        //             const {
        //                 signed_transaction
        //             } = ops;
        //             // console.log('-- broadcastTransactionSynchronous -->', JSON.stringify(signed_transaction.toObject(trx), null, 2));
        //             // toObject converts objects into serializable types
        //             const trObject = signed_transaction.toObject(trx);
        //             const buf = signed_transaction.toBuffer(trx);
        //             err.digest = hash.sha256(buf).toString('hex');
        //             err.transaction_id = buf.toString('hex');
        //             err.transaction = JSON.stringify(trObject);
        //             callback(err, '');
        //         } else {
        //             callback('', result);
        //         }
        //     },
        // );
        //
        // }

    }]);

    return Steem;
}(_events2.default);

// Export singleton instance


var steem = new Steem(_config2.default);
exports = module.exports = steem;
exports.Steem = Steem;

/***/ }),

/***/ 2930:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = [{
  "api": "database_api",
  "method": "set_subscribe_callback",
  "params": ["callback", "clearFilter"]
}, {
  "api": "database_api",
  "method": "set_pending_transaction_callback",
  "params": ["cb"]
}, {
  "api": "database_api",
  "method": "set_block_applied_callback",
  "params": ["cb"]
}, {
  "api": "database_api",
  "method": "cancel_all_subscriptions"
}, {
  "api": "database_api",
  "method": "get_trending_tags",
  "params": ["afterTag", "limit"]
}, {
  "api": "database_api",
  "method": "get_tags_used_by_author",
  "params": ["author"]
}, {
  "api": "database_api",
  "method": "get_post_discussions_by_payout",
  "params": ["query"]
}, {
  "api": "database_api",
  "method": "get_comment_discussions_by_payout",
  "params": ["query"]
}, {
  "api": "database_api",
  "method": "get_discussions_by_trending",
  "params": ["query"]
}, {
  "api": "database_api",
  "method": "get_discussions_by_trending30",
  "params": ["query"]
}, {
  "api": "database_api",
  "method": "get_discussions_by_created",
  "params": ["query"]
}, {
  "api": "database_api",
  "method": "get_discussions_by_active",
  "params": ["query"]
}, {
  "api": "database_api",
  "method": "get_discussions_by_cashout",
  "params": ["query"]
}, {
  "api": "database_api",
  "method": "get_discussions_by_payout",
  "params": ["query"]
}, {
  "api": "database_api",
  "method": "get_discussions_by_votes",
  "params": ["query"]
}, {
  "api": "database_api",
  "method": "get_discussions_by_children",
  "params": ["query"]
}, {
  "api": "database_api",
  "method": "get_discussions_by_hot",
  "params": ["query"]
}, {
  "api": "database_api",
  "method": "get_discussions_by_feed",
  "params": ["query"]
}, {
  "api": "database_api",
  "method": "get_discussions_by_blog",
  "params": ["query"]
}, {
  "api": "database_api",
  "method": "get_discussions_by_comments",
  "params": ["query"]
}, {
  "api": "database_api",
  "method": "get_discussions_by_promoted",
  "params": ["query"]
}, {
  "api": "database_api",
  "method": "get_block_header",
  "params": ["blockNum"]
}, {
  "api": "database_api",
  "method": "get_block",
  "params": ["blockNum"]
}, {
  "api": "database_api",
  "method": "get_ops_in_block",
  "params": ["blockNum", "onlyVirtual"]
}, {
  "api": "database_api",
  "method": "get_state",
  "params": ["path"]
}, {
  "api": "database_api",
  "method": "get_trending_categories",
  "params": ["after", "limit"]
}, {
  "api": "database_api",
  "method": "get_best_categories",
  "params": ["after", "limit"]
}, {
  "api": "database_api",
  "method": "get_active_categories",
  "params": ["after", "limit"]
}, {
  "api": "database_api",
  "method": "get_recent_categories",
  "params": ["after", "limit"]
}, {
  "api": "database_api",
  "method": "get_config"
}, {
  "api": "database_api",
  "method": "get_dynamic_global_properties"
}, {
  "api": "database_api",
  "method": "get_chain_properties"
}, {
  "api": "database_api",
  "method": "get_feed_history"
}, {
  "api": "database_api",
  "method": "get_current_median_history_price"
}, {
  "api": "database_api",
  "method": "get_witness_schedule"
}, {
  "api": "database_api",
  "method": "get_hardfork_version"
}, {
  "api": "database_api",
  "method": "get_next_scheduled_hardfork"
}, {
  "api": "account_by_key_api",
  "method": "get_key_references",
  "params": ["key"]
}, {
  "api": "database_api",
  "method": "get_accounts",
  "params": ["names"]
}, {
  "api": "database_api",
  "method": "get_account_references",
  "params": ["accountId"]
}, {
  "api": "database_api",
  "method": "lookup_account_names",
  "params": ["accountNames"]
}, {
  "api": "database_api",
  "method": "lookup_accounts",
  "params": ["lowerBoundName", "limit"]
}, {
  "api": "database_api",
  "method": "get_account_count"
}, {
  "api": "database_api",
  "method": "get_conversion_requests",
  "params": ["accountName"]
}, {
  "api": "database_api",
  "method": "get_account_history",
  "params": ["account", "from", "limit"]
}, {
  "api": "database_api",
  "method": "get_owner_history",
  "params": ["account"]
}, {
  "api": "database_api",
  "method": "get_recovery_request",
  "params": ["account"]
}, {
  "api": "database_api",
  "method": "get_escrow",
  "params": ["from", "escrowId"]
}, {
  "api": "database_api",
  "method": "get_withdraw_routes",
  "params": ["account", "withdrawRouteType"]
}, {
  "api": "database_api",
  "method": "get_account_bandwidth",
  "params": ["account", "bandwidthType"]
}, {
  "api": "database_api",
  "method": "get_savings_withdraw_from",
  "params": ["account"]
}, {
  "api": "database_api",
  "method": "get_savings_withdraw_to",
  "params": ["account"]
}, {
  "api": "database_api",
  "method": "get_order_book",
  "params": ["limit"]
}, {
  "api": "database_api",
  "method": "get_open_orders",
  "params": ["owner"]
}, {
  "api": "database_api",
  "method": "get_liquidity_queue",
  "params": ["startAccount", "limit"]
}, {
  "api": "database_api",
  "method": "get_transaction_hex",
  "params": ["trx"]
}, {
  "api": "database_api",
  "method": "get_transaction",
  "params": ["trxId"]
}, {
  "api": "database_api",
  "method": "get_required_signatures",
  "params": ["trx", "availableKeys"]
}, {
  "api": "database_api",
  "method": "get_potential_signatures",
  "params": ["trx"]
}, {
  "api": "database_api",
  "method": "verify_authority",
  "params": ["trx"]
}, {
  "api": "database_api",
  "method": "verify_account_authority",
  "params": ["nameOrId", "signers"]
}, {
  "api": "database_api",
  "method": "get_active_votes",
  "params": ["author", "permlink"]
}, {
  "api": "database_api",
  "method": "get_account_votes",
  "params": ["voter"]
}, {
  "api": "database_api",
  "method": "get_content",
  "params": ["author", "permlink"]
}, {
  "api": "database_api",
  "method": "get_content_replies",
  "params": ["author", "permlink"]
}, {
  "api": "database_api",
  "method": "get_discussions_by_author_before_date",
  "params": ["author", "startPermlink", "beforeDate", "limit"]
}, {
  "api": "database_api",
  "method": "get_replies_by_last_update",
  "params": ["startAuthor", "startPermlink", "limit"]
}, {
  "api": "database_api",
  "method": "get_witnesses",
  "params": ["witnessIds"]
}, {
  "api": "database_api",
  "method": "get_witness_by_account",
  "params": ["accountName"]
}, {
  "api": "database_api",
  "method": "get_witnesses_by_vote",
  "params": ["from", "limit"]
}, {
  "api": "database_api",
  "method": "lookup_witness_accounts",
  "params": ["lowerBoundName", "limit"]
}, {
  "api": "database_api",
  "method": "get_witness_count"
}, {
  "api": "database_api",
  "method": "get_active_witnesses"
}, {
  "api": "database_api",
  "method": "get_miner_queue"
}, {
  "api": "database_api",
  "method": "get_reward_fund",
  "params": ["name"]
}, {
  "api": "database_api",
  "method": "get_vesting_delegations",
  "params": ["account", "from", "limit"]
}, {
  "api": "login_api",
  "method": "login",
  "params": ["username", "password"]
}, {
  "api": "login_api",
  "method": "get_api_by_name",
  "params": ["database_api"]
}, {
  "api": "login_api",
  "method": "get_version"
}, {
  "api": "follow_api",
  "method": "get_followers",
  "params": ["following", "startFollower", "followType", "limit"]
}, {
  "api": "follow_api",
  "method": "get_following",
  "params": ["follower", "startFollowing", "followType", "limit"]
}, {
  "api": "follow_api",
  "method": "get_follow_count",
  "params": ["account"]
}, {
  "api": "follow_api",
  "method": "get_feed_entries",
  "params": ["account", "entryId", "limit"]
}, {
  "api": "follow_api",
  "method": "get_feed",
  "params": ["account", "entryId", "limit"]
}, {
  "api": "follow_api",
  "method": "get_blog_entries",
  "params": ["account", "entryId", "limit"]
}, {
  "api": "follow_api",
  "method": "get_blog",
  "params": ["account", "entryId", "limit"]
}, {
  "api": "follow_api",
  "method": "get_account_reputations",
  "params": ["lowerBoundName", "limit"]
}, {
  "api": "follow_api",
  "method": "get_reblogged_by",
  "params": ["author", "permlink"]
}, {
  "api": "follow_api",
  "method": "get_blog_authors",
  "params": ["blogAccount"]
}, {
  "api": "network_broadcast_api",
  "method": "broadcast_transaction",
  "params": ["trx"]
}, {
  "api": "network_broadcast_api",
  "method": "broadcast_transaction_with_callback",
  "params": ["confirmationCallback", "trx"]
}, {
  "api": "network_broadcast_api",
  "method": "broadcast_transaction_synchronous",
  "params": ["trx"]
}, {
  "api": "network_broadcast_api",
  "method": "broadcast_block",
  "params": ["b"]
}, {
  "api": "network_broadcast_api",
  "method": "set_max_block_age",
  "params": ["maxBlockAge"]
}, {
  "api": "market_history_api",
  "method": "get_ticker",
  "params": []
}, {
  "api": "market_history_api",
  "method": "get_volume",
  "params": []
}, {
  "api": "market_history_api",
  "method": "get_order_book",
  "method_name": "getMarketOrderBook",
  "params": ["limit"]
}, {
  "api": "market_history_api",
  "method": "get_trade_history",
  "params": ["start", "end", "limit"]
}, {
  "api": "market_history_api",
  "method": "get_recent_trades",
  "params": ["limit"]
}, {
  "api": "market_history_api",
  "method": "get_market_history",
  "params": ["bucket_seconds", "start", "end"]
}, {
  "api": "market_history_api",
  "method": "get_market_history_buckets",
  "params": []
}];

/***/ }),

/***/ 2936:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(471);

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Transport = function (_EventEmitter) {
  _inherits(Transport, _EventEmitter);

  function Transport() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Transport);

    var _this = _possibleConstructorReturn(this, (Transport.__proto__ || Object.getPrototypeOf(Transport)).call(this, options));

    _this.options = options;
    _this.id = 0;
    return _this;
  }

  _createClass(Transport, [{
    key: 'setOptions',
    value: function setOptions(options) {
      Object.assign(this.options, options);
      this.stop();
    }
  }, {
    key: 'listenTo',
    value: function listenTo(target, eventName, callback) {
      if (target.addEventListener) target.addEventListener(eventName, callback);else target.on(eventName, callback);

      return function () {
        if (target.removeEventListener) target.removeEventListener(eventName, callback);else target.removeListener(eventName, callback);
      };
    }
  }, {
    key: 'send',
    value: function send() {}
  }, {
    key: 'start',
    value: function start() {}
  }, {
    key: 'stop',
    value: function stop() {}
  }]);

  return Transport;
}(_events2.default);

exports["default"] = Transport;

/***/ }),

/***/ 2932:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.jsonRpc = jsonRpc;

var _crossFetch = __webpack_require__(2933);

var _crossFetch2 = _interopRequireDefault(_crossFetch);

var _debug = __webpack_require__(2934);

var _debug2 = _interopRequireDefault(_debug);

var _base = __webpack_require__(2936);

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debug = (0, _debug2.default)('steem:http');

var RPCError = function (_Error) {
  _inherits(RPCError, _Error);

  function RPCError(rpcError) {
    _classCallCheck(this, RPCError);

    var _this = _possibleConstructorReturn(this, (RPCError.__proto__ || Object.getPrototypeOf(RPCError)).call(this, rpcError.message));

    _this.name = 'RPCError';
    _this.code = rpcError.code;
    _this.data = rpcError.data;
    return _this;
  }

  return RPCError;
}(Error);

function jsonRpc(uri, _ref) {
  var method = _ref.method,
      id = _ref.id,
      params = _ref.params;

  var payload = { id: id, jsonrpc: '2.0', method: method, params: params };
  return (0, _crossFetch2.default)(uri, {
    body: JSON.stringify(payload),
    method: 'post',
    mode: 'cors',
    headers: {
      Accept: 'application/json, text/plain, */*',
      'Content-Type': 'application/json'
    }
  }).then(function (res) {
    if (!res.ok) {
      throw new Error('HTTP ' + res.status + ': ' + res.statusText);
    }
    return res.json();
  }).then(function (rpcRes) {
    if (rpcRes.id !== id) {
      throw new Error('Invalid response id: ' + rpcRes.id);
    }
    if (rpcRes.error) {
      throw new RPCError(rpcRes.error);
    }
    return rpcRes.result;
  });
}

var HttpTransport = function (_Transport) {
  _inherits(HttpTransport, _Transport);

  function HttpTransport() {
    _classCallCheck(this, HttpTransport);

    return _possibleConstructorReturn(this, (HttpTransport.__proto__ || Object.getPrototypeOf(HttpTransport)).apply(this, arguments));
  }

  _createClass(HttpTransport, [{
    key: 'send',
    value: function send(api, data, callback) {
      if (this.options.useAppbaseApi) {
        api = 'condenser_api';
      }
      debug('Steem::send', api, data);
      var id = data.id || this.id++;
      var params = [api, data.method, data.params];
      jsonRpc(this.options.uri, { method: 'call', id: id, params: params }).then(function (res) {
        callback(null, res);
      }, function (err) {
        callback(err);
      });
    }
  }]);

  return HttpTransport;
}(_base2.default);

exports["default"] = HttpTransport;

/***/ }),

/***/ 2931:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _http = __webpack_require__(2932);

var _http2 = _interopRequireDefault(_http);

var _ws = __webpack_require__(2937);

var _ws2 = _interopRequireDefault(_ws);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports["default"] = {
  http: _http2.default,
  ws: _ws2.default
};

/***/ }),

/***/ 2937:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _detectNode = __webpack_require__(2938);

var _detectNode2 = _interopRequireDefault(_detectNode);

var _debug = __webpack_require__(2934);

var _debug2 = _interopRequireDefault(_debug);

var _base = __webpack_require__(2936);

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WebSocket = void 0;
if (_detectNode2.default) {
  WebSocket = __webpack_require__(2939); // eslint-disable-line global-require
} else if (typeof window !== 'undefined') {
  WebSocket = window.WebSocket;
} else {
  throw new Error("Couldn't decide on a `WebSocket` class");
}

var debug = (0, _debug2.default)('steem:ws');

var WsTransport = function (_Transport) {
  _inherits(WsTransport, _Transport);

  function WsTransport() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, WsTransport);

    var _this = _possibleConstructorReturn(this, (WsTransport.__proto__ || Object.getPrototypeOf(WsTransport)).call(this, Object.assign({ id: 0 }, options)));

    _this._requests = new Map();
    _this.inFlight = 0;
    _this.isOpen = false;
    return _this;
  }

  _createClass(WsTransport, [{
    key: 'start',
    value: function start() {
      var _this2 = this;

      if (this.startPromise) {
        return this.startPromise;
      }

      this.startPromise = new Promise(function (resolve, reject) {
        _this2.ws = new WebSocket(_this2.options.websocket);
        _this2.ws.onerror = function (err) {
          _this2.startPromise = null;
          reject(err);
        };
        _this2.ws.onopen = function () {
          _this2.isOpen = true;
          _this2.ws.onerror = _this2.onError.bind(_this2);
          _this2.ws.onmessage = _this2.onMessage.bind(_this2);
          _this2.ws.onclose = _this2.onClose.bind(_this2);
          resolve();
        };
      });
      return this.startPromise;
    }
  }, {
    key: 'stop',
    value: function stop() {
      debug('Stopping...');

      this.startPromise = null;
      this.isOpen = false;
      this._requests.clear();

      if (this.ws) {
        this.ws.onerror = this.ws.onmessage = this.ws.onclose = null;
        this.ws.close();
        this.ws = null;
      }
    }
  }, {
    key: 'send',
    value: function send(api, data, callback) {
      var _this3 = this;

      debug('Steem::send', api, data);
      return this.start().then(function () {
        var deferral = {};
        new Promise(function (resolve, reject) {
          deferral.resolve = function (val) {
            resolve(val);
            callback(null, val);
          };
          deferral.reject = function (val) {
            reject(val);
            callback(val);
          };
        });

        if (_this3.options.useAppbaseApi) {
          api = 'condenser_api';
        }

        var _request = {
          deferral: deferral,
          startedAt: Date.now(),
          message: {
            id: data.id || _this3.id++,
            method: 'call',
            jsonrpc: '2.0',
            params: [api, data.method, data.params]
          }
        };
        _this3.inFlight++;
        _this3._requests.set(_request.message.id, _request);
        _this3.ws.send(JSON.stringify(_request.message));
        return deferral;
      });
    }
  }, {
    key: 'onError',
    value: function onError(error) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._requests[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _request = _step.value;

          _request.deferral.reject(error);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.stop();
    }
  }, {
    key: 'onClose',
    value: function onClose() {
      var error = new Error('Connection was closed');
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._requests[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _request = _step2.value;

          _request.deferral.reject(error);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      this._requests.clear();
    }
  }, {
    key: 'onMessage',
    value: function onMessage(websocketMessage) {
      var message = JSON.parse(websocketMessage.data);
      debug('-- Steem.onMessage -->', message.id);
      if (!this._requests.has(message.id)) {
        throw new Error('Panic: no request in queue for message id ' + message.id);
      }
      var _request = this._requests.get(message.id);
      this._requests.delete(message.id);

      var errorCause = message.error;
      if (errorCause) {
        var err = new Error(
        // eslint-disable-next-line prefer-template
        (errorCause.message || 'Failed to complete operation') + ' (see err.payload for the full error payload)');
        err.payload = message;
        _request.deferral.reject(err);
      } else {
        this.emit('track-performance', _request.message.method, Date.now() - _request.startedAt);
        _request.deferral.resolve(message.result);
      }
    }
  }]);

  return WsTransport;
}(_base2.default);

exports["default"] = WsTransport;

/***/ }),

/***/ 2921:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _each = __webpack_require__(2922);

var _each2 = _interopRequireDefault(_each);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultConfig = __webpack_require__(2929);

var Config = function () {
  function Config(c) {
    var _this = this;

    _classCallCheck(this, Config);

    (0, _each2.default)(c, function (value, key) {
      _this[key] = value;
    });
  }

  _createClass(Config, [{
    key: 'get',
    value: function get(k) {
      return this[k];
    }
  }, {
    key: 'set',
    value: function set(k, v) {
      this[k] = v;
    }
  }]);

  return Config;
}();

module.exports = new Config(defaultConfig);
if (typeof module.exports.Config !== 'undefined') {
  throw new Error("default config.json file may not contain a property 'Config'");
}
module.exports.Config = Config;

/***/ }),

/***/ 2919:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var api = __webpack_require__(2920);
var config = __webpack_require__(2921);
var utils = __webpack_require__(2940);

module.exports = {
  api: api,
  config: config,
  utils: utils
};

/***/ }),

/***/ 2940:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.camelCase = camelCase;
var snakeCaseRe = /_([a-z])/g;
function camelCase(str) {
  return str.replace(snakeCaseRe, function (_m, l) {
    return l.toUpperCase();
  });
}

/***/ }),

/***/ 2934:
/***/ ((module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(454)["process"];
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(2935);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = ({"NODE_ENV":"production"}).DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ 2935:
/***/ ((module, exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(2423);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ 3259:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(3260);
var availableTypedArrays = __webpack_require__(3262);
var callBound = __webpack_require__(1958);

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __webpack_require__(3257)();

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = __webpack_require__(3263);
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		if (typeof g[typedArray] === 'function') {
			var arr = new g[typedArray]();
			if (Symbol.toStringTag in arr) {
				var proto = getPrototypeOf(arr);
				var descriptor = gOPD(proto, Symbol.toStringTag);
				if (!descriptor) {
					var superProto = getPrototypeOf(proto);
					descriptor = gOPD(superProto, Symbol.toStringTag);
				}
				toStrTags[typedArray] = descriptor.get;
			}
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var foundName = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!foundName) {
			try {
				var name = getter.call(value);
				if (name === typedArray) {
					foundName = name;
				}
			} catch (e) {}
		}
	});
	return foundName;
};

var isTypedArray = __webpack_require__(3264);

module.exports = function whichTypedArray(value) {
	if (!isTypedArray(value)) { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }
	return tryTypedArrays(value);
};


/***/ }),

/***/ 3262:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var possibleNames = [
	'BigInt64Array',
	'BigUint64Array',
	'Float32Array',
	'Float64Array',
	'Int16Array',
	'Int32Array',
	'Int8Array',
	'Uint16Array',
	'Uint32Array',
	'Uint8Array',
	'Uint8ClampedArray'
];

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;

module.exports = function availableTypedArrays() {
	var out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};


/***/ }),

/***/ 3265:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(1953);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ 3263:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(1953);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ 3294:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"aes-128-ecb":{"cipher":"AES","key":128,"iv":0,"mode":"ECB","type":"block"},"aes-192-ecb":{"cipher":"AES","key":192,"iv":0,"mode":"ECB","type":"block"},"aes-256-ecb":{"cipher":"AES","key":256,"iv":0,"mode":"ECB","type":"block"},"aes-128-cbc":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes-192-cbc":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes-256-cbc":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes128":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes192":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes256":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes-128-cfb":{"cipher":"AES","key":128,"iv":16,"mode":"CFB","type":"stream"},"aes-192-cfb":{"cipher":"AES","key":192,"iv":16,"mode":"CFB","type":"stream"},"aes-256-cfb":{"cipher":"AES","key":256,"iv":16,"mode":"CFB","type":"stream"},"aes-128-cfb8":{"cipher":"AES","key":128,"iv":16,"mode":"CFB8","type":"stream"},"aes-192-cfb8":{"cipher":"AES","key":192,"iv":16,"mode":"CFB8","type":"stream"},"aes-256-cfb8":{"cipher":"AES","key":256,"iv":16,"mode":"CFB8","type":"stream"},"aes-128-cfb1":{"cipher":"AES","key":128,"iv":16,"mode":"CFB1","type":"stream"},"aes-192-cfb1":{"cipher":"AES","key":192,"iv":16,"mode":"CFB1","type":"stream"},"aes-256-cfb1":{"cipher":"AES","key":256,"iv":16,"mode":"CFB1","type":"stream"},"aes-128-ofb":{"cipher":"AES","key":128,"iv":16,"mode":"OFB","type":"stream"},"aes-192-ofb":{"cipher":"AES","key":192,"iv":16,"mode":"OFB","type":"stream"},"aes-256-ofb":{"cipher":"AES","key":256,"iv":16,"mode":"OFB","type":"stream"},"aes-128-ctr":{"cipher":"AES","key":128,"iv":16,"mode":"CTR","type":"stream"},"aes-192-ctr":{"cipher":"AES","key":192,"iv":16,"mode":"CTR","type":"stream"},"aes-256-ctr":{"cipher":"AES","key":256,"iv":16,"mode":"CTR","type":"stream"},"aes-128-gcm":{"cipher":"AES","key":128,"iv":12,"mode":"GCM","type":"auth"},"aes-192-gcm":{"cipher":"AES","key":192,"iv":12,"mode":"GCM","type":"auth"},"aes-256-gcm":{"cipher":"AES","key":256,"iv":12,"mode":"GCM","type":"auth"}}');

/***/ }),

/***/ 3113:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"websocket":"wss://api-full.golos.id/ws","node_timeout":30000,"address_prefix":"GLS","chain_id":"782a3039b478c839e4cb0c941ff4eaeb7df40bdd68bd441afd444b9da763de12","broadcast_transaction_with_callback":false}');

/***/ }),

/***/ 2929:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"transport":"http","websocket":"wss://gtg.steem.house:8090","uri":"https://api.steemit.com","url":"","dev_uri":"https://api.steemitdev.com","stage_uri":"https://api.steemitstage.com","address_prefix":"STM","chain_id":"0000000000000000000000000000000000000000000000000000000000000000"}');

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQuYWU1YTllNGNjYzAzZGQ3MjJkMmQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDN2RBO0FBQ0E7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDM1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3I2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN2dENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN2YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDNVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN0eUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN2V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN2Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN0bkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMvcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6akVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1RBO0FBQ0E7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBOzs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDSkE7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBOzs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBOzs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNWQTs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNKQTs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMvQ0E7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNWQTtBQUNBOzs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBOzs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0NBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBOzs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDUkE7QUFDQTs7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQy9SQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1JBO0FBQ0E7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUMzUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdllBO0FBQ0E7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2poQ0E7QUFDQTs7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN6aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDek1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDN1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUMxc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQy9EQTs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNqdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzVZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDek1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvYWJvcnQtY29udHJvbGxlci9icm93c2VyLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9hZXMuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2F1dGhDaXBoZXIuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2RlY3J5cHRlci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvZW5jcnlwdGVyLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9naGFzaC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvaW5jcjMyLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jYmMuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2NmYi5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiMS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiOC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY3RyLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9lY2IuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2luZGV4LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9vZmIuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL3N0cmVhbUNpcGhlci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvYnVmZmVyLXhvci9pbmRleC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvY3Jvc3MtZmV0Y2gvZGlzdC9icm93c2VyLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9kZXRlY3Qtbm9kZS9pbmRleC5lc20uanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2VzNi1vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9ldnBfYnl0ZXN0b2tleS9pbmRleC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZm9yLWVhY2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9saWIvYXBpL2luZGV4LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbGliL2FwaS9tZXRob2RzLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbGliL2FwaS90cmFuc3BvcnRzL2Jhc2UuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9saWIvYXBpL3RyYW5zcG9ydHMvaHR0cC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL2xpYi9hcGkvdHJhbnNwb3J0cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL2xpYi9hcGkvdHJhbnNwb3J0cy93cy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL2xpYi9hdXRoL2VjYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL2xpYi9hdXRoL2VjYy9zcmMvYWRkcmVzcy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL2xpYi9hdXRoL2VjYy9zcmMvYWVzLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbGliL2F1dGgvZWNjL3NyYy9icmFpbl9rZXkuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9saWIvYXV0aC9lY2Mvc3JjL2VjZHNhLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbGliL2F1dGgvZWNjL3NyYy9lY3NpZ25hdHVyZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL2xpYi9hdXRoL2VjYy9zcmMvZW5mb3JjZV90eXBlcy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL2xpYi9hdXRoL2VjYy9zcmMvaGFzaC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL2xpYi9hdXRoL2VjYy9zcmMva2V5X3ByaXZhdGUuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9saWIvYXV0aC9lY2Mvc3JjL2tleV9wdWJsaWMuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9saWIvYXV0aC9lY2Mvc3JjL2tleV91dGlscy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL2xpYi9hdXRoL2VjYy9zcmMvc2lnbmF0dXJlLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbGliL2F1dGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9saWIvYXV0aC9tZW1vLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbGliL2F1dGgvbWVzc2FnZXMuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9saWIvYXV0aC9zZXJpYWxpemVyL2luZGV4LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbGliL2F1dGgvc2VyaWFsaXplci9zcmMvQ2hhaW5UeXBlcy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL2xpYi9hdXRoL3NlcmlhbGl6ZXIvc3JjL2Vycm9yX3dpdGhfY2F1c2UuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9saWIvYXV0aC9zZXJpYWxpemVyL3NyYy9mYXN0X3BhcnNlci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL2xpYi9hdXRoL3NlcmlhbGl6ZXIvc3JjL251bWJlcl91dGlscy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL2xpYi9hdXRoL3NlcmlhbGl6ZXIvc3JjL29iamVjdF9pZC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL2xpYi9hdXRoL3NlcmlhbGl6ZXIvc3JjL29wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9saWIvYXV0aC9zZXJpYWxpemVyL3NyYy9zZXJpYWxpemVyLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbGliL2F1dGgvc2VyaWFsaXplci9zcmMvdGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9saWIvYXV0aC9zZXJpYWxpemVyL3NyYy90eXBlcy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL2xpYi9hdXRoL3NlcmlhbGl6ZXIvc3JjL3ZhbGlkYXRpb24uanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9saWIvYXV0aC9zZXNzaW9uLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbGliL2Jyb2FkY2FzdC9oZWxwZXJzLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbGliL2Jyb2FkY2FzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL2xpYi9icm9hZGNhc3Qvb3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL2xpYi9jb25maWcuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9saWIvY29yZS9jb2RlLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbGliL2NvcmUvZ29sb3NfbGliLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbGliL2NvcmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9saWIvZm9ybWF0dGVyLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbGliL2luZGV4LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbGliL21pZGRsZXdhcmVzL0VtcHR5TWlkZGxld2FyZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL2xpYi9taWRkbGV3YXJlcy9PQXV0aE1pZGRsZXdhcmUuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9saWIvbWlkZGxld2FyZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9saWIvb2F1dGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9saWIvcHJvbWlzaWZ5LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbGliL3V0aWxzL0Fzc2V0LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbGliL3V0aWxzL2ZldGNoRXguanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9saWIvdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9saWIvdXRpbHMvbWlzYy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvYXNzZXJ0LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtY2FsbGFibGUuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXguanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4taW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci1uYXRpdmUuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLW5vbi1leHRlbnNpYmxlLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWNvcHktd2l0aGluLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWZpbGwuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktZm9yLWVhY2guanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktZnJvbS1jb25zdHJ1Y3Rvci1hbmQtbGlzdC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mcm9tLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1sYXN0LWluZGV4LW9mLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktcmVkdWNlLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNsaWNlLXNpbXBsZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zbGljZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zb3J0LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29sbGVjdGlvbi1zdHJvbmcuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1pcy1yZWdleHAtbG9naWMuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi1hY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4uanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWlucy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtZ2xvYmFsLXByb3BlcnR5LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVsZXRlLXByb3BlcnR5LW9yLXRocm93LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvZXMtbm90LWV4Y2VlZC1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlcy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20tdG9rZW4tbGlzdC1wcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLWZmLXZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLWlzLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLWlzLWllLW9yLWVkZ2UuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLWlzLWlvcy1wZWJibGUuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLWlzLWlvcy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtaXMtbm9kZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtaXMtd2Vib3Mtd2Via2l0LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS13ZWJraXQtdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZyZWV6aW5nLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWFwcGx5LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LXN1YnN0aXR1dGlvbi5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9ob3N0LXJlcG9ydC1lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZWVlNzU0LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWRhdGEtZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtaW50ZWdyYWwtbnVtYmVyLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXJlZ2V4cC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0ZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jbG9zZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMtY29yZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbWFrZS1idWlsdC1pbi5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9tYXRoLXRydW5jLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtc3ltYm9sLXJlZ2lzdHJ5LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbmF0aXZlLXVybC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbmV3LXByb21pc2UtY2FwYWJpbGl0eS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9ub3QtYS1yZWdleHAuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbi5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtaXMtZXh0ZW5zaWJsZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC10by1hcnJheS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtdG8tc3RyaW5nLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29yZGluYXJ5LXRvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXRoLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BlcmZvcm0uanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcHJvbWlzZS1jb25zdHJ1Y3Rvci1kZXRlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcHJvbWlzZS1uYXRpdmUtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcHJvbWlzZS1yZXNvbHZlLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Byb21pc2Utc3RhdGljcy1pbmNvcnJlY3QtaXRlcmF0aW9uLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Byb3h5LWFjY2Vzc29yLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3F1ZXVlLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1leGVjLWFic3RyYWN0LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1leGVjLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1mbGFncy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtZ2V0LWZsYWdzLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1zdGlja3ktaGVscGVycy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtdW5zdXBwb3J0ZWQtZG90LWFsbC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtdW5zdXBwb3J0ZWQtbmNnLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1zdG9yZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy1wdW55Y29kZS10by1hc2NpaS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctcmVwZWF0LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy10cmltLWZvcmNlZC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctdHJpbS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zeW1ib2wtZGVmaW5lLXRvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90YXNrLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RoaXMtbnVtYmVyLXZhbHVlLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWJpZy1pbnQuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXguanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9mZnNldC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wb3NpdGl2ZS1pbnRlZ2VyLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90cnktdG8tc3RyaW5nLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9ycy1yZXF1aXJlLXdyYXBwZXJzLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3R5cGVkLWFycmF5LWZyb20tc3BlY2llcy1hbmQtbGlzdC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90eXBlZC1hcnJheS1mcm9tLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3R5cGVkLWFycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Y4LXByb3RvdHlwZS1kZWZpbmUtYnVnLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3ZhbGlkYXRlLWFyZ3VtZW50cy1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtd3JhcHBlZC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93aGl0ZXNwYWNlcy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWxsLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20uanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pbi5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29ydC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc3BsaWNlLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5qc29uLnN0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubWFwLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5tYXAuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmlzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci50by1maXhlZC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmVudHJpZXMuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktc3ltYm9scy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLmFsbC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5jYXRjaC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5yYWNlLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLnJlamVjdC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5yZXNvbHZlLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmNvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucmVmbGVjdC5nZXQuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnNldC5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc2V0LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2UuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnN0YXJ0cy13aXRoLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcudHJpbS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5mb3IuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wua2V5LWZvci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuY29weS13aXRoaW4uanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWxsLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQtaW5kZXguanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZvci1lYWNoLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mcm9tLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmludDMyLWFycmF5LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pbi5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubGFzdC1pbmRleC1vZi5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubWFwLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHQuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmV2ZXJzZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zbGljZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29tZS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc3ViYXJyYXkuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLWxvY2FsZS1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDgtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2guanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi51cmwtc2VhcmNoLXBhcmFtcy5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnVybC1zZWFyY2gtcGFyYW1zLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudXJsLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudXJsLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudXJsLnRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvY3Jvc3MtZmV0Y2gvZGlzdC9icm93c2VyLXBvbnlmaWxsLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvZ29sb3MtbGliLWpzL25vZGVfbW9kdWxlcy9zZWN1cmUtcmFuZG9tL2xpYi9zZWN1cmUtcmFuZG9tLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2dvbG9zLWxpYi1qcy9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L3R5cGVzLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9nb2xvcy1saWItanMvbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvaGFzLXRvc3RyaW5ndGFnL3NoYW1zLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9pcy1hcmd1bWVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2lzLWNhbGxhYmxlL2luZGV4LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9pcy1nZW5lcmF0b3ItZnVuY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2lzLW5hbi9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvaXMtbmFuL2luZGV4LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9pcy1uYW4vcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2lzLW5hbi9zaGltLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9pcy10eXBlZC1hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUVhY2guanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbi5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduSW4uanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNsb25lLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VFYWNoLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3JPd24uanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTWFwLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1JlZ0V4cC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNTZXQuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdEZ1bmN0aW9uLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lRGF0YVZpZXcuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVSZWdFeHAuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHNJbi5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRWFjaC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9sc0luLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUFycmF5LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUJ5VGFnLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmVEZWVwLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lYWNoLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZm9yRWFjaC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTWFwLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNSZWdFeHAuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1NldC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RydW5jYXRlLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL3BvbHlmaWxsLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvc2hpbS5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9zdGVlbS1qcy1hcGkvbGliL2FwaS9pbmRleC5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvc3RlZW0tanMtYXBpL2xpYi9hcGkvbWV0aG9kcy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvc3RlZW0tanMtYXBpL2xpYi9hcGkvdHJhbnNwb3J0cy9iYXNlLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9zdGVlbS1qcy1hcGkvbGliL2FwaS90cmFuc3BvcnRzL2h0dHAuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL3N0ZWVtLWpzLWFwaS9saWIvYXBpL3RyYW5zcG9ydHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL3N0ZWVtLWpzLWFwaS9saWIvYXBpL3RyYW5zcG9ydHMvd3MuanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL3N0ZWVtLWpzLWFwaS9saWIvY29uZmlnLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9zdGVlbS1qcy1hcGkvbGliL2luZGV4LmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9zdGVlbS1qcy1hcGkvbGliL3V0aWxzLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9zdGVlbS1qcy1hcGkvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovL1J1REVYMy1saWdodC8uL25vZGVfbW9kdWxlcy9zdGVlbS1qcy1hcGkvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvd2hpY2gtdHlwZWQtYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2F2YWlsYWJsZS10eXBlZC1hcnJheXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUnVERVgzLWxpZ2h0Ly4vbm9kZV9tb2R1bGVzL2lzLXR5cGVkLWFycmF5L25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9SdURFWDMtbGlnaHQvLi9ub2RlX21vZHVsZXMvd2hpY2gtdHlwZWQtYXJyYXkvbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFscyBzZWxmLCB3aW5kb3cgKi9cblwidXNlIHN0cmljdFwiXG5cbi8qZXNsaW50LWRpc2FibGUgQG15c3RpY2F0ZWEvcHJldHRpZXIgKi9cbmNvbnN0IHsgQWJvcnRDb250cm9sbGVyLCBBYm9ydFNpZ25hbCB9ID1cbiAgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOlxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOlxuICAgIC8qIG90aGVyd2lzZSAqLyB1bmRlZmluZWRcbi8qZXNsaW50LWVuYWJsZSBAbXlzdGljYXRlYS9wcmV0dGllciAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFib3J0Q29udHJvbGxlclxubW9kdWxlLmV4cG9ydHMuQWJvcnRTaWduYWwgPSBBYm9ydFNpZ25hbFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEFib3J0Q29udHJvbGxlclxuIiwiLy8gYmFzZWQgb24gdGhlIGFlcyBpbXBsaW1lbnRhdGlvbiBpbiB0cmlwbGUgc2VjXG4vLyBodHRwczovL2dpdGh1Yi5jb20va2V5YmFzZS90cmlwbGVzZWNcbi8vIHdoaWNoIGlzIGluIHR1cm4gYmFzZWQgb24gdGhlIG9uZSBmcm9tIGNyeXB0by1qc1xuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5mdW5jdGlvbiBhc1VJbnQzMkFycmF5IChidWYpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuXG4gIHZhciBsZW4gPSAoYnVmLmxlbmd0aCAvIDQpIHwgMFxuICB2YXIgb3V0ID0gbmV3IEFycmF5KGxlbilcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gYnVmLnJlYWRVSW50MzJCRShpICogNClcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gc2NydWJWZWMgKHYpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgdisrKSB7XG4gICAgdltpXSA9IDBcbiAgfVxufVxuXG5mdW5jdGlvbiBjcnlwdEJsb2NrIChNLCBrZXlTY2hlZHVsZSwgU1VCX01JWCwgU0JPWCwgblJvdW5kcykge1xuICB2YXIgU1VCX01JWDAgPSBTVUJfTUlYWzBdXG4gIHZhciBTVUJfTUlYMSA9IFNVQl9NSVhbMV1cbiAgdmFyIFNVQl9NSVgyID0gU1VCX01JWFsyXVxuICB2YXIgU1VCX01JWDMgPSBTVUJfTUlYWzNdXG5cbiAgdmFyIHMwID0gTVswXSBeIGtleVNjaGVkdWxlWzBdXG4gIHZhciBzMSA9IE1bMV0gXiBrZXlTY2hlZHVsZVsxXVxuICB2YXIgczIgPSBNWzJdIF4ga2V5U2NoZWR1bGVbMl1cbiAgdmFyIHMzID0gTVszXSBeIGtleVNjaGVkdWxlWzNdXG4gIHZhciB0MCwgdDEsIHQyLCB0M1xuICB2YXIga3NSb3cgPSA0XG5cbiAgZm9yICh2YXIgcm91bmQgPSAxOyByb3VuZCA8IG5Sb3VuZHM7IHJvdW5kKyspIHtcbiAgICB0MCA9IFNVQl9NSVgwW3MwID4+PiAyNF0gXiBTVUJfTUlYMVsoczEgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWDJbKHMyID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWDNbczMgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDEgPSBTVUJfTUlYMFtzMSA+Pj4gMjRdIF4gU1VCX01JWDFbKHMyID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVgyWyhzMyA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVgzW3MwICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHQyID0gU1VCX01JWDBbczIgPj4+IDI0XSBeIFNVQl9NSVgxWyhzMyA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYMlsoczAgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYM1tzMSAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgICB0MyA9IFNVQl9NSVgwW3MzID4+PiAyNF0gXiBTVUJfTUlYMVsoczAgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWDJbKHMxID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWDNbczIgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgczAgPSB0MFxuICAgIHMxID0gdDFcbiAgICBzMiA9IHQyXG4gICAgczMgPSB0M1xuICB9XG5cbiAgdDAgPSAoKFNCT1hbczAgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczEgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMiA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczMgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICB0MSA9ICgoU0JPWFtzMSA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMiA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMzID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMCAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHQyID0gKChTQk9YW3MyID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMzID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczAgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MxICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgdDMgPSAoKFNCT1hbczMgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczAgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMSA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczIgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICB0MCA9IHQwID4+PiAwXG4gIHQxID0gdDEgPj4+IDBcbiAgdDIgPSB0MiA+Pj4gMFxuICB0MyA9IHQzID4+PiAwXG5cbiAgcmV0dXJuIFt0MCwgdDEsIHQyLCB0M11cbn1cblxuLy8gQUVTIGNvbnN0YW50c1xudmFyIFJDT04gPSBbMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl1cbnZhciBHID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gQ29tcHV0ZSBkb3VibGUgdGFibGVcbiAgdmFyIGQgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKHZhciBqID0gMDsgaiA8IDI1NjsgaisrKSB7XG4gICAgaWYgKGogPCAxMjgpIHtcbiAgICAgIGRbal0gPSBqIDw8IDFcbiAgICB9IGVsc2Uge1xuICAgICAgZFtqXSA9IChqIDw8IDEpIF4gMHgxMWJcbiAgICB9XG4gIH1cblxuICB2YXIgU0JPWCA9IFtdXG4gIHZhciBJTlZfU0JPWCA9IFtdXG4gIHZhciBTVUJfTUlYID0gW1tdLCBbXSwgW10sIFtdXVxuICB2YXIgSU5WX1NVQl9NSVggPSBbW10sIFtdLCBbXSwgW11dXG5cbiAgLy8gV2FsayBHRigyXjgpXG4gIHZhciB4ID0gMFxuICB2YXIgeGkgPSAwXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAvLyBDb21wdXRlIHNib3hcbiAgICB2YXIgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KVxuICAgIHN4ID0gKHN4ID4+PiA4KSBeIChzeCAmIDB4ZmYpIF4gMHg2M1xuICAgIFNCT1hbeF0gPSBzeFxuICAgIElOVl9TQk9YW3N4XSA9IHhcblxuICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cbiAgICB2YXIgeDIgPSBkW3hdXG4gICAgdmFyIHg0ID0gZFt4Ml1cbiAgICB2YXIgeDggPSBkW3g0XVxuXG4gICAgLy8gQ29tcHV0ZSBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuICAgIHZhciB0ID0gKGRbc3hdICogMHgxMDEpIF4gKHN4ICogMHgxMDEwMTAwKVxuICAgIFNVQl9NSVhbMF1beF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOClcbiAgICBTVUJfTUlYWzFdW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KVxuICAgIFNVQl9NSVhbMl1beF0gPSAodCA8PCA4KSB8ICh0ID4+PiAyNClcbiAgICBTVUJfTUlYWzNdW3hdID0gdFxuXG4gICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgdCA9ICh4OCAqIDB4MTAxMDEwMSkgXiAoeDQgKiAweDEwMDAxKSBeICh4MiAqIDB4MTAxKSBeICh4ICogMHgxMDEwMTAwKVxuICAgIElOVl9TVUJfTUlYWzBdW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KVxuICAgIElOVl9TVUJfTUlYWzFdW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNilcbiAgICBJTlZfU1VCX01JWFsyXVtzeF0gPSAodCA8PCA4KSB8ICh0ID4+PiAyNClcbiAgICBJTlZfU1VCX01JWFszXVtzeF0gPSB0XG5cbiAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgeCA9IHhpID0gMVxuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dXG4gICAgICB4aSBePSBkW2RbeGldXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgU0JPWDogU0JPWCxcbiAgICBJTlZfU0JPWDogSU5WX1NCT1gsXG4gICAgU1VCX01JWDogU1VCX01JWCxcbiAgICBJTlZfU1VCX01JWDogSU5WX1NVQl9NSVhcbiAgfVxufSkoKVxuXG5mdW5jdGlvbiBBRVMgKGtleSkge1xuICB0aGlzLl9rZXkgPSBhc1VJbnQzMkFycmF5KGtleSlcbiAgdGhpcy5fcmVzZXQoKVxufVxuXG5BRVMuYmxvY2tTaXplID0gNCAqIDRcbkFFUy5rZXlTaXplID0gMjU2IC8gOFxuQUVTLnByb3RvdHlwZS5ibG9ja1NpemUgPSBBRVMuYmxvY2tTaXplXG5BRVMucHJvdG90eXBlLmtleVNpemUgPSBBRVMua2V5U2l6ZVxuQUVTLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBrZXlXb3JkcyA9IHRoaXMuX2tleVxuICB2YXIga2V5U2l6ZSA9IGtleVdvcmRzLmxlbmd0aFxuICB2YXIgblJvdW5kcyA9IGtleVNpemUgKyA2XG4gIHZhciBrc1Jvd3MgPSAoblJvdW5kcyArIDEpICogNFxuXG4gIHZhciBrZXlTY2hlZHVsZSA9IFtdXG4gIGZvciAodmFyIGsgPSAwOyBrIDwga2V5U2l6ZTsgaysrKSB7XG4gICAga2V5U2NoZWR1bGVba10gPSBrZXlXb3Jkc1trXVxuICB9XG5cbiAgZm9yIChrID0ga2V5U2l6ZTsgayA8IGtzUm93czsgaysrKSB7XG4gICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrIC0gMV1cblxuICAgIGlmIChrICUga2V5U2l6ZSA9PT0gMCkge1xuICAgICAgdCA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KVxuICAgICAgdCA9XG4gICAgICAgIChHLlNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8XG4gICAgICAgIChHLlNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8XG4gICAgICAgIChHLlNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfFxuICAgICAgICAoRy5TQk9YW3QgJiAweGZmXSlcblxuICAgICAgdCBePSBSQ09OWyhrIC8ga2V5U2l6ZSkgfCAwXSA8PCAyNFxuICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYgayAlIGtleVNpemUgPT09IDQpIHtcbiAgICAgIHQgPVxuICAgICAgICAoRy5TQk9YW3QgPj4+IDI0XSA8PCAyNCkgfFxuICAgICAgICAoRy5TQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfFxuICAgICAgICAoRy5TQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHxcbiAgICAgICAgKEcuU0JPWFt0ICYgMHhmZl0pXG4gICAgfVxuXG4gICAga2V5U2NoZWR1bGVba10gPSBrZXlTY2hlZHVsZVtrIC0ga2V5U2l6ZV0gXiB0XG4gIH1cblxuICB2YXIgaW52S2V5U2NoZWR1bGUgPSBbXVxuICBmb3IgKHZhciBpayA9IDA7IGlrIDwga3NSb3dzOyBpaysrKSB7XG4gICAgdmFyIGtzUiA9IGtzUm93cyAtIGlrXG4gICAgdmFyIHR0ID0ga2V5U2NoZWR1bGVba3NSIC0gKGlrICUgNCA/IDAgOiA0KV1cblxuICAgIGlmIChpayA8IDQgfHwga3NSIDw9IDQpIHtcbiAgICAgIGludktleVNjaGVkdWxlW2lrXSA9IHR0XG4gICAgfSBlbHNlIHtcbiAgICAgIGludktleVNjaGVkdWxlW2lrXSA9XG4gICAgICAgIEcuSU5WX1NVQl9NSVhbMF1bRy5TQk9YW3R0ID4+PiAyNF1dIF5cbiAgICAgICAgRy5JTlZfU1VCX01JWFsxXVtHLlNCT1hbKHR0ID4+PiAxNikgJiAweGZmXV0gXlxuICAgICAgICBHLklOVl9TVUJfTUlYWzJdW0cuU0JPWFsodHQgPj4+IDgpICYgMHhmZl1dIF5cbiAgICAgICAgRy5JTlZfU1VCX01JWFszXVtHLlNCT1hbdHQgJiAweGZmXV1cbiAgICB9XG4gIH1cblxuICB0aGlzLl9uUm91bmRzID0gblJvdW5kc1xuICB0aGlzLl9rZXlTY2hlZHVsZSA9IGtleVNjaGVkdWxlXG4gIHRoaXMuX2ludktleVNjaGVkdWxlID0gaW52S2V5U2NoZWR1bGVcbn1cblxuQUVTLnByb3RvdHlwZS5lbmNyeXB0QmxvY2tSYXcgPSBmdW5jdGlvbiAoTSkge1xuICBNID0gYXNVSW50MzJBcnJheShNKVxuICByZXR1cm4gY3J5cHRCbG9jayhNLCB0aGlzLl9rZXlTY2hlZHVsZSwgRy5TVUJfTUlYLCBHLlNCT1gsIHRoaXMuX25Sb3VuZHMpXG59XG5cbkFFUy5wcm90b3R5cGUuZW5jcnlwdEJsb2NrID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIG91dCA9IHRoaXMuZW5jcnlwdEJsb2NrUmF3KE0pXG4gIHZhciBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFswXSwgMClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMl0sIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFszXSwgMTIpXG4gIHJldHVybiBidWZcbn1cblxuQUVTLnByb3RvdHlwZS5kZWNyeXB0QmxvY2sgPSBmdW5jdGlvbiAoTSkge1xuICBNID0gYXNVSW50MzJBcnJheShNKVxuXG4gIC8vIHN3YXBcbiAgdmFyIG0xID0gTVsxXVxuICBNWzFdID0gTVszXVxuICBNWzNdID0gbTFcblxuICB2YXIgb3V0ID0gY3J5cHRCbG9jayhNLCB0aGlzLl9pbnZLZXlTY2hlZHVsZSwgRy5JTlZfU1VCX01JWCwgRy5JTlZfU0JPWCwgdGhpcy5fblJvdW5kcylcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxNilcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzBdLCAwKVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbM10sIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsyXSwgOClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdLCAxMilcbiAgcmV0dXJuIGJ1ZlxufVxuXG5BRVMucHJvdG90eXBlLnNjcnViID0gZnVuY3Rpb24gKCkge1xuICBzY3J1YlZlYyh0aGlzLl9rZXlTY2hlZHVsZSlcbiAgc2NydWJWZWModGhpcy5faW52S2V5U2NoZWR1bGUpXG4gIHNjcnViVmVjKHRoaXMuX2tleSlcbn1cblxubW9kdWxlLmV4cG9ydHMuQUVTID0gQUVTXG4iLCJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEdIQVNIID0gcmVxdWlyZSgnLi9naGFzaCcpXG52YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG52YXIgaW5jcjMyID0gcmVxdWlyZSgnLi9pbmNyMzInKVxuXG5mdW5jdGlvbiB4b3JUZXN0IChhLCBiKSB7XG4gIHZhciBvdXQgPSAwXG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIG91dCsrXG5cbiAgdmFyIGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIG91dCArPSAoYVtpXSBeIGJbaV0pXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGNhbGNJdiAoc2VsZiwgaXYsIGNrKSB7XG4gIGlmIChpdi5sZW5ndGggPT09IDEyKSB7XG4gICAgc2VsZi5fZmluSUQgPSBCdWZmZXIuY29uY2F0KFtpdiwgQnVmZmVyLmZyb20oWzAsIDAsIDAsIDFdKV0pXG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2l2LCBCdWZmZXIuZnJvbShbMCwgMCwgMCwgMl0pXSlcbiAgfVxuICB2YXIgZ2hhc2ggPSBuZXcgR0hBU0goY2spXG4gIHZhciBsZW4gPSBpdi5sZW5ndGhcbiAgdmFyIHRvUGFkID0gbGVuICUgMTZcbiAgZ2hhc2gudXBkYXRlKGl2KVxuICBpZiAodG9QYWQpIHtcbiAgICB0b1BhZCA9IDE2IC0gdG9QYWRcbiAgICBnaGFzaC51cGRhdGUoQnVmZmVyLmFsbG9jKHRvUGFkLCAwKSlcbiAgfVxuICBnaGFzaC51cGRhdGUoQnVmZmVyLmFsbG9jKDgsIDApKVxuICB2YXIgaXZCaXRzID0gbGVuICogOFxuICB2YXIgdGFpbCA9IEJ1ZmZlci5hbGxvYyg4KVxuICB0YWlsLndyaXRlVUludEJFKGl2Qml0cywgMCwgOClcbiAgZ2hhc2gudXBkYXRlKHRhaWwpXG4gIHNlbGYuX2ZpbklEID0gZ2hhc2guc3RhdGVcbiAgdmFyIG91dCA9IEJ1ZmZlci5mcm9tKHNlbGYuX2ZpbklEKVxuICBpbmNyMzIob3V0KVxuICByZXR1cm4gb3V0XG59XG5mdW5jdGlvbiBTdHJlYW1DaXBoZXIgKG1vZGUsIGtleSwgaXYsIGRlY3J5cHQpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcblxuICB2YXIgaCA9IEJ1ZmZlci5hbGxvYyg0LCAwKVxuXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdmFyIGNrID0gdGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayhoKVxuICB0aGlzLl9naGFzaCA9IG5ldyBHSEFTSChjaylcbiAgaXYgPSBjYWxjSXYodGhpcywgaXYsIGNrKVxuXG4gIHRoaXMuX3ByZXYgPSBCdWZmZXIuZnJvbShpdilcbiAgdGhpcy5fY2FjaGUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbiAgdGhpcy5fc2VjQ2FjaGUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbiAgdGhpcy5fZGVjcnlwdCA9IGRlY3J5cHRcbiAgdGhpcy5fYWxlbiA9IDBcbiAgdGhpcy5fbGVuID0gMFxuICB0aGlzLl9tb2RlID0gbW9kZVxuXG4gIHRoaXMuX2F1dGhUYWcgPSBudWxsXG4gIHRoaXMuX2NhbGxlZCA9IGZhbHNlXG59XG5cbmluaGVyaXRzKFN0cmVhbUNpcGhlciwgVHJhbnNmb3JtKVxuXG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgaWYgKCF0aGlzLl9jYWxsZWQgJiYgdGhpcy5fYWxlbikge1xuICAgIHZhciBydW1wID0gMTYgLSAodGhpcy5fYWxlbiAlIDE2KVxuICAgIGlmIChydW1wIDwgMTYpIHtcbiAgICAgIHJ1bXAgPSBCdWZmZXIuYWxsb2MocnVtcCwgMClcbiAgICAgIHRoaXMuX2doYXNoLnVwZGF0ZShydW1wKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2NhbGxlZCA9IHRydWVcbiAgdmFyIG91dCA9IHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaylcbiAgaWYgKHRoaXMuX2RlY3J5cHQpIHtcbiAgICB0aGlzLl9naGFzaC51cGRhdGUoY2h1bmspXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZ2hhc2gudXBkYXRlKG91dClcbiAgfVxuICB0aGlzLl9sZW4gKz0gY2h1bmsubGVuZ3RoXG4gIHJldHVybiBvdXRcbn1cblxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kZWNyeXB0ICYmICF0aGlzLl9hdXRoVGFnKSB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHN0YXRlIG9yIHVuYWJsZSB0byBhdXRoZW50aWNhdGUgZGF0YScpXG5cbiAgdmFyIHRhZyA9IHhvcih0aGlzLl9naGFzaC5maW5hbCh0aGlzLl9hbGVuICogOCwgdGhpcy5fbGVuICogOCksIHRoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2sodGhpcy5fZmluSUQpKVxuICBpZiAodGhpcy5fZGVjcnlwdCAmJiB4b3JUZXN0KHRhZywgdGhpcy5fYXV0aFRhZykpIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc3RhdGUgb3IgdW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSBkYXRhJylcblxuICB0aGlzLl9hdXRoVGFnID0gdGFnXG4gIHRoaXMuX2NpcGhlci5zY3J1YigpXG59XG5cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuZ2V0QXV0aFRhZyA9IGZ1bmN0aW9uIGdldEF1dGhUYWcgKCkge1xuICBpZiAodGhpcy5fZGVjcnlwdCB8fCAhQnVmZmVyLmlzQnVmZmVyKHRoaXMuX2F1dGhUYWcpKSB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gZ2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcblxuICByZXR1cm4gdGhpcy5fYXV0aFRhZ1xufVxuXG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLnNldEF1dGhUYWcgPSBmdW5jdGlvbiBzZXRBdXRoVGFnICh0YWcpIHtcbiAgaWYgKCF0aGlzLl9kZWNyeXB0KSB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gc2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcblxuICB0aGlzLl9hdXRoVGFnID0gdGFnXG59XG5cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuc2V0QUFEID0gZnVuY3Rpb24gc2V0QUFEIChidWYpIHtcbiAgaWYgKHRoaXMuX2NhbGxlZCkgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIHNldCBBQUQgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxuXG4gIHRoaXMuX2doYXNoLnVwZGF0ZShidWYpXG4gIHRoaXMuX2FsZW4gKz0gYnVmLmxlbmd0aFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbUNpcGhlclxuIiwidmFyIGNpcGhlcnMgPSByZXF1aXJlKCcuL2VuY3J5cHRlcicpXG52YXIgZGVjaXBoZXJzID0gcmVxdWlyZSgnLi9kZWNyeXB0ZXInKVxudmFyIG1vZGVzID0gcmVxdWlyZSgnLi9tb2Rlcy9saXN0Lmpzb24nKVxuXG5mdW5jdGlvbiBnZXRDaXBoZXJzICgpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1vZGVzKVxufVxuXG5leHBvcnRzLmNyZWF0ZUNpcGhlciA9IGV4cG9ydHMuQ2lwaGVyID0gY2lwaGVycy5jcmVhdGVDaXBoZXJcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyaXYgPSBleHBvcnRzLkNpcGhlcml2ID0gY2lwaGVycy5jcmVhdGVDaXBoZXJpdlxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlciA9IGV4cG9ydHMuRGVjaXBoZXIgPSBkZWNpcGhlcnMuY3JlYXRlRGVjaXBoZXJcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXJpdiA9IGV4cG9ydHMuRGVjaXBoZXJpdiA9IGRlY2lwaGVycy5jcmVhdGVEZWNpcGhlcml2XG5leHBvcnRzLmxpc3RDaXBoZXJzID0gZXhwb3J0cy5nZXRDaXBoZXJzID0gZ2V0Q2lwaGVyc1xuIiwidmFyIEF1dGhDaXBoZXIgPSByZXF1aXJlKCcuL2F1dGhDaXBoZXInKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgTU9ERVMgPSByZXF1aXJlKCcuL21vZGVzJylcbnZhciBTdHJlYW1DaXBoZXIgPSByZXF1aXJlKCcuL3N0cmVhbUNpcGhlcicpXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGFlcyA9IHJlcXVpcmUoJy4vYWVzJylcbnZhciBlYnRrID0gcmVxdWlyZSgnZXZwX2J5dGVzdG9rZXknKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5mdW5jdGlvbiBEZWNpcGhlciAobW9kZSwga2V5LCBpdikge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuXG4gIHRoaXMuX2NhY2hlID0gbmV3IFNwbGl0dGVyKClcbiAgdGhpcy5fbGFzdCA9IHZvaWQgMFxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHRoaXMuX3ByZXYgPSBCdWZmZXIuZnJvbShpdilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSB0cnVlXG59XG5cbmluaGVyaXRzKERlY2lwaGVyLCBUcmFuc2Zvcm0pXG5cbkRlY2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5fY2FjaGUuYWRkKGRhdGEpXG4gIHZhciBjaHVua1xuICB2YXIgdGhpbmdcbiAgdmFyIG91dCA9IFtdXG4gIHdoaWxlICgoY2h1bmsgPSB0aGlzLl9jYWNoZS5nZXQodGhpcy5fYXV0b3BhZGRpbmcpKSkge1xuICAgIHRoaW5nID0gdGhpcy5fbW9kZS5kZWNyeXB0KHRoaXMsIGNodW5rKVxuICAgIG91dC5wdXNoKHRoaW5nKVxuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbn1cblxuRGVjaXBoZXIucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNodW5rID0gdGhpcy5fY2FjaGUuZmx1c2goKVxuICBpZiAodGhpcy5fYXV0b3BhZGRpbmcpIHtcbiAgICByZXR1cm4gdW5wYWQodGhpcy5fbW9kZS5kZWNyeXB0KHRoaXMsIGNodW5rKSlcbiAgfSBlbHNlIGlmIChjaHVuaykge1xuICAgIHRocm93IG5ldyBFcnJvcignZGF0YSBub3QgbXVsdGlwbGUgb2YgYmxvY2sgbGVuZ3RoJylcbiAgfVxufVxuXG5EZWNpcGhlci5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoc2V0VG8pIHtcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSAhIXNldFRvXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIFNwbGl0dGVyICgpIHtcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxufVxuXG5TcGxpdHRlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIGRhdGFdKVxufVxuXG5TcGxpdHRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGF1dG9QYWRkaW5nKSB7XG4gIHZhciBvdXRcbiAgaWYgKGF1dG9QYWRkaW5nKSB7XG4gICAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoID4gMTYpIHtcbiAgICAgIG91dCA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICAgIHJldHVybiBvdXRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoID49IDE2KSB7XG4gICAgICBvdXQgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgICByZXR1cm4gb3V0XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jYWNoZS5sZW5ndGgpIHJldHVybiB0aGlzLmNhY2hlXG59XG5cbmZ1bmN0aW9uIHVucGFkIChsYXN0KSB7XG4gIHZhciBwYWRkZWQgPSBsYXN0WzE1XVxuICBpZiAocGFkZGVkIDwgMSB8fCBwYWRkZWQgPiAxNikge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGRlY3J5cHQgZGF0YScpXG4gIH1cbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgcGFkZGVkKSB7XG4gICAgaWYgKGxhc3RbKGkgKyAoMTYgLSBwYWRkZWQpKV0gIT09IHBhZGRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gZGVjcnlwdCBkYXRhJylcbiAgICB9XG4gIH1cbiAgaWYgKHBhZGRlZCA9PT0gMTYpIHJldHVyblxuXG4gIHJldHVybiBsYXN0LnNsaWNlKDAsIDE2IC0gcGFkZGVkKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNpcGhlcml2IChzdWl0ZSwgcGFzc3dvcmQsIGl2KSB7XG4gIHZhciBjb25maWcgPSBNT0RFU1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcblxuICBpZiAodHlwZW9mIGl2ID09PSAnc3RyaW5nJykgaXYgPSBCdWZmZXIuZnJvbShpdilcbiAgaWYgKGNvbmZpZy5tb2RlICE9PSAnR0NNJyAmJiBpdi5sZW5ndGggIT09IGNvbmZpZy5pdikgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBpdiBsZW5ndGggJyArIGl2Lmxlbmd0aClcblxuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAnc3RyaW5nJykgcGFzc3dvcmQgPSBCdWZmZXIuZnJvbShwYXNzd29yZClcbiAgaWYgKHBhc3N3b3JkLmxlbmd0aCAhPT0gY29uZmlnLmtleSAvIDgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQga2V5IGxlbmd0aCAnICsgcGFzc3dvcmQubGVuZ3RoKVxuXG4gIGlmIChjb25maWcudHlwZSA9PT0gJ3N0cmVhbScpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUNpcGhlcihjb25maWcubW9kdWxlLCBwYXNzd29yZCwgaXYsIHRydWUpXG4gIH0gZWxzZSBpZiAoY29uZmlnLnR5cGUgPT09ICdhdXRoJykge1xuICAgIHJldHVybiBuZXcgQXV0aENpcGhlcihjb25maWcubW9kdWxlLCBwYXNzd29yZCwgaXYsIHRydWUpXG4gIH1cblxuICByZXR1cm4gbmV3IERlY2lwaGVyKGNvbmZpZy5tb2R1bGUsIHBhc3N3b3JkLCBpdilcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICB2YXIgY29uZmlnID0gTU9ERVNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG5cbiAgdmFyIGtleXMgPSBlYnRrKHBhc3N3b3JkLCBmYWxzZSwgY29uZmlnLmtleSwgY29uZmlnLml2KVxuICByZXR1cm4gY3JlYXRlRGVjaXBoZXJpdihzdWl0ZSwga2V5cy5rZXksIGtleXMuaXYpXG59XG5cbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXIgPSBjcmVhdGVEZWNpcGhlclxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlcml2ID0gY3JlYXRlRGVjaXBoZXJpdlxuIiwidmFyIE1PREVTID0gcmVxdWlyZSgnLi9tb2RlcycpXG52YXIgQXV0aENpcGhlciA9IHJlcXVpcmUoJy4vYXV0aENpcGhlcicpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBTdHJlYW1DaXBoZXIgPSByZXF1aXJlKCcuL3N0cmVhbUNpcGhlcicpXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGFlcyA9IHJlcXVpcmUoJy4vYWVzJylcbnZhciBlYnRrID0gcmVxdWlyZSgnZXZwX2J5dGVzdG9rZXknKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5mdW5jdGlvbiBDaXBoZXIgKG1vZGUsIGtleSwgaXYpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcblxuICB0aGlzLl9jYWNoZSA9IG5ldyBTcGxpdHRlcigpXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IEJ1ZmZlci5mcm9tKGl2KVxuICB0aGlzLl9tb2RlID0gbW9kZVxuICB0aGlzLl9hdXRvcGFkZGluZyA9IHRydWVcbn1cblxuaW5oZXJpdHMoQ2lwaGVyLCBUcmFuc2Zvcm0pXG5cbkNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2NhY2hlLmFkZChkYXRhKVxuICB2YXIgY2h1bmtcbiAgdmFyIHRoaW5nXG4gIHZhciBvdXQgPSBbXVxuXG4gIHdoaWxlICgoY2h1bmsgPSB0aGlzLl9jYWNoZS5nZXQoKSkpIHtcbiAgICB0aGluZyA9IHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaylcbiAgICBvdXQucHVzaCh0aGluZylcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbn1cblxudmFyIFBBRERJTkcgPSBCdWZmZXIuYWxsb2MoMTYsIDB4MTApXG5cbkNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2h1bmsgPSB0aGlzLl9jYWNoZS5mbHVzaCgpXG4gIGlmICh0aGlzLl9hdXRvcGFkZGluZykge1xuICAgIGNodW5rID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICAgIHRoaXMuX2NpcGhlci5zY3J1YigpXG4gICAgcmV0dXJuIGNodW5rXG4gIH1cblxuICBpZiAoIWNodW5rLmVxdWFscyhQQURESU5HKSkge1xuICAgIHRoaXMuX2NpcGhlci5zY3J1YigpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIG5vdCBtdWx0aXBsZSBvZiBibG9jayBsZW5ndGgnKVxuICB9XG59XG5cbkNpcGhlci5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoc2V0VG8pIHtcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSAhIXNldFRvXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIFNwbGl0dGVyICgpIHtcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxufVxuXG5TcGxpdHRlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIGRhdGFdKVxufVxuXG5TcGxpdHRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jYWNoZS5sZW5ndGggPiAxNSkge1xuICAgIHZhciBvdXQgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgIHJldHVybiBvdXRcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5TcGxpdHRlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZW4gPSAxNiAtIHRoaXMuY2FjaGUubGVuZ3RoXG4gIHZhciBwYWRCdWZmID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbilcblxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBwYWRCdWZmLndyaXRlVUludDgobGVuLCBpKVxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIHBhZEJ1ZmZdKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDaXBoZXJpdiAoc3VpdGUsIHBhc3N3b3JkLCBpdikge1xuICB2YXIgY29uZmlnID0gTU9ERVNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG5cbiAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3N0cmluZycpIHBhc3N3b3JkID0gQnVmZmVyLmZyb20ocGFzc3dvcmQpXG4gIGlmIChwYXNzd29yZC5sZW5ndGggIT09IGNvbmZpZy5rZXkgLyA4KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGtleSBsZW5ndGggJyArIHBhc3N3b3JkLmxlbmd0aClcblxuICBpZiAodHlwZW9mIGl2ID09PSAnc3RyaW5nJykgaXYgPSBCdWZmZXIuZnJvbShpdilcbiAgaWYgKGNvbmZpZy5tb2RlICE9PSAnR0NNJyAmJiBpdi5sZW5ndGggIT09IGNvbmZpZy5pdikgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBpdiBsZW5ndGggJyArIGl2Lmxlbmd0aClcblxuICBpZiAoY29uZmlnLnR5cGUgPT09ICdzdHJlYW0nKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1DaXBoZXIoY29uZmlnLm1vZHVsZSwgcGFzc3dvcmQsIGl2KVxuICB9IGVsc2UgaWYgKGNvbmZpZy50eXBlID09PSAnYXV0aCcpIHtcbiAgICByZXR1cm4gbmV3IEF1dGhDaXBoZXIoY29uZmlnLm1vZHVsZSwgcGFzc3dvcmQsIGl2KVxuICB9XG5cbiAgcmV0dXJuIG5ldyBDaXBoZXIoY29uZmlnLm1vZHVsZSwgcGFzc3dvcmQsIGl2KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICB2YXIgY29uZmlnID0gTU9ERVNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG5cbiAgdmFyIGtleXMgPSBlYnRrKHBhc3N3b3JkLCBmYWxzZSwgY29uZmlnLmtleSwgY29uZmlnLml2KVxuICByZXR1cm4gY3JlYXRlQ2lwaGVyaXYoc3VpdGUsIGtleXMua2V5LCBrZXlzLml2KVxufVxuXG5leHBvcnRzLmNyZWF0ZUNpcGhlcml2ID0gY3JlYXRlQ2lwaGVyaXZcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyID0gY3JlYXRlQ2lwaGVyXG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBaRVJPRVMgPSBCdWZmZXIuYWxsb2MoMTYsIDApXG5cbmZ1bmN0aW9uIHRvQXJyYXkgKGJ1Zikge1xuICByZXR1cm4gW1xuICAgIGJ1Zi5yZWFkVUludDMyQkUoMCksXG4gICAgYnVmLnJlYWRVSW50MzJCRSg0KSxcbiAgICBidWYucmVhZFVJbnQzMkJFKDgpLFxuICAgIGJ1Zi5yZWFkVUludDMyQkUoMTIpXG4gIF1cbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5IChvdXQpIHtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxNilcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzBdID4+PiAwLCAwKVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMV0gPj4+IDAsIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsyXSA+Pj4gMCwgOClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzNdID4+PiAwLCAxMilcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBHSEFTSCAoa2V5KSB7XG4gIHRoaXMuaCA9IGtleVxuICB0aGlzLnN0YXRlID0gQnVmZmVyLmFsbG9jKDE2LCAwKVxuICB0aGlzLmNhY2hlID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG59XG5cbi8vIGZyb20gaHR0cDovL2JpdHdpc2VzaGlmdGxlZnQuZ2l0aHViLmlvL3NqY2wvZG9jL3N5bWJvbHMvc3JjL2NvcmVfZ2NtLmpzLmh0bWxcbi8vIGJ5IEp1aG8gVsOkaMOkLUhlcnR0dWFcbkdIQVNILnByb3RvdHlwZS5naGFzaCA9IGZ1bmN0aW9uIChibG9jaykge1xuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBibG9jay5sZW5ndGgpIHtcbiAgICB0aGlzLnN0YXRlW2ldIF49IGJsb2NrW2ldXG4gIH1cbiAgdGhpcy5fbXVsdGlwbHkoKVxufVxuXG5HSEFTSC5wcm90b3R5cGUuX211bHRpcGx5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgVmkgPSB0b0FycmF5KHRoaXMuaClcbiAgdmFyIFppID0gWzAsIDAsIDAsIDBdXG4gIHZhciBqLCB4aSwgbHNiVmlcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgMTI4KSB7XG4gICAgeGkgPSAodGhpcy5zdGF0ZVt+fihpIC8gOCldICYgKDEgPDwgKDcgLSAoaSAlIDgpKSkpICE9PSAwXG4gICAgaWYgKHhpKSB7XG4gICAgICAvLyBaX2krMSA9IFpfaSBeIFZfaVxuICAgICAgWmlbMF0gXj0gVmlbMF1cbiAgICAgIFppWzFdIF49IFZpWzFdXG4gICAgICBaaVsyXSBePSBWaVsyXVxuICAgICAgWmlbM10gXj0gVmlbM11cbiAgICB9XG5cbiAgICAvLyBTdG9yZSB0aGUgdmFsdWUgb2YgTFNCKFZfaSlcbiAgICBsc2JWaSA9IChWaVszXSAmIDEpICE9PSAwXG5cbiAgICAvLyBWX2krMSA9IFZfaSA+PiAxXG4gICAgZm9yIChqID0gMzsgaiA+IDA7IGotLSkge1xuICAgICAgVmlbal0gPSAoVmlbal0gPj4+IDEpIHwgKChWaVtqIC0gMV0gJiAxKSA8PCAzMSlcbiAgICB9XG4gICAgVmlbMF0gPSBWaVswXSA+Pj4gMVxuXG4gICAgLy8gSWYgTFNCKFZfaSkgaXMgMSwgVl9pKzEgPSAoVl9pID4+IDEpIF4gUlxuICAgIGlmIChsc2JWaSkge1xuICAgICAgVmlbMF0gPSBWaVswXSBeICgweGUxIDw8IDI0KVxuICAgIH1cbiAgfVxuICB0aGlzLnN0YXRlID0gZnJvbUFycmF5KFppKVxufVxuXG5HSEFTSC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgYnVmXSlcbiAgdmFyIGNodW5rXG4gIHdoaWxlICh0aGlzLmNhY2hlLmxlbmd0aCA+PSAxNikge1xuICAgIGNodW5rID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICB0aGlzLmdoYXNoKGNodW5rKVxuICB9XG59XG5cbkdIQVNILnByb3RvdHlwZS5maW5hbCA9IGZ1bmN0aW9uIChhYmwsIGJsKSB7XG4gIGlmICh0aGlzLmNhY2hlLmxlbmd0aCkge1xuICAgIHRoaXMuZ2hhc2goQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgWkVST0VTXSwgMTYpKVxuICB9XG5cbiAgdGhpcy5naGFzaChmcm9tQXJyYXkoWzAsIGFibCwgMCwgYmxdKSlcbiAgcmV0dXJuIHRoaXMuc3RhdGVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHSEFTSFxuIiwiZnVuY3Rpb24gaW5jcjMyIChpdikge1xuICB2YXIgbGVuID0gaXYubGVuZ3RoXG4gIHZhciBpdGVtXG4gIHdoaWxlIChsZW4tLSkge1xuICAgIGl0ZW0gPSBpdi5yZWFkVUludDgobGVuKVxuICAgIGlmIChpdGVtID09PSAyNTUpIHtcbiAgICAgIGl2LndyaXRlVUludDgoMCwgbGVuKVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVtKytcbiAgICAgIGl2LndyaXRlVUludDgoaXRlbSwgbGVuKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gaW5jcjMyXG4iLCJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBibG9jaykge1xuICB2YXIgZGF0YSA9IHhvcihibG9jaywgc2VsZi5fcHJldilcblxuICBzZWxmLl9wcmV2ID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhkYXRhKVxuICByZXR1cm4gc2VsZi5fcHJldlxufVxuXG5leHBvcnRzLmRlY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgYmxvY2spIHtcbiAgdmFyIHBhZCA9IHNlbGYuX3ByZXZcblxuICBzZWxmLl9wcmV2ID0gYmxvY2tcbiAgdmFyIG91dCA9IHNlbGYuX2NpcGhlci5kZWNyeXB0QmxvY2soYmxvY2spXG5cbiAgcmV0dXJuIHhvcihvdXQsIHBhZClcbn1cbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuXG5mdW5jdGlvbiBlbmNyeXB0U3RhcnQgKHNlbGYsIGRhdGEsIGRlY3J5cHQpIHtcbiAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoXG4gIHZhciBvdXQgPSB4b3IoZGF0YSwgc2VsZi5fY2FjaGUpXG4gIHNlbGYuX2NhY2hlID0gc2VsZi5fY2FjaGUuc2xpY2UobGVuKVxuICBzZWxmLl9wcmV2ID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fcHJldiwgZGVjcnlwdCA/IGRhdGEgOiBvdXRdKVxuICByZXR1cm4gb3V0XG59XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBkYXRhLCBkZWNyeXB0KSB7XG4gIHZhciBvdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbiAgdmFyIGxlblxuXG4gIHdoaWxlIChkYXRhLmxlbmd0aCkge1xuICAgIGlmIChzZWxmLl9jYWNoZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHNlbGYuX2NhY2hlID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICAgICAgc2VsZi5fcHJldiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxuICAgIH1cblxuICAgIGlmIChzZWxmLl9jYWNoZS5sZW5ndGggPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIGxlbiA9IHNlbGYuX2NhY2hlLmxlbmd0aFxuICAgICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbb3V0LCBlbmNyeXB0U3RhcnQoc2VsZiwgZGF0YS5zbGljZSgwLCBsZW4pLCBkZWNyeXB0KV0pXG4gICAgICBkYXRhID0gZGF0YS5zbGljZShsZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IEJ1ZmZlci5jb25jYXQoW291dCwgZW5jcnlwdFN0YXJ0KHNlbGYsIGRhdGEsIGRlY3J5cHQpXSlcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbmZ1bmN0aW9uIGVuY3J5cHRCeXRlIChzZWxmLCBieXRlUGFyYW0sIGRlY3J5cHQpIHtcbiAgdmFyIHBhZFxuICB2YXIgaSA9IC0xXG4gIHZhciBsZW4gPSA4XG4gIHZhciBvdXQgPSAwXG4gIHZhciBiaXQsIHZhbHVlXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBwYWQgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gICAgYml0ID0gKGJ5dGVQYXJhbSAmICgxIDw8ICg3IC0gaSkpKSA/IDB4ODAgOiAwXG4gICAgdmFsdWUgPSBwYWRbMF0gXiBiaXRcbiAgICBvdXQgKz0gKCh2YWx1ZSAmIDB4ODApID4+IChpICUgOCkpXG4gICAgc2VsZi5fcHJldiA9IHNoaWZ0SW4oc2VsZi5fcHJldiwgZGVjcnlwdCA/IGJpdCA6IHZhbHVlKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gc2hpZnRJbiAoYnVmZmVyLCB2YWx1ZSkge1xuICB2YXIgbGVuID0gYnVmZmVyLmxlbmd0aFxuICB2YXIgaSA9IC0xXG4gIHZhciBvdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnVmZmVyLmxlbmd0aClcbiAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCBCdWZmZXIuZnJvbShbdmFsdWVdKV0pXG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGJ1ZmZlcltpXSA8PCAxIHwgYnVmZmVyW2kgKyAxXSA+PiAoNylcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rLCBkZWNyeXB0KSB7XG4gIHZhciBsZW4gPSBjaHVuay5sZW5ndGhcbiAgdmFyIG91dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW4pXG4gIHZhciBpID0gLTFcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gZW5jcnlwdEJ5dGUoc2VsZiwgY2h1bmtbaV0sIGRlY3J5cHQpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuZnVuY3Rpb24gZW5jcnlwdEJ5dGUgKHNlbGYsIGJ5dGVQYXJhbSwgZGVjcnlwdCkge1xuICB2YXIgcGFkID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICB2YXIgb3V0ID0gcGFkWzBdIF4gYnl0ZVBhcmFtXG5cbiAgc2VsZi5fcHJldiA9IEJ1ZmZlci5jb25jYXQoW1xuICAgIHNlbGYuX3ByZXYuc2xpY2UoMSksXG4gICAgQnVmZmVyLmZyb20oW2RlY3J5cHQgPyBieXRlUGFyYW0gOiBvdXRdKVxuICBdKVxuXG4gIHJldHVybiBvdXRcbn1cblxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rLCBkZWNyeXB0KSB7XG4gIHZhciBsZW4gPSBjaHVuay5sZW5ndGhcbiAgdmFyIG91dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW4pXG4gIHZhciBpID0gLTFcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gZW5jcnlwdEJ5dGUoc2VsZiwgY2h1bmtbaV0sIGRlY3J5cHQpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG4iLCJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBpbmNyMzIgPSByZXF1aXJlKCcuLi9pbmNyMzInKVxuXG5mdW5jdGlvbiBnZXRCbG9jayAoc2VsZikge1xuICB2YXIgb3V0ID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9ja1JhdyhzZWxmLl9wcmV2KVxuICBpbmNyMzIoc2VsZi5fcHJldilcbiAgcmV0dXJuIG91dFxufVxuXG52YXIgYmxvY2tTaXplID0gMTZcbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaykge1xuICB2YXIgY2h1bmtOdW0gPSBNYXRoLmNlaWwoY2h1bmsubGVuZ3RoIC8gYmxvY2tTaXplKVxuICB2YXIgc3RhcnQgPSBzZWxmLl9jYWNoZS5sZW5ndGhcbiAgc2VsZi5fY2FjaGUgPSBCdWZmZXIuY29uY2F0KFtcbiAgICBzZWxmLl9jYWNoZSxcbiAgICBCdWZmZXIuYWxsb2NVbnNhZmUoY2h1bmtOdW0gKiBibG9ja1NpemUpXG4gIF0pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmtOdW07IGkrKykge1xuICAgIHZhciBvdXQgPSBnZXRCbG9jayhzZWxmKVxuICAgIHZhciBvZmZzZXQgPSBzdGFydCArIGkgKiBibG9ja1NpemVcbiAgICBzZWxmLl9jYWNoZS53cml0ZVVJbnQzMkJFKG91dFswXSwgb2Zmc2V0ICsgMClcbiAgICBzZWxmLl9jYWNoZS53cml0ZVVJbnQzMkJFKG91dFsxXSwgb2Zmc2V0ICsgNClcbiAgICBzZWxmLl9jYWNoZS53cml0ZVVJbnQzMkJFKG91dFsyXSwgb2Zmc2V0ICsgOClcbiAgICBzZWxmLl9jYWNoZS53cml0ZVVJbnQzMkJFKG91dFszXSwgb2Zmc2V0ICsgMTIpXG4gIH1cbiAgdmFyIHBhZCA9IHNlbGYuX2NhY2hlLnNsaWNlKDAsIGNodW5rLmxlbmd0aClcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShjaHVuay5sZW5ndGgpXG4gIHJldHVybiB4b3IoY2h1bmssIHBhZClcbn1cbiIsImV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBibG9jaykge1xuICByZXR1cm4gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhibG9jaylcbn1cblxuZXhwb3J0cy5kZWNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHJldHVybiBzZWxmLl9jaXBoZXIuZGVjcnlwdEJsb2NrKGJsb2NrKVxufVxuIiwidmFyIG1vZGVNb2R1bGVzID0ge1xuICBFQ0I6IHJlcXVpcmUoJy4vZWNiJyksXG4gIENCQzogcmVxdWlyZSgnLi9jYmMnKSxcbiAgQ0ZCOiByZXF1aXJlKCcuL2NmYicpLFxuICBDRkI4OiByZXF1aXJlKCcuL2NmYjgnKSxcbiAgQ0ZCMTogcmVxdWlyZSgnLi9jZmIxJyksXG4gIE9GQjogcmVxdWlyZSgnLi9vZmInKSxcbiAgQ1RSOiByZXF1aXJlKCcuL2N0cicpLFxuICBHQ006IHJlcXVpcmUoJy4vY3RyJylcbn1cblxudmFyIG1vZGVzID0gcmVxdWlyZSgnLi9saXN0Lmpzb24nKVxuXG5mb3IgKHZhciBrZXkgaW4gbW9kZXMpIHtcbiAgbW9kZXNba2V5XS5tb2R1bGUgPSBtb2RlTW9kdWxlc1ttb2Rlc1trZXldLm1vZGVdXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbW9kZXNcbiIsInZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcblxuZnVuY3Rpb24gZ2V0QmxvY2sgKHNlbGYpIHtcbiAgc2VsZi5fcHJldiA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgcmV0dXJuIHNlbGYuX3ByZXZcbn1cblxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rKSB7XG4gIHdoaWxlIChzZWxmLl9jYWNoZS5sZW5ndGggPCBjaHVuay5sZW5ndGgpIHtcbiAgICBzZWxmLl9jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3NlbGYuX2NhY2hlLCBnZXRCbG9jayhzZWxmKV0pXG4gIH1cblxuICB2YXIgcGFkID0gc2VsZi5fY2FjaGUuc2xpY2UoMCwgY2h1bmsubGVuZ3RoKVxuICBzZWxmLl9jYWNoZSA9IHNlbGYuX2NhY2hlLnNsaWNlKGNodW5rLmxlbmd0aClcbiAgcmV0dXJuIHhvcihjaHVuaywgcGFkKVxufVxuIiwidmFyIGFlcyA9IHJlcXVpcmUoJy4vYWVzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuZnVuY3Rpb24gU3RyZWFtQ2lwaGVyIChtb2RlLCBrZXksIGl2LCBkZWNyeXB0KSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG5cbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gQnVmZmVyLmZyb20oaXYpXG4gIHRoaXMuX2NhY2hlID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG4gIHRoaXMuX3NlY0NhY2hlID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG4gIHRoaXMuX2RlY3J5cHQgPSBkZWNyeXB0XG4gIHRoaXMuX21vZGUgPSBtb2RlXG59XG5cbmluaGVyaXRzKFN0cmVhbUNpcGhlciwgVHJhbnNmb3JtKVxuXG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaywgdGhpcy5fZGVjcnlwdClcbn1cblxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2NpcGhlci5zY3J1YigpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtQ2lwaGVyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhvciAoYSwgYikge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKVxuICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGJ1ZmZlcltpXSA9IGFbaV0gXiBiW2ldXG4gIH1cblxuICByZXR1cm4gYnVmZmVyXG59XG4iLCJ2YXIgc2VsZiA9IHt9O1xuKGZ1bmN0aW9uKHNlbGYpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmIChzZWxmLmZldGNoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIHNlbGYsXG4gICAgaXRlcmFibGU6ICdTeW1ib2wnIGluIHNlbGYgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gICAgYmxvYjogJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiYgJ0Jsb2InIGluIHNlbGYgJiYgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KSgpLFxuICAgIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIHNlbGYsXG4gICAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gc2VsZlxuICB9O1xuXG4gIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gICAgXTtcblxuICAgIHZhciBpc0RhdGFWaWV3ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbiAgICB9O1xuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID0gQXJyYXlCdWZmZXIuaXNWaWV3IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB2aWV3Q2xhc3Nlcy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSA+IC0xXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLlxcXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbiAgZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcmF0b3JcbiAgfVxuXG4gIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMubWFwID0ge307XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdO1xuICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSsnLCcrdmFsdWUgOiB2YWx1ZTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChuYW1lKTsgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkgeyBpdGVtcy5wdXNoKHZhbHVlKTsgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKTsgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgfTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKTtcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcik7XG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIEJvZHlJbml0IHR5cGUnKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gY29uc3VtZWQodGhpcykgfHwgUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXTtcblxuICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gKG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xKSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7XG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHM7XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kO1xuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTtcbiAgICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0O1xuICAgICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdvbWl0JztcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGw7XG4gICAgdGhpcy5yZWZlcnJlciA9IG51bGw7XG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpO1xuICB9XG5cbiAgUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywgeyBib2R5OiB0aGlzLl9ib2R5SW5pdCB9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpO1xuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJz0nKS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZm9ybVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgcmF3SGVhZGVycy5zcGxpdCgvXFxyP1xcbi8pLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpO1xuICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpO1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpO1xuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9ICdkZWZhdWx0JztcbiAgICB0aGlzLnN0YXR1cyA9ICdzdGF0dXMnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1cyA6IDIwMDtcbiAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9ICdzdGF0dXNUZXh0JyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXNUZXh0IDogJ09LJztcbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJyc7XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpO1xuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSk7XG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfTtcblxuICBSZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAwLCBzdGF0dXNUZXh0OiAnJ30pO1xuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InO1xuICAgIHJldHVybiByZXNwb25zZVxuICB9O1xuXG4gIHZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XTtcblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9O1xuXG4gIHNlbGYuSGVhZGVycyA9IEhlYWRlcnM7XG4gIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZTtcblxuICBzZWxmLmZldGNoID0gZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KTtcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KTtcbiAgICB9KVxuICB9O1xuICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzKTtcblxuLypcbiAqIFJvbGx1cCB3cmFwcyB1cCB0aGUgd2hhdHdnLWZldGNoIGNvZGUgb24gcG9ueWZpbGwgbW9kZSBpblxuICogb3JkZXIgdG8gcHJldmVudCBpdCBmcm9tIGFkZGluZyBmZXRjaCB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAqL1xuXG4gICAgICB2YXIgZmV0Y2ggPSBzZWxmLmZldGNoO1xuXG4gICAgICBmZXRjaC5mZXRjaCA9IGZldGNoO1xuICAgICAgZmV0Y2guUmVzcG9uc2UgPSBzZWxmLlJlc3BvbnNlO1xuICAgICAgZmV0Y2guSGVhZGVycyA9IHNlbGYuSGVhZGVycztcbiAgICAgIGZldGNoLlJlcXVlc3QgPSBzZWxmLlJlcXVlc3Q7XG5cbiAgICAgIC8vIGZldGNoIG5vdyBjYW4gYmUgaW1wb3J0ZWQgYXMgdGhlIGRlZmF1bHQgb2JqZWN0XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZldGNoO1xuICAgIFxuIiwiLy8gT25seSBOb2RlLkpTIGhhcyBhIHByb2Nlc3MgdmFyaWFibGUgdGhhdCBpcyBvZiBbW0NsYXNzXV0gcHJvY2Vzc1xuZXhwb3J0IGRlZmF1bHQgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyA/IHByb2Nlc3MgOiAwKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuIiwiLyoqXG4gKiBDb2RlIHJlZmFjdG9yZWQgZnJvbSBNb3ppbGxhIERldmVsb3BlciBOZXR3b3JrOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgZmlyc3RTb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGZpcnN0IGFyZ3VtZW50IHRvIG9iamVjdCcpO1xuICB9XG5cbiAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKG5leHRTb3VyY2UgPT09IHVuZGVmaW5lZCB8fCBuZXh0U291cmNlID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5c0FycmF5ID0gT2JqZWN0LmtleXMoT2JqZWN0KG5leHRTb3VyY2UpKTtcbiAgICBmb3IgKHZhciBuZXh0SW5kZXggPSAwLCBsZW4gPSBrZXlzQXJyYXkubGVuZ3RoOyBuZXh0SW5kZXggPCBsZW47IG5leHRJbmRleCsrKSB7XG4gICAgICB2YXIgbmV4dEtleSA9IGtleXNBcnJheVtuZXh0SW5kZXhdO1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5leHRTb3VyY2UsIG5leHRLZXkpO1xuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCAmJiBkZXNjLmVudW1lcmFibGUpIHtcbiAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICBpZiAoIU9iamVjdC5hc3NpZ24pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LCAnYXNzaWduJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBhc3NpZ25cbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXNzaWduOiBhc3NpZ24sXG4gIHBvbHlmaWxsOiBwb2x5ZmlsbFxufTtcbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIE1ENSA9IHJlcXVpcmUoJ21kNS5qcycpXG5cbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuZnVuY3Rpb24gRVZQX0J5dGVzVG9LZXkgKHBhc3N3b3JkLCBzYWx0LCBrZXlCaXRzLCBpdkxlbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXNzd29yZCkpIHBhc3N3b3JkID0gQnVmZmVyLmZyb20ocGFzc3dvcmQsICdiaW5hcnknKVxuICBpZiAoc2FsdCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHNhbHQpKSBzYWx0ID0gQnVmZmVyLmZyb20oc2FsdCwgJ2JpbmFyeScpXG4gICAgaWYgKHNhbHQubGVuZ3RoICE9PSA4KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2FsdCBzaG91bGQgYmUgQnVmZmVyIHdpdGggOCBieXRlIGxlbmd0aCcpXG4gIH1cblxuICB2YXIga2V5TGVuID0ga2V5Qml0cyAvIDhcbiAgdmFyIGtleSA9IEJ1ZmZlci5hbGxvYyhrZXlMZW4pXG4gIHZhciBpdiA9IEJ1ZmZlci5hbGxvYyhpdkxlbiB8fCAwKVxuICB2YXIgdG1wID0gQnVmZmVyLmFsbG9jKDApXG5cbiAgd2hpbGUgKGtleUxlbiA+IDAgfHwgaXZMZW4gPiAwKSB7XG4gICAgdmFyIGhhc2ggPSBuZXcgTUQ1KClcbiAgICBoYXNoLnVwZGF0ZSh0bXApXG4gICAgaGFzaC51cGRhdGUocGFzc3dvcmQpXG4gICAgaWYgKHNhbHQpIGhhc2gudXBkYXRlKHNhbHQpXG4gICAgdG1wID0gaGFzaC5kaWdlc3QoKVxuXG4gICAgdmFyIHVzZWQgPSAwXG5cbiAgICBpZiAoa2V5TGVuID4gMCkge1xuICAgICAgdmFyIGtleVN0YXJ0ID0ga2V5Lmxlbmd0aCAtIGtleUxlblxuICAgICAgdXNlZCA9IE1hdGgubWluKGtleUxlbiwgdG1wLmxlbmd0aClcbiAgICAgIHRtcC5jb3B5KGtleSwga2V5U3RhcnQsIDAsIHVzZWQpXG4gICAgICBrZXlMZW4gLT0gdXNlZFxuICAgIH1cblxuICAgIGlmICh1c2VkIDwgdG1wLmxlbmd0aCAmJiBpdkxlbiA+IDApIHtcbiAgICAgIHZhciBpdlN0YXJ0ID0gaXYubGVuZ3RoIC0gaXZMZW5cbiAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihpdkxlbiwgdG1wLmxlbmd0aCAtIHVzZWQpXG4gICAgICB0bXAuY29weShpdiwgaXZTdGFydCwgdXNlZCwgdXNlZCArIGxlbmd0aClcbiAgICAgIGl2TGVuIC09IGxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHRtcC5maWxsKDApXG4gIHJldHVybiB7IGtleToga2V5LCBpdjogaXYgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVWUF9CeXRlc1RvS2V5XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnaXMtY2FsbGFibGUnKTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmb3JFYWNoQXJyYXkgPSBmdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoU3RyaW5nID0gZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoT2JqZWN0ID0gZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iob2JqZWN0W2tdLCBrLCBvYmplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBvYmplY3Rba10sIGssIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIHRoaXNBcmcpIHtcbiAgICBpZiAoIWlzQ2FsbGFibGUoaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHZhciByZWNlaXZlcjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIHJlY2VpdmVyID0gdGhpc0FyZztcbiAgICB9XG5cbiAgICBpZiAodG9TdHIuY2FsbChsaXN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVmbGVjdC5jb25zdHJ1Y3QuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXAuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnbi5qc1wiKTtcblxudmFyIF9ldmVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJldmVudHNcIikpO1xuXG52YXIgX2Nsb25lRGVlcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9jbG9uZURlZXBcIikpO1xuXG52YXIgX2RlZmF1bHRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2RlZmF1bHRzXCIpKTtcblxudmFyIF9kZXRlY3ROb2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiZGV0ZWN0LW5vZGVcIikpO1xuXG52YXIgX2RlYnVnID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuXG52YXIgX2NvbmZpZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2NvbmZpZ1wiKSk7XG5cbnZhciBfbWV0aG9kcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbWV0aG9kc1wiKSk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5cbnZhciBfcHJvbWlzaWZ5ID0gcmVxdWlyZShcIi4uL3Byb21pc2lmeVwiKTtcblxudmFyIF90cmFuc3BvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi90cmFuc3BvcnRzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgdGhyb3cgX2UyOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UzKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMzsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG52YXIgZGVidWdFbWl0dGVycyA9ICgwLCBfZGVidWcuZGVmYXVsdCkoJ2dvbG9zOmVtaXR0ZXJzJyk7XG52YXIgZGVidWdTZXR1cCA9ICgwLCBfZGVidWcuZGVmYXVsdCkoJ2dvbG9zOnNldHVwJyk7XG52YXIgREVGQVVMVFMgPSB7XG4gIGlkOiAwXG59O1xuXG52YXIgR29sb3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKEdvbG9zLCBfRXZlbnRFbWl0dGVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEdvbG9zKTtcblxuICBmdW5jdGlvbiBHb2xvcygpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR29sb3MpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAoMCwgX2RlZmF1bHRzLmRlZmF1bHQpKG9wdGlvbnMsIERFRkFVTFRTKTtcbiAgICBfdGhpcy5vcHRpb25zID0gKDAsIF9jbG9uZURlZXAuZGVmYXVsdCkob3B0aW9ucyk7XG4gICAgX3RoaXMuX3N0cmVhbURlZmF1bHRzID0ge1xuICAgICAgbW9kZTogJ2hlYWQnLFxuICAgICAgc3RhcnRCbG9jazogMFxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEdvbG9zLCBbe1xuICAgIGtleTogXCJfc2V0VHJhbnNwb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRUcmFuc3BvcnQodXJsKSB7XG4gICAgICBpZiAodXJsICYmIHVybC5tYXRjaCgnXigoaHR0cHxodHRwcyk/OlxcL1xcLyknKSkge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG5ldyBfdHJhbnNwb3J0cy5kZWZhdWx0Lmh0dHAoKTtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICB9IGVsc2UgaWYgKHVybCAmJiB1cmwubWF0Y2goJ14oKHdzfHdzcyk/OlxcL1xcLyknKSkge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG5ldyBfdHJhbnNwb3J0cy5kZWZhdWx0LndzKCk7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJ1bmtub3duIHRyYW5zcG9ydCEgW1wiICsgdXJsICsgXCJdXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRXZWJTb2NrZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0V2ViU29ja2V0KHVybCkge1xuICAgICAgY29uc29sZS53YXJuKFwiZ29sb3MuYXBpLnNldFdlYlNvY2tldCh1cmwpIGlzIG5vdyBkZXByZWNhdGVkIGluc3RlYWQgdXNlIGdvbG9zLmNvbmZpZy5zZXQoJ3dlYnNvY2tldCcsdXJsKVwiKTtcbiAgICAgIGRlYnVnU2V0dXAoJ1NldHRpbmcgV1MnLCB1cmwpO1xuXG4gICAgICBfY29uZmlnLmRlZmF1bHQuc2V0KCd3ZWJzb2NrZXQnLCB1cmwpO1xuXG4gICAgICB0aGlzLl9zZXRUcmFuc3BvcnQodXJsKTtcblxuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIHVybCA9IF9jb25maWcuZGVmYXVsdC5nZXQoJ3dlYnNvY2tldCcpO1xuXG4gICAgICB0aGlzLl9zZXRUcmFuc3BvcnQodXJsKTtcblxuICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LnN0YXJ0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0b3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIGRlYnVnU2V0dXAoJ1N0b3BwaW5nLi4uJyk7XG4gICAgICB2YXIgcmV0ID0gdGhpcy50cmFuc3BvcnQuc3RvcCgpO1xuICAgICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICAgICAgdGhpcy51cmwgPSBudWxsO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kKGFwaSwgZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgIGRlYnVnU2V0dXAoJ0dvbG9zOjpzZW5kJywgYXBpLCBkYXRhKTtcblxuICAgICAgaWYgKCF0aGlzLnRyYW5zcG9ydCkge1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdXJsID0gX2NvbmZpZy5kZWZhdWx0LmdldCgnd2Vic29ja2V0Jyk7XG5cbiAgICAgICAgaWYgKHVybCAhPT0gdGhpcy51cmwpIHtcbiAgICAgICAgICBkZWJ1Z1NldHVwKCd3ZWJzb2NrZXQgVVJMIGNoYW5nZWQsIHJlc3RhcnRpbmcgdHJhbnNwb3J0Li4uJyk7XG4gICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5zZW5kKGFwaSwgZGF0YSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxsUmVsaWFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsbFJlbGlhYmxlKG1ldGhvZCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBhcmdzV2l0aG91dENiID0gYXJncy5zbGljZSgwLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgICAgdGhpc1ttZXRob2RdLmFwcGx5KHRoaXMsIF90b0NvbnN1bWFibGVBcnJheShhcmdzV2l0aG91dENiKS5jb25jYXQoW2Z1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAoZXJyIHx8ICFyZXN1bHQpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG1ldGhvZCArICcgcmVsaWFibGUgY2FsbCAtIGZhaWwsIHJldHJ5aW5nLi4uIENhdXNlOicsIGVyciA/IGVyci5tZXNzYWdlIDogJ0FQSSByZXR1cm5lZCBudWxsJyk7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIuY2FsbFJlbGlhYmxlLmFwcGx5KF90aGlzMiwgW21ldGhvZF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgfV0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RyZWFtQmxvY2tOdW1iZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RyZWFtQmxvY2tOdW1iZXIob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgICgwLCBfZGVmYXVsdHMuZGVmYXVsdCkob3B0aW9ucywgdGhpcy5fc3RyZWFtRGVmYXVsdHMpO1xuICAgICAgdmFyIHN0YXJ0QmxvY2sgPSBvcHRpb25zLnN0YXJ0QmxvY2s7XG4gICAgICB2YXIgcHJldkJsb2NrID0gMDtcbiAgICAgIHZhciBydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKCFydW5uaW5nKSByZXR1cm47XG5cbiAgICAgICAgX3RoaXMzLmNhbGxSZWxpYWJsZUFzeW5jKCdnZXREeW5hbWljR2xvYmFsUHJvcGVydGllcycpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIHZhciBjdXJyZW50QmxvY2sgPSBvcHRpb25zLm1vZGUgPT09ICdpcnJldmVyc2libGUnID8gcmVzdWx0Lmxhc3RfaXJyZXZlcnNpYmxlX2Jsb2NrX251bSA6IHJlc3VsdC5oZWFkX2Jsb2NrX251bWJlcjtcbiAgICAgICAgICBpZiAoIXN0YXJ0QmxvY2spIHN0YXJ0QmxvY2sgPSBjdXJyZW50QmxvY2s7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRCbG9jazsgaSA8PSBjdXJyZW50QmxvY2s7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJldCA9IGNhbGxiYWNrKG51bGwsIGkpO1xuICAgICAgICAgICAgaWYgKHJldCA9PT0gdHJ1ZSB8fCAhcnVubmluZykgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXJ0QmxvY2sgPSBjdXJyZW50QmxvY2sgKyAxO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHVwZGF0ZSgpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RyZWFtQmxvY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RyZWFtQmxvY2sob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgICgwLCBfZGVmYXVsdHMuZGVmYXVsdCkob3B0aW9ucywgdGhpcy5fc3RyZWFtRGVmYXVsdHMpO1xuICAgICAgdmFyIGN1cnJlbnQgPSAnJztcbiAgICAgIHZhciBsYXN0ID0gJyc7XG4gICAgICB2YXIgcmVsZWFzZSA9IHRoaXMuc3RyZWFtQmxvY2tOdW1iZXIob3B0aW9ucywgZnVuY3Rpb24gKGVyciwgaWQpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPSBpZDtcblxuICAgICAgICBpZiAoY3VycmVudCAhPT0gbGFzdCkge1xuICAgICAgICAgIGxhc3QgPSBjdXJyZW50O1xuXG4gICAgICAgICAgX3RoaXM0LmNhbGxSZWxpYWJsZSgnZ2V0QmxvY2snLCBjdXJyZW50LCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgIHJlcy5ibG9ja19udW0gPSBjdXJyZW50O1xuICAgICAgICAgICAgcmVzLnRpbWVzdGFtcF9wcmV2ID0gbmV3IERhdGUobmV3IERhdGUocmVzLnRpbWVzdGFtcCkuZ2V0VGltZSgpIC0gMzAwMCkudG9JU09TdHJpbmcoKS5zcGxpdCgnLicpWzBdO1xuICAgICAgICAgICAgdmFyIHJldCA9IGNhbGxiYWNrKGVyciwgcmVzKTtcbiAgICAgICAgICAgIGlmIChyZXQgPT09IHRydWUpIHJlbGVhc2UoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVsZWFzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RyZWFtVHJhbnNhY3Rpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0cmVhbVRyYW5zYWN0aW9ucyhvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICAoMCwgX2RlZmF1bHRzLmRlZmF1bHQpKG9wdGlvbnMsIHRoaXMuX3N0cmVhbURlZmF1bHRzKTtcbiAgICAgIHZhciByZWxlYXNlID0gdGhpcy5zdHJlYW1CbG9jayhvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBibG9jaykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJsb2NrICYmIGJsb2NrLnRyYW5zYWN0aW9ucykge1xuICAgICAgICAgIGJsb2NrLnRyYW5zYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgdmFyIHJldCA9IGNhbGxiYWNrKG51bGwsIHRyYW5zYWN0aW9uLCBibG9jayk7XG4gICAgICAgICAgICBpZiAocmV0ID09PSB0cnVlKSByZWxlYXNlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlbGVhc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0cmVhbU9wZXJhdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RyZWFtT3BlcmF0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgICgwLCBfZGVmYXVsdHMuZGVmYXVsdCkob3B0aW9ucywgdGhpcy5fc3RyZWFtRGVmYXVsdHMpO1xuICAgICAgdmFyIHJlbGVhc2UgPSB0aGlzLnN0cmVhbVRyYW5zYWN0aW9ucyhvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCB0cmFuc2FjdGlvbiwgYmxvY2spIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zYWN0aW9uLm9wZXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgICAgICAgdmFyIHJldCA9IGNhbGxiYWNrKG51bGwsIG9wZXJhdGlvbiwgdHJhbnNhY3Rpb24sIGJsb2NrKTtcbiAgICAgICAgICBpZiAocmV0ID09PSB0cnVlKSByZWxlYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVsZWFzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RyZWFtRXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0cmVhbUV2ZW50cyhvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgKDAsIF9kZWZhdWx0cy5kZWZhdWx0KShvcHRpb25zLCB0aGlzLl9zdHJlYW1EZWZhdWx0cyk7XG4gICAgICB2YXIgY3VycmVudCA9ICcnO1xuICAgICAgdmFyIGxhc3QgPSAnJztcbiAgICAgIHZhciByZWxlYXNlID0gdGhpcy5zdHJlYW1CbG9ja051bWJlcihvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBpZCkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA9IGlkO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBsYXN0KSB7XG4gICAgICAgICAgbGFzdCA9IGN1cnJlbnQ7XG5cbiAgICAgICAgICBfdGhpczUuY2FsbFJlbGlhYmxlKCdnZXRFdmVudHNJbkJsb2NrJywgY3VycmVudCwgZmFsc2UsIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJlcyksXG4gICAgICAgICAgICAgICAgX3N0ZXA7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50TWV0YSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBjYWxsYmFjayhlcnIsIGV2ZW50TWV0YS5vcCwgZXZlbnRNZXRhKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0ID09PSB0cnVlKSByZWxlYXNlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVsZWFzZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gR29sb3M7XG59KF9ldmVudHMuZGVmYXVsdCk7IC8vIEdlbmVyYXRlIE1ldGhvZHMgZnJvbSBtZXRob2RzLmpzXG5cblxuX21ldGhvZHMuZGVmYXVsdC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgdmFyIG1ldGhvZE5hbWUgPSBtZXRob2QubWV0aG9kX25hbWUgfHwgKDAsIF91dGlscy5jYW1lbENhc2UpKG1ldGhvZC5tZXRob2QpO1xuICB2YXIgbWV0aG9kUGFyYW1zID0gbWV0aG9kLnBhcmFtcyB8fCBbXTtcbiAgdmFyIGRlZmF1bHRQYXJtcyA9IHt9O1xuICB2YXIgaGFzRGVmYXVsdFZhbHVlcyA9IG1ldGhvZC5oYXNfZGVmYXVsdF92YWx1ZXM7XG5cbiAgaWYgKGhhc0RlZmF1bHRWYWx1ZXMpIHtcbiAgICBtZXRob2RQYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciBfcGFyYW0kc3BsaXQgPSBwYXJhbS5zcGxpdCgnPScpLFxuICAgICAgICAgIF9wYXJhbSRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfcGFyYW0kc3BsaXQsIDIpLFxuICAgICAgICAgIHAgPSBfcGFyYW0kc3BsaXQyWzBdLFxuICAgICAgICAgIHZhbHVlID0gX3BhcmFtJHNwbGl0MlsxXTtcblxuICAgICAgZGVmYXVsdFBhcm1zW3BdID0gdmFsdWUgPyBKU09OLnBhcnNlKHZhbHVlKSA6ICcnO1xuICAgIH0pO1xuICB9XG5cbiAgR29sb3MucHJvdG90eXBlW1wiXCIuY29uY2F0KG1ldGhvZE5hbWUsIFwiV2l0aFwiKV0gPSBmdW5jdGlvbiBHb2xvcyQkc3BlY2lhbGl6ZWRTZW5kV2l0aChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciBwYXJhbXMgPSBtZXRob2RQYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnNbaGFzRGVmYXVsdFZhbHVlcyA/IHBhcmFtLnNwbGl0KCc9JylbMF0gOiBwYXJhbV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuc2VuZChtZXRob2QuYXBpLCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZC5tZXRob2QsXG4gICAgICBwYXJhbXM6IHBhcmFtc1xuICAgIH0sIGNhbGxiYWNrKTtcbiAgfTtcblxuICBHb2xvcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiBHb2xvcyRzcGVjaWFsaXplZFNlbmQoKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICAgIGlmIChoYXNEZWZhdWx0VmFsdWVzKSB7XG4gICAgICB2YXIgYXJnc1dpdGhvdXRDYiA9IGFyZ3Muc2xpY2UoMCwgYXJncy5sZW5ndGggLSAxKTtcbiAgICAgIG1ldGhvZFBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSwgaSkge1xuICAgICAgICB2YXIgX3BhcmFtJHNwbGl0MyA9IHBhcmFtLnNwbGl0KCc9JyksXG4gICAgICAgICAgICBfcGFyYW0kc3BsaXQ0ID0gX3NsaWNlZFRvQXJyYXkoX3BhcmFtJHNwbGl0MywgMiksXG4gICAgICAgICAgICBwID0gX3BhcmFtJHNwbGl0NFswXSxcbiAgICAgICAgICAgIHZhbHVlID0gX3BhcmFtJHNwbGl0NFsxXTtcblxuICAgICAgICBpZiAoYXJnc1dpdGhvdXRDYltpXSkge1xuICAgICAgICAgIG9wdGlvbnNbcF0gPSBhcmdzV2l0aG91dENiW2ldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFybXMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3B0ID0gbWV0aG9kUGFyYW1zLnJlZHVjZShmdW5jdGlvbiAobWVtbywgcGFyYW0sIGkpIHtcbiAgICAgICAgbWVtb1twYXJhbV0gPSBhcmdzW2ldO1xuICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgIH0sIHt9KTtcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHQpO1xuICAgIH1cblxuICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbaGFzRGVmYXVsdFZhbHVlcyA/IGFyZ3MubGVuZ3RoIC0gMSA6IG1ldGhvZFBhcmFtcy5sZW5ndGhdO1xuICAgIHJldHVybiB0aGlzW1wiXCIuY29uY2F0KG1ldGhvZE5hbWUsIFwiV2l0aFwiKV0ob3B0aW9ucywgY2FsbGJhY2spO1xuICB9O1xufSk7XG5cbigwLCBfcHJvbWlzaWZ5LnByb21pc2lmeUFsbCkoR29sb3MucHJvdG90eXBlKTtcblxuR29sb3MucHJvdG90eXBlWydzZXRCbG9ja0FwcGxpZWRDYWxsYmFjayddID0gZnVuY3Rpb24gR29sb3Mkc2V0Q2FsbGJhY2sodHlwZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuc2VuZCgnZGF0YWJhc2VfYXBpJywge1xuICAgIG1ldGhvZDogJ3NldF9ibG9ja19hcHBsaWVkX2NhbGxiYWNrJyxcbiAgICBwYXJhbXM6IFt0eXBlXVxuICB9LCBjYWxsYmFjayk7XG59O1xuXG5Hb2xvcy5wcm90b3R5cGVbJ3NldFBlbmRpbmdUcmFuc2FjdGlvbkNhbGxiYWNrJ10gPSBmdW5jdGlvbiBHb2xvcyRzZXRDYWxsYmFjayhjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5zZW5kKCdkYXRhYmFzZV9hcGknLCB7XG4gICAgbWV0aG9kOiAnc2V0X3BlbmRpbmdfdHJhbnNhY3Rpb25fY2FsbGJhY2snLFxuICAgIHBhcmFtczogW11cbiAgfSwgY2FsbGJhY2spO1xufTtcblxuR29sb3MucHJvdG90eXBlWydzZXRQcml2YXRlTWVzc2FnZUNhbGxiYWNrJ10gPSBmdW5jdGlvbiBHb2xvcyRzZXRDYWxsYmFjayhxdWVyeSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuc2VuZCgncHJpdmF0ZV9tZXNzYWdlJywge1xuICAgIG1ldGhvZDogJ3NldF9jYWxsYmFjaycsXG4gICAgcGFyYW1zOiBbcXVlcnldXG4gIH0sIGNhbGxiYWNrKTtcbn07IC8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcblxuXG52YXIgZ29sb3MgPSBuZXcgR29sb3MoKTtcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGdvbG9zO1xuZXhwb3J0cy5Hb2xvcyA9IEdvbG9zO1xuZXhwb3J0cy5Hb2xvcy5ERUZBVUxUUyA9IERFRkFVTFRTOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgTU9TVF9SRUNFTlQgPSAtMTtcbnZhciBBQ0NPVU5UX0hJU1RPUllfREVGQVVMVF9MSU1JVCA9IDEwMDtcbnZhciBERUZBVUxUX1ZPVEVTX0xJTUlUID0gMTAwMDA7XG52YXIgREVGQVVMVF9WT1RFU19PRkZTRVQgPSAwO1xudmFyIERFRkFVTFRfTUFSS0VUX1BBSVIgPSAnW1wiR09MT1NcIiwgXCJHQkdcIl0nO1xudmFyIERFRkFVTFRfQVNTRVRTX0xJTUlUID0gMjA7XG52YXIgREVGQVVMVF9CTE9HX0ZFRURfTElNSVQgPSA1MDA7XG52YXIgRU1QVFlfU1RSSU5HID0gJyc7XG52YXIgRU1QVFlfQVJSQVkgPSAnW10nO1xudmFyIEVNUFRZX09QVElPTkFMID0gbnVsbDtcbm1vZHVsZS5leHBvcnRzID0gW3tcbiAgXCJhcGlcIjogXCJ3aXRuZXNzX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9jdXJyZW50X21lZGlhbl9oaXN0b3J5X3ByaWNlXCJcbn0sIHtcbiAgXCJhcGlcIjogXCJ3aXRuZXNzX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9mZWVkX2hpc3RvcnlcIlxufSwge1xuICBcImFwaVwiOiBcIndpdG5lc3NfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X21pbmVyX3F1ZXVlXCJcbn0sIHtcbiAgXCJhcGlcIjogXCJ3aXRuZXNzX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF93aXRuZXNzX3NjaGVkdWxlXCJcbn0sIHtcbiAgXCJhcGlcIjogXCJ3aXRuZXNzX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF93aXRuZXNzZXNcIixcbiAgXCJwYXJhbXNcIjogW1wid2l0bmVzc0lkc1wiXVxufSwge1xuICBcImFwaVwiOiBcIndpdG5lc3NfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X3dpdG5lc3NfYnlfYWNjb3VudFwiLFxuICBcInBhcmFtc1wiOiBbXCJhY2NvdW50TmFtZVwiXVxufSwge1xuICBcImFwaVwiOiBcIndpdG5lc3NfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X3dpdG5lc3Nfdm90ZXNcIixcbiAgXCJoYXNfZGVmYXVsdF92YWx1ZXNcIjogdHJ1ZSxcbiAgXCJwYXJhbXNcIjogW1wid2l0bmVzc0lkc1wiLCBcImxpbWl0PTIwXCIsIFwib2Zmc2V0PTBcIiwgXCJtaW5fcnNoYXJlc190b19zaG93PVxcXCIwLjAwMDAwMCBHRVNUU1xcXCJcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJ3aXRuZXNzX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF93aXRuZXNzZXNfYnlfdm90ZVwiLFxuICBcInBhcmFtc1wiOiBbXCJmcm9tXCIsIFwibGltaXRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJ3aXRuZXNzX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF93aXRuZXNzX2NvdW50XCJcbn0sIHtcbiAgXCJhcGlcIjogXCJ3aXRuZXNzX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImxvb2t1cF93aXRuZXNzX2FjY291bnRzXCIsXG4gIFwicGFyYW1zXCI6IFtcImxvd2VyQm91bmROYW1lXCIsIFwibGltaXRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJ3aXRuZXNzX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9hY3RpdmVfd2l0bmVzc2VzXCJcbn0sIHtcbiAgXCJhcGlcIjogXCJhY2NvdW50X2hpc3RvcnlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfYWNjb3VudF9oaXN0b3J5XCIsXG4gIFwiaGFzX2RlZmF1bHRfdmFsdWVzXCI6IHRydWUsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnRcIiwgXCJmcm9tPVwiLmNvbmNhdChNT1NUX1JFQ0VOVCksIFwibGltaXQ9XCIuY29uY2F0KEFDQ09VTlRfSElTVE9SWV9ERUZBVUxUX0xJTUlUKSwgXCJxdWVyeT17fVwiXVxufSwge1xuICBcImFwaVwiOiBcIm9wZXJhdGlvbl9oaXN0b3J5XCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X29wc19pbl9ibG9ja1wiLFxuICBcInBhcmFtc1wiOiBbXCJibG9ja051bVwiLCBcIm9ubHlWaXJ0dWFsXCJdXG59LCB7XG4gIFwiYXBpXCI6IFwib3BlcmF0aW9uX2hpc3RvcnlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfdHJhbnNhY3Rpb25cIixcbiAgXCJwYXJhbXNcIjogW1widHJ4SWRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJ0YWdzXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X3RyZW5kaW5nX3RhZ3NcIixcbiAgXCJwYXJhbXNcIjogW1wiYWZ0ZXJUYWdcIiwgXCJsaW1pdFwiXVxufSwge1xuICBcImFwaVwiOiBcInRhZ3NcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfdGFnc1wiLFxuICBcInBhcmFtc1wiOiBbXCJ0YWdzXCJdXG59LCB7XG4gIFwiYXBpXCI6IFwidGFnc1wiLFxuICBcIm1ldGhvZFwiOiBcImdldF90YWdzX3VzZWRfYnlfYXV0aG9yXCIsXG4gIFwicGFyYW1zXCI6IFtcImF1dGhvclwiXVxufSwge1xuICBcImFwaVwiOiBcInRhZ3NcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZGlzY3Vzc2lvbnNfYnlfcGF5b3V0XCIsXG4gIFwicGFyYW1zXCI6IFtcInF1ZXJ5XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwidGFnc1wiLFxuICBcIm1ldGhvZFwiOiBcImdldF9kaXNjdXNzaW9uc19ieV90cmVuZGluZ1wiLFxuICBcInBhcmFtc1wiOiBbXCJxdWVyeVwiXVxufSwge1xuICBcImFwaVwiOiBcInRhZ3NcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZGlzY3Vzc2lvbnNfYnlfY3JlYXRlZFwiLFxuICBcInBhcmFtc1wiOiBbXCJxdWVyeVwiXVxufSwge1xuICBcImFwaVwiOiBcInRhZ3NcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZGlzY3Vzc2lvbnNfYnlfYWN0aXZlXCIsXG4gIFwicGFyYW1zXCI6IFtcInF1ZXJ5XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwidGFnc1wiLFxuICBcIm1ldGhvZFwiOiBcImdldF9kaXNjdXNzaW9uc19ieV9jYXNob3V0XCIsXG4gIFwicGFyYW1zXCI6IFtcInF1ZXJ5XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwidGFnc1wiLFxuICBcIm1ldGhvZFwiOiBcImdldF9kaXNjdXNzaW9uc19ieV92b3Rlc1wiLFxuICBcInBhcmFtc1wiOiBbXCJxdWVyeVwiXVxufSwge1xuICBcImFwaVwiOiBcInRhZ3NcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZGlzY3Vzc2lvbnNfYnlfY2hpbGRyZW5cIixcbiAgXCJwYXJhbXNcIjogW1wicXVlcnlcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJ0YWdzXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2Rpc2N1c3Npb25zX2J5X2RvbmF0ZXNcIixcbiAgXCJwYXJhbXNcIjogW1wicXVlcnlcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJ0YWdzXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2Rpc2N1c3Npb25zX2J5X2hvdFwiLFxuICBcInBhcmFtc1wiOiBbXCJxdWVyeVwiXVxufSwge1xuICBcImFwaVwiOiBcInRhZ3NcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZGlzY3Vzc2lvbnNfYnlfZmVlZFwiLFxuICBcInBhcmFtc1wiOiBbXCJxdWVyeVwiXVxufSwge1xuICBcImFwaVwiOiBcInRhZ3NcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZGlzY3Vzc2lvbnNfYnlfYmxvZ1wiLFxuICBcInBhcmFtc1wiOiBbXCJxdWVyeVwiXVxufSwge1xuICBcImFwaVwiOiBcInRhZ3NcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZGlzY3Vzc2lvbnNfYnlfY29tbWVudHNcIixcbiAgXCJwYXJhbXNcIjogW1wicXVlcnlcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJ0YWdzXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2Rpc2N1c3Npb25zX2J5X3Byb21vdGVkXCIsXG4gIFwicGFyYW1zXCI6IFtcInF1ZXJ5XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwidGFnc1wiLFxuICBcIm1ldGhvZFwiOiBcImdldF9kaXNjdXNzaW9uc19ieV9hdXRob3JfYmVmb3JlX2RhdGVcIixcbiAgXCJwYXJhbXNcIjogW1wiYXV0aG9yXCIsIFwic3RhcnRQZXJtbGlua1wiLCBcImJlZm9yZURhdGVcIiwgXCJsaW1pdFwiXVxufSwge1xuICBcImFwaVwiOiBcInRhZ3NcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfbGFuZ3VhZ2VzXCJcbn0sIHtcbiAgXCJhcGlcIjogXCJzb2NpYWxfbmV0d29ya1wiLFxuICBcIm1ldGhvZFwiOiBcImdldF9yZXBsaWVzX2J5X2xhc3RfdXBkYXRlXCIsXG4gIFwiaGFzX2RlZmF1bHRfdmFsdWVzXCI6IHRydWUsXG4gIFwicGFyYW1zXCI6IFtcInN0YXJ0QXV0aG9yXCIsIFwic3RhcnRQZXJtbGlua1wiLCBcImxpbWl0XCIsIFwidm90ZUxpbWl0PVwiLmNvbmNhdChERUZBVUxUX1ZPVEVTX0xJTUlUKSwgXCJ2b3RlT2Zmc2V0PVwiLmNvbmNhdChERUZBVUxUX1ZPVEVTX09GRlNFVCksIFwiZmlsdGVyVGFnTWFza3M9XCIuY29uY2F0KEVNUFRZX0FSUkFZKV1cbn0sIHtcbiAgXCJhcGlcIjogXCJzb2NpYWxfbmV0d29ya1wiLFxuICBcIm1ldGhvZFwiOiBcImdldF9hbGxfZGlzY3Vzc2lvbnNfYnlfYWN0aXZlXCIsXG4gIFwiaGFzX2RlZmF1bHRfdmFsdWVzXCI6IHRydWUsXG4gIFwicGFyYW1zXCI6IFtcInN0YXJ0QXV0aG9yXCIsIFwic3RhcnRQZXJtbGlua1wiLCBcImZyb209MFwiLCBcImxpbWl0PTIwXCIsIFwiY2F0ZWdvcmllcz1cIi5jb25jYXQoRU1QVFlfQVJSQVkpLCBcInZvdGVMaW1pdD1cIi5jb25jYXQoREVGQVVMVF9WT1RFU19MSU1JVCksIFwidm90ZU9mZnNldD1cIi5jb25jYXQoREVGQVVMVF9WT1RFU19PRkZTRVQpLCBcImZpbHRlcklkcz1cIi5jb25jYXQoRU1QVFlfQVJSQVkpLCBcImZpbHRlckF1dGhvcnM9XCIuY29uY2F0KEVNUFRZX0FSUkFZKSwgXCJjYXRlZ29yeVByZWZpeD1cIi5jb25jYXQoRU1QVFlfU1RSSU5HKV1cbn0sIHtcbiAgXCJhcGlcIjogXCJzb2NpYWxfbmV0d29ya1wiLFxuICBcIm1ldGhvZFwiOiBcImdldF9jb250ZW50XCIsXG4gIFwiaGFzX2RlZmF1bHRfdmFsdWVzXCI6IHRydWUsXG4gIFwicGFyYW1zXCI6IFtcImF1dGhvclwiLCBcInBlcm1saW5rXCIsIFwidm90ZUxpbWl0PVwiLmNvbmNhdChERUZBVUxUX1ZPVEVTX0xJTUlUKSwgXCJ2b3RlT2Zmc2V0PVwiLmNvbmNhdChERUZBVUxUX1ZPVEVTX09GRlNFVCldXG59LCB7XG4gIFwiYXBpXCI6IFwic29jaWFsX25ldHdvcmtcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfY29udGVudF9yZXBsaWVzXCIsXG4gIFwiaGFzX2RlZmF1bHRfdmFsdWVzXCI6IHRydWUsXG4gIFwicGFyYW1zXCI6IFtcInBhcmVudFwiLCBcInBhcmVudFBlcm1saW5rXCIsIFwidm90ZUxpbWl0PVwiLmNvbmNhdChERUZBVUxUX1ZPVEVTX0xJTUlUKSwgXCJ2b3RlT2Zmc2V0PVwiLmNvbmNhdChERUZBVUxUX1ZPVEVTX09GRlNFVCksIFwiZmlsdGVySWRzPVwiLmNvbmNhdChFTVBUWV9BUlJBWSksIFwiZmlsdGVyQXV0aG9ycz1cIi5jb25jYXQoRU1QVFlfQVJSQVkpLCBcImZpbHRlck5lZ2F0aXZlUmVwQXV0aG9ycz1mYWxzZVwiXVxufSwge1xuICBcImFwaVwiOiBcInNvY2lhbF9uZXR3b3JrXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2FsbF9jb250ZW50X3JlcGxpZXNcIixcbiAgXCJoYXNfZGVmYXVsdF92YWx1ZXNcIjogdHJ1ZSxcbiAgXCJwYXJhbXNcIjogW1wicGFyZW50XCIsIFwicGFyZW50UGVybWxpbmtcIiwgXCJ2b3RlTGltaXQ9XCIuY29uY2F0KERFRkFVTFRfVk9URVNfTElNSVQpLCBcInZvdGVPZmZzZXQ9XCIuY29uY2F0KERFRkFVTFRfVk9URVNfT0ZGU0VUKSwgXCJmaWx0ZXJJZHM9XCIuY29uY2F0KEVNUFRZX0FSUkFZKSwgXCJmaWx0ZXJBdXRob3JzPVwiLmNvbmNhdChFTVBUWV9BUlJBWSksIFwiZmlsdGVyTmVnYXRpdmVSZXBBdXRob3JzPWZhbHNlXCIsIFwic29ydEJ5Q3JlYXRlZERlc2M9XCIuY29uY2F0KEVNUFRZX09QVElPTkFMKSAvLyB1c2Ugc3RyaW5nczogJ3RydWUnLCAnZmFsc2UnLiBOb24tc3RyaW5nIGZhbHNlIGlzIG51bGxcbiAgXVxufSwge1xuICBcImFwaVwiOiBcInNvY2lhbF9uZXR3b3JrXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2xhc3RfcmVwbHlcIixcbiAgXCJoYXNfZGVmYXVsdF92YWx1ZXNcIjogdHJ1ZSxcbiAgXCJwYXJhbXNcIjogW1wiYXV0aG9yXCIsIFwicGVybWxpbmtcIiwgXCJ2b3RlTGltaXQ9XCIuY29uY2F0KERFRkFVTFRfVk9URVNfTElNSVQpLCBcInZvdGVPZmZzZXQ9XCIuY29uY2F0KERFRkFVTFRfVk9URVNfT0ZGU0VUKSwgXCJmaWx0ZXJJZHM9XCIuY29uY2F0KEVNUFRZX0FSUkFZKSwgXCJmaWx0ZXJBdXRob3JzPVwiLmNvbmNhdChFTVBUWV9BUlJBWSldXG59LCB7XG4gIFwiYXBpXCI6IFwic29jaWFsX25ldHdvcmtcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfYWN0aXZlX3ZvdGVzXCIsXG4gIFwiaGFzX2RlZmF1bHRfdmFsdWVzXCI6IHRydWUsXG4gIFwicGFyYW1zXCI6IFtcImF1dGhvclwiLCBcInBlcm1saW5rXCIsIFwidm90ZUxpbWl0PVwiLmNvbmNhdChERUZBVUxUX1ZPVEVTX0xJTUlUKSwgXCJ2b3RlT2Zmc2V0PVwiLmNvbmNhdChERUZBVUxUX1ZPVEVTX09GRlNFVCldXG59LCB7XG4gIFwiYXBpXCI6IFwic29jaWFsX25ldHdvcmtcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfYWNjb3VudF92b3Rlc1wiLFxuICBcInBhcmFtc1wiOiBbXCJ2b3RlclwiLCBcImZyb21cIiwgXCJ2b3RlTGltaXRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJzb2NpYWxfbmV0d29ya1wiLFxuICBcIm1ldGhvZFwiOiBcImdldF9kb25hdGVzXCIsXG4gIFwicGFyYW1zXCI6IFtcInVpYVwiLCBcInRhcmdldFwiLCBcImZyb21cIiwgXCJ0b1wiLCBcImxpbWl0XCIsIFwib2Zmc2V0XCIsIFwiam9pbl9mcm9tc1wiXVxufSwge1xuICBcImFwaVwiOiBcInNvY2lhbF9uZXR3b3JrXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2RvbmF0ZXNfZm9yX3RhcmdldHNcIixcbiAgXCJwYXJhbXNcIjogW1widGFyZ2V0c1wiLCBcImxpbWl0XCIsIFwib2Zmc2V0XCIsIFwiam9pbl9mcm9tc1wiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9ibG9ja19oZWFkZXJcIixcbiAgXCJwYXJhbXNcIjogW1wiYmxvY2tOdW1cIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfYmxvY2tcIixcbiAgXCJwYXJhbXNcIjogW1wiYmxvY2tOdW1cIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfY29uZmlnXCJcbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZHluYW1pY19nbG9iYWxfcHJvcGVydGllc1wiXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2NoYWluX3Byb3BlcnRpZXNcIlxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9oYXJkZm9ya192ZXJzaW9uXCJcbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfbmV4dF9zY2hlZHVsZWRfaGFyZGZvcmtcIlxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9hY2NvdW50X2NvdW50XCJcbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfb3duZXJfaGlzdG9yeVwiLFxuICBcInBhcmFtc1wiOiBbXCJhY2NvdW50XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X3JlY292ZXJ5X3JlcXVlc3RcIixcbiAgXCJwYXJhbXNcIjogW1wiYWNjb3VudFwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9yZWNvdmVyeV9pbmZvXCIsXG4gIFwicGFyYW1zXCI6IFtcInF1ZXJ5XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2VzY3Jvd1wiLFxuICBcInBhcmFtc1wiOiBbXCJmcm9tXCIsIFwiZXNjcm93SWRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfd2l0aGRyYXdfcm91dGVzXCIsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnRcIiwgXCJ3aXRoZHJhd1JvdXRlVHlwZVwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9hY2NvdW50X2JhbmR3aWR0aFwiLFxuICBcInBhcmFtc1wiOiBbXCJhY2NvdW50XCIsIFwiYmFuZHdpZHRoVHlwZVwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9zYXZpbmdzX3dpdGhkcmF3X2Zyb21cIixcbiAgXCJwYXJhbXNcIjogW1wiYWNjb3VudFwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9zYXZpbmdzX3dpdGhkcmF3X3RvXCIsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfY29udmVyc2lvbl9yZXF1ZXN0c1wiLFxuICBcInBhcmFtc1wiOiBbXCJhY2NvdW50TmFtZVwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF90cmFuc2FjdGlvbl9oZXhcIixcbiAgXCJwYXJhbXNcIjogW1widHJ4XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXNcIixcbiAgXCJwYXJhbXNcIjogW1widHJ4XCIsIFwiYXZhaWxhYmxlS2V5c1wiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9wb3RlbnRpYWxfc2lnbmF0dXJlc1wiLFxuICBcInBhcmFtc1wiOiBbXCJ0cnhcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJ2ZXJpZnlfYXV0aG9yaXR5XCIsXG4gIFwicGFyYW1zXCI6IFtcInRyeFwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcInZlcmlmeV9hY2NvdW50X2F1dGhvcml0eVwiLFxuICBcInBhcmFtc1wiOiBbXCJuYW1lXCIsIFwic2lnbmVyc1wiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9hY2NvdW50c1wiLFxuICBcInBhcmFtc1wiOiBbXCJhY2NvdW50TmFtZXNcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJsb29rdXBfYWNjb3VudF9uYW1lc1wiLFxuICBcInBhcmFtc1wiOiBbXCJhY2NvdW50TmFtZXNcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJsb29rdXBfYWNjb3VudHNcIixcbiAgXCJwYXJhbXNcIjogW1wibG93ZXJCb3VuZE5hbWVcIiwgXCJsaW1pdFwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9wcm9wb3NlZF90cmFuc2FjdGlvbnNcIixcbiAgXCJwYXJhbXNcIjogW1wiYWNjb3VudFwiLCBcImZyb21cIiwgXCJsaW1pdFwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9kYXRhYmFzZV9pbmZvXCJcbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfdmVzdGluZ19kZWxlZ2F0aW9uc1wiLFxuICBcInBhcmFtc1wiOiBbXCJhY2NvdW50XCIsIFwiZnJvbVwiLCBcImxpbWl0XCIsIFwidHlwZVwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9leHBpcmluZ192ZXN0aW5nX2RlbGVnYXRpb25zXCIsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnRcIiwgXCJmcm9tXCIsIFwibGltaXRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfaW52aXRlXCIsXG4gIFwicGFyYW1zXCI6IFtcImludml0ZV9rZXlcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfYXNzZXRzXCIsXG4gIFwiaGFzX2RlZmF1bHRfdmFsdWVzXCI6IHRydWUsXG4gIFwicGFyYW1zXCI6IFtcImNyZWF0b3I9XCIuY29uY2F0KEVNUFRZX1NUUklORyksIFwic3ltYm9scz1cIi5jb25jYXQoRU1QVFlfQVJSQVkpLCBcImZyb209XCIuY29uY2F0KEVNUFRZX1NUUklORyksIFwibGltaXQ9XCIuY29uY2F0KERFRkFVTFRfQVNTRVRTX0xJTUlUKSwgXCJzb3J0PVxcXCJieV9zeW1ib2xfbmFtZVxcXCJcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfYWNjb3VudHNfYmFsYW5jZXNcIixcbiAgXCJwYXJhbXNcIjogWydhY2NvdW50X25hbWVzJ11cbn0sIHtcbiAgXCJhcGlcIjogXCJmb2xsb3dcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZm9sbG93ZXJzXCIsXG4gIFwicGFyYW1zXCI6IFtcImZvbGxvd2luZ1wiLCBcInN0YXJ0Rm9sbG93ZXJcIiwgXCJmb2xsb3dUeXBlXCIsIFwibGltaXRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJmb2xsb3dcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZm9sbG93aW5nXCIsXG4gIFwicGFyYW1zXCI6IFtcImZvbGxvd2VyXCIsIFwic3RhcnRGb2xsb3dpbmdcIiwgXCJmb2xsb3dUeXBlXCIsIFwibGltaXRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJmb2xsb3dcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZm9sbG93X2NvdW50XCIsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJmb2xsb3dcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZmVlZF9lbnRyaWVzXCIsXG4gIFwiaGFzX2RlZmF1bHRfdmFsdWVzXCI6IHRydWUsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnRcIiwgXCJlbnRyeUlkPTBcIiwgXCJsaW1pdD1cIi5jb25jYXQoREVGQVVMVF9CTE9HX0ZFRURfTElNSVQpLCBcImZpbHRlclRhZ01hc2tzPVwiLmNvbmNhdChFTVBUWV9BUlJBWSldXG59LCB7XG4gIFwiYXBpXCI6IFwiZm9sbG93XCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2ZlZWRcIixcbiAgXCJoYXNfZGVmYXVsdF92YWx1ZXNcIjogdHJ1ZSxcbiAgXCJwYXJhbXNcIjogW1wiYWNjb3VudFwiLCBcImVudHJ5SWQ9MFwiLCBcImxpbWl0PVwiLmNvbmNhdChERUZBVUxUX0JMT0dfRkVFRF9MSU1JVCksIFwiZmlsdGVyVGFnTWFza3M9XCIuY29uY2F0KEVNUFRZX0FSUkFZKV1cbn0sIHtcbiAgXCJhcGlcIjogXCJmb2xsb3dcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfYmxvZ19lbnRyaWVzXCIsXG4gIFwiaGFzX2RlZmF1bHRfdmFsdWVzXCI6IHRydWUsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnRcIiwgXCJlbnRyeUlkPTBcIiwgXCJsaW1pdD1cIi5jb25jYXQoREVGQVVMVF9CTE9HX0ZFRURfTElNSVQpLCBcImZpbHRlclRhZ01hc2tzPVwiLmNvbmNhdChFTVBUWV9BUlJBWSldXG59LCB7XG4gIFwiYXBpXCI6IFwiZm9sbG93XCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2Jsb2dcIixcbiAgXCJoYXNfZGVmYXVsdF92YWx1ZXNcIjogdHJ1ZSxcbiAgXCJwYXJhbXNcIjogW1wiYWNjb3VudFwiLCBcImVudHJ5SWQ9MFwiLCBcImxpbWl0PVwiLmNvbmNhdChERUZBVUxUX0JMT0dfRkVFRF9MSU1JVCksIFwiZmlsdGVyVGFnTWFza3M9XCIuY29uY2F0KEVNUFRZX0FSUkFZKV1cbn0sIHtcbiAgXCJhcGlcIjogXCJmb2xsb3dcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfYWNjb3VudF9yZXB1dGF0aW9uc1wiLFxuICBcInBhcmFtc1wiOiBbXCJuYW1lc1wiXVxufSwge1xuICBcImFwaVwiOiBcImZvbGxvd1wiLFxuICBcIm1ldGhvZFwiOiBcImdldF9yZWJsb2dnZWRfYnlcIixcbiAgXCJwYXJhbXNcIjogW1wiYXV0aG9yXCIsIFwicGVybWxpbmtcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJmb2xsb3dcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfYmxvZ19hdXRob3JzXCIsXG4gIFwicGFyYW1zXCI6IFtcImJsb2dBY2NvdW50XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiYWNjb3VudF9ieV9rZXlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfa2V5X3JlZmVyZW5jZXNcIixcbiAgXCJwYXJhbXNcIjogW1wiYWNjb3VudF9uYW1lX3R5cGVcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJuZXR3b3JrX2Jyb2FkY2FzdF9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJicm9hZGNhc3RfdHJhbnNhY3Rpb25cIixcbiAgXCJwYXJhbXNcIjogW1widHJ4XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwibmV0d29ya19icm9hZGNhc3RfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiYnJvYWRjYXN0X3RyYW5zYWN0aW9uX3dpdGhfY2FsbGJhY2tcIixcbiAgXCJwYXJhbXNcIjogW1wiY29uZmlybWF0aW9uQ2FsbGJhY2tcIiwgXCJ0cnhcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJuZXR3b3JrX2Jyb2FkY2FzdF9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJicm9hZGNhc3RfdHJhbnNhY3Rpb25fc3luY2hyb25vdXNcIixcbiAgXCJwYXJhbXNcIjogW1widHJ4XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwibmV0d29ya19icm9hZGNhc3RfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiYnJvYWRjYXN0X2Jsb2NrXCIsXG4gIFwicGFyYW1zXCI6IFtcImJsb2NrXCJdXG59LCB7XG4gIFwiYXBpXCI6IFwibWFya2V0X2hpc3RvcnlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfdGlja2VyXCIsXG4gIFwiaGFzX2RlZmF1bHRfdmFsdWVzXCI6IHRydWUsXG4gIFwicGFyYW1zXCI6IFtcInBhaXI9XCIuY29uY2F0KERFRkFVTFRfTUFSS0VUX1BBSVIpXVxufSwge1xuICBcImFwaVwiOiBcIm1hcmtldF9oaXN0b3J5XCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X3ZvbHVtZVwiLFxuICBcImhhc19kZWZhdWx0X3ZhbHVlc1wiOiB0cnVlLFxuICBcInBhcmFtc1wiOiBbXCJwYWlyPVwiLmNvbmNhdChERUZBVUxUX01BUktFVF9QQUlSKV1cbn0sIHtcbiAgXCJhcGlcIjogXCJtYXJrZXRfaGlzdG9yeVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9kZXB0aFwiLFxuICBcImhhc19kZWZhdWx0X3ZhbHVlc1wiOiB0cnVlLFxuICBcInBhcmFtc1wiOiBbXCJwYWlyPVwiLmNvbmNhdChERUZBVUxUX01BUktFVF9QQUlSKV1cbn0sIHtcbiAgXCJhcGlcIjogXCJtYXJrZXRfaGlzdG9yeVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9vcmRlcl9ib29rXCIsXG4gIFwiaGFzX2RlZmF1bHRfdmFsdWVzXCI6IHRydWUsXG4gIFwicGFyYW1zXCI6IFtcImxpbWl0XCIsIFwicGFpcj1cIi5jb25jYXQoREVGQVVMVF9NQVJLRVRfUEFJUildXG59LCB7XG4gIFwiYXBpXCI6IFwibWFya2V0X2hpc3RvcnlcIixcbiAgXCJoYXNfZGVmYXVsdF92YWx1ZXNcIjogdHJ1ZSxcbiAgXCJtZXRob2RcIjogXCJnZXRfb3JkZXJfYm9va19leHRlbmRlZFwiLFxuICBcInBhcmFtc1wiOiBbXCJsaW1pdFwiLCBcInBhaXI9XCIuY29uY2F0KERFRkFVTFRfTUFSS0VUX1BBSVIpXVxufSwge1xuICBcImFwaVwiOiBcIm1hcmtldF9oaXN0b3J5XCIsXG4gIFwiaGFzX2RlZmF1bHRfdmFsdWVzXCI6IHRydWUsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X3RyYWRlX2hpc3RvcnlcIixcbiAgXCJwYXJhbXNcIjogW1wic3RhcnRcIiwgXCJlbmRcIiwgXCJsaW1pdFwiLCBcInBhaXI9XCIuY29uY2F0KERFRkFVTFRfTUFSS0VUX1BBSVIpXVxufSwge1xuICBcImFwaVwiOiBcIm1hcmtldF9oaXN0b3J5XCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X3JlY2VudF90cmFkZXNcIixcbiAgXCJoYXNfZGVmYXVsdF92YWx1ZXNcIjogdHJ1ZSxcbiAgXCJwYXJhbXNcIjogW1wibGltaXRcIiwgXCJwYWlyPVwiLmNvbmNhdChERUZBVUxUX01BUktFVF9QQUlSKV1cbn0sIHtcbiAgXCJhcGlcIjogXCJtYXJrZXRfaGlzdG9yeVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9tYXJrZXRfaGlzdG9yeVwiLFxuICBcImhhc19kZWZhdWx0X3ZhbHVlc1wiOiB0cnVlLFxuICBcInBhcmFtc1wiOiBbXCJidWNrZXRfc2Vjb25kc1wiLCBcInN0YXJ0XCIsIFwiZW5kXCIsIFwicGFpcj1cIi5jb25jYXQoREVGQVVMVF9NQVJLRVRfUEFJUildXG59LCB7XG4gIFwiYXBpXCI6IFwibWFya2V0X2hpc3RvcnlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfbWFya2V0X2hpc3RvcnlfYnVja2V0c1wiLFxuICBcInBhcmFtc1wiOiBbXVxufSwge1xuICBcImFwaVwiOiBcIm1hcmtldF9oaXN0b3J5XCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X29wZW5fb3JkZXJzXCIsXG4gIFwiaGFzX2RlZmF1bHRfdmFsdWVzXCI6IHRydWUsXG4gIFwicGFyYW1zXCI6IFtcIm93bmVyXCIsIFwicGFpcj1cIi5jb25jYXQoREVGQVVMVF9NQVJLRVRfUEFJUildXG59LCB7XG4gIFwiYXBpXCI6IFwibWFya2V0X2hpc3RvcnlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZmlsbGFibGVfb3JkZXJzXCIsXG4gIFwicGFyYW1zXCI6IFtcIm1hcmtldF9wcmljZVwiXVxufSwge1xuICBcImFwaVwiOiBcInByaXZhdGVfbWVzc2FnZVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9pbmJveFwiLFxuICBcInBhcmFtc1wiOiBbXCJ0b1wiLCBcInF1ZXJ5XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwicHJpdmF0ZV9tZXNzYWdlXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X291dGJveFwiLFxuICBcInBhcmFtc1wiOiBbXCJmcm9tXCIsIFwicXVlcnlcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJwcml2YXRlX21lc3NhZ2VcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfdGhyZWFkXCIsXG4gIFwicGFyYW1zXCI6IFtcImZyb21cIiwgXCJ0b1wiLCBcInF1ZXJ5XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwicHJpdmF0ZV9tZXNzYWdlXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X3NldHRpbmdzXCIsXG4gIFwibWV0aG9kX25hbWVcIjogXCJnZXRQcml2YXRlTWVzc2FnZXNTZXR0aW5nc1wiLFxuICBcInBhcmFtc1wiOiBbXCJvd25lclwiXVxufSwge1xuICBcImFwaVwiOiBcInByaXZhdGVfbWVzc2FnZVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9jb250YWN0c19zaXplXCIsXG4gIFwicGFyYW1zXCI6IFtcIm93bmVyXCJdXG59LCB7XG4gIFwiYXBpXCI6IFwicHJpdmF0ZV9tZXNzYWdlXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2NvbnRhY3RfaW5mb1wiLFxuICBcInBhcmFtc1wiOiBbXCJvd25lclwiLCBcImNvbnRhY3RcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJwcml2YXRlX21lc3NhZ2VcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfY29udGFjdHNcIixcbiAgXCJwYXJhbXNcIjogW1wib3duZXJcIiwgXCJ0eXBlXCIsIFwibGltaXRcIiwgXCJvZmZzZXRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJ3b3JrZXJfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X3dvcmtlcl9yZXF1ZXN0c1wiLFxuICBcInBhcmFtc1wiOiBbXCJxdWVyeVwiLCBcInNvcnRcIiwgXCJmaWxsX3Bvc3RzXCJdXG59LCB7XG4gIFwiYXBpXCI6IFwid29ya2VyX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF93b3JrZXJfcmVxdWVzdF92b3Rlc1wiLFxuICBcInBhcmFtc1wiOiBbXCJhdXRob3JcIiwgXCJwZXJtbGlua1wiLCBcInN0YXJ0X3ZvdGVyXCIsIFwibGltaXRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJhY2NvdW50X25vdGVzXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X3ZhbHVlc19zZXR0aW5nc1wiLFxuICBcInBhcmFtc1wiOiBbXVxufSwge1xuICBcImFwaVwiOiBcImFjY291bnRfbm90ZXNcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfdmFsdWVzXCIsXG4gIFwiaGFzX2RlZmF1bHRfdmFsdWVzXCI6IHRydWUsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnRcIiwgXCJrZXlzPVwiLmNvbmNhdChFTVBUWV9BUlJBWSldXG59LCB7XG4gIFwiYXBpXCI6IFwiZXZlbnRfcGx1Z2luXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2V2ZW50c19pbl9ibG9ja1wiLFxuICBcInBhcmFtc1wiOiBbXCJibG9ja051bVwiLCBcIm9ubHlWaXJ0dWFsXCJdXG59XTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVmbGVjdC5jb25zdHJ1Y3QuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanNcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnbi5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qc1wiKTtcblxudmFyIF9ldmVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJldmVudHNcIikpO1xuXG52YXIgX3Byb21pc2lmeSA9IHJlcXVpcmUoXCIuLi8uLi9wcm9taXNpZnlcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG52YXIgVHJhbnNwb3J0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhUcmFuc3BvcnQsIF9FdmVudEVtaXR0ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVHJhbnNwb3J0KTtcblxuICBmdW5jdGlvbiBUcmFuc3BvcnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zcG9ydCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIF90aGlzLmlkID0gMDtcbiAgICBfdGhpcy5yZWxlYXNlcyA9IFtdO1xuICAgIF90aGlzLnJlcXVlc3RzID0ge307XG4gICAgX3RoaXMuY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRyYW5zcG9ydCwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsaXN0ZW5Ub1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW5Ubyh0YXJnZXQsIGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjayk7ZWxzZSB0YXJnZXQub24oZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spO2Vsc2UgdGFyZ2V0LnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kKCkge31cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBUcmFuc3BvcnQ7XG59KF9ldmVudHMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRyYW5zcG9ydDtcbigwLCBfcHJvbWlzaWZ5LnByb21pc2lmeUFsbCkoVHJhbnNwb3J0LnByb3RvdHlwZSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZmxlY3QuY29uc3RydWN0LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm1hcC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qc1wiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuUlBDRXJyb3IgPSB2b2lkIDA7XG5leHBvcnRzLmpzb25ScGMgPSBqc29uUnBjO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24uanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzXCIpO1xuXG52YXIgX2RlYnVnID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuXG52YXIgX2NvbmZpZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL2NvbmZpZ1wiKSk7XG5cbnZhciBfYmFzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYmFzZVwiKSk7XG5cbnZhciBfcHJvbWlzaWZ5ID0gcmVxdWlyZShcIi4uLy4uL3Byb21pc2lmeVwiKTtcblxudmFyIF9mZXRjaEV4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vdXRpbHMvZmV0Y2hFeFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7IGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHsgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7IF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7IH07IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7IH0gZWxzZSB7IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgdmFyIGEgPSBbbnVsbF07IGEucHVzaC5hcHBseShhLCBhcmdzKTsgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpOyB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTsgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7IHJldHVybiBpbnN0YW5jZTsgfTsgfSByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIGNiTWV0aG9kcyA9IFsnc2V0X2Jsb2NrX2FwcGxpZWRfY2FsbGJhY2snLCAnc2V0X3BlbmRpbmdfdHJhbnNhY3Rpb25fY2FsbGJhY2snLCAnc2V0X2NhbGxiYWNrJ107XG52YXIgZGVidWdQcm90b2NvbCA9ICgwLCBfZGVidWcuZGVmYXVsdCkoJ2dvbG9zOnByb3RvY29sJyk7XG52YXIgZGVidWdIdHRwID0gKDAsIF9kZWJ1Zy5kZWZhdWx0KSgnZ29sb3M6aHR0cCcpO1xuXG52YXIgUlBDRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoUlBDRXJyb3IsIF9FcnJvcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihSUENFcnJvcik7XG5cbiAgZnVuY3Rpb24gUlBDRXJyb3IocnBjRXJyb3IsIHJwY1Jlcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSUENFcnJvcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJwY0Vycm9yLm1lc3NhZ2UpO1xuICAgIF90aGlzLm5hbWUgPSAnUlBDRXJyb3InO1xuICAgIF90aGlzLmNvZGUgPSBycGNFcnJvci5jb2RlO1xuICAgIF90aGlzLmRhdGEgPSBycGNFcnJvci5kYXRhO1xuICAgIF90aGlzLnJlc2lkID0gcnBjUmVzLmlkO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBSUENFcnJvcjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbmV4cG9ydHMuUlBDRXJyb3IgPSBSUENFcnJvcjtcblxuZnVuY3Rpb24ganNvblJwYyh1cmksIF9yZWYpIHtcbiAgdmFyIG1ldGhvZCA9IF9yZWYubWV0aG9kLFxuICAgICAgaWQgPSBfcmVmLmlkLFxuICAgICAgcGFyYW1zID0gX3JlZi5wYXJhbXM7XG4gIHZhciBwYXlsb2FkID0ge1xuICAgIGlkOiBpZCxcbiAgICBqc29ucnBjOiAnMi4wJyxcbiAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICBwYXJhbXM6IHBhcmFtc1xuICB9O1xuICB2YXIgcmVxID0ge1xuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgIG1ldGhvZDogJ3Bvc3QnLFxuICAgIG1vZGU6ICdjb3JzJyxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgIH0sXG4gICAgdGltZW91dDogX2NvbmZpZy5kZWZhdWx0LmdldCgnbm9kZV90aW1lb3V0JylcbiAgfTtcbiAgcmVxLmNyZWRlbnRpYWxzID0gX2NvbmZpZy5kZWZhdWx0LmdldCgnY3JlZGVudGlhbHMnKTtcbiAgaWYgKCFyZXEuY3JlZGVudGlhbHMpIGRlbGV0ZSByZXEuY3JlZGVudGlhbHM7XG4gIHJldHVybiAoMCwgX2ZldGNoRXguZGVmYXVsdCkodXJpLCByZXEpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIVFRQIFwiLmNvbmNhdChyZXMuc3RhdHVzLCBcIjogXCIpLmNvbmNhdChyZXMuc3RhdHVzVGV4dCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuanNvbigpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChycGNSZXMpIHtcbiAgICBpZiAocnBjUmVzLmlkICE9PSBpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBpZDogXCIuY29uY2F0KHJwY1Jlcy5pZCkpO1xuICAgIH1cblxuICAgIGlmIChycGNSZXMuZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBSUENFcnJvcihycGNSZXMuZXJyb3IsIHJwY1Jlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJwY1JlcztcbiAgfSk7XG59XG5cbnZhciBIdHRwVHJhbnNwb3J0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVHJhbnNwb3J0KSB7XG4gIF9pbmhlcml0cyhIdHRwVHJhbnNwb3J0LCBfVHJhbnNwb3J0KTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihIdHRwVHJhbnNwb3J0KTtcblxuICBmdW5jdGlvbiBIdHRwVHJhbnNwb3J0KCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIdHRwVHJhbnNwb3J0KTtcblxuICAgIHJldHVybiBfc3VwZXIyLmNhbGwodGhpcywgT2JqZWN0LmFzc2lnbih7XG4gICAgICBpZDogMFxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhIdHRwVHJhbnNwb3J0LCBbe1xuICAgIGtleTogXCJzZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmQoYXBpLCBkYXRhLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGlkID0gZGF0YS5pZCB8fCB0aGlzLmlkKys7XG4gICAgICB0aGlzLmN1cnJlbnRQID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcGFyYW1zID0gW2FwaSwgZGF0YS5tZXRob2QsIGRhdGEucGFyYW1zXTtcblxuICAgICAgICB2YXIgdXJsID0gX2NvbmZpZy5kZWZhdWx0LmdldCgnd2Vic29ja2V0Jyk7XG5cbiAgICAgICAganNvblJwYyh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6ICdjYWxsJyxcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXMucmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jdXJyZW50UCA9ICgwLCBfcHJvbWlzaWZ5Lm5vZGVpZnkpKHRoaXMuY3VycmVudFAsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIdHRwVHJhbnNwb3J0O1xufShfYmFzZS5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSHR0cFRyYW5zcG9ydDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF93cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vd3NcIikpO1xuXG52YXIgX2h0dHAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2h0dHBcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX2RlZmF1bHQgPSB7XG4gIHdzOiBfd3MuZGVmYXVsdCxcbiAgaHR0cDogX2h0dHAuZGVmYXVsdFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVmbGVjdC5jb25zdHJ1Y3QuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24uanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5lbnRyaWVzLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzXCIpO1xuXG52YXIgX2RldGVjdE5vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJkZXRlY3Qtbm9kZVwiKSk7XG5cbnZhciBfZGVidWcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5cbnZhciBfY29uZmlnID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vY29uZmlnXCIpKTtcblxudmFyIF9iYXNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9iYXNlXCIpKTtcblxudmFyIF9wcm9taXNpZnkgPSByZXF1aXJlKFwiLi4vLi4vcHJvbWlzaWZ5XCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG52YXIgY2JNZXRob2RzID0gWydzZXRfYmxvY2tfYXBwbGllZF9jYWxsYmFjaycsICdzZXRfcGVuZGluZ190cmFuc2FjdGlvbl9jYWxsYmFjaycsICdzZXRfY2FsbGJhY2snXTtcbnZhciBXZWJTb2NrZXQ7XG5cbmlmIChfZGV0ZWN0Tm9kZS5kZWZhdWx0KSB7XG4gIFdlYlNvY2tldCA9IHJlcXVpcmUoJ3dzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ2xvYmFsLXJlcXVpcmVcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgV2ViU29ja2V0ID0gd2luZG93LldlYlNvY2tldDtcbn0gZWxzZSB7XG4gIHRocm93IG5ldyBFcnJvcignQ291bGRuXFwndCBkZWNpZGUgb24gYSBgV2ViU29ja2V0YCBjbGFzcycpO1xufVxuXG52YXIgZGVidWdQcm90b2NvbCA9ICgwLCBfZGVidWcuZGVmYXVsdCkoJ2dvbG9zOnByb3RvY29sJyk7XG52YXIgZGVidWdXcyA9ICgwLCBfZGVidWcuZGVmYXVsdCkoJ2dvbG9zOndzJyk7XG5cbnZhciBXc1RyYW5zcG9ydCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RyYW5zcG9ydCkge1xuICBfaW5oZXJpdHMoV3NUcmFuc3BvcnQsIF9UcmFuc3BvcnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoV3NUcmFuc3BvcnQpO1xuXG4gIGZ1bmN0aW9uIFdzVHJhbnNwb3J0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXc1RyYW5zcG9ydCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgaWQ6IDBcbiAgICB9LCBvcHRpb25zKSk7XG4gICAgX3RoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFdzVHJhbnNwb3J0LCBbe1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5zdGFydFApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRQO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRQID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZiAoc3RhcnRQICE9PSBfdGhpczIuc3RhcnRQKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHVybCA9IF9jb25maWcuZGVmYXVsdC5nZXQoJ3dlYnNvY2tldCcpO1xuXG4gICAgICAgIF90aGlzMi53cyA9IG5ldyBXZWJTb2NrZXQodXJsKTtcblxuICAgICAgICB2YXIgcmVsZWFzZU9wZW4gPSBfdGhpczIubGlzdGVuVG8oX3RoaXMyLndzLCAnb3BlbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkZWJ1Z1dzKCdPcGVuZWQgV1MgY29ubmVjdGlvbiB3aXRoJywgdXJsKTtcbiAgICAgICAgICBfdGhpczIuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICByZWxlYXNlT3BlbigpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGVyckhhbmRsZXIgPSBmdW5jdGlvbiBlcnJIYW5kbGVyKCkge1xuICAgICAgICAgIHZhciB3YXNPcGVuID0gX3RoaXMyLmlzT3BlbjtcbiAgICAgICAgICBfdGhpczIuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgZGVsZXRlIF90aGlzMi53cztcblxuICAgICAgICAgIF90aGlzMi5zdG9wKCk7XG5cbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdUaGUgV1MgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGJlZm9yZSB0aGlzIG9wZXJhdGlvbiB3YXMgbWFkZScpO1xuXG4gICAgICAgICAgaWYgKCF3YXNPcGVuKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9PYmplY3QkZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKF90aGlzMi5yZXF1ZXN0cyk7IF9pIDwgX09iamVjdCRlbnRyaWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIF9PYmplY3QkZW50cmllcyRfaSA9IF9zbGljZWRUb0FycmF5KF9PYmplY3QkZW50cmllc1tfaV0sIDIpLFxuICAgICAgICAgICAgICAgIGlkID0gX09iamVjdCRlbnRyaWVzJF9pWzBdLFxuICAgICAgICAgICAgICAgIHZhbCA9IF9PYmplY3QkZW50cmllcyRfaVsxXTtcblxuICAgICAgICAgICAgZGVsZXRlIF90aGlzMi5yZXF1ZXN0c1tpZF07XG4gICAgICAgICAgICB2YWwucmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX09iamVjdCRlbnRyaWVzMiA9IE9iamVjdC5lbnRyaWVzKF90aGlzMi5jYWxsYmFja3MpOyBfaTIgPCBfT2JqZWN0JGVudHJpZXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgIHZhciBfT2JqZWN0JGVudHJpZXMyJF9pID0gX3NsaWNlZFRvQXJyYXkoX09iamVjdCRlbnRyaWVzMltfaTJdLCAyKSxcbiAgICAgICAgICAgICAgICBfaWQgPSBfT2JqZWN0JGVudHJpZXMyJF9pWzBdLFxuICAgICAgICAgICAgICAgIF92YWwgPSBfT2JqZWN0JGVudHJpZXMyJF9pWzFdO1xuXG4gICAgICAgICAgICBkZWxldGUgX3RoaXMyLmNhbGxiYWNrc1tfaWRdO1xuXG4gICAgICAgICAgICBfdmFsLmNiKGVyciwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZWxlYXNlQ2xvc2UgPSBfdGhpczIubGlzdGVuVG8oX3RoaXMyLndzLCAnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGVidWdXcygnQ2xvc2VkIFdTIGNvbm5lY3Rpb24gd2l0aCcsIHVybCk7XG4gICAgICAgICAgZXJySGFuZGxlcigpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVsZWFzZUVycm9yID0gX3RoaXMyLmxpc3RlblRvKF90aGlzMi53cywgJ2Vycm9yJywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgZGVidWdXcygnQ2xvc2VkIFdTIGNvbm5lY3Rpb24gd2l0aCcsIHVybCwgJ2Vycm9yIGlzJywgZXJyb3IpO1xuICAgICAgICAgIGVyckhhbmRsZXIoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlbGVhc2VNZXNzYWdlID0gX3RoaXMyLmxpc3RlblRvKF90aGlzMi53cywgJ21lc3NhZ2UnLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgIGRlYnVnV3MoJ1JlY2VpdmVkIG1lc3NhZ2UnLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgIHZhciBpZCA9IGRhdGEuaWQ7XG4gICAgICAgICAgdmFyIHJlcXVlc3QgPSBfdGhpczIucmVxdWVzdHNbaWRdIHx8IF90aGlzMi5jYWxsYmFja3NbaWRdO1xuXG4gICAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgICBkZWJ1Z1dzKCdHb2xvcy5vbk1lc3NhZ2UgZXJyb3I6IHVua25vd24gcmVxdWVzdCAnLCBpZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVsZXRlIF90aGlzMi5yZXF1ZXN0c1tpZF07XG5cbiAgICAgICAgICBfdGhpczIub25NZXNzYWdlKGRhdGEsIHJlcXVlc3QpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpczIucmVsZWFzZXMgPSBfdGhpczIucmVsZWFzZXMuY29uY2F0KFtyZWxlYXNlT3BlbiwgcmVsZWFzZUNsb3NlLCByZWxlYXNlRXJyb3IsIHJlbGVhc2VNZXNzYWdlXSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc3RhcnRQID0gc3RhcnRQO1xuICAgICAgcmV0dXJuIHN0YXJ0UDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgaWYgKHRoaXMud3MpIHRoaXMud3MuY2xvc2UoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnN0YXJ0UDtcbiAgICAgIGRlbGV0ZSB0aGlzLndzO1xuICAgICAgdGhpcy5yZWxlYXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWxlYXNlKSB7XG4gICAgICAgIHJldHVybiByZWxlYXNlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVsZWFzZXMgPSBbXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25NZXNzYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWVzc2FnZShtZXNzYWdlLCByZXF1ZXN0KSB7XG4gICAgICB2YXIgYXBpID0gcmVxdWVzdC5hcGksXG4gICAgICAgICAgZGF0YSA9IHJlcXVlc3QuZGF0YSxcbiAgICAgICAgICByZXNvbHZlID0gcmVxdWVzdC5yZXNvbHZlLFxuICAgICAgICAgIHJlamVjdCA9IHJlcXVlc3QucmVqZWN0LFxuICAgICAgICAgIHN0YXJ0X3RpbWUgPSByZXF1ZXN0LnN0YXJ0X3RpbWU7XG4gICAgICBkZWJ1Z1dzKCctLSBHb2xvcy5vbk1lc3NhZ2UgLS0+JywgbWVzc2FnZS5pZCk7XG4gICAgICB2YXIgZXJyb3JDYXVzZSA9IG1lc3NhZ2UuZXJyb3I7XG5cbiAgICAgIGlmIChlcnJvckNhdXNlKSB7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItdGVtcGxhdGVcbiAgICAgICAgKGVycm9yQ2F1c2UubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGNvbXBsZXRlIG9wZXJhdGlvbicpICsgJyAoc2VlIGVyci5wYXlsb2FkIGZvciB0aGUgZnVsbCBlcnJvciBwYXlsb2FkKScpO1xuICAgICAgICBlcnIucGF5bG9hZCA9IG1lc3NhZ2U7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRlYnVnUHJvdG9jb2woJ1Jlc29sdmVkJywgYXBpLCBkYXRhLCAnLT4nLCBtZXNzYWdlKTtcblxuICAgICAgaWYgKGNiTWV0aG9kcy5pbmNsdWRlcyhkYXRhLm1ldGhvZCkpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3NbbWVzc2FnZS5pZF0uY2IobnVsbCwgbWVzc2FnZS5yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMucmVxdWVzdHNbbWVzc2FnZS5pZF07XG4gICAgICAgIHJlc29sdmUobWVzc2FnZS5yZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmQoYXBpLCBkYXRhLCBjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBpZCA9IGRhdGEuaWQgfHwgdGhpcy5pZCsrO1xuICAgICAgdmFyIHN0YXJ0UCA9IHRoaXMuc3RhcnQoKTtcbiAgICAgIHRoaXMuY3VycmVudFAgPSBzdGFydFAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaWYgKCFfdGhpczMud3MpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RoZSBXUyBjb25uZWN0aW9uIHdhcyBjbG9zZWQgd2hpbGUgdGhpcyByZXF1ZXN0IHdhcyBwZW5kaW5nJykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgbWV0aG9kOiAnY2FsbCcsXG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgIHBhcmFtczogW2FwaSwgZGF0YS5tZXRob2QsIGRhdGEucGFyYW1zXVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlYnVnV3MoJ1NlbmRpbmcgbWVzc2FnZScsIHBheWxvYWQpO1xuXG4gICAgICAgICAgaWYgKGNiTWV0aG9kcy5pbmNsdWRlcyhkYXRhLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIF90aGlzMy5jYWxsYmFja3NbaWRdID0ge1xuICAgICAgICAgICAgICBhcGk6IGFwaSxcbiAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgY2I6IGNhbGxiYWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpczMucmVxdWVzdHNbaWRdID0ge1xuICAgICAgICAgICAgICBhcGk6IGFwaSxcbiAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgcmVqZWN0OiByZWplY3QsXG4gICAgICAgICAgICAgIHN0YXJ0X3RpbWU6IERhdGUubm93KClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMzLndzLnNlbmQocGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmN1cnJlbnRQID0gKDAsIF9wcm9taXNpZnkubm9kZWlmeSkodGhpcy5jdXJyZW50UCwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFA7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFdzVHJhbnNwb3J0O1xufShfYmFzZS5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gV3NUcmFuc3BvcnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBZGRyZXNzOiByZXF1aXJlKFwiLi9zcmMvYWRkcmVzc1wiKSxcbiAgQWVzOiByZXF1aXJlKFwiLi9zcmMvYWVzXCIpLFxuICBQcml2YXRlS2V5OiByZXF1aXJlKFwiLi9zcmMva2V5X3ByaXZhdGVcIiksXG4gIFB1YmxpY0tleTogcmVxdWlyZShcIi4vc3JjL2tleV9wdWJsaWNcIiksXG4gIFNpZ25hdHVyZTogcmVxdWlyZShcIi4vc3JjL3NpZ25hdHVyZVwiKSxcbiAgYnJhaW5LZXk6IHJlcXVpcmUoXCIuL3NyYy9icmFpbl9rZXlcIiksXG4gIGtleV91dGlsczogcmVxdWlyZShcIi4vc3JjL2tleV91dGlsc1wiKSxcbiAgaGFzaDogcmVxdWlyZShcIi4vc3JjL2hhc2hcIiksXG4gIGVjY19jb25maWc6IHJlcXVpcmUoXCIuLi8uLi9jb25maWdcIilcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzXCIpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbmZpZycpO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpO1xuXG52YXIgYmFzZTU4ID0gcmVxdWlyZSgnYnM1OCcpO1xuLyoqIEFkZHJlc3NlcyBhcmUgc2hvcnRlbmVkIG5vbi1yZXZlcnNhYmxlIGhhc2hlcyBvZiBhIHB1YmxpYyBrZXkuICBUaGUgZnVsbCBQdWJsaWNLZXkgaXMgcHJlZmVycmVkLlxuICAgIEBkZXByZWNhdGVkXG4qL1xuXG5cbnZhciBBZGRyZXNzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQWRkcmVzcyhhZGR5KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFkZHJlc3MpO1xuXG4gICAgdGhpcy5hZGR5ID0gYWRkeTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBZGRyZXNzLCBbe1xuICAgIGtleTogXCJ0b0J1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J1ZmZlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZHk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBjb25maWcuZ2V0KCdhZGRyZXNzX3ByZWZpeCcpO1xuICAgICAgdmFyIGNoZWNrc3VtID0gaGFzaC5yaXBlbWQxNjAodGhpcy5hZGR5KTtcbiAgICAgIHZhciBhZGR5ID0gQnVmZmVyLmNvbmNhdChbdGhpcy5hZGR5LCBjaGVja3N1bS5zbGljZSgwLCA0KV0pO1xuICAgICAgcmV0dXJuIGFkZHJlc3NfcHJlZml4ICsgYmFzZTU4LmVuY29kZShhZGR5KTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tQnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgICB2YXIgX2hhc2ggPSBoYXNoLnNoYTUxMihidWZmZXIpO1xuXG4gICAgICB2YXIgYWRkeSA9IGhhc2gucmlwZW1kMTYwKF9oYXNoKTtcbiAgICAgIHJldHVybiBuZXcgQWRkcmVzcyhhZGR5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cmluZykge1xuICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBjb25maWcuZ2V0KCdhZGRyZXNzX3ByZWZpeCcpO1xuICAgICAgdmFyIHByZWZpeCA9IHN0cmluZy5zbGljZSgwLCBhZGRyZXNzX3ByZWZpeC5sZW5ndGgpO1xuICAgICAgYXNzZXJ0LmVxdWFsKGFkZHJlc3NfcHJlZml4LCBwcmVmaXgsIFwiRXhwZWN0aW5nIGtleSB0byBiZWdpbiB3aXRoIFwiLmNvbmNhdChhZGRyZXNzX3ByZWZpeCwgXCIsIGluc3RlYWQgZ290IFwiKS5jb25jYXQocHJlZml4KSk7XG4gICAgICB2YXIgYWRkeSA9IHN0cmluZy5zbGljZShhZGRyZXNzX3ByZWZpeC5sZW5ndGgpO1xuICAgICAgYWRkeSA9IG5ldyBCdWZmZXIoYmFzZTU4LmRlY29kZShhZGR5KSwgJ2JpbmFyeScpO1xuICAgICAgdmFyIGNoZWNrc3VtID0gYWRkeS5zbGljZSgtNCk7XG4gICAgICBhZGR5ID0gYWRkeS5zbGljZSgwLCAtNCk7XG4gICAgICB2YXIgbmV3X2NoZWNrc3VtID0gaGFzaC5yaXBlbWQxNjAoYWRkeSk7XG4gICAgICBuZXdfY2hlY2tzdW0gPSBuZXdfY2hlY2tzdW0uc2xpY2UoMCwgNCk7XG4gICAgICBhc3NlcnQuZGVlcEVxdWFsKGNoZWNrc3VtLCBuZXdfY2hlY2tzdW0sICdDaGVja3N1bSBkaWQgbm90IG1hdGNoJyk7XG4gICAgICByZXR1cm4gbmV3IEFkZHJlc3MoYWRkeSk7XG4gICAgfVxuICAgIC8qKiBAcmV0dXJuIEFkZHJlc3MgLSBDb21wcmVzc2VkIFBUUyBmb3JtYXQgKGJ5IGRlZmF1bHQpICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmcm9tUHVibGljXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21QdWJsaWMocHVibGljX2tleSkge1xuICAgICAgdmFyIGNvbXByZXNzZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgdmVyc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogNTY7XG4gICAgICB2YXIgc2hhMiA9IGhhc2guc2hhMjU2KHB1YmxpY19rZXkudG9CdWZmZXIoY29tcHJlc3NlZCkpO1xuICAgICAgdmFyIHJlcCA9IGhhc2gucmlwZW1kMTYwKHNoYTIpO1xuICAgICAgdmFyIHZlcnNpb25CdWZmZXIgPSBuZXcgQnVmZmVyKDEpO1xuICAgICAgdmVyc2lvbkJ1ZmZlci53cml0ZVVJbnQ4KDB4RkYgJiB2ZXJzaW9uLCAwKTtcbiAgICAgIHZhciBhZGRyID0gQnVmZmVyLmNvbmNhdChbdmVyc2lvbkJ1ZmZlciwgcmVwXSk7XG4gICAgICB2YXIgY2hlY2sgPSBoYXNoLnNoYTI1NihhZGRyKTtcbiAgICAgIGNoZWNrID0gaGFzaC5zaGEyNTYoY2hlY2spO1xuICAgICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2FkZHIsIGNoZWNrLnNsaWNlKDAsIDQpXSk7XG4gICAgICByZXR1cm4gbmV3IEFkZHJlc3MoaGFzaC5yaXBlbWQxNjAoYnVmZmVyKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFkZHJlc3M7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWRkcmVzczsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVjcnlwdCA9IGRlY3J5cHQ7XG5leHBvcnRzLmVuY3J5cHQgPSBlbmNyeXB0O1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanNcIik7XG5cbnZhciBfc2VjdXJlUmFuZG9tID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwic2VjdXJlLXJhbmRvbVwiKSk7XG5cbnZhciBfYnl0ZWJ1ZmZlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImJ5dGVidWZmZXJcIikpO1xuXG52YXIgX2Jyb3dzZXJpZnlBZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJicm93c2VyaWZ5LWFlc1wiKSk7XG5cbnZhciBfYXNzZXJ0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcblxudmFyIF9rZXlfcHVibGljID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9rZXlfcHVibGljXCIpKTtcblxudmFyIF9rZXlfcHJpdmF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4va2V5X3ByaXZhdGVcIikpO1xuXG52YXIgX2hhc2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2hhc2hcIikpO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29yZVwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIExvbmcgPSBfYnl0ZWJ1ZmZlci5kZWZhdWx0Lkxvbmc7XG4vKipcbiAgICBTcGVjOiBodHRwOi8vbG9jYWxob3N0OjMwMDIvc3RlZW0vQGRhbnRoZW1hbi9ob3ctdG8tZW5jcnlwdC1hLW1lbW8td2hlbi10cmFuc2ZlcnJpbmctc3RlZW1cbiAgICBAdGhyb3dzIHtFcnJvcnxUeXBlRXJyb3J9IC0gXCJJbnZhbGlkIEtleSwgLi4uXCJcbiAgICBAYXJnIHtQcml2YXRlS2V5fFVpbnQ4QXJyYXl9IHByaXZhdGVfa2V5IC0gcmVxdWlyZWQgYW5kIHVzZWQgZm9yIGRlY3J5cHRpb24uIElmIHlvdSBoYXZlIG1hbnkgbWVzc2FnZXMgdG8gZGVjcnlwdCwgaXQgaXMgZmFzdGVyIHRvIHBhc3MgcHJlcGFyZWQgc2hhcmVkX3NlY3JldCwgaW5zdGVhZCBvZiBwcml2YXRlX2tleVxuICAgIEBhcmcge1B1YmxpY0tleX0gcHVibGljX2tleSAtIHJlcXVpcmVkIChpZiBwcml2YXRlX2tleV9vcl9zaGFyZWRfc2VjcmV0IGlzIG5vdCBhIHNoYXJlZCBzZWNyZXQpIGFuZCB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgc2hhcmVkIHNlY3JldFxuICAgIEBhcmcge3N0cmluZ30gW25vbmNlID0gdW5pcXVlTm9uY2UoKV0gLSBhc3NpZ25lZCBhIHJhbmRvbSB1bmlxdWUgdWludDY0XG5cbiAgICBAcmV0dXJuIHtvYmplY3R9XG4gICAgQHByb3BlcnR5IHtzdHJpbmd9IG5vbmNlIC0gcmFuZG9tIG9yIHVuaXF1ZSB1aW50NjQsIHByb3ZpZGVzIGVudHJvcHkgd2hlbiByZS11c2luZyB0aGUgc2FtZSBwcml2YXRlL3B1YmxpYyBrZXlzLlxuICAgIEBwcm9wZXJ0eSB7QnVmZmVyfSBtZXNzYWdlIC0gUGxhaW4gdGV4dCBtZXNzYWdlXG4gICAgQHByb3BlcnR5IHtudW1iZXJ9IGNoZWNrc3VtIC0gc2hhcmVkIHNlY3JldCBjaGVja3N1bVxuKi9cblxuZnVuY3Rpb24gZW5jcnlwdChwcml2YXRlX2tleV9vcl9zaGFyZWRfc2VjcmV0LCBwdWJsaWNfa2V5LCBtZXNzYWdlKSB7XG4gIHZhciBub25jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdW5pcXVlTm9uY2UoKTtcbiAgcmV0dXJuIGNyeXB0KHByaXZhdGVfa2V5X29yX3NoYXJlZF9zZWNyZXQsIHB1YmxpY19rZXksIG5vbmNlLCBtZXNzYWdlKTtcbn1cbi8qKlxuICAgIFNwZWM6IGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMi9zdGVlbS9AZGFudGhlbWFuL2hvdy10by1lbmNyeXB0LWEtbWVtby13aGVuLXRyYW5zZmVycmluZy1zdGVlbVxuICAgIEBhcmcge1ByaXZhdGVLZXl8VWludDhBcnJheX0gcHJpdmF0ZV9rZXlfb3Jfc2hhcmVkX3NlY3JldCAtIHJlcXVpcmVkIGFuZCB1c2VkIGZvciBkZWNyeXB0aW9uLiBJZiB5b3UgaGF2ZSBtYW55IG1lc3NhZ2VzIHRvIGRlY3J5cHQsIGl0IGlzIGZhc3RlciB0byBwYXNzIHByZXBhcmVkIHNoYXJlZF9zZWNyZXQsIGluc3RlYWQgb2YgcHJpdmF0ZV9rZXlcbiAgICBAYXJnIHtQdWJsaWNLZXl9IHB1YmxpY19rZXkgLSByZXF1aXJlZCAoaWYgcHJpdmF0ZV9rZXlfb3Jfc2hhcmVkX3NlY3JldCBpcyBub3QgYSBzaGFyZWQgc2VjcmV0KSBhbmQgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHNoYXJlZCBzZWNyZXRcbiAgICBAYXJnIHtzdHJpbmd9IG5vbmNlIC0gcmFuZG9tIG9yIHVuaXF1ZSB1aW50NjQsIHByb3ZpZGVzIGVudHJvcHkgd2hlbiByZS11c2luZyB0aGUgc2FtZSBwcml2YXRlL3B1YmxpYyBrZXlzLlxuICAgIEBhcmcge0J1ZmZlcn0gbWVzc2FnZSAtIEVuY3J5cHRlZCBvciBwbGFpbiB0ZXh0IG1lc3NhZ2VcbiAgICBAYXJnIHtudW1iZXJ9IGNoZWNrc3VtIC0gc2hhcmVkIHNlY3JldCBjaGVja3N1bVxuICAgIEB0aHJvd3Mge0Vycm9yfFR5cGVFcnJvcn0gLSBcIkludmFsaWQgS2V5LCAuLi5cIlxuICAgIEByZXR1cm4ge0J1ZmZlcn0gLSBtZXNzYWdlXG4qL1xuXG5cbmZ1bmN0aW9uIGRlY3J5cHQocHJpdmF0ZV9rZXlfb3Jfc2hhcmVkX3NlY3JldCwgcHVibGljX2tleSwgbm9uY2UsIG1lc3NhZ2UsIGNoZWNrc3VtKSB7XG4gIHJldHVybiBjcnlwdChwcml2YXRlX2tleV9vcl9zaGFyZWRfc2VjcmV0LCBwdWJsaWNfa2V5LCBub25jZSwgbWVzc2FnZSwgY2hlY2tzdW0pLm1lc3NhZ2U7XG59XG4vKipcbiAgICBAYXJnIHtCdWZmZXJ9IG1lc3NhZ2UgLSBFbmNyeXB0ZWQgb3IgcGxhaW4gdGV4dCBtZXNzYWdlIChzZWUgY2hlY2tzdW0pXG4gICAgQGFyZyB7bnVtYmVyfSBjaGVja3N1bSAtIHNoYXJlZCBzZWNyZXQgY2hlY2tzdW0gKG51bGwgdG8gZW5jcnlwdCwgbm9uLW51bGwgdG8gZGVjcnlwdClcbiovXG5cblxuZnVuY3Rpb24gY3J5cHQocHJpdmF0ZV9rZXlfb3Jfc2hhcmVkX3NlY3JldCwgcHVibGljX2tleSwgbm9uY2UsIG1lc3NhZ2UsIGNoZWNrc3VtKSB7XG4gIHZhciBzaGFyZWRfc2VjcmV0O1xuXG4gIGlmICghcHJpdmF0ZV9rZXlfb3Jfc2hhcmVkX3NlY3JldC5kICYmIHR5cGVvZiBwcml2YXRlX2tleV9vcl9zaGFyZWRfc2VjcmV0ICE9PSAnc3RyaW5nJykge1xuICAgIHNoYXJlZF9zZWNyZXQgPSBwcml2YXRlX2tleV9vcl9zaGFyZWRfc2VjcmV0O1xuICB9IGVsc2Uge1xuICAgIHZhciBwcml2YXRlX2tleSA9IHRvUHJpdmF0ZU9iaihwcml2YXRlX2tleV9vcl9zaGFyZWRfc2VjcmV0KTtcbiAgICBpZiAoIXByaXZhdGVfa2V5KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcml2YXRlX2tleSBpcyByZXF1aXJlZCcpO1xuICAgIHB1YmxpY19rZXkgPSB0b1B1YmxpY09iaihwdWJsaWNfa2V5KTtcbiAgICBpZiAoIXB1YmxpY19rZXkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3B1YmxpY19rZXkgaXMgcmVxdWlyZWQnKTtcbiAgICBzaGFyZWRfc2VjcmV0ID0gcHJpdmF0ZV9rZXkuZ2V0X3NoYXJlZF9zZWNyZXQocHVibGljX2tleSk7XG4gIH1cblxuICBub25jZSA9IHRvTG9uZ09iaihub25jZSk7XG4gIGlmICghbm9uY2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vbmNlIGlzIHJlcXVpcmVkJyk7XG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIobWVzc2FnZSkpIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdtZXNzYWdlIHNob3VsZCBiZSBidWZmZXIgb3Igc3RyaW5nJyk7XG4gICAgbWVzc2FnZSA9IG5ldyBCdWZmZXIobWVzc2FnZSwgJ2JpbmFyeScpO1xuICB9XG5cbiAgaWYgKGNoZWNrc3VtICYmIHR5cGVvZiBjaGVja3N1bSAhPT0gJ251bWJlcicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NoZWNrc3VtIHNob3VsZCBiZSBhIG51bWJlcicpO1xuICB2YXIgZWJ1ZiA9IG5ldyBfYnl0ZWJ1ZmZlci5kZWZhdWx0KF9ieXRlYnVmZmVyLmRlZmF1bHQuREVGQVVMVF9DQVBBQ0lUWSwgX2J5dGVidWZmZXIuZGVmYXVsdC5MSVRUTEVfRU5ESUFOKTtcbiAgZWJ1Zi53cml0ZVVpbnQ2NChub25jZSk7XG4gIGVidWYuYXBwZW5kKHNoYXJlZF9zZWNyZXQudG9TdHJpbmcoJ2JpbmFyeScpLCAnYmluYXJ5Jyk7XG4gIGVidWYgPSBuZXcgQnVmZmVyKGVidWYuY29weSgwLCBlYnVmLm9mZnNldCkudG9CaW5hcnkoKSwgJ2JpbmFyeScpO1xuXG4gIHZhciBlbmNyeXB0aW9uX2tleSA9IF9oYXNoLmRlZmF1bHQuc2hhNTEyKGVidWYpOyAvLyBEIEUgQiBVIEdcbiAgLy8gY29uc29sZS5sb2coJ2NyeXB0Jywge1xuICAvLyAgICAgcHJpdl90b19wdWI6IHByaXZhdGVfa2V5LnRvUHVibGljS2V5KCkudG9TdHJpbmcoKSxcbiAgLy8gICAgIHB1YjogcHVibGljX2tleS50b1N0cmluZygpLFxuICAvLyAgICAgbm9uY2U6IG5vbmNlLnRvU3RyaW5nKCksXG4gIC8vICAgICBtZXNzYWdlOiBtZXNzYWdlLmxlbmd0aCxcbiAgLy8gICAgIGNoZWNrc3VtLFxuICAvLyAgICAgc2hhcmVkX3NlY3JldDogc2hhcmVkX3NlY3JldC50b1N0cmluZygnaGV4JyksXG4gIC8vICAgICBlbmNyeXB0aW9uX2tleTogZW5jcnlwdGlvbl9rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAvLyB9KVxuXG5cbiAgdmFyIGl2ID0gZW5jcnlwdGlvbl9rZXkuc2xpY2UoMzIsIDQ4KTtcbiAgdmFyIGtleSA9IGVuY3J5cHRpb25fa2V5LnNsaWNlKDAsIDMyKTsgLy8gY2hlY2sgaXMgZmlyc3QgNjQgYml0IG9mIHNoYTI1NiBoYXNoIHRyZWF0ZWQgYXMgdWludDY0X3QgdHJ1bmNhdGVkIHRvIDMyIGJpdHMuXG5cbiAgdmFyIGNoZWNrID0gX2hhc2guZGVmYXVsdC5zaGEyNTYoZW5jcnlwdGlvbl9rZXkpO1xuXG4gIGNoZWNrID0gY2hlY2suc2xpY2UoMCwgNCk7XG5cbiAgdmFyIGNidWYgPSBfYnl0ZWJ1ZmZlci5kZWZhdWx0LmZyb21CaW5hcnkoY2hlY2sudG9TdHJpbmcoJ2JpbmFyeScpLCBfYnl0ZWJ1ZmZlci5kZWZhdWx0LkRFRkFVTFRfQ0FQQUNJVFksIF9ieXRlYnVmZmVyLmRlZmF1bHQuTElUVExFX0VORElBTik7XG5cbiAgY2hlY2sgPSBjYnVmLnJlYWRVaW50MzIoKTtcblxuICBpZiAoY2hlY2tzdW0pIHtcbiAgICAoMCwgX2NvcmUuYXNzZXJ0TmF0aXZlTGliKSgnQWVzLmRlY3J5cHQoKScpO1xuICAgIGlmIChjaGVjayAhPT0gY2hlY2tzdW0pIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXknKTtcbiAgICBtZXNzYWdlID0gQnVmZmVyLmZyb20oKDAsIF9jb3JlLmFlc19kZWNyeXB0KShrZXksIGl2LCBtZXNzYWdlKSk7XG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZSA9IGNyeXB0b0pzRW5jcnlwdChtZXNzYWdlLCBrZXksIGl2KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbm9uY2U6IG5vbmNlLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgY2hlY2tzdW06IGNoZWNrXG4gIH07XG59XG4vKiogVGhpcyBtZXRob2QgZG9lcyBub3QgdXNlIGEgY2hlY2tzdW0sIHRoZSByZXR1cm5lZCBkYXRhIG11c3QgYmUgdmFsaWRhdGVkIHNvbWUgb3RoZXIgd2F5LlxuICAgIEBhcmcge3N0cmluZ3xCdWZmZXJ9IHBsYWludGV4dCAtIGJpbmFyeSBmb3JtYXRcbiAgICBAcmV0dXJuIHtCdWZmZXJ9IGJpbmFyeVxuKi9cblxuXG5mdW5jdGlvbiBjcnlwdG9Kc0VuY3J5cHQobWVzc2FnZSwga2V5LCBpdikge1xuICAoMCwgX2Fzc2VydC5kZWZhdWx0KShtZXNzYWdlLCBcIk1pc3NpbmcgcGxhaW4gdGV4dFwiKTtcbiAgbWVzc2FnZSA9IHRvQmluYXJ5QnVmZmVyKG1lc3NhZ2UpO1xuXG4gIHZhciBjaXBoZXIgPSBfYnJvd3NlcmlmeUFlcy5kZWZhdWx0LmNyZWF0ZUNpcGhlcml2KCdhZXMtMjU2LWNiYycsIGtleSwgaXYpOyAvLyBjaXBoZXIuc2V0QXV0b1BhZGRpbmcodHJ1ZSlcblxuXG4gIG1lc3NhZ2UgPSBCdWZmZXIuY29uY2F0KFtjaXBoZXIudXBkYXRlKG1lc3NhZ2UpLCBjaXBoZXIuZmluYWwoKV0pO1xuICByZXR1cm4gbWVzc2FnZTtcbn1cbi8qKiBAcmV0dXJuIHtzdHJpbmd9IHVuaXF1ZSA2NCBiaXQgdW5zaWduZWQgbnVtYmVyIHN0cmluZy4gIEJlaW5nIHRpbWUgYmFzZWQsIHRoaXMgaXMgY2FyZWZ1bCB0byBuZXZlciBjaG9vc2UgdGhlIHNhbWUgbm9uY2UgdHdpY2UuICBUaGlzIHZhbHVlIGNvdWxkIGJlIHJlY29yZGVkIGluIHRoZSBibG9ja2NoYWluIGZvciBhIGxvbmcgdGltZS5cbiovXG5cblxuZnVuY3Rpb24gdW5pcXVlTm9uY2UoKSB7XG4gIGlmICh1bmlxdWVfbm9uY2VfZW50cm9weSA9PT0gbnVsbCkge1xuICAgIHZhciBiID0gX3NlY3VyZVJhbmRvbS5kZWZhdWx0LnJhbmRvbVVpbnQ4QXJyYXkoMik7XG5cbiAgICB1bmlxdWVfbm9uY2VfZW50cm9weSA9IHBhcnNlSW50KGJbMF0gPDwgOCB8IGJbMV0sIDEwKTtcbiAgfVxuXG4gIHZhciBsb25nID0gTG9uZy5mcm9tTnVtYmVyKERhdGUubm93KCkpO1xuICB2YXIgZW50cm9weSA9ICsrdW5pcXVlX25vbmNlX2VudHJvcHkgJSAweEZGRkY7IC8vIGNvbnNvbGUubG9nKCd1bmlxdWVOb25jZSBkYXRlXFx0JywgQnl0ZUJ1ZmZlci5hbGxvY2F0ZSg4KS53cml0ZVVpbnQ2NChsb25nKS50b0hleCgwKSlcbiAgLy8gY29uc29sZS5sb2coJ3VuaXF1ZU5vbmNlIGVudHJvcHlcXHQnLCBCeXRlQnVmZmVyLmFsbG9jYXRlKDgpLndyaXRlVWludDY0KExvbmcuZnJvbU51bWJlcihlbnRyb3B5KSkudG9IZXgoMCkpXG5cbiAgbG9uZyA9IGxvbmcuc2hpZnRMZWZ0KDE2KS5vcihMb25nLmZyb21OdW1iZXIoZW50cm9weSkpOyAvLyBjb25zb2xlLmxvZygndW5pcXVlTm9uY2UgZmluYWxcXHQnLCBCeXRlQnVmZmVyLmFsbG9jYXRlKDgpLndyaXRlVWludDY0KGxvbmcpLnRvSGV4KDApKVxuXG4gIHJldHVybiBsb25nLnRvU3RyaW5nKCk7XG59XG5cbnZhciB1bmlxdWVfbm9uY2VfZW50cm9weSA9IG51bGw7IC8vIGZvcihsZXQgaT0xOyBpIDwgMTA7IGkrKykga2V5LnVuaXF1ZU5vbmNlKClcblxudmFyIHRvUHJpdmF0ZU9iaiA9IGZ1bmN0aW9uIHRvUHJpdmF0ZU9iaihvKSB7XG4gIHJldHVybiBvID8gby5kID8gbyA6IF9rZXlfcHJpdmF0ZS5kZWZhdWx0LmZyb21XaWYobykgOiBvXG4gIC8qbnVsbCBvciB1bmRlZmluZWQqL1xuICA7XG59O1xuXG52YXIgdG9QdWJsaWNPYmogPSBmdW5jdGlvbiB0b1B1YmxpY09iaihvKSB7XG4gIHJldHVybiBvID8gby5RID8gbyA6IF9rZXlfcHVibGljLmRlZmF1bHQuZnJvbVN0cmluZyhvKSA6IG9cbiAgLypudWxsIG9yIHVuZGVmaW5lZCovXG4gIDtcbn07XG5cbnZhciB0b0xvbmdPYmogPSBmdW5jdGlvbiB0b0xvbmdPYmoobykge1xuICByZXR1cm4gbyA/IExvbmcuaXNMb25nKG8pID8gbyA6IExvbmcuZnJvbVN0cmluZyhvKSA6IG87XG59O1xuXG52YXIgdG9CaW5hcnlCdWZmZXIgPSBmdW5jdGlvbiB0b0JpbmFyeUJ1ZmZlcihvKSB7XG4gIHJldHVybiBvID8gQnVmZmVyLmlzQnVmZmVyKG8pID8gbyA6IG5ldyBCdWZmZXIobywgJ2JpbmFyeScpIDogbztcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcudHJpbS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdC5qc1wiKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplKGJyYWluX2tleSkge1xuICBpZiAodHlwZW9mIGJyYWluX2tleSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmcgcmVxdWlyZWQgZm9yIGJyYWluX2tleVwiKTtcbiAgfVxuXG4gIGJyYWluX2tleSA9IGJyYWluX2tleS50cmltKCk7XG4gIHJldHVybiBicmFpbl9rZXkuc3BsaXQoL1tcXHRcXG5cXHZcXGZcXHIgXSsvKS5qb2luKCcgJyk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbGwuanNcIik7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTsgLy8gZnJvbSBnaXRodWIuY29tL2JpdGNvaW5qcy9iaXRjb2luanMtbGliIGZyb20gZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvZWNkc2FcblxuXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnLi9oYXNoJyk7XG5cbnZhciBlbmZvcmNlVHlwZSA9IHJlcXVpcmUoJy4vZW5mb3JjZV90eXBlcycpO1xuXG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKTtcblxudmFyIEVDU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9lY3NpZ25hdHVyZScpOyAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjk3OSNzZWN0aW9uLTMuMlxuXG5cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNHZW5lcmF0ZUsoY3VydmUsIGhhc2gsIGQsIGNoZWNrU2lnLCBub25jZSkge1xuICBlbmZvcmNlVHlwZSgnQnVmZmVyJywgaGFzaCk7XG4gIGVuZm9yY2VUeXBlKEJpZ0ludGVnZXIsIGQpO1xuXG4gIGlmIChub25jZSkge1xuICAgIGhhc2ggPSBjcnlwdG8uc2hhMjU2KEJ1ZmZlci5jb25jYXQoW2hhc2gsIG5ldyBCdWZmZXIobm9uY2UpXSkpO1xuICB9IC8vIHNhbml0eSBjaGVja1xuXG5cbiAgYXNzZXJ0LmVxdWFsKGhhc2gubGVuZ3RoLCAzMiwgJ0hhc2ggbXVzdCBiZSAyNTYgYml0Jyk7XG4gIHZhciB4ID0gZC50b0J1ZmZlcigzMik7XG4gIHZhciBrID0gbmV3IEJ1ZmZlcigzMik7XG4gIHZhciB2ID0gbmV3IEJ1ZmZlcigzMik7IC8vIFN0ZXAgQlxuXG4gIHYuZmlsbCgxKTsgLy8gU3RlcCBDXG5cbiAgay5maWxsKDApOyAvLyBTdGVwIERcblxuICBrID0gY3J5cHRvLkhtYWNTSEEyNTYoQnVmZmVyLmNvbmNhdChbdiwgbmV3IEJ1ZmZlcihbMF0pLCB4LCBoYXNoXSksIGspOyAvLyBTdGVwIEVcblxuICB2ID0gY3J5cHRvLkhtYWNTSEEyNTYodiwgayk7IC8vIFN0ZXAgRlxuXG4gIGsgPSBjcnlwdG8uSG1hY1NIQTI1NihCdWZmZXIuY29uY2F0KFt2LCBuZXcgQnVmZmVyKFsxXSksIHgsIGhhc2hdKSwgayk7IC8vIFN0ZXAgR1xuXG4gIHYgPSBjcnlwdG8uSG1hY1NIQTI1Nih2LCBrKTsgLy8gU3RlcCBIMS9IMmEsIGlnbm9yZWQgYXMgdGxlbiA9PT0gcWxlbiAoMjU2IGJpdClcbiAgLy8gU3RlcCBIMmJcblxuICB2ID0gY3J5cHRvLkhtYWNTSEEyNTYodiwgayk7XG4gIHZhciBUID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKHYpOyAvLyBTdGVwIEgzLCByZXBlYXQgdW50aWwgVCBpcyB3aXRoaW4gdGhlIGludGVydmFsIFsxLCBuIC0gMV1cblxuICB3aGlsZSAoVC5zaWdudW0oKSA8PSAwIHx8IFQuY29tcGFyZVRvKGN1cnZlLm4pID49IDAgfHwgIWNoZWNrU2lnKFQpKSB7XG4gICAgayA9IGNyeXB0by5IbWFjU0hBMjU2KEJ1ZmZlci5jb25jYXQoW3YsIG5ldyBCdWZmZXIoWzBdKV0pLCBrKTtcbiAgICB2ID0gY3J5cHRvLkhtYWNTSEEyNTYodiwgayk7IC8vIFN0ZXAgSDEvSDJhLCBhZ2FpbiwgaWdub3JlZCBhcyB0bGVuID09PSBxbGVuICgyNTYgYml0KVxuICAgIC8vIFN0ZXAgSDJiIGFnYWluXG5cbiAgICB2ID0gY3J5cHRvLkhtYWNTSEEyNTYodiwgayk7XG4gICAgVCA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcih2KTtcbiAgfVxuXG4gIHJldHVybiBUO1xufVxuXG5mdW5jdGlvbiBzaWduKGN1cnZlLCBoYXNoLCBkLCBub25jZSkge1xuICB2YXIgZSA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihoYXNoKTtcbiAgdmFyIG4gPSBjdXJ2ZS5uO1xuICB2YXIgRyA9IGN1cnZlLkc7XG4gIHZhciByLCBzO1xuICB2YXIgayA9IGRldGVybWluaXN0aWNHZW5lcmF0ZUsoY3VydmUsIGhhc2gsIGQsIGZ1bmN0aW9uIChrKSB7XG4gICAgLy8gZmluZCBjYW5vbmljYWxseSB2YWxpZCBzaWduYXR1cmVcbiAgICB2YXIgUSA9IEcubXVsdGlwbHkoayk7XG4gICAgaWYgKGN1cnZlLmlzSW5maW5pdHkoUSkpIHJldHVybiBmYWxzZTtcbiAgICByID0gUS5hZmZpbmVYLm1vZChuKTtcbiAgICBpZiAoci5zaWdudW0oKSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIHMgPSBrLm1vZEludmVyc2UobikubXVsdGlwbHkoZS5hZGQoZC5tdWx0aXBseShyKSkpLm1vZChuKTtcbiAgICBpZiAocy5zaWdudW0oKSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBub25jZSk7XG4gIHZhciBOX09WRVJfVFdPID0gbi5zaGlmdFJpZ2h0KDEpOyAvLyBlbmZvcmNlIGxvdyBTIHZhbHVlcywgc2VlIGJpcDYyOiAnbG93IHMgdmFsdWVzIGluIHNpZ25hdHVyZXMnXG5cbiAgaWYgKHMuY29tcGFyZVRvKE5fT1ZFUl9UV08pID4gMCkge1xuICAgIHMgPSBuLnN1YnRyYWN0KHMpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBFQ1NpZ25hdHVyZShyLCBzKTtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5UmF3KGN1cnZlLCBlLCBzaWduYXR1cmUsIFEpIHtcbiAgdmFyIG4gPSBjdXJ2ZS5uO1xuICB2YXIgRyA9IGN1cnZlLkc7XG4gIHZhciByID0gc2lnbmF0dXJlLnI7XG4gIHZhciBzID0gc2lnbmF0dXJlLnM7IC8vIDEuNC4xIEVuZm9yY2UgciBhbmQgcyBhcmUgYm90aCBpbnRlZ2VycyBpbiB0aGUgaW50ZXJ2YWwgWzEsIG4g4oiSIDFdXG5cbiAgaWYgKHIuc2lnbnVtKCkgPD0gMCB8fCByLmNvbXBhcmVUbyhuKSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmIChzLnNpZ251bSgpIDw9IDAgfHwgcy5jb21wYXJlVG8obikgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyBjID0gc14tMSBtb2QgblxuXG4gIHZhciBjID0gcy5tb2RJbnZlcnNlKG4pOyAvLyAxLjQuNCBDb21wdXRlIHUxID0gZXNe4oiSMSBtb2QgblxuICAvLyAgICAgICAgICAgICAgIHUyID0gcnNe4oiSMSBtb2QgblxuXG4gIHZhciB1MSA9IGUubXVsdGlwbHkoYykubW9kKG4pO1xuICB2YXIgdTIgPSByLm11bHRpcGx5KGMpLm1vZChuKTsgLy8gMS40LjUgQ29tcHV0ZSBSID0gKHhSLCB5UikgPSB1MUcgKyB1MlFcblxuICB2YXIgUiA9IEcubXVsdGlwbHlUd28odTEsIFEsIHUyKTsgLy8gMS40LjUgKGNvbnQuKSBFbmZvcmNlIFIgaXMgbm90IGF0IGluZmluaXR5XG5cbiAgaWYgKGN1cnZlLmlzSW5maW5pdHkoUikpIHJldHVybiBmYWxzZTsgLy8gMS40LjYgQ29udmVydCB0aGUgZmllbGQgZWxlbWVudCBSLnggdG8gYW4gaW50ZWdlclxuXG4gIHZhciB4UiA9IFIuYWZmaW5lWDsgLy8gMS40LjcgU2V0IHYgPSB4UiBtb2QgblxuXG4gIHZhciB2ID0geFIubW9kKG4pOyAvLyAxLjQuOCBJZiB2ID0gciwgb3V0cHV0IFwidmFsaWRcIiwgYW5kIGlmIHYgIT0gciwgb3V0cHV0IFwiaW52YWxpZFwiXG5cbiAgcmV0dXJuIHYuZXF1YWxzKHIpO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnkoY3VydmUsIGhhc2gsIHNpZ25hdHVyZSwgUSkge1xuICAvLyAxLjQuMiBIID0gSGFzaChNKSwgYWxyZWFkeSBkb25lIGJ5IHRoZSB1c2VyXG4gIC8vIDEuNC4zIGUgPSBIXG4gIHZhciBlID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGhhc2gpO1xuICByZXR1cm4gdmVyaWZ5UmF3KGN1cnZlLCBlLCBzaWduYXR1cmUsIFEpO1xufVxuLyoqXG4gICogUmVjb3ZlciBhIHB1YmxpYyBrZXkgZnJvbSBhIHNpZ25hdHVyZS5cbiAgKlxuICAqIFNlZSBTRUMgMTogRWxsaXB0aWMgQ3VydmUgQ3J5cHRvZ3JhcGh5LCBzZWN0aW9uIDQuMS42LCBcIlB1YmxpY1xuICAqIEtleSBSZWNvdmVyeSBPcGVyYXRpb25cIi5cbiAgKlxuICAqIGh0dHA6Ly93d3cuc2VjZy5vcmcvZG93bmxvYWQvYWlkLTc4MC9zZWMxLXYyLnBkZlxuICAqL1xuXG5cbmZ1bmN0aW9uIHJlY292ZXJQdWJLZXkoY3VydmUsIGUsIHNpZ25hdHVyZSwgaSkge1xuICBhc3NlcnQuc3RyaWN0RXF1YWwoaSAmIDMsIGksICdSZWNvdmVyeSBwYXJhbSBpcyBtb3JlIHRoYW4gdHdvIGJpdHMnKTtcbiAgdmFyIG4gPSBjdXJ2ZS5uO1xuICB2YXIgRyA9IGN1cnZlLkc7XG4gIHZhciByID0gc2lnbmF0dXJlLnI7XG4gIHZhciBzID0gc2lnbmF0dXJlLnM7XG4gIGFzc2VydChyLnNpZ251bSgpID4gMCAmJiByLmNvbXBhcmVUbyhuKSA8IDAsICdJbnZhbGlkIHIgdmFsdWUnKTtcbiAgYXNzZXJ0KHMuc2lnbnVtKCkgPiAwICYmIHMuY29tcGFyZVRvKG4pIDwgMCwgJ0ludmFsaWQgcyB2YWx1ZScpOyAvLyBBIHNldCBMU0Igc2lnbmlmaWVzIHRoYXQgdGhlIHktY29vcmRpbmF0ZSBpcyBvZGRcblxuICB2YXIgaXNZT2RkID0gaSAmIDE7IC8vIFRoZSBtb3JlIHNpZ25pZmljYW50IGJpdCBzcGVjaWZpZXMgd2hldGhlciB3ZSBzaG91bGQgdXNlIHRoZVxuICAvLyBmaXJzdCBvciBzZWNvbmQgY2FuZGlkYXRlIGtleS5cblxuICB2YXIgaXNTZWNvbmRLZXkgPSBpID4+IDE7IC8vIDEuMSBMZXQgeCA9IHIgKyBqblxuXG4gIHZhciB4ID0gaXNTZWNvbmRLZXkgPyByLmFkZChuKSA6IHI7XG4gIHZhciBSID0gY3VydmUucG9pbnRGcm9tWChpc1lPZGQsIHgpOyAvLyAxLjQgQ2hlY2sgdGhhdCBuUiBpcyBhdCBpbmZpbml0eVxuXG4gIHZhciBuUiA9IFIubXVsdGlwbHkobik7XG4gIGFzc2VydChjdXJ2ZS5pc0luZmluaXR5KG5SKSwgJ25SIGlzIG5vdCBhIHZhbGlkIGN1cnZlIHBvaW50Jyk7IC8vIENvbXB1dGUgLWUgZnJvbSBlXG5cbiAgdmFyIGVOZWcgPSBlLm5lZ2F0ZSgpLm1vZChuKTsgLy8gMS42LjEgQ29tcHV0ZSBRID0gcl4tMSAoc1IgLSAgZUcpXG4gIC8vICAgICAgICAgICAgICAgUSA9IHJeLTEgKHNSICsgLWVHKVxuXG4gIHZhciBySW52ID0gci5tb2RJbnZlcnNlKG4pO1xuICB2YXIgUSA9IFIubXVsdGlwbHlUd28ocywgRywgZU5lZykubXVsdGlwbHkockludik7XG4gIGN1cnZlLnZhbGlkYXRlKFEpO1xuICByZXR1cm4gUTtcbn1cbi8qKlxuICAqIENhbGN1bGF0ZSBwdWJrZXkgZXh0cmFjdGlvbiBwYXJhbWV0ZXIuXG4gICpcbiAgKiBXaGVuIGV4dHJhY3RpbmcgYSBwdWJrZXkgZnJvbSBhIHNpZ25hdHVyZSwgd2UgaGF2ZSB0b1xuICAqIGRpc3Rpbmd1aXNoIGZvdXIgZGlmZmVyZW50IGNhc2VzLiBSYXRoZXIgdGhhbiBwdXR0aW5nIHRoaXNcbiAgKiBidXJkZW4gb24gdGhlIHZlcmlmaWVyLCBCaXRjb2luIGluY2x1ZGVzIGEgMi1iaXQgdmFsdWUgd2l0aCB0aGVcbiAgKiBzaWduYXR1cmUuXG4gICpcbiAgKiBUaGlzIGZ1bmN0aW9uIHNpbXBseSB0cmllcyBhbGwgZm91ciBjYXNlcyBhbmQgcmV0dXJucyB0aGUgdmFsdWVcbiAgKiB0aGF0IHJlc3VsdGVkIGluIGEgc3VjY2Vzc2Z1bCBwdWJrZXkgcmVjb3ZlcnkuXG4gICovXG5cblxuZnVuY3Rpb24gY2FsY1B1YktleVJlY292ZXJ5UGFyYW0oY3VydmUsIGUsIHNpZ25hdHVyZSwgUSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBRcHJpbWUgPSByZWNvdmVyUHViS2V5KGN1cnZlLCBlLCBzaWduYXR1cmUsIGkpOyAvLyAxLjYuMiBWZXJpZnkgUVxuXG4gICAgaWYgKFFwcmltZS5lcXVhbHMoUSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgdmFsaWQgcmVjb3ZlcnkgZmFjdG9yJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjYWxjUHViS2V5UmVjb3ZlcnlQYXJhbTogY2FsY1B1YktleVJlY292ZXJ5UGFyYW0sXG4gIGRldGVybWluaXN0aWNHZW5lcmF0ZUs6IGRldGVybWluaXN0aWNHZW5lcmF0ZUssXG4gIHJlY292ZXJQdWJLZXk6IHJlY292ZXJQdWJLZXksXG4gIHNpZ246IHNpZ24sXG4gIHZlcmlmeTogdmVyaWZ5LFxuICB2ZXJpZnlSYXc6IHZlcmlmeVJhd1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanNcIik7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTsgLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbmpzL2JpdGNvaW5qcy1saWJcblxuXG52YXIgZW5mb3JjZVR5cGUgPSByZXF1aXJlKCcuL2VuZm9yY2VfdHlwZXMnKTtcblxudmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKCdiaWdpJyk7XG5cbmZ1bmN0aW9uIEVDU2lnbmF0dXJlKHIsIHMpIHtcbiAgZW5mb3JjZVR5cGUoQmlnSW50ZWdlciwgcik7XG4gIGVuZm9yY2VUeXBlKEJpZ0ludGVnZXIsIHMpO1xuICB0aGlzLnIgPSByO1xuICB0aGlzLnMgPSBzO1xufSAvLyBJbXBvcnQgb3BlcmF0aW9uc1xuXG5cbkVDU2lnbmF0dXJlLnBhcnNlQ29tcGFjdCA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgYXNzZXJ0LmVxdWFsKGJ1ZmZlci5sZW5ndGgsIDY1LCAnSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gIHZhciBpID0gYnVmZmVyLnJlYWRVSW50OCgwKSAtIDI3OyAvLyBBdCBtb3N0IDMgYml0c1xuXG4gIGFzc2VydC5lcXVhbChpLCBpICYgNywgJ0ludmFsaWQgc2lnbmF0dXJlIHBhcmFtZXRlcicpO1xuICB2YXIgY29tcHJlc3NlZCA9ICEhKGkgJiA0KTsgLy8gUmVjb3ZlcnkgcGFyYW0gb25seVxuXG4gIGkgPSBpICYgMztcbiAgdmFyIHIgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoYnVmZmVyLnNsaWNlKDEsIDMzKSk7XG4gIHZhciBzID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGJ1ZmZlci5zbGljZSgzMykpO1xuICByZXR1cm4ge1xuICAgIGNvbXByZXNzZWQ6IGNvbXByZXNzZWQsXG4gICAgaTogaSxcbiAgICBzaWduYXR1cmU6IG5ldyBFQ1NpZ25hdHVyZShyLCBzKVxuICB9O1xufTtcblxuRUNTaWduYXR1cmUuZnJvbURFUiA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgYXNzZXJ0LmVxdWFsKGJ1ZmZlci5yZWFkVUludDgoMCksIDB4MzAsICdOb3QgYSBERVIgc2VxdWVuY2UnKTtcbiAgYXNzZXJ0LmVxdWFsKGJ1ZmZlci5yZWFkVUludDgoMSksIGJ1ZmZlci5sZW5ndGggLSAyLCAnSW52YWxpZCBzZXF1ZW5jZSBsZW5ndGgnKTtcbiAgYXNzZXJ0LmVxdWFsKGJ1ZmZlci5yZWFkVUludDgoMiksIDB4MDIsICdFeHBlY3RlZCBhIERFUiBpbnRlZ2VyJyk7XG4gIHZhciByTGVuID0gYnVmZmVyLnJlYWRVSW50OCgzKTtcbiAgYXNzZXJ0KHJMZW4gPiAwLCAnUiBsZW5ndGggaXMgemVybycpO1xuICB2YXIgb2Zmc2V0ID0gNCArIHJMZW47XG4gIGFzc2VydC5lcXVhbChidWZmZXIucmVhZFVJbnQ4KG9mZnNldCksIDB4MDIsICdFeHBlY3RlZCBhIERFUiBpbnRlZ2VyICgyKScpO1xuICB2YXIgc0xlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0ICsgMSk7XG4gIGFzc2VydChzTGVuID4gMCwgJ1MgbGVuZ3RoIGlzIHplcm8nKTtcbiAgdmFyIHJCID0gYnVmZmVyLnNsaWNlKDQsIG9mZnNldCk7XG4gIHZhciBzQiA9IGJ1ZmZlci5zbGljZShvZmZzZXQgKyAyKTtcbiAgb2Zmc2V0ICs9IDIgKyBzTGVuO1xuXG4gIGlmIChyTGVuID4gMSAmJiByQi5yZWFkVUludDgoMCkgPT09IDB4MDApIHtcbiAgICBhc3NlcnQockIucmVhZFVJbnQ4KDEpICYgMHg4MCwgJ1IgdmFsdWUgZXhjZXNzaXZlbHkgcGFkZGVkJyk7XG4gIH1cblxuICBpZiAoc0xlbiA+IDEgJiYgc0IucmVhZFVJbnQ4KDApID09PSAweDAwKSB7XG4gICAgYXNzZXJ0KHNCLnJlYWRVSW50OCgxKSAmIDB4ODAsICdTIHZhbHVlIGV4Y2Vzc2l2ZWx5IHBhZGRlZCcpO1xuICB9XG5cbiAgYXNzZXJ0LmVxdWFsKG9mZnNldCwgYnVmZmVyLmxlbmd0aCwgJ0ludmFsaWQgREVSIGVuY29kaW5nJyk7XG4gIHZhciByID0gQmlnSW50ZWdlci5mcm9tREVSSW50ZWdlcihyQik7XG4gIHZhciBzID0gQmlnSW50ZWdlci5mcm9tREVSSW50ZWdlcihzQik7XG4gIGFzc2VydChyLnNpZ251bSgpID49IDAsICdSIHZhbHVlIGlzIG5lZ2F0aXZlJyk7XG4gIGFzc2VydChzLnNpZ251bSgpID49IDAsICdTIHZhbHVlIGlzIG5lZ2F0aXZlJyk7XG4gIHJldHVybiBuZXcgRUNTaWduYXR1cmUociwgcyk7XG59OyAvLyBGSVhNRTogMHgwMCwgMHgwNCwgMHg4MCBhcmUgU0lHSEFTSF8qIGJvdW5kYXJ5IGNvbnN0YW50cywgaW1wb3J0aW5nIFRyYW5zYWN0aW9uIGNhdXNlcyBhIGNpcmN1bGFyIGRlcGVuZGVuY3lcblxuXG5FQ1NpZ25hdHVyZS5wYXJzZVNjcmlwdFNpZ25hdHVyZSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgdmFyIGhhc2hUeXBlID0gYnVmZmVyLnJlYWRVSW50OChidWZmZXIubGVuZ3RoIC0gMSk7XG4gIHZhciBoYXNoVHlwZU1vZCA9IGhhc2hUeXBlICYgfjB4ODA7XG4gIGFzc2VydChoYXNoVHlwZU1vZCA+IDB4MDAgJiYgaGFzaFR5cGVNb2QgPCAweDA0LCAnSW52YWxpZCBoYXNoVHlwZScpO1xuICByZXR1cm4ge1xuICAgIHNpZ25hdHVyZTogRUNTaWduYXR1cmUuZnJvbURFUihidWZmZXIuc2xpY2UoMCwgLTEpKSxcbiAgICBoYXNoVHlwZTogaGFzaFR5cGVcbiAgfTtcbn07IC8vIEV4cG9ydCBvcGVyYXRpb25zXG5cblxuRUNTaWduYXR1cmUucHJvdG90eXBlLnRvQ29tcGFjdCA9IGZ1bmN0aW9uIChpLCBjb21wcmVzc2VkKSB7XG4gIGlmIChjb21wcmVzc2VkKSBpICs9IDQ7XG4gIGkgKz0gMjc7XG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKDY1KTtcbiAgYnVmZmVyLndyaXRlVUludDgoaSwgMCk7XG4gIHRoaXMuci50b0J1ZmZlcigzMikuY29weShidWZmZXIsIDEpO1xuICB0aGlzLnMudG9CdWZmZXIoMzIpLmNvcHkoYnVmZmVyLCAzMyk7XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG5FQ1NpZ25hdHVyZS5wcm90b3R5cGUudG9ERVIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByQmEgPSB0aGlzLnIudG9ERVJJbnRlZ2VyKCk7XG4gIHZhciBzQmEgPSB0aGlzLnMudG9ERVJJbnRlZ2VyKCk7XG4gIHZhciBzZXF1ZW5jZSA9IFtdOyAvLyBJTlRFR0VSXG5cbiAgc2VxdWVuY2UucHVzaCgweDAyLCByQmEubGVuZ3RoKTtcbiAgc2VxdWVuY2UgPSBzZXF1ZW5jZS5jb25jYXQockJhKTsgLy8gSU5URUdFUlxuXG4gIHNlcXVlbmNlLnB1c2goMHgwMiwgc0JhLmxlbmd0aCk7XG4gIHNlcXVlbmNlID0gc2VxdWVuY2UuY29uY2F0KHNCYSk7IC8vIFNFUVVFTkNFXG5cbiAgc2VxdWVuY2UudW5zaGlmdCgweDMwLCBzZXF1ZW5jZS5sZW5ndGgpO1xuICByZXR1cm4gbmV3IEJ1ZmZlcihzZXF1ZW5jZSk7XG59O1xuXG5FQ1NpZ25hdHVyZS5wcm90b3R5cGUudG9TY3JpcHRTaWduYXR1cmUgPSBmdW5jdGlvbiAoaGFzaFR5cGUpIHtcbiAgdmFyIGhhc2hUeXBlQnVmZmVyID0gbmV3IEJ1ZmZlcigxKTtcbiAgaGFzaFR5cGVCdWZmZXIud3JpdGVVSW50OChoYXNoVHlwZSwgMCk7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFt0aGlzLnRvREVSKCksIGhhc2hUeXBlQnVmZmVyXSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVDU2lnbmF0dXJlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5mb3JjZSh0eXBlLCB2YWx1ZSkge1xuICAvLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbmpzL2JpdGNvaW5qcy1saWJcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnQXJyYXknOlxuICAgICAge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSByZXR1cm47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnQnVmZmVyJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdOdW1iZXInOlxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgcmV0dXJuO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSByZXR1cm47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKGdldE5hbWUodmFsdWUuY29uc3RydWN0b3IpID09PSBnZXROYW1lKHR5cGUpKSByZXR1cm47XG4gICAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCAnICsgKGdldE5hbWUodHlwZSkgfHwgdHlwZSkgKyAnLCBnb3QgJyArIHZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIGdldE5hbWUoZm4pIHtcbiAgLy8gV2h5IG5vdCBmbi5uYW1lOiBodHRwczovL2thbmdheC5naXRodWIuaW8vY29tcGF0LXRhYmxlL2VzNi8jZnVuY3Rpb25fbmFtZV9wcm9wZXJ0eVxuICB2YXIgbWF0Y2ggPSBmbi50b1N0cmluZygpLm1hdGNoKC9mdW5jdGlvbiAoLio/KVxcKC8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IG51bGw7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfY3JlYXRlSGFzaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNyZWF0ZS1oYXNoXCIpKTtcblxudmFyIF9jcmVhdGVIbWFjID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY3JlYXRlLWhtYWNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKiogQGFyZyB7c3RyaW5nfEJ1ZmZlcn0gZGF0YVxuICAgIEBhcmcge3N0cmluZ30gW2RpZ2VzdCA9IG51bGxdIC0gJ2hleCcsICdiaW5hcnknIG9yICdiYXNlNjQnXG4gICAgQHJldHVybiB7c3RyaW5nfEJ1ZmZlcn0gLSBCdWZmZXIgd2hlbiBkaWdlc3QgaXMgbnVsbCwgb3Igc3RyaW5nXG4qL1xuZnVuY3Rpb24gc2hhMShkYXRhLCBlbmNvZGluZykge1xuICByZXR1cm4gKDAsIF9jcmVhdGVIYXNoLmRlZmF1bHQpKCdzaGExJykudXBkYXRlKGRhdGEpLmRpZ2VzdChlbmNvZGluZyk7XG59XG4vKiogQGFyZyB7c3RyaW5nfEJ1ZmZlcn0gZGF0YVxuICAgIEBhcmcge3N0cmluZ30gW2RpZ2VzdCA9IG51bGxdIC0gJ2hleCcsICdiaW5hcnknIG9yICdiYXNlNjQnXG4gICAgQHJldHVybiB7c3RyaW5nfEJ1ZmZlcn0gLSBCdWZmZXIgd2hlbiBkaWdlc3QgaXMgbnVsbCwgb3Igc3RyaW5nXG4qL1xuXG5cbmZ1bmN0aW9uIHNoYTI1NihkYXRhLCBlbmNvZGluZykge1xuICByZXR1cm4gKDAsIF9jcmVhdGVIYXNoLmRlZmF1bHQpKCdzaGEyNTYnKS51cGRhdGUoZGF0YSkuZGlnZXN0KGVuY29kaW5nKTtcbn1cbi8qKiBAYXJnIHtzdHJpbmd8QnVmZmVyfSBkYXRhXG4gICAgQGFyZyB7c3RyaW5nfSBbZGlnZXN0ID0gbnVsbF0gLSAnaGV4JywgJ2JpbmFyeScgb3IgJ2Jhc2U2NCdcbiAgICBAcmV0dXJuIHtzdHJpbmd8QnVmZmVyfSAtIEJ1ZmZlciB3aGVuIGRpZ2VzdCBpcyBudWxsLCBvciBzdHJpbmdcbiovXG5cblxuZnVuY3Rpb24gc2hhNTEyKGRhdGEsIGVuY29kaW5nKSB7XG4gIHJldHVybiAoMCwgX2NyZWF0ZUhhc2guZGVmYXVsdCkoJ3NoYTUxMicpLnVwZGF0ZShkYXRhKS5kaWdlc3QoZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBIbWFjU0hBMjU2KGJ1ZmZlciwgc2VjcmV0KSB7XG4gIHJldHVybiAoMCwgX2NyZWF0ZUhtYWMuZGVmYXVsdCkoJ3NoYTI1NicsIHNlY3JldCkudXBkYXRlKGJ1ZmZlcikuZGlnZXN0KCk7XG59XG5cbmZ1bmN0aW9uIHJpcGVtZDE2MChkYXRhKSB7XG4gIHJldHVybiAoMCwgX2NyZWF0ZUhhc2guZGVmYXVsdCkoJ3JtZDE2MCcpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbn0gLy8gZnVuY3Rpb24gaGFzaDE2MChidWZmZXIpIHtcbi8vICAgcmV0dXJuIHJpcGVtZDE2MChzaGEyNTYoYnVmZmVyKSlcbi8vIH1cbi8vIFxuLy8gZnVuY3Rpb24gaGFzaDI1NihidWZmZXIpIHtcbi8vICAgcmV0dXJuIHNoYTI1NihzaGEyNTYoYnVmZmVyKSlcbi8vIH1cbi8vIFxuLy8gZnVuY3Rpb24gSG1hY1NIQTUxMihidWZmZXIsIHNlY3JldCkge1xuLy8gICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYTUxMicsIHNlY3JldCkudXBkYXRlKGJ1ZmZlcikuZGlnZXN0KClcbi8vIH1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2hhMTogc2hhMSxcbiAgc2hhMjU2OiBzaGEyNTYsXG4gIHNoYTUxMjogc2hhNTEyLFxuICBIbWFjU0hBMjU2OiBIbWFjU0hBMjU2LFxuICByaXBlbWQxNjA6IHJpcGVtZDE2MCAvLyBoYXNoMTYwOiBoYXNoMTYwLFxuICAvLyBoYXNoMjU2OiBoYXNoMjU2LFxuICAvLyBIbWFjU0hBNTEyOiBIbWFjU0hBNTEyXG5cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZy5qc1wiKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgZWN1cnZlID0gcmVxdWlyZSgnZWN1cnZlJyk7XG5cbnZhciBQb2ludCA9IGVjdXJ2ZS5Qb2ludDtcbnZhciBzZWNwMjU2azEgPSBlY3VydmUuZ2V0Q3VydmVCeU5hbWUoJ3NlY3AyNTZrMScpO1xuXG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKTtcblxudmFyIGJhc2U1OCA9IHJlcXVpcmUoJ2JzNTgnKTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpO1xuXG52YXIgUHVibGljS2V5ID0gcmVxdWlyZSgnLi9rZXlfcHVibGljJyk7XG5cbnZhciBHID0gc2VjcDI1NmsxLkc7XG52YXIgbiA9IHNlY3AyNTZrMS5uO1xuXG52YXIgUHJpdmF0ZUtleSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgICAgQHByaXZhdGUgc2VlIHN0YXRpYyBmdW5jdGlvbnNcbiAgICAgIEBwYXJhbSB7QmlnSW50ZWdlcn1cbiAgKi9cbiAgZnVuY3Rpb24gUHJpdmF0ZUtleShkKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByaXZhdGVLZXkpO1xuXG4gICAgdGhpcy5kID0gZDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQcml2YXRlS2V5LCBbe1xuICAgIGtleTogXCJ0b1dpZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1dpZigpIHtcbiAgICAgIHZhciBwcml2YXRlX2tleSA9IHRoaXMudG9CdWZmZXIoKTsgLy8gY2hlY2tzdW0gaW5jbHVkZXMgdGhlIHZlcnNpb25cblxuICAgICAgcHJpdmF0ZV9rZXkgPSBCdWZmZXIuY29uY2F0KFtuZXcgQnVmZmVyKFsweDgwXSksIHByaXZhdGVfa2V5XSk7XG4gICAgICB2YXIgY2hlY2tzdW0gPSBoYXNoLnNoYTI1Nihwcml2YXRlX2tleSk7XG4gICAgICBjaGVja3N1bSA9IGhhc2guc2hhMjU2KGNoZWNrc3VtKTtcbiAgICAgIGNoZWNrc3VtID0gY2hlY2tzdW0uc2xpY2UoMCwgNCk7XG4gICAgICB2YXIgcHJpdmF0ZV93aWYgPSBCdWZmZXIuY29uY2F0KFtwcml2YXRlX2tleSwgY2hlY2tzdW1dKTtcbiAgICAgIHJldHVybiBiYXNlNTguZW5jb2RlKHByaXZhdGVfd2lmKTtcbiAgICB9XG4gICAgLyoqIEFsaWFzIGZvciB7QGxpbmsgdG9XaWZ9ICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvV2lmKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgICBAcmV0dXJuIHtQb2ludH1cbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9QdWJsaWNLZXlQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1B1YmxpY0tleVBvaW50KCkge1xuICAgICAgdmFyIFE7XG4gICAgICByZXR1cm4gUSA9IHNlY3AyNTZrMS5HLm11bHRpcGx5KHRoaXMuZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvUHVibGljXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvUHVibGljKCkge1xuICAgICAgaWYgKHRoaXMucHVibGljX2tleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNfa2V5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wdWJsaWNfa2V5ID0gUHVibGljS2V5LmZyb21Qb2ludCh0aGlzLnRvUHVibGljS2V5UG9pbnQoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvQnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvQnVmZmVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZC50b0J1ZmZlcigzMik7XG4gICAgfVxuICAgIC8qKiBFQ0lFUyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0X3NoYXJlZF9zZWNyZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0X3NoYXJlZF9zZWNyZXQocHVibGljX2tleSkge1xuICAgICAgcHVibGljX2tleSA9IHRvUHVibGljKHB1YmxpY19rZXkpO1xuICAgICAgdmFyIEtCID0gcHVibGljX2tleS50b1VuY29tcHJlc3NlZCgpLnRvQnVmZmVyKCk7XG4gICAgICB2YXIgS0JQID0gUG9pbnQuZnJvbUFmZmluZShzZWNwMjU2azEsIEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihLQi5zbGljZSgxLCAzMykpLCAvLyB4XG4gICAgICBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoS0Iuc2xpY2UoMzMsIDY1KSkgLy8geVxuICAgICAgKTtcbiAgICAgIHZhciByID0gdGhpcy50b0J1ZmZlcigpO1xuICAgICAgdmFyIFAgPSBLQlAubXVsdGlwbHkoQmlnSW50ZWdlci5mcm9tQnVmZmVyKHIpKTtcbiAgICAgIHZhciBTID0gUC5hZmZpbmVYLnRvQnVmZmVyKHtcbiAgICAgICAgc2l6ZTogMzJcbiAgICAgIH0pOyAvLyBTSEE1MTIgdXNlZCBpbiBFQ0lFU1xuXG4gICAgICByZXR1cm4gaGFzaC5zaGE1MTIoUyk7XG4gICAgfSAvLyAvKiogRUNJRVMgKGRvZXMgbm90IGFsd2F5cyBtYXRjaCB0aGUgUG9pbnQuZnJvbUFmZmluZSB2ZXJzaW9uIGFib3ZlKSAqL1xuICAgIC8vIGdldF9zaGFyZWRfc2VjcmV0KHB1YmxpY19rZXkpe1xuICAgIC8vICAgICBwdWJsaWNfa2V5ID0gdG9QdWJsaWMocHVibGljX2tleSlcbiAgICAvLyAgICAgdmFyIFAgPSBwdWJsaWNfa2V5LlEubXVsdGlwbHkoIHRoaXMuZCApO1xuICAgIC8vICAgICB2YXIgUyA9IFAuYWZmaW5lWC50b0J1ZmZlcih7c2l6ZTogMzJ9KTtcbiAgICAvLyAgICAgLy8gRUNJRVMsIGFkZHMgYW4gZXh0cmEgc2hhNTEyXG4gICAgLy8gICAgIHJldHVybiBoYXNoLnNoYTUxMihTKTtcbiAgICAvLyB9XG5cbiAgICAvKiogQHRocm93cyB7RXJyb3J9IC0gb3ZlcmZsb3cgb2YgdGhlIGtleSBjb3VsZCBub3QgYmUgZGVyaXZlZCAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hpbGQob2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBCdWZmZXIuY29uY2F0KFt0aGlzLnRvUHVibGljS2V5KCkudG9CdWZmZXIoKSwgb2Zmc2V0XSk7XG4gICAgICBvZmZzZXQgPSBoYXNoLnNoYTI1NihvZmZzZXQpO1xuICAgICAgdmFyIGMgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIob2Zmc2V0KTtcbiAgICAgIGlmIChjLmNvbXBhcmVUbyhuKSA+PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBvZmZzZXQgd2VudCBvdXQgb2YgYm91bmRzLCB0cnkgYWdhaW5cIik7XG4gICAgICB2YXIgZGVyaXZlZCA9IHRoaXMuZC5hZGQoYyk7IC8vLm1vZChuKVxuXG4gICAgICBpZiAoZGVyaXZlZC5zaWdudW0oKSA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgb2Zmc2V0IGRlcml2ZWQgdG8gYW4gaW52YWxpZCBrZXksIHRyeSBhZ2FpblwiKTtcbiAgICAgIHJldHVybiBuZXcgUHJpdmF0ZUtleShkZXJpdmVkKTtcbiAgICB9IC8vIHRvQnl0ZUJ1ZmZlcigpIHtcbiAgICAvLyAgICAgdmFyIGIgPSBuZXcgQnl0ZUJ1ZmZlcihCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFksIEJ5dGVCdWZmZXIuTElUVExFX0VORElBTik7XG4gICAgLy8gICAgIHRoaXMuYXBwZW5kQnl0ZUJ1ZmZlcihiKTtcbiAgICAvLyAgICAgcmV0dXJuIGIuY29weSgwLCBiLm9mZnNldCk7XG4gICAgLy8gfVxuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9IZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9IZXgoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0J1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9QdWJsaWNLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9QdWJsaWNLZXkoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1B1YmxpYygpO1xuICAgIH1cbiAgICAvKiA8L2hlbHBlcl9mdW5jdGlvbnM+ICovXG5cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21CdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWYpIHtcbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0aW5nIHBhcmFtdGVyIHRvIGJlIGEgQnVmZmVyIHR5cGVcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICgzMiAhPT0gYnVmLmxlbmd0aCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIldBUk46IEV4cGVjdGluZyAzMiBieXRlcywgaW5zdGVhZCBnb3QgXCIuY29uY2F0KGJ1Zi5sZW5ndGgsIFwiLCBzdGFjayB0cmFjZTpcIiksIG5ldyBFcnJvcigpLnN0YWNrKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW1wdHkgYnVmZmVyXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByaXZhdGVLZXkoQmlnSW50ZWdlci5mcm9tQnVmZmVyKGJ1ZikpO1xuICAgIH1cbiAgICAvKiogQGFyZyB7c3RyaW5nfSBzZWVkIC0gYW55IGxlbmd0aCBzdHJpbmcuICBUaGlzIGlzIHByaXZhdGUsIHRoZSBzYW1lIHNlZWQgcHJvZHVjZXMgdGhlIHNhbWUgcHJpdmF0ZSBrZXkgZXZlcnkgdGltZS4gICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmcm9tU2VlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU2VlZChzZWVkKSB7XG4gICAgICAvLyBnZW5lcmF0ZV9wcml2YXRlX2tleVxuICAgICAgaWYgKCEodHlwZW9mIHNlZWQgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlZWQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJpdmF0ZUtleS5mcm9tQnVmZmVyKGhhc2guc2hhMjU2KHNlZWQpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNXaWZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNXaWYodGV4dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5mcm9tV2lmKHRleHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgICAgQHRocm93cyB7QXNzZXJ0RXJyb3J8RXJyb3J9IHBhcnNpbmcga2V5XG4gICAgICAgIEByZXR1cm4ge3N0cmluZ30gV2FsbGV0IEltcG9ydCBGb3JtYXQgKHN0aWxsIGEgc2VjcmV0LCBOb3QgZW5jcnlwdGVkKVxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmcm9tV2lmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21XaWYoX3ByaXZhdGVfd2lmKSB7XG4gICAgICB2YXIgcHJpdmF0ZV93aWYgPSBuZXcgQnVmZmVyKGJhc2U1OC5kZWNvZGUoX3ByaXZhdGVfd2lmKSk7XG4gICAgICB2YXIgdmVyc2lvbiA9IHByaXZhdGVfd2lmLnJlYWRVSW50OCgwKTtcbiAgICAgIGFzc2VydC5lcXVhbCgweDgwLCB2ZXJzaW9uLCBcIkV4cGVjdGVkIHZlcnNpb24gXCIuY29uY2F0KDB4ODAsIFwiLCBpbnN0ZWFkIGdvdCBcIiwgdmVyc2lvbikpOyAvLyBjaGVja3N1bSBpbmNsdWRlcyB0aGUgdmVyc2lvblxuXG4gICAgICB2YXIgcHJpdmF0ZV9rZXkgPSBwcml2YXRlX3dpZi5zbGljZSgwLCAtNCk7XG4gICAgICB2YXIgY2hlY2tzdW0gPSBwcml2YXRlX3dpZi5zbGljZSgtNCk7XG4gICAgICB2YXIgbmV3X2NoZWNrc3VtID0gaGFzaC5zaGEyNTYocHJpdmF0ZV9rZXkpO1xuICAgICAgbmV3X2NoZWNrc3VtID0gaGFzaC5zaGEyNTYobmV3X2NoZWNrc3VtKTtcbiAgICAgIG5ld19jaGVja3N1bSA9IG5ld19jaGVja3N1bS5zbGljZSgwLCA0KTtcbiAgICAgIGlmIChjaGVja3N1bS50b1N0cmluZygpICE9PSBuZXdfY2hlY2tzdW0udG9TdHJpbmcoKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFdJRiBrZXkgKGNoZWNrc3VtIG1pc3MtbWF0Y2gpJyk7XG4gICAgICBwcml2YXRlX2tleSA9IHByaXZhdGVfa2V5LnNsaWNlKDEpO1xuICAgICAgcmV0dXJuIFByaXZhdGVLZXkuZnJvbUJ1ZmZlcihwcml2YXRlX2tleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21IZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUhleChoZXgpIHtcbiAgICAgIHJldHVybiBQcml2YXRlS2V5LmZyb21CdWZmZXIobmV3IEJ1ZmZlcihoZXgsICdoZXgnKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFByaXZhdGVLZXk7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJpdmF0ZUtleTtcblxudmFyIHRvUHVibGljID0gZnVuY3Rpb24gdG9QdWJsaWMoZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PSBudWxsID8gZGF0YSA6IGRhdGEuUSA/IGRhdGEgOiBQdWJsaWNLZXkuZnJvbVN0cmluZ09yVGhyb3coZGF0YSk7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanNcIik7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKCdiaWdpJyk7XG5cbnZhciBlY3VydmUgPSByZXF1aXJlKCdlY3VydmUnKTtcblxudmFyIHNlY3AyNTZrMSA9IGVjdXJ2ZS5nZXRDdXJ2ZUJ5TmFtZSgnc2VjcDI1NmsxJyk7XG5CaWdJbnRlZ2VyID0gcmVxdWlyZSgnYmlnaScpO1xuXG52YXIgYmFzZTU4ID0gcmVxdWlyZSgnYnM1OCcpO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpO1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vLi4vY29uZmlnJyk7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxudmFyIEcgPSBzZWNwMjU2azEuRztcbnZhciBuID0gc2VjcDI1NmsxLm47XG5cbnZhciBQdWJsaWNLZXkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKiogQHBhcmFtIHtlY3VydmUuUG9pbnR9IHB1YmxpYyBrZXkgKi9cbiAgZnVuY3Rpb24gUHVibGljS2V5KFEpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHVibGljS2V5KTtcblxuICAgIHRoaXMuUSA9IFE7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUHVibGljS2V5LCBbe1xuICAgIGtleTogXCJ0b0J1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J1ZmZlcigpIHtcbiAgICAgIHZhciBjb21wcmVzc2VkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLlEgPyB0aGlzLlEuY29tcHJlc3NlZCA6IG51bGw7XG4gICAgICBpZiAodGhpcy5RID09PSBudWxsKSByZXR1cm4gQnVmZmVyLmZyb20oXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIiwgXCJoZXhcIik7XG4gICAgICByZXR1cm4gdGhpcy5RLmdldEVuY29kZWQoY29tcHJlc3NlZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvVW5jb21wcmVzc2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvVW5jb21wcmVzc2VkKCkge1xuICAgICAgdmFyIGJ1ZiA9IHRoaXMuUS5nZXRFbmNvZGVkKGZhbHNlKTtcbiAgICAgIHZhciBwb2ludCA9IGVjdXJ2ZS5Qb2ludC5kZWNvZGVGcm9tKHNlY3AyNTZrMSwgYnVmKTtcbiAgICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbVBvaW50KHBvaW50KTtcbiAgICB9XG4gICAgLyoqIGJ0czo6YmxvY2tjaGFpbjo6YWRkcmVzcyAodW5pcXVlIGJ1dCBub3QgYSBmdWxsIHB1YmxpYyBrZXkpICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b0Jsb2NrY2hhaW5BZGRyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvQmxvY2tjaGFpbkFkZHJlc3MoKSB7XG4gICAgICB2YXIgcHViX2J1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICAgIHZhciBwdWJfc2hhID0gaGFzaC5zaGE1MTIocHViX2J1Zik7XG4gICAgICByZXR1cm4gaGFzaC5yaXBlbWQxNjAocHViX3NoYSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBjb25maWcuZ2V0KCdhZGRyZXNzX3ByZWZpeCcpO1xuICAgICAgcmV0dXJuIHRoaXMudG9QdWJsaWNLZXlTdHJpbmcoYWRkcmVzc19wcmVmaXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgICAgRnVsbCBwdWJsaWMga2V5XG4gICAgICAgIHtyZXR1cm59IHN0cmluZ1xuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b1B1YmxpY0tleVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1B1YmxpY0tleVN0cmluZygpIHtcbiAgICAgIHZhciBhZGRyZXNzX3ByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogY29uZmlnLmdldCgnYWRkcmVzc19wcmVmaXgnKTtcbiAgICAgIGlmICh0aGlzLnB1YmRhdGEpIHJldHVybiBhZGRyZXNzX3ByZWZpeCArIHRoaXMucHViZGF0YTtcbiAgICAgIHZhciBwdWJfYnVmID0gdGhpcy50b0J1ZmZlcigpO1xuICAgICAgdmFyIGNoZWNrc3VtID0gaGFzaC5yaXBlbWQxNjAocHViX2J1Zik7XG4gICAgICB2YXIgYWRkeSA9IEJ1ZmZlci5jb25jYXQoW3B1Yl9idWYsIGNoZWNrc3VtLnNsaWNlKDAsIDQpXSk7XG4gICAgICB0aGlzLnB1YmRhdGEgPSBiYXNlNTguZW5jb2RlKGFkZHkpO1xuICAgICAgcmV0dXJuIGFkZHJlc3NfcHJlZml4ICsgdGhpcy5wdWJkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgICAgQGFyZyB7c3RyaW5nfSBwdWJsaWNfa2V5IC0gbGlrZSBHTFNYeXouLi5cbiAgICAgICAgQGFyZyB7c3RyaW5nfSBhZGRyZXNzX3ByZWZpeCAtIGxpa2UgR0xTXG4gICAgICAgIEByZXR1cm4gUHVibGljS2V5IG9yIGBudWxsYCAoaWYgdGhlIHB1YmxpY19rZXkgc3RyaW5nIGlzIGludmFsaWQpXG4gICAgICAgIEBkZXByZWNhdGVkIGZyb21QdWJsaWNLZXlTdHJpbmcgKHVzZSBmcm9tU3RyaW5nIGluc3RlYWQpXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvQWRkcmVzc1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0FkZHJlc3NTdHJpbmcoKSB7XG4gICAgICB2YXIgYWRkcmVzc19wcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGNvbmZpZy5nZXQoJ2FkZHJlc3NfcHJlZml4Jyk7XG4gICAgICB2YXIgcHViX2J1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICAgIHZhciBwdWJfc2hhID0gaGFzaC5zaGE1MTIocHViX2J1Zik7XG4gICAgICB2YXIgYWRkeSA9IGhhc2gucmlwZW1kMTYwKHB1Yl9zaGEpO1xuICAgICAgdmFyIGNoZWNrc3VtID0gaGFzaC5yaXBlbWQxNjAoYWRkeSk7XG4gICAgICBhZGR5ID0gQnVmZmVyLmNvbmNhdChbYWRkeSwgY2hlY2tzdW0uc2xpY2UoMCwgNCldKTtcbiAgICAgIHJldHVybiBhZGRyZXNzX3ByZWZpeCArIGJhc2U1OC5lbmNvZGUoYWRkeSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvUHRzQWRkeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1B0c0FkZHkoKSB7XG4gICAgICB2YXIgcHViX2J1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICAgIHZhciBwdWJfc2hhID0gaGFzaC5zaGEyNTYocHViX2J1Zik7XG4gICAgICB2YXIgYWRkeSA9IGhhc2gucmlwZW1kMTYwKHB1Yl9zaGEpO1xuICAgICAgYWRkeSA9IEJ1ZmZlci5jb25jYXQoW25ldyBCdWZmZXIoWzB4MzhdKSwgYWRkeV0pOyAvL3ZlcnNpb24gNTYoZGVjaW1hbClcblxuICAgICAgdmFyIGNoZWNrc3VtID0gaGFzaC5zaGEyNTYoYWRkeSk7XG4gICAgICBjaGVja3N1bSA9IGhhc2guc2hhMjU2KGNoZWNrc3VtKTtcbiAgICAgIGFkZHkgPSBCdWZmZXIuY29uY2F0KFthZGR5LCBjaGVja3N1bS5zbGljZSgwLCA0KV0pO1xuICAgICAgcmV0dXJuIGJhc2U1OC5lbmNvZGUoYWRkeSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoaWxkKG9mZnNldCkge1xuICAgICAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihvZmZzZXQpLCBcIkJ1ZmZlciByZXF1aXJlZDogb2Zmc2V0XCIpO1xuICAgICAgYXNzZXJ0LmVxdWFsKG9mZnNldC5sZW5ndGgsIDMyLCBcIm9mZnNldCBsZW5ndGhcIik7XG4gICAgICBvZmZzZXQgPSBCdWZmZXIuY29uY2F0KFt0aGlzLnRvQnVmZmVyKCksIG9mZnNldF0pO1xuICAgICAgb2Zmc2V0ID0gaGFzaC5zaGEyNTYob2Zmc2V0KTtcbiAgICAgIHZhciBjID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKG9mZnNldCk7XG4gICAgICBpZiAoYy5jb21wYXJlVG8obikgPj0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgb2Zmc2V0IHdlbnQgb3V0IG9mIGJvdW5kcywgdHJ5IGFnYWluXCIpO1xuICAgICAgdmFyIGNHID0gRy5tdWx0aXBseShjKTtcbiAgICAgIHZhciBRcHJpbWUgPSB0aGlzLlEuYWRkKGNHKTtcbiAgICAgIGlmIChzZWNwMjU2azEuaXNJbmZpbml0eShRcHJpbWUpKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBvZmZzZXQgZGVyaXZlZCB0byBhbiBpbnZhbGlkIGtleSwgdHJ5IGFnYWluXCIpO1xuICAgICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tUG9pbnQoUXByaW1lKTtcbiAgICB9IC8vIHRvQnl0ZUJ1ZmZlcigpIHtcbiAgICAvLyAgICAgdmFyIGIgPSBuZXcgQnl0ZUJ1ZmZlcihCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFksIEJ5dGVCdWZmZXIuTElUVExFX0VORElBTik7XG4gICAgLy8gICAgIHRoaXMuYXBwZW5kQnl0ZUJ1ZmZlcihiKTtcbiAgICAvLyAgICAgcmV0dXJuIGIuY29weSgwLCBiLm9mZnNldCk7XG4gICAgLy8gfVxuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9IZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9IZXgoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0J1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tQmluYXJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21CaW5hcnkoYmluKSB7XG4gICAgICByZXR1cm4gUHVibGljS2V5LmZyb21CdWZmZXIobmV3IEJ1ZmZlcihiaW4sICdiaW5hcnknKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21CdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgIGlmIChidWZmZXIudG9TdHJpbmcoXCJoZXhcIikgPT09IFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpIHJldHVybiBuZXcgUHVibGljS2V5KG51bGwpO1xuICAgICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoZWN1cnZlLlBvaW50LmRlY29kZUZyb20oc2VjcDI1NmsxLCBidWZmZXIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbVBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Qb2ludChwb2ludCkge1xuICAgICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkocG9pbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21TdHJpbmcocHVibGljX2tleSkge1xuICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBjb25maWcuZ2V0KCdhZGRyZXNzX3ByZWZpeCcpO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21TdHJpbmdPclRocm93KHB1YmxpY19rZXksIGFkZHJlc3NfcHJlZml4KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAgICBAYXJnIHtzdHJpbmd9IHB1YmxpY19rZXkgLSBsaWtlIEdMU1h5ei4uLlxuICAgICAgICBAYXJnIHtzdHJpbmd9IGFkZHJlc3NfcHJlZml4IC0gbGlrZSBHTFNcbiAgICAgICAgQHRocm93cyB7RXJyb3J9IGlmIHB1YmxpYyBrZXkgaXMgaW52YWxpZFxuICAgICAgICBAcmV0dXJuIFB1YmxpY0tleVxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmcm9tU3RyaW5nT3JUaHJvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU3RyaW5nT3JUaHJvdyhwdWJsaWNfa2V5KSB7XG4gICAgICB2YXIgYWRkcmVzc19wcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGNvbmZpZy5nZXQoJ2FkZHJlc3NfcHJlZml4Jyk7XG4gICAgICB2YXIgcHJlZml4ID0gcHVibGljX2tleS5zbGljZSgwLCBhZGRyZXNzX3ByZWZpeC5sZW5ndGgpO1xuICAgICAgYXNzZXJ0LmVxdWFsKGFkZHJlc3NfcHJlZml4LCBwcmVmaXgsIFwiRXhwZWN0aW5nIGtleSB0byBiZWdpbiB3aXRoIFwiLmNvbmNhdChhZGRyZXNzX3ByZWZpeCwgXCIsIGluc3RlYWQgZ290IFwiKS5jb25jYXQocHJlZml4KSk7XG4gICAgICBwdWJsaWNfa2V5ID0gcHVibGljX2tleS5zbGljZShhZGRyZXNzX3ByZWZpeC5sZW5ndGgpO1xuICAgICAgcHVibGljX2tleSA9IG5ldyBCdWZmZXIoYmFzZTU4LmRlY29kZShwdWJsaWNfa2V5KSwgJ2JpbmFyeScpO1xuICAgICAgdmFyIGNoZWNrc3VtID0gcHVibGljX2tleS5zbGljZSgtNCk7XG4gICAgICBwdWJsaWNfa2V5ID0gcHVibGljX2tleS5zbGljZSgwLCAtNCk7XG4gICAgICB2YXIgbmV3X2NoZWNrc3VtID0gaGFzaC5yaXBlbWQxNjAocHVibGljX2tleSk7XG4gICAgICBuZXdfY2hlY2tzdW0gPSBuZXdfY2hlY2tzdW0uc2xpY2UoMCwgNCk7XG4gICAgICBhc3NlcnQuZGVlcEVxdWFsKGNoZWNrc3VtLCBuZXdfY2hlY2tzdW0sICdDaGVja3N1bSBkaWQgbm90IG1hdGNoJyk7XG4gICAgICByZXR1cm4gUHVibGljS2V5LmZyb21CdWZmZXIocHVibGljX2tleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21IZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUhleChoZXgpIHtcbiAgICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbUJ1ZmZlcihuZXcgQnVmZmVyKGhleCwgJ2hleCcpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbVN0cmluZ0hleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU3RyaW5nSGV4KGhleCkge1xuICAgICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tU3RyaW5nKG5ldyBCdWZmZXIoaGV4LCAnaGV4JykpO1xuICAgIH1cbiAgICAvKiA8L0hFWD4gKi9cblxuICB9XSk7XG5cbiAgcmV0dXJuIFB1YmxpY0tleTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQdWJsaWNLZXk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4uanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanNcIik7XG5cbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi9rZXlfcHJpdmF0ZScpO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpO1xuXG52YXIgc2VjdXJlUmFuZG9tID0gcmVxdWlyZSgnc2VjdXJlLXJhbmRvbScpOyAvLyBoYXNoIGZvciAuMjUgc2Vjb25kXG5cblxudmFyIEhBU0hfUE9XRVJfTUlMTFMgPSAyNTA7XG52YXIgZW50cm9weVBvcyA9IDAsXG4gICAgZW50cm9weUNvdW50ID0gMDtcbnZhciBlbnRyb3B5QXJyYXkgPSBzZWN1cmVSYW5kb20ucmFuZG9tQnVmZmVyKDEwMSk7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkRW50cm9weTogZnVuY3Rpb24gYWRkRW50cm9weSgpIHtcbiAgICBlbnRyb3B5Q291bnQrKztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBpbnRzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgaW50c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDAsIF9pbnRzID0gaW50czsgX2kgPCBfaW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpID0gX2ludHNbX2ldO1xuICAgICAgdmFyIHBvcyA9IGVudHJvcHlQb3MrKyAlIDEwMTtcbiAgICAgIHZhciBpMiA9IGVudHJvcHlBcnJheVtwb3NdICs9IGk7XG4gICAgICBpZiAoaTIgPiA5MDA3MTk5MjU0NzQwOTkxKSBlbnRyb3B5QXJyYXlbcG9zXSA9IDA7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgICAgQSB3ZWVrIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGNhbiBydW4gb3V0IG9mIGVudHJvcHkuICBUaGlzIHNob3VsZCBlbnN1cmUgZXZlbiB0aGUgd29yc3QgcmFuZG9tIG51bWJlciBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHJlYXNvbmFibHkgc2FmZS5cbiAgICAgICBAcGFyYW0xIHN0cmluZyBlbnRyb3B5IG9mIGF0IGxlYXN0IDMyIGJ5dGVzXG4gICovXG4gIHJhbmRvbTMyQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gcmFuZG9tMzJCeXRlQnVmZmVyKCkge1xuICAgIHZhciBlbnRyb3B5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLmJyb3dzZXJFbnRyb3B5KCk7XG5cbiAgICBpZiAoISh0eXBlb2YgZW50cm9weSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmcgcmVxdWlyZWQgZm9yIGVudHJvcHlcIik7XG4gICAgfVxuXG4gICAgaWYgKGVudHJvcHkubGVuZ3RoIDwgMzIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGluZyBhdCBsZWFzdCAzMiBieXRlcyBvZiBlbnRyb3B5XCIpO1xuICAgIH1cblxuICAgIHZhciBzdGFydF90ID0gRGF0ZS5ub3coKTtcblxuICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRfdCA8IEhBU0hfUE9XRVJfTUlMTFMpIHtcbiAgICAgIGVudHJvcHkgPSBoYXNoLnNoYTI1NihlbnRyb3B5KTtcbiAgICB9XG5cbiAgICB2YXIgaGFzaF9hcnJheSA9IFtdO1xuICAgIGhhc2hfYXJyYXkucHVzaChlbnRyb3B5KTsgLy8gSGFzaGluZyBmb3IgMSBzZWNvbmQgbWF5IGhlbHBzIHRoZSBjb21wdXRlciBpcyBub3QgbG93IG9uIGVudHJvcHkgKHRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgYmFjay10by1iYWNrKS5cblxuICAgIGhhc2hfYXJyYXkucHVzaChzZWN1cmVSYW5kb20ucmFuZG9tQnVmZmVyKDMyKSk7XG4gICAgcmV0dXJuIGhhc2guc2hhMjU2KEJ1ZmZlci5jb25jYXQoaGFzaF9hcnJheSkpO1xuICB9LFxuICBnZXRfcmFuZG9tX2tleTogZnVuY3Rpb24gZ2V0X3JhbmRvbV9rZXkoZW50cm9weSkge1xuICAgIHJldHVybiBQcml2YXRlS2V5LmZyb21CdWZmZXIodGhpcy5yYW5kb20zMkJ5dGVCdWZmZXIoZW50cm9weSkpO1xuICB9LFxuICAvLyBUdXJuIGludmlzaWJsZSBzcGFjZSBsaWtlIGNoYXJhY3RlcnMgaW50byBhIHNpbmdsZSBzcGFjZVxuICAvLyBub3JtYWxpemVfYnJhaW5fa2V5KGJyYWluX2tleSl7XG4gIC8vICAgICBpZiAoISh0eXBlb2YgYnJhaW5fa2V5ID09PSAnc3RyaW5nJykpIHtcbiAgLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmcgcmVxdWlyZWQgZm9yIGJyYWluX2tleVwiKTtcbiAgLy8gICAgIH1cbiAgLy8gICAgIGJyYWluX2tleSA9IGJyYWluX2tleS50cmltKCk7XG4gIC8vICAgICByZXR1cm4gYnJhaW5fa2V5LnNwbGl0KC9bXFx0XFxuXFx2XFxmXFxyIF0rLykuam9pbignICcpO1xuICAvLyB9LFxuICBicm93c2VyRW50cm9weTogZnVuY3Rpb24gYnJvd3NlckVudHJvcHkoKSB7XG4gICAgdmFyIGVudHJvcHlTdHIgPSBBcnJheShlbnRyb3B5QXJyYXkpLmpvaW4oKTtcblxuICAgIHRyeSB7XG4gICAgICBlbnRyb3B5U3RyICs9IG5ldyBEYXRlKCkudG9TdHJpbmcoKSArIFwiIFwiICsgd2luZG93LnNjcmVlbi5oZWlnaHQgKyBcIiBcIiArIHdpbmRvdy5zY3JlZW4ud2lkdGggKyBcIiBcIiArIHdpbmRvdy5zY3JlZW4uY29sb3JEZXB0aCArIFwiIFwiICsgXCIgXCIgKyB3aW5kb3cuc2NyZWVuLmF2YWlsSGVpZ2h0ICsgXCIgXCIgKyB3aW5kb3cuc2NyZWVuLmF2YWlsV2lkdGggKyBcIiBcIiArIHdpbmRvdy5zY3JlZW4ucGl4ZWxEZXB0aCArIG5hdmlnYXRvci5sYW5ndWFnZSArIFwiIFwiICsgd2luZG93LmxvY2F0aW9uICsgXCIgXCIgKyB3aW5kb3cuaGlzdG9yeS5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBtaW1lVHlwZTsgaSA8IG5hdmlnYXRvci5taW1lVHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWltZVR5cGUgPSBuYXZpZ2F0b3IubWltZVR5cGVzW2ldO1xuICAgICAgICBlbnRyb3B5U3RyICs9IG1pbWVUeXBlLmRlc2NyaXB0aW9uICsgXCIgXCIgKyBtaW1lVHlwZS50eXBlICsgXCIgXCIgKyBtaW1lVHlwZS5zdWZmaXhlcyArIFwiIFwiO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhcIklORk9cXHRicm93c2VyRW50cm9weSBnYXRoZXJlZFwiLCBlbnRyb3B5Q291bnQsICdldmVudHMnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy9ub2RlanM6UmVmZXJlbmNlRXJyb3I6IHdpbmRvdyBpcyBub3QgZGVmaW5lZFxuICAgICAgZW50cm9weVN0ciArPSBoYXNoLnNoYTI1NihuZXcgRGF0ZSgpLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIHZhciBiID0gbmV3IEJ1ZmZlcihlbnRyb3B5U3RyKTtcbiAgICBlbnRyb3B5U3RyICs9IGIudG9TdHJpbmcoJ2JpbmFyeScpICsgXCIgXCIgKyBuZXcgRGF0ZSgpLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIGVudHJvcHlTdHI7XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzXCIpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBlY2RzYSA9IHJlcXVpcmUoJy4vZWNkc2EnKTtcblxudmFyIGhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKTtcblxudmFyIGN1cnZlID0gcmVxdWlyZSgnZWN1cnZlJykuZ2V0Q3VydmVCeU5hbWUoJ3NlY3AyNTZrMScpO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnYmlnaScpO1xuXG52YXIgUHVibGljS2V5ID0gcmVxdWlyZSgnLi9rZXlfcHVibGljJyk7XG5cbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi9rZXlfcHJpdmF0ZScpO1xuXG52YXIgU2lnbmF0dXJlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2lnbmF0dXJlKHIxLCBzMSwgaTEpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2lnbmF0dXJlKTtcblxuICAgIHRoaXMuciA9IHIxO1xuICAgIHRoaXMucyA9IHMxO1xuICAgIHRoaXMuaSA9IGkxO1xuICAgIGFzc2VydC5lcXVhbCh0aGlzLnIgIT0gbnVsbCwgdHJ1ZSwgJ01pc3NpbmcgcGFyYW1ldGVyJyk7XG4gICAgYXNzZXJ0LmVxdWFsKHRoaXMucyAhPSBudWxsLCB0cnVlLCAnTWlzc2luZyBwYXJhbWV0ZXInKTtcbiAgICBhc3NlcnQuZXF1YWwodGhpcy5pICE9IG51bGwsIHRydWUsICdNaXNzaW5nIHBhcmFtZXRlcicpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNpZ25hdHVyZSwgW3tcbiAgICBrZXk6IFwidG9CdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9CdWZmZXIoKSB7XG4gICAgICB2YXIgYnVmO1xuICAgICAgYnVmID0gbmV3IEJ1ZmZlcig2NSk7XG4gICAgICBidWYud3JpdGVVSW50OCh0aGlzLmksIDApO1xuICAgICAgdGhpcy5yLnRvQnVmZmVyKDMyKS5jb3B5KGJ1ZiwgMSk7XG4gICAgICB0aGlzLnMudG9CdWZmZXIoMzIpLmNvcHkoYnVmLCAzMyk7XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWNvdmVyUHVibGljS2V5RnJvbUJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvdmVyUHVibGljS2V5RnJvbUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlY292ZXJQdWJsaWNLZXkoaGFzaC5zaGEyNTYoYnVmZmVyKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlY292ZXJQdWJsaWNLZXlcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgICAgQHJldHVybiB7UHVibGljS2V5fVxuICAgICovXG4gICAgZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShzaGEyNTZfYnVmZmVyKSB7XG4gICAgICB2YXIgUSwgZSwgaTtcbiAgICAgIGUgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoc2hhMjU2X2J1ZmZlcik7XG4gICAgICBpID0gdGhpcy5pO1xuICAgICAgaSAtPSAyNztcbiAgICAgIGkgPSBpICYgMztcbiAgICAgIFEgPSBlY2RzYS5yZWNvdmVyUHViS2V5KGN1cnZlLCBlLCB0aGlzLCBpKTtcbiAgICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbVBvaW50KFEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2ZXJpZnlCdWZmZXJcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgICAgQHBhcmFtIHtCdWZmZXJ9IHVuLWhhc2hlZFxuICAgICAgICBAcGFyYW0gey4vUHVibGljS2V5fVxuICAgICAgICBAcmV0dXJuIHtib29sZWFufVxuICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5QnVmZmVyKGJ1ZiwgcHVibGljX2tleSkge1xuICAgICAgdmFyIF9oYXNoID0gaGFzaC5zaGEyNTYoYnVmKTtcblxuICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5SGFzaChfaGFzaCwgcHVibGljX2tleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZlcmlmeUhhc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmVyaWZ5SGFzaChoYXNoLCBwdWJsaWNfa2V5KSB7XG4gICAgICBhc3NlcnQuZXF1YWwoaGFzaC5sZW5ndGgsIDMyLCBcIkEgU0hBIDI1NiBzaG91bGQgYmUgMzIgYnl0ZXMgbG9uZywgaW5zdGVhZCBnb3QgXCIgKyBoYXNoLmxlbmd0aCk7XG4gICAgICByZXR1cm4gZWNkc2EudmVyaWZ5KGN1cnZlLCBoYXNoLCB7XG4gICAgICAgIHI6IHRoaXMucixcbiAgICAgICAgczogdGhpcy5zXG4gICAgICB9LCBwdWJsaWNfa2V5LlEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0hleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0hleCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQnVmZmVyKCkudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZlcmlmeUhleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnlIZXgoaGV4LCBwdWJsaWNfa2V5KSB7XG4gICAgICB2YXIgYnVmO1xuICAgICAgYnVmID0gbmV3IEJ1ZmZlcihoZXgsICdoZXgnKTtcbiAgICAgIHJldHVybiB0aGlzLnZlcmlmeUJ1ZmZlcihidWYsIHB1YmxpY19rZXkpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21CdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWYpIHtcbiAgICAgIHZhciBpLCByLCBzO1xuICAgICAgYXNzZXJ0LmVxdWFsKGJ1Zi5sZW5ndGgsIDY1LCAnSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gICAgICBpID0gYnVmLnJlYWRVSW50OCgwKTtcbiAgICAgIGFzc2VydC5lcXVhbChpIC0gMjcsIGkgLSAyNyAmIDcsICdJbnZhbGlkIHNpZ25hdHVyZSBwYXJhbWV0ZXInKTtcbiAgICAgIHIgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoYnVmLnNsaWNlKDEsIDMzKSk7XG4gICAgICBzID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGJ1Zi5zbGljZSgzMykpO1xuICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcywgaSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpZ25CdWZmZXJcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgICAgQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICAgICAgICBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVfa2V5XG4gICAgICAgIEByZXR1cm4ge1NpZ25hdHVyZX1cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHNpZ25CdWZmZXIoYnVmLCBwcml2YXRlX2tleSkge1xuICAgICAgdmFyIF9oYXNoID0gaGFzaC5zaGEyNTYoYnVmKTtcblxuICAgICAgcmV0dXJuIFNpZ25hdHVyZS5zaWduQnVmZmVyU2hhMjU2KF9oYXNoLCBwcml2YXRlX2tleSk7XG4gICAgfVxuICAgIC8qKiBTaWduIGEgYnVmZmVyIG9mIGV4YWN0YWxseSAzMiBieXRlcyBpbiBzaXplIChzaGEyNTYodGV4dCkpXG4gICAgICAgIEBwYXJhbSB7QnVmZmVyfSBidWYgLSAzMiBieXRlcyBiaW5hcnlcbiAgICAgICAgQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlX2tleVxuICAgICAgICBAcmV0dXJuIHtTaWduYXR1cmV9XG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNpZ25CdWZmZXJTaGEyNTZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2lnbkJ1ZmZlclNoYTI1NihidWZfc2hhMjU2LCBwcml2YXRlX2tleSkge1xuICAgICAgaWYgKGJ1Zl9zaGEyNTYubGVuZ3RoICE9PSAzMiB8fCAhQnVmZmVyLmlzQnVmZmVyKGJ1Zl9zaGEyNTYpKSB0aHJvdyBuZXcgRXJyb3IoXCJidWZfc2hhMjU2OiAzMiBieXRlIGJ1ZmZlciByZXF1cmVkXCIpO1xuICAgICAgcHJpdmF0ZV9rZXkgPSB0b1ByaXZhdGVPYmoocHJpdmF0ZV9rZXkpO1xuICAgICAgYXNzZXJ0KHByaXZhdGVfa2V5LCAncHJpdmF0ZV9rZXkgcmVxdWlyZWQnKTtcbiAgICAgIHZhciBkZXIsIGUsIGVjc2lnbmF0dXJlLCBpLCBsZW5SLCBsZW5TLCBub25jZTtcbiAgICAgIGkgPSBudWxsO1xuICAgICAgbm9uY2UgPSAwO1xuICAgICAgZSA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihidWZfc2hhMjU2KTtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgZWNzaWduYXR1cmUgPSBlY2RzYS5zaWduKGN1cnZlLCBidWZfc2hhMjU2LCBwcml2YXRlX2tleS5kLCBub25jZSsrKTtcbiAgICAgICAgZGVyID0gZWNzaWduYXR1cmUudG9ERVIoKTtcbiAgICAgICAgbGVuUiA9IGRlclszXTtcbiAgICAgICAgbGVuUyA9IGRlcls1ICsgbGVuUl07XG5cbiAgICAgICAgaWYgKGxlblIgPT09IDMyICYmIGxlblMgPT09IDMyKSB7XG4gICAgICAgICAgaSA9IGVjZHNhLmNhbGNQdWJLZXlSZWNvdmVyeVBhcmFtKGN1cnZlLCBlLCBlY3NpZ25hdHVyZSwgcHJpdmF0ZV9rZXkudG9QdWJsaWNLZXkoKS5RKTtcbiAgICAgICAgICBpICs9IDQ7IC8vIGNvbXByZXNzZWRcblxuICAgICAgICAgIGkgKz0gMjc7IC8vIGNvbXBhY3QgIC8vICAyNCBvciAyNyA6KCBmb3JjaW5nIG9kZC15IDJuZCBrZXkgY2FuZGlkYXRlKVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9uY2UgJSAxMCA9PT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiV0FSTjogXCIgKyBub25jZSArIFwiIGF0dGVtcHRzIHRvIGZpbmQgY2Fub25pY2FsIHNpZ25hdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShlY3NpZ25hdHVyZS5yLCBlY3NpZ25hdHVyZS5zLCBpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2lnblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaWduKHN0cmluZywgcHJpdmF0ZV9rZXkpIHtcbiAgICAgIHJldHVybiBTaWduYXR1cmUuc2lnbkJ1ZmZlcihuZXcgQnVmZmVyKHN0cmluZyksIHByaXZhdGVfa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUhleFwiLFxuICAgIHZhbHVlOiAvLyB0b0J5dGVCdWZmZXIoKSB7XG4gICAgLy8gICAgIHZhciBiO1xuICAgIC8vICAgICBiID0gbmV3IEJ5dGVCdWZmZXIoQnl0ZUJ1ZmZlci5ERUZBVUxUX0NBUEFDSVRZLCBCeXRlQnVmZmVyLkxJVFRMRV9FTkRJQU4pO1xuICAgIC8vICAgICB0aGlzLmFwcGVuZEJ5dGVCdWZmZXIoYik7XG4gICAgLy8gICAgIHJldHVybiBiLmNvcHkoMCwgYi5vZmZzZXQpO1xuICAgIC8vIH07XG4gICAgZnVuY3Rpb24gZnJvbUhleChoZXgpIHtcbiAgICAgIHJldHVybiBTaWduYXR1cmUuZnJvbUJ1ZmZlcihuZXcgQnVmZmVyKGhleCwgXCJoZXhcIikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaWduSGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ25IZXgoaGV4LCBwcml2YXRlX2tleSkge1xuICAgICAgdmFyIGJ1ZjtcbiAgICAgIGJ1ZiA9IG5ldyBCdWZmZXIoaGV4LCAnaGV4Jyk7XG4gICAgICByZXR1cm4gU2lnbmF0dXJlLnNpZ25CdWZmZXIoYnVmLCBwcml2YXRlX2tleSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNpZ25hdHVyZTtcbn0oKTtcblxudmFyIHRvUHJpdmF0ZU9iaiA9IGZ1bmN0aW9uIHRvUHJpdmF0ZU9iaihvKSB7XG4gIHJldHVybiBvID8gby5kID8gbyA6IFByaXZhdGVLZXkuZnJvbVdpZihvKSA6IG9cbiAgLypudWxsIG9yIHVuZGVmaW5lZCovXG4gIDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2lnbmF0dXJlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20uanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4uanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanNcIik7XG5cbnZhciBfcHJvbWlzaWZ5ID0gcmVxdWlyZShcIi4uL3Byb21pc2lmeVwiKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9zLCBfZTsgdHJ5IHsgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyB0aHJvdyBfZTI7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTMpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UzOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxudmFyIGJpZ2kgPSByZXF1aXJlKCdiaWdpJyksXG4gICAgYnM1OCA9IHJlcXVpcmUoJ2JzNTgnKSxcbiAgICBlY3VydmUgPSByZXF1aXJlKCdlY3VydmUnKSxcbiAgICBQb2ludCA9IGVjdXJ2ZS5Qb2ludCxcbiAgICBzZWNwMjU2azEgPSBlY3VydmUuZ2V0Q3VydmVCeU5hbWUoJ3NlY3AyNTZrMScpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpLFxuICAgIG9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL3NlcmlhbGl6ZXIvc3JjL29wZXJhdGlvbnMnKSxcbiAgICBTaWduYXR1cmUgPSByZXF1aXJlKCcuL2VjYy9zcmMvc2lnbmF0dXJlJyksXG4gICAgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vZWNjL3NyYy9rZXlfcHJpdmF0ZScpLFxuICAgIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4vZWNjL3NyYy9rZXlfcHVibGljJyksXG4gICAgc2Vzc2lvbiA9IHJlcXVpcmUoJy4vc2Vzc2lvbicpLFxuICAgIGFwaSA9IHJlcXVpcmUoJy4uL2FwaScpLFxuICAgIGhhc2ggPSByZXF1aXJlKCcuL2VjYy9zcmMvaGFzaCcpO1xuXG52YXIgQXV0aCA9IHt9O1xudmFyIHRyYW5zYWN0aW9uID0gb3BlcmF0aW9ucy50cmFuc2FjdGlvbjtcbnZhciBzaWduZWRfdHJhbnNhY3Rpb24gPSBvcGVyYXRpb25zLnNpZ25lZF90cmFuc2FjdGlvbjtcblxuQXV0aC52ZXJpZnkgPSBmdW5jdGlvbiAobmFtZSwgcGFzc3dvcmQsIGF1dGhzKSB7XG4gIHZhciBoYXNLZXkgPSBmYWxzZTtcbiAgdmFyIHJvbGVzID0gW107XG5cbiAgZm9yICh2YXIgcm9sZSBpbiBhdXRocykge1xuICAgIHJvbGVzLnB1c2gocm9sZSk7XG4gIH1cblxuICB2YXIgcHViS2V5cyA9IHRoaXMuZ2VuZXJhdGVLZXlzKG5hbWUsIHBhc3N3b3JkLCByb2xlcyk7XG4gIHJvbGVzLmZvckVhY2goZnVuY3Rpb24gKHJvbGUpIHtcbiAgICBpZiAoYXV0aHNbcm9sZV1bMF1bMF0gPT09IHB1YktleXNbcm9sZV0pIHtcbiAgICAgIGhhc0tleSA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGhhc0tleTtcbn07XG5cbkF1dGguZ2VuZXJhdGVLZXlzID0gZnVuY3Rpb24gKG5hbWUsIHBhc3N3b3JkLCByb2xlcykge1xuICB2YXIgcHViS2V5cyA9IHt9O1xuICByb2xlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb2xlKSB7XG4gICAgdmFyIHNlZWQgPSBuYW1lICsgcm9sZSArIHBhc3N3b3JkO1xuICAgIHZhciBicmFpbktleSA9IHNlZWQudHJpbSgpLnNwbGl0KC9bXFx0XFxuXFx2XFxmXFxyIF0rLykuam9pbignICcpO1xuICAgIHZhciBoYXNoU2hhMjU2ID0gaGFzaC5zaGEyNTYoYnJhaW5LZXkpO1xuICAgIHZhciBiaWdJbnQgPSBiaWdpLmZyb21CdWZmZXIoaGFzaFNoYTI1Nik7XG4gICAgdmFyIHRvUHViS2V5ID0gc2VjcDI1NmsxLkcubXVsdGlwbHkoYmlnSW50KTtcbiAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQodG9QdWJLZXkuY3VydmUsIHRvUHViS2V5LngsIHRvUHViS2V5LnksIHRvUHViS2V5LnopO1xuICAgIHZhciBwdWJCdWYgPSBwb2ludC5nZXRFbmNvZGVkKHRvUHViS2V5LmNvbXByZXNzZWQpO1xuICAgIHZhciBjaGVja3N1bSA9IGhhc2gucmlwZW1kMTYwKHB1YkJ1Zik7XG4gICAgdmFyIGFkZHkgPSBCdWZmZXIuY29uY2F0KFtwdWJCdWYsIGNoZWNrc3VtLnNsaWNlKDAsIDQpXSk7XG4gICAgcHViS2V5c1tyb2xlXSA9IGNvbmZpZy5nZXQoJ2FkZHJlc3NfcHJlZml4JykgKyBiczU4LmVuY29kZShhZGR5KTtcbiAgfSk7XG4gIHJldHVybiBwdWJLZXlzO1xufTtcbi8qKlxuICAgIEBhcmcge3N0cmluZ30gbmFtZSAtIGJsb2NrY2hhaW4gYWNjb3VudCBuYW1lXG4gICAgQGFyZyB7c3RyaW5nfSBwYXNzd29yZCAtIHZlcnkgc3Ryb25nIHBhc3N3b3JkIHR5cGljYWxseSBubyBzaG9ydGVyIHRoYW4gYSBwcml2YXRlIGtleVxuICAgIEBhcmcge2FycmF5fSByb2xlcyAtIGRlZmF1bHRzIHRvIHN0YW5kYXJkIEdvbG9zIGJsb2NrY2hhaW4tbGV2ZWwgcm9sZXNcbiovXG5cblxuQXV0aC5nZXRQcml2YXRlS2V5cyA9IGZ1bmN0aW9uIChuYW1lLCBwYXNzd29yZCkge1xuICB2YXIgcm9sZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFsnb3duZXInLCAnYWN0aXZlJywgJ3Bvc3RpbmcnLCAnbWVtbyddO1xuICB2YXIgcHJpdktleXMgPSB7fTtcbiAgcm9sZXMuZm9yRWFjaChmdW5jdGlvbiAocm9sZSkge1xuICAgIHByaXZLZXlzW3JvbGVdID0gdGhpcy50b1dpZihuYW1lLCBwYXNzd29yZCwgcm9sZSk7XG4gICAgcHJpdktleXNbcm9sZSArICdQdWJrZXknXSA9IHRoaXMud2lmVG9QdWJsaWMocHJpdktleXNbcm9sZV0pO1xuICB9LmJpbmQodGhpcykpO1xuICByZXR1cm4gcHJpdktleXM7XG59O1xuXG5BdXRoLmlzV2lmID0gZnVuY3Rpb24gKHByaXZXaWYpIHtcbiAgdmFyIGlzV2lmID0gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgYnVmV2lmID0gbmV3IEJ1ZmZlcihiczU4LmRlY29kZShwcml2V2lmKSk7XG4gICAgdmFyIHByaXZLZXkgPSBidWZXaWYuc2xpY2UoMCwgLTQpO1xuICAgIHZhciBjaGVja3N1bSA9IGJ1ZldpZi5zbGljZSgtNCk7XG4gICAgdmFyIG5ld0NoZWNrc3VtID0gaGFzaC5zaGEyNTYocHJpdktleSk7XG4gICAgbmV3Q2hlY2tzdW0gPSBoYXNoLnNoYTI1NihuZXdDaGVja3N1bSk7XG4gICAgbmV3Q2hlY2tzdW0gPSBuZXdDaGVja3N1bS5zbGljZSgwLCA0KTtcblxuICAgIGlmIChjaGVja3N1bS50b1N0cmluZygpID09IG5ld0NoZWNrc3VtLnRvU3RyaW5nKCkpIHtcbiAgICAgIGlzV2lmID0gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgcmV0dXJuIGlzV2lmO1xufTtcblxuQXV0aC5sb2dpbkFzeW5jID0gZnVuY3Rpb24gKG5hbWUsIHBhc3N3b3JkLCBjYWxsYmFjaykge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIG93bmVyOiBudWxsLFxuICAgICAgYWN0aXZlOiBudWxsLFxuICAgICAgcG9zdGluZzogbnVsbCxcbiAgICAgIG1lbW86IG51bGwsXG4gICAgICBwYXNzd29yZDogbnVsbFxuICAgIH07XG4gICAgdmFyIHJvbGVzID0gT2JqZWN0LmtleXMocmVzdWx0KS5zbGljZSgwLCA0KTtcbiAgICB2YXIgcHJpdmF0ZUtleXMgPSB7fTtcbiAgICB2YXIgaXNQYXNzID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHBrID0gUHJpdmF0ZUtleS5mcm9tV2lmKHBhc3N3b3JkKTtcbiAgICAgIHJvbGVzLm1hcChmdW5jdGlvbiAocm9sZSkge1xuICAgICAgICByZXR1cm4gcHJpdmF0ZUtleXNbcm9sZV0gPSBway50b1N0cmluZygpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpc1Bhc3MgPSB0cnVlO1xuICAgICAgcm9sZXMubWFwKGZ1bmN0aW9uIChyb2xlKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlS2V5c1tyb2xlXSA9IFByaXZhdGVLZXkuZnJvbVNlZWQoXCJcIi5jb25jYXQobmFtZSkuY29uY2F0KHJvbGUpLmNvbmNhdChwYXNzd29yZCkpLnRvU3RyaW5nKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBhcGkuZ2V0QWNjb3VudHNBc3luYyhbbmFtZV0sIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgY2FsbGJhY2soJ05vIHN1Y2ggYWNjb3VudCcsIG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJvbGVzLnNsaWNlKDAsIDMpLm1hcChmdW5jdGlvbiAocm9sZSkge1xuICAgICAgICB2YXIga2V5X2F1dGhzID0gcmVzWzBdW3JvbGVdLmtleV9hdXRocztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleV9hdXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChfdGhpcy53aWZJc1ZhbGlkKHByaXZhdGVLZXlzW3JvbGVdLCBrZXlfYXV0aHNbaV1bMF0pKSB7XG4gICAgICAgICAgICByZXN1bHRbcm9sZV0gPSBwcml2YXRlS2V5c1tyb2xlXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoX3RoaXMud2lmSXNWYWxpZChwcml2YXRlS2V5cy5tZW1vLCByZXNbMF0ubWVtb19rZXkpKSByZXN1bHQubWVtbyA9IHByaXZhdGVLZXlzLm1lbW87XG4gICAgICBpZiAoaXNQYXNzICYmIHJlc3VsdC5wb3N0aW5nKSByZXN1bHQucGFzc3dvcmQgPSBwYXNzd29yZDtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gIH1cbn07XG5cbkF1dGgubG9naW4gPSAoMCwgX3Byb21pc2lmeS5wcm9taXNpZnkpKEF1dGgubG9naW5Bc3luYyk7XG5cbkF1dGgudG9XaWYgPSBmdW5jdGlvbiAobmFtZSwgcGFzc3dvcmQsIHJvbGUpIHtcbiAgdmFyIHNlZWQgPSBuYW1lICsgcm9sZSArIHBhc3N3b3JkO1xuICB2YXIgYnJhaW5LZXkgPSBzZWVkLnRyaW0oKS5zcGxpdCgvW1xcdFxcblxcdlxcZlxcciBdKy8pLmpvaW4oJyAnKTtcbiAgdmFyIGhhc2hTaGEyNTYgPSBoYXNoLnNoYTI1NihicmFpbktleSk7XG4gIHZhciBwcml2S2V5ID0gQnVmZmVyLmNvbmNhdChbbmV3IEJ1ZmZlcihbMHg4MF0pLCBoYXNoU2hhMjU2XSk7XG4gIHZhciBjaGVja3N1bSA9IGhhc2guc2hhMjU2KHByaXZLZXkpO1xuICBjaGVja3N1bSA9IGhhc2guc2hhMjU2KGNoZWNrc3VtKTtcbiAgY2hlY2tzdW0gPSBjaGVja3N1bS5zbGljZSgwLCA0KTtcbiAgdmFyIHByaXZXaWYgPSBCdWZmZXIuY29uY2F0KFtwcml2S2V5LCBjaGVja3N1bV0pO1xuICByZXR1cm4gYnM1OC5lbmNvZGUocHJpdldpZik7XG59O1xuXG5BdXRoLndpZklzVmFsaWQgPSBmdW5jdGlvbiAocHJpdldpZiwgcHViV2lmKSB7XG4gIHJldHVybiB0aGlzLndpZlRvUHVibGljKHByaXZXaWYpID09IHB1YldpZjtcbn07XG5cbkF1dGgud2lmVG9QdWJsaWMgPSBmdW5jdGlvbiAocHJpdldpZikge1xuICB2YXIgcHViV2lmID0gUHJpdmF0ZUtleS5mcm9tV2lmKHByaXZXaWYpO1xuICBwdWJXaWYgPSBwdWJXaWYudG9QdWJsaWMoKS50b1N0cmluZygpO1xuICByZXR1cm4gcHViV2lmO1xufTtcblxuQXV0aC5pc1B1YmtleSA9IGZ1bmN0aW9uIChwdWJrZXksIGFkZHJlc3NfcHJlZml4KSB7XG4gIHJldHVybiBQdWJsaWNLZXkuZnJvbVN0cmluZyhwdWJrZXksIGFkZHJlc3NfcHJlZml4KSAhPSBudWxsO1xufTtcblxuQXV0aC5zaWduVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJ4LCBrZXlzKSB7XG4gIHZhciBzaWduYXR1cmVzID0gW107XG5cbiAgaWYgKHRyeC5zaWduYXR1cmVzKSB7XG4gICAgc2lnbmF0dXJlcyA9IFtdLmNvbmNhdCh0cnguc2lnbmF0dXJlcyk7XG4gIH1cblxuICB2YXIgY2lkID0gbmV3IEJ1ZmZlcihjb25maWcuZ2V0KCdjaGFpbl9pZCcpLCAnaGV4Jyk7XG4gIHZhciBidWYgPSB0cmFuc2FjdGlvbi50b0J1ZmZlcih0cngpO1xuXG4gIGZvciAodmFyIGtleSBpbiBrZXlzKSB7XG4gICAgdmFyIHNpZyA9IFNpZ25hdHVyZS5zaWduQnVmZmVyKEJ1ZmZlci5jb25jYXQoW2NpZCwgYnVmXSksIGtleXNba2V5XSk7XG4gICAgc2lnbmF0dXJlcy5wdXNoKHNpZy50b0J1ZmZlcigpKTtcbiAgfVxuXG4gIHJldHVybiBzaWduZWRfdHJhbnNhY3Rpb24udG9PYmplY3QoT2JqZWN0LmFzc2lnbih0cngsIHtcbiAgICBzaWduYXR1cmVzOiBzaWduYXR1cmVzXG4gIH0pKTtcbn07XG5cbkF1dGguc2lnbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSwga2V5cykge1xuICB2YXIgc2lnbmF0dXJlcyA9IHt9O1xuICB2YXIgYnVmU2hhID0gaGFzaC5zaGEyNTYoZGF0YSk7XG5cbiAgdmFyIHNpZ24gPSBmdW5jdGlvbiBzaWduKHJvbGUsIGQpIHtcbiAgICBpZiAoIWQpIHJldHVybjtcbiAgICB2YXIgc2lnID0gU2lnbmF0dXJlLnNpZ25CdWZmZXJTaGEyNTYoYnVmU2hhLCBkKTtcbiAgICBzaWduYXR1cmVzW3JvbGVdID0gc2lnLnRvSGV4KCk7XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIGtleXMpIHtcbiAgICBzaWduKGtleSwga2V5c1trZXldKTtcbiAgfVxuXG4gIHJldHVybiBzaWduYXR1cmVzO1xufTtcblxuQXV0aC52ZXJpZnlTaWduZWREYXRhID0gZnVuY3Rpb24gKGRhdGEsIHNpZ25hdHVyZXMsIGFjY291bnQsIGF1dGhUeXBlcykge1xuICB2YXIgYXV0aCA9IHt9O1xuICB2YXIgYnVmU2hhID0gaGFzaC5zaGEyNTYoZGF0YSk7XG5cbiAgdmFyIHZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeSh0eXBlLCBzaWdIZXgsIHB1YmtleSwgd2VpZ2h0LCB3ZWlnaHRfdGhyZXNob2xkKSB7XG4gICAgaWYgKCFzaWdIZXgpIHJldHVybjtcblxuICAgIGlmICh3ZWlnaHQgIT09IDEgfHwgd2VpZ2h0X3RocmVzaG9sZCAhPT0gMSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkF1dGgudmVyaWZ5U2lnbmVkRGF0YSB1bnN1cHBvcnRlZCBcIi5jb25jYXQodHlwZSwgXCIgYXV0aCBjb25maWd1cmF0aW9uOiBcIikuY29uY2F0KGFjY291bnQubmFtZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFyc2VTaWcgPSBmdW5jdGlvbiBwYXJzZVNpZyhoZXhTaWcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gU2lnbmF0dXJlLmZyb21IZXgoaGV4U2lnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgc2lnID0gcGFyc2VTaWcoc2lnSGV4KTtcbiAgICAgIHZhciBwdWJsaWNfa2V5ID0gUHVibGljS2V5LmZyb21TdHJpbmcocHVia2V5KTtcbiAgICAgIHZhciB2ZXJpZmllZCA9IHNpZy52ZXJpZnlIYXNoKGJ1ZlNoYSwgcHVibGljX2tleSk7XG4gICAgICBhdXRoW3R5cGVdID0gdmVyaWZpZWQ7XG4gICAgfVxuICB9O1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihhdXRoVHlwZXMpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIGF1dGhUeXBlID0gX3N0ZXAudmFsdWU7XG4gICAgICB2YXIgX2FjY291bnQkYXV0aFR5cGUgPSBhY2NvdW50W2F1dGhUeXBlXSxcbiAgICAgICAgICBrZXlfYXV0aHMgPSBfYWNjb3VudCRhdXRoVHlwZS5rZXlfYXV0aHMsXG4gICAgICAgICAgd2VpZ2h0X3RocmVzaG9sZCA9IF9hY2NvdW50JGF1dGhUeXBlLndlaWdodF90aHJlc2hvbGQ7XG5cbiAgICAgIHZhciBfa2V5X2F1dGhzID0gX3NsaWNlZFRvQXJyYXkoa2V5X2F1dGhzLCAxKSxcbiAgICAgICAgICBfa2V5X2F1dGhzJCA9IF9zbGljZWRUb0FycmF5KF9rZXlfYXV0aHNbMF0sIDIpLFxuICAgICAgICAgIHB1YktleSA9IF9rZXlfYXV0aHMkWzBdLFxuICAgICAgICAgIHdlaWdodCA9IF9rZXlfYXV0aHMkWzFdO1xuXG4gICAgICB2ZXJpZnkoYXV0aFR5cGUsIHNpZ25hdHVyZXNbYXV0aFR5cGVdLCBwdWJLZXksIHdlaWdodCwgd2VpZ2h0X3RocmVzaG9sZCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cblxuICByZXR1cm4gYXV0aDtcbn07XG5cbkF1dGggPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIEF1dGgpLCBzZXNzaW9uKTtcbm1vZHVsZS5leHBvcnRzID0gQXV0aDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzXCIpO1xuXG52YXIgX2J5dGVidWZmZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJieXRlYnVmZmVyXCIpKTtcblxudmFyIF9hc3NlcnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuXG52YXIgX2JzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiYnM1OFwiKSk7XG5cbnZhciBfZWNjID0gcmVxdWlyZShcIi4vZWNjXCIpO1xuXG52YXIgX3NlcmlhbGl6ZXIgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVyXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBlbmNNZW1vID0gX3NlcmlhbGl6ZXIub3BzLmVuY3J5cHRlZF9tZW1vO1xuLyoqXG4gICAgU29tZSBmaWVsZHMgYXJlIG9ubHkgcmVxdWlyZWQgaWYgdGhlIG1lbW8gaXMgbWFya2VkIGZvciBkZWNyeXB0aW9uIChzdGFydHMgd2l0aCBhIGhhc2gpLlxuICAgIEBhcmcge3N0cmluZ3xQcml2YXRlS2V5fSBwcml2YXRlX2tleSAtIFdJRiBvciBQcml2YXRlS2V5IG9iamVjdFxuICAgIEBhcmcge3N0cmluZ30gbWVtbyAtIHBsYWluIHRleHQgaXMgcmV0dXJuZWQsIGhhc2ggcHJlZml4IGJhc2U1OCBpcyBkZWNyeXB0ZWRcbiAgICBAcmV0dXJuIHtzdHJpbmd9IC0gdXRmOCBkZWNvZGVkIHN0cmluZyAoaGFzaCBwcmVmaXgpXG4qL1xuXG5mdW5jdGlvbiBkZWNvZGUocHJpdmF0ZV9rZXksIG1lbW8pIHtcbiAgKDAsIF9hc3NlcnQuZGVmYXVsdCkobWVtbywgJ21lbW8gaXMgcmVxdWlyZWQnKTtcblxuICBfYXNzZXJ0LmRlZmF1bHQuZXF1YWwoX3R5cGVvZihtZW1vKSwgJ3N0cmluZycsICdtZW1vJyk7XG5cbiAgaWYgKCEvXiMvLnRlc3QobWVtbykpIHJldHVybiBtZW1vO1xuICBtZW1vID0gbWVtby5zdWJzdHJpbmcoMSk7XG4gICgwLCBfYXNzZXJ0LmRlZmF1bHQpKHByaXZhdGVfa2V5LCAncHJpdmF0ZV9rZXkgaXMgcmVxdWlyZWQnKTtcbiAgY2hlY2tFbmNyeXB0aW9uKCk7XG4gIHByaXZhdGVfa2V5ID0gdG9Qcml2YXRlT2JqKHByaXZhdGVfa2V5KTtcbiAgbWVtbyA9IF9icy5kZWZhdWx0LmRlY29kZShtZW1vKTtcbiAgbWVtbyA9IGVuY01lbW8uZnJvbUJ1ZmZlcihuZXcgQnVmZmVyKG1lbW8sICdiaW5hcnknKSk7XG4gIHZhciBfbWVtbyA9IG1lbW8sXG4gICAgICBmcm9tID0gX21lbW8uZnJvbSxcbiAgICAgIHRvID0gX21lbW8udG8sXG4gICAgICBub25jZSA9IF9tZW1vLm5vbmNlLFxuICAgICAgY2hlY2sgPSBfbWVtby5jaGVjayxcbiAgICAgIGVuY3J5cHRlZCA9IF9tZW1vLmVuY3J5cHRlZDtcbiAgdmFyIHB1YmtleSA9IHByaXZhdGVfa2V5LnRvUHVibGljS2V5KCkudG9TdHJpbmcoKTtcbiAgdmFyIG90aGVycHViID0gcHVia2V5ID09PSBmcm9tLnRvU3RyaW5nKCkgPyB0by50b1N0cmluZygpIDogZnJvbS50b1N0cmluZygpO1xuICBtZW1vID0gX2VjYy5BZXMuZGVjcnlwdChwcml2YXRlX2tleSwgb3RoZXJwdWIsIG5vbmNlLCBlbmNyeXB0ZWQsIGNoZWNrKTsgLy8gcmVtb3ZlIHZhcmludCBsZW5ndGggcHJlZml4XG5cbiAgdmFyIG1idWYgPSBfYnl0ZWJ1ZmZlci5kZWZhdWx0LmZyb21CaW5hcnkobWVtby50b1N0cmluZygnYmluYXJ5JyksIF9ieXRlYnVmZmVyLmRlZmF1bHQuREVGQVVMVF9DQVBBQ0lUWSwgX2J5dGVidWZmZXIuZGVmYXVsdC5MSVRUTEVfRU5ESUFOKTtcblxuICB0cnkge1xuICAgIG1idWYubWFyaygpO1xuICAgIHJldHVybiAnIycgKyBtYnVmLnJlYWRWU3RyaW5nKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBtYnVmLnJlc2V0KCk7IC8vIFNlbmRlciBkaWQgbm90IGxlbmd0aC1wcmVmaXggdGhlIG1lbW9cblxuICAgIG1lbW8gPSBuZXcgQnVmZmVyKG1idWYudG9TdHJpbmcoJ2JpbmFyeScpLCAnYmluYXJ5JykudG9TdHJpbmcoJ3V0Zi04Jyk7XG4gICAgcmV0dXJuICcjJyArIG1lbW87XG4gIH1cbn1cbi8qKlxuICAgIFNvbWUgZmllbGRzIGFyZSBvbmx5IHJlcXVpcmVkIGlmIHRoZSBtZW1vIGlzIG1hcmtlZCBmb3IgZW5jcnlwdGlvbiAoc3RhcnRzIHdpdGggYSBoYXNoKS5cbiAgICBAYXJnIHtzdHJpbmd8UHJpdmF0ZUtleX0gcHJpdmF0ZV9rZXkgLSBXSUYgb3IgUHJpdmF0ZUtleSBvYmplY3RcbiAgICBAYXJnIHtzdHJpbmd8UHVibGljS2V5fSBwdWJsaWNfa2V5IC0gUmVjaXBpZW50XG4gICAgQGFyZyB7c3RyaW5nfSBtZW1vIC0gcGxhaW4gdGV4dCBpcyByZXR1cm5lZCwgaGFzaCBwcmVmaXggdGV4dCBpcyBlbmNyeXB0ZWRcbiAgICBAYXJnIHtzdHJpbmd9IFt0ZXN0Tm9uY2UgPSB1bmRlZmluZWRdIC0ganVzdCBmb3IgdGVzdGluZ1xuICAgIEByZXR1cm4ge3N0cmluZ30gLSBiYXNlNjQgZGVjb2RlZCBzdHJpbmcgKG9yIHBsYWluIHRleHQpXG4qL1xuXG5cbmZ1bmN0aW9uIGVuY29kZShwcml2YXRlX2tleSwgcHVibGljX2tleSwgbWVtbywgdGVzdE5vbmNlKSB7XG4gICgwLCBfYXNzZXJ0LmRlZmF1bHQpKG1lbW8sICdtZW1vIGlzIHJlcXVpcmVkJyk7XG5cbiAgX2Fzc2VydC5kZWZhdWx0LmVxdWFsKF90eXBlb2YobWVtbyksICdzdHJpbmcnLCAnbWVtbycpO1xuXG4gIGlmICghL14jLy50ZXN0KG1lbW8pKSByZXR1cm4gbWVtbztcbiAgbWVtbyA9IG1lbW8uc3Vic3RyaW5nKDEpO1xuICAoMCwgX2Fzc2VydC5kZWZhdWx0KShwcml2YXRlX2tleSwgJ3ByaXZhdGVfa2V5IGlzIHJlcXVpcmVkJyk7XG4gICgwLCBfYXNzZXJ0LmRlZmF1bHQpKHB1YmxpY19rZXksICdwdWJsaWNfa2V5IGlzIHJlcXVpcmVkJyk7XG4gIGNoZWNrRW5jcnlwdGlvbigpO1xuICBwcml2YXRlX2tleSA9IHRvUHJpdmF0ZU9iaihwcml2YXRlX2tleSk7XG4gIHB1YmxpY19rZXkgPSB0b1B1YmxpY09iaihwdWJsaWNfa2V5KTtcbiAgdmFyIG1idWYgPSBuZXcgX2J5dGVidWZmZXIuZGVmYXVsdChfYnl0ZWJ1ZmZlci5kZWZhdWx0LkRFRkFVTFRfQ0FQQUNJVFksIF9ieXRlYnVmZmVyLmRlZmF1bHQuTElUVExFX0VORElBTik7XG4gIG1idWYud3JpdGVWU3RyaW5nKG1lbW8pO1xuICBtZW1vID0gbmV3IEJ1ZmZlcihtYnVmLmNvcHkoMCwgbWJ1Zi5vZmZzZXQpLnRvQmluYXJ5KCksICdiaW5hcnknKTtcblxuICB2YXIgX0FlcyRlbmNyeXB0ID0gX2VjYy5BZXMuZW5jcnlwdChwcml2YXRlX2tleSwgcHVibGljX2tleSwgbWVtbywgdGVzdE5vbmNlKSxcbiAgICAgIG5vbmNlID0gX0FlcyRlbmNyeXB0Lm5vbmNlLFxuICAgICAgbWVzc2FnZSA9IF9BZXMkZW5jcnlwdC5tZXNzYWdlLFxuICAgICAgY2hlY2tzdW0gPSBfQWVzJGVuY3J5cHQuY2hlY2tzdW07XG5cbiAgbWVtbyA9IGVuY01lbW8uZnJvbU9iamVjdCh7XG4gICAgZnJvbTogcHJpdmF0ZV9rZXkudG9QdWJsaWNLZXkoKSxcbiAgICB0bzogcHVibGljX2tleSxcbiAgICBub25jZTogbm9uY2UsXG4gICAgY2hlY2s6IGNoZWNrc3VtLFxuICAgIGVuY3J5cHRlZDogbWVzc2FnZVxuICB9KTsgLy8gc2VyaWFsaXplXG5cbiAgbWVtbyA9IGVuY01lbW8udG9CdWZmZXIobWVtbyk7XG4gIHJldHVybiAnIycgKyBfYnMuZGVmYXVsdC5lbmNvZGUobmV3IEJ1ZmZlcihtZW1vLCAnYmluYXJ5JykpO1xufVxuXG52YXIgZW5jb2RlVGVzdCA9IHVuZGVmaW5lZDtcbi8qKlxuICBNZW1vIGVuY3J5cHRpb24gaGFzIGZhaWxlZCBpbiB0aGUgYnJvd3NlciBiZWZvcmUuICBBbiBFcnJvciB3aWxsIGJlIHRocm93blxuICBpZiBhIG1lbW8gY2FuJ3QgYmUgZW5jcnlwdGVkIGFuZCBkZWNyeXB0ZWQuXG4qL1xuXG5mdW5jdGlvbiBjaGVja0VuY3J5cHRpb24oKSB7XG4gIGlmIChlbmNvZGVUZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcGxhaW50ZXh0O1xuICAgIGVuY29kZVRlc3QgPSB0cnVlOyAvLyBwcmV2ZW50IGluZmluYXRlIGxvb3BpbmdcblxuICAgIHRyeSB7XG4gICAgICB2YXIgd2lmID0gJzVKZGVDOVA3UGJkMXVHZEZWRXNKNDFFa0VuQURiYkhHcTZwMUJ3RnhtNnR4TkJzUW5zdyc7XG4gICAgICB2YXIgcHVia2V5ID0gJ0dMUzhtNVVnYUZBQVlRUnVhTmVqWWRTOEZWTFZwOVNzM0sxcUFWazVkZTZGOHMzSG5WYnZBJztcbiAgICAgIHZhciBjeXBoZXJ0ZXh0ID0gZW5jb2RlKHdpZiwgcHVia2V5LCAnI21lbW/niLEnKTtcbiAgICAgIHBsYWludGV4dCA9IGRlY29kZSh3aWYsIGN5cGhlcnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuY29kZVRlc3QgPSBwbGFpbnRleHQgPT09ICcjbWVtb+eIsSc7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuY29kZVRlc3QgPT09IGZhbHNlKSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBlbmNyeXB0aW9uLicpO1xufVxuXG52YXIgdG9Qcml2YXRlT2JqID0gZnVuY3Rpb24gdG9Qcml2YXRlT2JqKG8pIHtcbiAgcmV0dXJuIG8gPyBvLmQgPyBvIDogX2VjYy5Qcml2YXRlS2V5LmZyb21XaWYobykgOiBvXG4gIC8qbnVsbCBvciB1bmRlZmluZWQqL1xuICA7XG59O1xuXG52YXIgdG9QdWJsaWNPYmogPSBmdW5jdGlvbiB0b1B1YmxpY09iaihvKSB7XG4gIHJldHVybiBvID8gby5RID8gbyA6IF9lY2MuUHVibGljS2V5LmZyb21TdHJpbmcobykgOiBvXG4gIC8qbnVsbCBvciB1bmRlZmluZWQqL1xuICA7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qc1wiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTUFYX1RFWFRfUVVPVEVfTEVOR1RIID0gZXhwb3J0cy5NQVhfUFJFVklFV19XSURUSCA9IGV4cG9ydHMuTUFYX1BSRVZJRVdfSEVJR0hUID0gZXhwb3J0cy5NQVhfSU1BR0VfUVVPVEVfTEVOR1RIID0gZXhwb3J0cy5ERUZBVUxUX1ZFUlNJT04gPSBleHBvcnRzLkRFRkFVTFRfQVBQID0gdm9pZCAwO1xuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMubWFrZURhdGVkR3JvdXBzID0gbWFrZURhdGVkR3JvdXBzO1xuZXhwb3J0cy5tYWtlUXVvdGVNc2cgPSBtYWtlUXVvdGVNc2c7XG5leHBvcnRzLm5ld1RleHRNc2cgPSBuZXdUZXh0TXNnO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5pcy1pbnRlZ2VyLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3Rvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0LmpzXCIpO1xuXG52YXIgX2J5dGVidWZmZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJieXRlYnVmZmVyXCIpKTtcblxudmFyIF9hc3NlcnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuXG52YXIgX2JzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiYnM1OFwiKSk7XG5cbnZhciBfdHJ1bmNhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvdHJ1bmNhdGVcIikpO1xuXG52YXIgX2VjYyA9IHJlcXVpcmUoXCIuL2VjY1wiKTtcblxudmFyIF9zZXJpYWxpemVyID0gcmVxdWlyZShcIi4vc2VyaWFsaXplclwiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcblxudmFyIF9wcm9taXNpZnkgPSByZXF1aXJlKFwiLi4vcHJvbWlzaWZ5XCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyB0aHJvdyBfZTI7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTMpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UzOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlcjtcbi8qKiBAY29uc3Qge3N0cmluZ30gREVGQVVMVF9BUFAgXG4gICAgQGRlZmF1bHQgJ2dvbG9zLW1lc3NlbmdlcicgKi9cblxudmFyIERFRkFVTFRfQVBQID0gJ2dvbG9zLW1lc3Nlbmdlcic7XG4vKiogQGNvbnN0IHtzdHJpbmd9IERFRkFVTFRfVkVSU0lPTiBcbiAgICBAZGVmYXVsdCAxICovXG5cbmV4cG9ydHMuREVGQVVMVF9BUFAgPSBERUZBVUxUX0FQUDtcbnZhciBERUZBVUxUX1ZFUlNJT04gPSAxO1xuLyoqIEBjb25zdCB7c3RyaW5nfSBNQVhfUFJFVklFV19XSURUSCBcbiAgICBAZGVmYXVsdCA2MDAgKi9cblxuZXhwb3J0cy5ERUZBVUxUX1ZFUlNJT04gPSBERUZBVUxUX1ZFUlNJT047XG52YXIgTUFYX1BSRVZJRVdfV0lEVEggPSA2MDA7XG4vKiogQGNvbnN0IHtzdHJpbmd9IE1BWF9QUkVWSUVXX0hFSUdIVCBcbiAgICBAZGVmYXVsdCAzMDAgKi9cblxuZXhwb3J0cy5NQVhfUFJFVklFV19XSURUSCA9IE1BWF9QUkVWSUVXX1dJRFRIO1xudmFyIE1BWF9QUkVWSUVXX0hFSUdIVCA9IDMwMDtcbi8qKiBAY29uc3Qge3N0cmluZ30gTUFYX1RFWFRfUVVPVEVfTEVOR1RIXG4gICAgQGRlZmF1bHQgMjAwICovXG5cbmV4cG9ydHMuTUFYX1BSRVZJRVdfSEVJR0hUID0gTUFYX1BSRVZJRVdfSEVJR0hUO1xudmFyIE1BWF9URVhUX1FVT1RFX0xFTkdUSCA9IDIwMDtcbi8qKiBAY29uc3Qge3N0cmluZ30gTUFYX0lNQUdFX1FVT1RFX0xFTkdUSFxuICAgIEBkZWZhdWx0IDIwMDAgKi9cblxuZXhwb3J0cy5NQVhfVEVYVF9RVU9URV9MRU5HVEggPSBNQVhfVEVYVF9RVU9URV9MRU5HVEg7XG52YXIgTUFYX0lNQUdFX1FVT1RFX0xFTkdUSCA9IDIwMDA7XG5leHBvcnRzLk1BWF9JTUFHRV9RVU9URV9MRU5HVEggPSBNQVhfSU1BR0VfUVVPVEVfTEVOR1RIO1xuXG52YXIgdG9Qcml2YXRlT2JqID0gZnVuY3Rpb24gdG9Qcml2YXRlT2JqKG8pIHtcbiAgcmV0dXJuIG8gPyBvLmQgPyBvIDogX2VjYy5Qcml2YXRlS2V5LmZyb21XaWYobykgOiBvXG4gIC8qbnVsbCBvciB1bmRlZmluZWQqL1xuICA7XG59O1xuXG52YXIgdG9QdWJsaWNPYmogPSBmdW5jdGlvbiB0b1B1YmxpY09iaihvKSB7XG4gIHJldHVybiBvID8gby5RID8gbyA6IF9lY2MuUHVibGljS2V5LmZyb21TdHJpbmcobykgOiBvXG4gIC8qbnVsbCBvciB1bmRlZmluZWQqL1xuICA7XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUFwcFZlcnNpb24oYXBwLCB2ZXJzaW9uKSB7XG4gICgwLCBfYXNzZXJ0LmRlZmF1bHQpKHR5cGVvZiBhcHAgPT09ICdzdHJpbmcnICYmIGFwcC5sZW5ndGggPj0gMSAmJiBhcHAubGVuZ3RoIDw9IDE2LCAnbWVzc2FnZS5hcHAgc2hvdWxkIGJlIGEgc3RyaW5nLCA+PSAxLCA8PSAxNicpO1xuICAoMCwgX2Fzc2VydC5kZWZhdWx0KShpc0ludGVnZXIodmVyc2lvbikgJiYgdmVyc2lvbiA+PSAxLCAnbWVzc2FnZS52ZXJzaW9uIHNob3VsZCBiZSBhbiBpbnRlZ2VyLCA+PSAxJyk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQm9keShib2R5KSB7XG4gICgwLCBfYXNzZXJ0LmRlZmF1bHQpKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJywgJ21lc3NhZ2UuYm9keSBzaG91bGQgYmUgYSBzdHJpbmcnKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVJbWFnZU1zZyhtc2cpIHtcbiAgKDAsIF9hc3NlcnQuZGVmYXVsdCkoaXNJbnRlZ2VyKG1zZy5wcmV2aWV3V2lkdGgpICYmIG1zZy5wcmV2aWV3V2lkdGggPj0gMSAmJiBtc2cucHJldmlld1dpZHRoIDw9IE1BWF9QUkVWSUVXX1dJRFRILCAnbWVzc2FnZS5wcmV2aWV3V2lkdGggKGZvciBpbWFnZSkgc2hvdWxkIGJlIGFuIGludGVnZXIsID49IDEsIDw9ICcgKyBNQVhfUFJFVklFV19XSURUSCk7XG4gICgwLCBfYXNzZXJ0LmRlZmF1bHQpKGlzSW50ZWdlcihtc2cucHJldmlld0hlaWdodCkgJiYgbXNnLnByZXZpZXdIZWlnaHQgPj0gMSAmJiBtc2cucHJldmlld0hlaWdodCA8PSBNQVhfUFJFVklFV19IRUlHSFQsICdtZXNzYWdlLnByZXZpZXdIZWlnaHQgKGZvciBpbWFnZSkgc2hvdWxkIGJlIGFuIGludGVnZXIsID49IDEsIDw9ICcgKyBNQVhfUFJFVklFV19IRUlHSFQpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU1zZ1dpdGhRdW90ZShtc2cpIHtcbiAgaWYgKG1zZy5xdW90ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgKDAsIF9hc3NlcnQuZGVmYXVsdCkoX3R5cGVvZihtc2cucXVvdGUpID09PSAnb2JqZWN0JywgJ21lc3NhZ2UucXVvdGUgc2hvdWxkIGJlIGFuIG9iamVjdCBvciB1bmRlZmluZWQgYXQgYWxsJyk7XG4gICAgKDAsIF9hc3NlcnQuZGVmYXVsdCkodHlwZW9mIG1zZy5xdW90ZS5mcm9tID09PSAnc3RyaW5nJyAmJiBtc2cucXVvdGUuZnJvbS5sZW5ndGggPj0gMSAmJiBtc2cucXVvdGUuZnJvbS5sZW5ndGggPD0gMTYsICdtZXNzYWdlLnF1b3RlLmZyb20gc2hvdWxkIGJlIGEgdmFsaWQgbmlja25hbWUgb2Ygc2VuZGVyIG9mIG1lc3NhZ2UsIHRvIHdoaWNoIHRoaXMgcmVwbHkgaXMnKTtcbiAgICAoMCwgX2Fzc2VydC5kZWZhdWx0KSh0eXBlb2YgbXNnLnF1b3RlLm5vbmNlID09PSAnc3RyaW5nJyAmJiBtc2cucXVvdGUubm9uY2UubGVuZ3RoLCAnbWVzc2FnZS5xdW90ZS5ub25jZSBzaG91bGQgYmUgYSB2YWxpZCBub25jZSBvZiBtZXNzYWdlLCB0byB3aGljaCB0aGlzIHJlcGx5IGlzJyk7XG5cbiAgICBpZiAobXNnLnF1b3RlLnR5cGUgIT09ICdpbWFnZScpIHtcbiAgICAgICgwLCBfYXNzZXJ0LmRlZmF1bHQpKHR5cGVvZiBtc2cucXVvdGUuYm9keSA9PT0gJ3N0cmluZycgJiYgbXNnLnF1b3RlLmJvZHkubGVuZ3RoIDw9IE1BWF9URVhUX1FVT1RFX0xFTkdUSCwgJ21lc3NhZ2UucXVvdGUuYm9keSBzaG91bGQgYmUgYSB0cnVuY2F0ZWQgKGxlbmd0aCA8PSAyMDApIHRleHQgb2YgbWVzc2FnZSwgdG8gd2hpY2ggdGhpcyByZXBseSBpcycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAoMCwgX2Fzc2VydC5kZWZhdWx0KSh0eXBlb2YgbXNnLnF1b3RlLmJvZHkgPT09ICdzdHJpbmcnICYmIG1zZy5xdW90ZS5ib2R5Lmxlbmd0aCA8PSBNQVhfSU1BR0VfUVVPVEVfTEVOR1RILCAnbWVzc2FnZS5xdW90ZS5ib2R5IHNob3VsZCBiZSBhIHRydW5jYXRlZCAobGVuZ3RoIDw9IDIwMDApIGltYWdlIFVSTCBmcm9tIG1lc3NhZ2UsIHRvIHdoaWNoIHRoaXMgcmVwbHkgaXMnKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICAgIENyZWF0ZXMgbmV3IG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBlbmNvZGVkIGJ5IGdvbG9zLm1lc3NhZ2VzLmVuY29kZS5cbiAgICBAYXJnIHtzdHJpbmd9IHRleHQgLSB0ZXh0IChcImJvZHlcIikgb2YgdGhlIG1lc3NhZ2UuXG4gICAgQGFyZyB7c3RyaW5nfSBbYXBwID0gREVGQVVMVF9BUFBdIC0gXCJhcHBcIiBmaWVsZCBvZiB0aGUgbWVzc2FnZS4gU2hvdWxkIGJlIGEgc3RyaW5nIHdpdGggbGVuZ3RoIGZyb20gMSB0byAxNi5cbiAgICBAYXJnIHtzdHJpbmd9IFt2ZXJzaW9uID0gREVGQVVMVF9WRVJTSU9OXSAtIFwidmVyc2lvblwiIGZpZWxkIG9mIHRoZSBtZXNzYWdlLiBTaG91bGQgYmUgYW4gaW50ZWdlciwgc3RhcnRpbmcgb2YgMS5cbiAgICBAdGhyb3dzIHtFeGNlcHRpb259IHdoZW4gc3VwcGxpZWQgZGF0YSBpcyBpbnZhbGlkLlxuICAgIEByZXR1cm4ge29iamVjdH0gLSByZXN1bHQgbWVzc2FnZSBvYmplY3QuXG4qL1xuXG5cbmZ1bmN0aW9uIG5ld1RleHRNc2codGV4dCkge1xuICB2YXIgYXBwID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBERUZBVUxUX0FQUDtcbiAgdmFyIHZlcnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IERFRkFVTFRfVkVSU0lPTjtcbiAgdmFsaWRhdGVCb2R5KHRleHQpO1xuICB2YWxpZGF0ZUFwcFZlcnNpb24oYXBwLCB2ZXJzaW9uKTtcbiAgdmFyIG1zZyA9IHtcbiAgICBhcHA6IGFwcCxcbiAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgIGJvZHk6IHRleHRcbiAgfTtcbiAgcmV0dXJuIG1zZztcbn1cbi8qKlxuICAgIENyZWF0ZXMgbmV3IGltYWdlIG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBlbmNvZGVkIGJ5IGdvbG9zLm1lc3NhZ2VzLmVuY29kZS5cbiAgICBAYXJnIHtzdHJpbmd9IGltYWdlX3VybCAtIFVSTCBvZiB0aGUgaW1hZ2UgaW4gdGhlIEludGVybmV0IChwbGVhc2UgdXNlIGh0dHBzOi8vLCBhbmQgc3RvcmUgaW1hZ2VzIGluIGltYWdlIGhvc3RpbmdzLCB0byBtYWtlIHRoZW0gc3RvcmluZyBldGVybmFsbHkpLiBUaGlzIFVSTCB3aWxsIGJlIGEgXCJib2R5XCIgb2YgdGhlIG1lc3NhZ2UuXG4gICAgQGFyZyB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gY2FsbGJhY2suIFBhcmFtcyBhcmUgPGNvZGU+KGVyciwgbWVzc2FnZSk8L2NvZGU+LiBDYWxsaW5nIGFmdGVyIG1lc3NhZ2UgY29uc3RydWN0aW9uIChlcnIgaXMgbnVsbCBpbiB0aGlzIGNhc2UpLCBvciBpZiBlcnJvciBvY2N1cmVkIChlcnIgaXMgZXhjZXB0aW9uLCBtZXNzYWdlIGlzIG51bGwpLlxuICAgIEBhcmcge2Z1bmN0aW9ufSBbb25fcHJvZ3Jlc3MgPSB1bmRlZmluZWRdIC0gcHJvZ3Jlc3MgY2FsbGJhY2suIFBhcmFtcyBhcmUgPGNvZGU+KHBlcmNlbnQsIGV4dHJhX2RhdGEpPC9jb2RlPi4gUGVyY2VudCBpcyBpbnRlZ2VyIGZyb20gMSB0byAxMDAuXG4gICAgQGFyZyB7c3RyaW5nfSBbYXBwID0gREVGQVVMVF9BUFBdIC0gXCJhcHBcIiBmaWVsZCBvZiB0aGUgbWVzc2FnZS4gU2hvdWxkIGJlIGEgc3RyaW5nIHdpdGggbGVuZ3RoIGZyb20gMSB0byAxNi5cbiAgICBAYXJnIHtzdHJpbmd9IFt2ZXJzaW9uID0gREVGQVVMVF9WRVJTSU9OXSAtIFwidmVyc2lvblwiIGZpZWxkIG9mIHRoZSBtZXNzYWdlLiBTaG91bGQgYmUgYW4gaW50ZWdlciwgc3RhcnRpbmcgb2YgMS5cbiAgICBAdGhyb3dzIHtFeGNlcHRpb259IG9ubHkgaWYgY2FsbGJhY2sgY2FsbGVkIGR1ZSBlcnJvciwgYW5kIGNhbGxiYWNrIGFsc28gdGhyb3dzIGVycm9yLiBTbyBjYWxsYmFjayBzaG91bGRuJ3QgdGhyb3cgZXJyb3JzLlxuKi9cblxuXG5leHBvcnRzLm5ld0ltYWdlTXNnID0gZnVuY3Rpb24gKGltYWdlX3VybCwgY2FsbGJhY2spIHtcbiAgdmFyIG9uX3Byb2dyZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBhcHAgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IERFRkFVTFRfQVBQO1xuICB2YXIgdmVyc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogREVGQVVMVF9WRVJTSU9OO1xuXG4gIHZhciByZXBvcnRQcm9ncmVzcyA9IGZ1bmN0aW9uIHJlcG9ydFByb2dyZXNzKHByb2dyZXNzKSB7XG4gICAgdmFyIGVycm9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgIGlmIChvbl9wcm9ncmVzcykgb25fcHJvZ3Jlc3MocHJvZ3Jlc3MsIHtcbiAgICAgIGVycm9yOiBlcnJvclxuICAgIH0pO1xuICB9O1xuXG4gIHRyeSB7XG4gICAgKDAsIF9hc3NlcnQuZGVmYXVsdCkodHlwZW9mIEltYWdlICE9PSAndW5kZWZpbmVkJywgJ0N1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBJbWFnZSgpJyk7XG4gICAgKDAsIF9hc3NlcnQuZGVmYXVsdCkoaW1hZ2VfdXJsLCAnaW1hZ2VfdXJsIGlzIHJlcXVpcmVkJyk7XG4gICAgKDAsIF9hc3NlcnQuZGVmYXVsdCkoY2FsbGJhY2ssICdjYWxsYmFjayBpcyByZXF1aXJlZCcpO1xuICAgIHZhbGlkYXRlQXBwVmVyc2lvbihhcHAsIHZlcnNpb24pO1xuICAgIHJlcG9ydFByb2dyZXNzKDApO1xuXG4gICAgdmFyIHJlcG9ydExvYWRFcnJvciA9IGZ1bmN0aW9uIHJlcG9ydExvYWRFcnJvcihlcnJvclRleHQpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoZXJyb3JUZXh0KTtcbiAgICAgIHJlcG9ydFByb2dyZXNzKDEwMCwgZXJyKTtcbiAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgfTtcblxuICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICB2YXIgd2F0Y2hkb2c7XG5cbiAgICB2YXIgY2xlYXJXYXRjaGRvZyA9IGZ1bmN0aW9uIGNsZWFyV2F0Y2hkb2coKSB7XG4gICAgICBpZiAod2F0Y2hkb2cpIGNsZWFyVGltZW91dCh3YXRjaGRvZyk7XG4gICAgfTtcblxuICAgIGltZy5vbmVycm9yID0gaW1nLm9uYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhcldhdGNoZG9nKCk7XG4gICAgICByZXBvcnRMb2FkRXJyb3IoJ0Nhbm5vdCBsb2FkIGltYWdlJyk7XG4gICAgfTtcblxuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhcldhdGNoZG9nKCk7XG4gICAgICByZXBvcnRQcm9ncmVzcygxMDApO1xuICAgICAgdmFyIHByZXZpZXdTaXplID0gKDAsIF91dGlscy5maXRJbWFnZVRvU2l6ZSkoaW1nLndpZHRoLCBpbWcuaGVpZ2h0LCBNQVhfUFJFVklFV19XSURUSCwgTUFYX1BSRVZJRVdfSEVJR0hUKTtcbiAgICAgIHZhciBtc2cgPSB7XG4gICAgICAgIGFwcDogYXBwLFxuICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICBib2R5OiBpbWFnZV91cmwsXG4gICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgIHByZXZpZXdXaWR0aDogcHJldmlld1NpemUud2lkdGgsXG4gICAgICAgIHByZXZpZXdIZWlnaHQ6IHByZXZpZXdTaXplLmhlaWdodFxuICAgICAgfTtcbiAgICAgIHZhbGlkYXRlSW1hZ2VNc2cobXNnKTtcbiAgICAgIGNhbGxiYWNrKG51bGwsIG1zZyk7XG4gICAgfTtcblxuICAgIHdhdGNoZG9nID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWltZy5jb21wbGV0ZSkge1xuICAgICAgICBpbWcub25sb2FkID0gaW1nLm9uZXJyb3IgPSBpbWcub25hYm9ydCA9IHt9O1xuICAgICAgICByZXBvcnRMb2FkRXJyb3IoJ0ltYWdlIGxvYWQgdGltZWQgb3V0LCBtYXliZSBpdCBpcyB0b28gbGFyZ2UnKTtcbiAgICAgIH1cbiAgICB9LCA1MDAwKTtcbiAgICBpbWcuc3JjID0gaW1hZ2VfdXJsO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXBvcnRQcm9ncmVzcygxMDAsIGVycik7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIsIG51bGwpO1xuICB9XG59O1xuLyoqXG4gICAgQ3JlYXRlcyBuZXcgaW1hZ2UgbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGVuY29kZWQgYnkgZ29sb3MubWVzc2FnZXMuZW5jb2RlLiBBc3luYyB2ZXJzaW9uIG9mIGZ1bmN0aW9uLCBzaG91bGQgYmUgY2FsbGVkIHdpdGggYXdhaXQuXG4gICAgQGFyZyB7c3RyaW5nfSBpbWFnZV91cmwgLSBVUkwgb2YgdGhlIGltYWdlIGluIHRoZSBJbnRlcm5ldC4gSXQgd2lsbCBiZSBhIFwiYm9keVwiIG9mIHRoZSBtZXNzYWdlLlxuICAgIEBhcmcge2Z1bmN0aW9ufSBbb25fcHJvZ3Jlc3MgPSB1bmRlZmluZWRdIC0gcHJvZ3Jlc3MgY2FsbGJhY2suIFBhcmFtcyBhcmUgPGNvZGU+KHBlcmNlbnQsIGV4dHJhX2RhdGEpPC9jb2RlPi4gUGVyY2VudCBpcyBpbnRlZ2VyIGZyb20gMSB0byAxMDAuXG4gICAgQGFyZyB7c3RyaW5nfSBbYXBwID0gREVGQVVMVF9BUFBdIC0gXCJhcHBcIiBmaWVsZCBvZiB0aGUgbWVzc2FnZS4gU2hvdWxkIGJlIGEgc3RyaW5nIHdpdGggbGVuZ3RoIGZyb20gMSB0byAxNi5cbiAgICBAYXJnIHtzdHJpbmd9IFt2ZXJzaW9uID0gREVGQVVMVF9WRVJTSU9OXSAtIFwidmVyc2lvblwiIGZpZWxkIG9mIHRoZSBtZXNzYWdlLiBTaG91bGQgYmUgYW4gaW50ZWdlciwgc3RhcnRpbmcgb2YgMS5cbiAgICBAdGhyb3dzIHtFeGNlcHRpb259IGlmIGVycm9yIG9jY3VyZWQuXG4gICAgQHJldHVybiB7b2JqZWN0fSAtIHJlc3VsdCBtZXNzYWdlIG9iamVjdC5cbiAgICBAZnVuY3Rpb24gbmV3SW1hZ2VNc2dBc3luY1xuKi9cblxuXG5leHBvcnRzLm5ld0ltYWdlTXNnQXN5bmMgPSAoMCwgX3Byb21pc2lmeS5wcm9taXNpZnkpKGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBjYWxsYmFjayA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcblxuICB2YXIgX2FyZ3Mkc2xpY2UgPSBhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSksXG4gICAgICBfYXJncyRzbGljZTIgPSBfc2xpY2VkVG9BcnJheShfYXJncyRzbGljZSwgNCksXG4gICAgICBpbWFnZV91cmwgPSBfYXJncyRzbGljZTJbMF0sXG4gICAgICBvbl9wcm9ncmVzcyA9IF9hcmdzJHNsaWNlMlsxXSxcbiAgICAgIGFwcCA9IF9hcmdzJHNsaWNlMlsyXSxcbiAgICAgIHZlcnNpb24gPSBfYXJncyRzbGljZTJbM107XG5cbiAgcmV0dXJuIGV4cG9ydHMubmV3SW1hZ2VNc2coaW1hZ2VfdXJsLCBjYWxsYmFjaywgb25fcHJvZ3Jlc3MsIGFwcCwgdmVyc2lvbik7XG59KTtcbi8qKlxuICAgIE1ha2VzIHlvdXIgbWVzc2FnZSB0aGUgcmVwbHkgdG8gYW5vdGhlciBtZXNzYWdlX29iamVjdC4gQ2FsbCBpdCBhZnRlciBgbmV3VGV4dE1zZ2AvYG5ld0ltYWdlTXNnYC9ldGMsIG5leHQgY2FsbCBgZW5jb2RlYCwgYW5kIGZpbmFsbHkgc2VuZCByZXN1bHRpbmcgbWVzc2FnZSBhcyB1c3VhbGx5LlxuICAgIEBhcmcge29iamVjdH0gbXNnID0gWW91ciBtZXNzYWdlLCBjcmVhdGVkIGJ5IGBuZXdUZXh0TXNnYCwgYG5ld0ltYWdlTXNnYCwgZXRjLlxuICAgIEBhcmcge29iamVjdH0gcXVvdGVkX21lc3NhZ2Vfb2JqZWN0ID0gTWVzc2FnZSB0byB3aGljaCB5b3Ugd2FudCB0byByZXBseS4gSXQgc2hvdWxkIGJlIG9uZSBvZiBtZXNzYWdlcyByZXR1cm5lZCBieSBgZ29sb3MubWVzc2FnZXMuZGVjb2RlYCwgYW5kIGhhdmUgXCJmcm9tXCIsIFwibm9uY2VcIiwgYW5kICh3YXJuaW5nISkgXCJtZXNzYWdlXCIuIElmIG1lc3NhZ2UgaXMgaW52YWxpZCAoY2Fubm90IGJlIGRlY29kZWQpLCBpdCBoYXMgbm8gXCJtZXNzYWdlXCIgZmllbGQsIGFuZCBpZiB5b3UgdHJ5IHJlcGx5IGl0LCBpdCB3aWxsIHRocm93LlxuICAgIEB0aHJvd3Mge0V4Y2VwdGlvbn0gaWYgcXVvdGVkX21lc3NhZ2Vfb2JqZWN0IGlzIGludmFsaWQuXG4gICAgQHJldHVybiB7b2JqZWN0fSAtIHJlc3VsdCBtZXNzYWdlIG9iamVjdCwgd2hpY2ggY2FuIGJlIGVuY29kZWQgYW5kIHNlbnQuXG4gICAgQGZ1bmN0aW9uIG5ld0ltYWdlTXNnQXN5bmNcbiovXG5cbmZ1bmN0aW9uIG1ha2VRdW90ZU1zZyhtc2csIHF1b3RlZF9tZXNzYWdlX29iamVjdCkge1xuICAoMCwgX2Fzc2VydC5kZWZhdWx0KShxdW90ZWRfbWVzc2FnZV9vYmplY3QsICdxdW90ZWRfbWVzc2FnZV9vYmplY3QgaXMgcmVxdWlyZWQnKTtcbiAgdmFyIGFzc2VydFByZWZpeCA9ICdxdW90ZWRfbWVzc2FnZV9vYmplY3Qgc2hvdWxkIGJlIG9uZSBvZiBWQUxJRCBvYmplY3RzLCByZXR1cm5lZCBieSBgZ29sb3MubWVzc2FnZXMuZGVjb2RlYCc7XG4gICgwLCBfYXNzZXJ0LmRlZmF1bHQpKHF1b3RlZF9tZXNzYWdlX29iamVjdC5mcm9tLCBcIlwiLmNvbmNhdChhc3NlcnRQcmVmaXgsIFwiLCBhbmQgaGF2ZSBcXFwiZnJvbVxcXCIgZmllbGRcIikpO1xuICAoMCwgX2Fzc2VydC5kZWZhdWx0KShxdW90ZWRfbWVzc2FnZV9vYmplY3Qubm9uY2UsIFwiXCIuY29uY2F0KGFzc2VydFByZWZpeCwgXCIsIGFuZCBoYXZlIFxcXCJub25jZVxcXCIgZmllbGRcIikpO1xuICAoMCwgX2Fzc2VydC5kZWZhdWx0KShxdW90ZWRfbWVzc2FnZV9vYmplY3QubWVzc2FnZSwgXCJcIi5jb25jYXQoYXNzZXJ0UHJlZml4LCBcIiwgYW5kIGhhdmUgXFxcIm1lc3NhZ2VcXFwiIGZpZWxkXCIpKTtcbiAgKDAsIF9hc3NlcnQuZGVmYXVsdCkocXVvdGVkX21lc3NhZ2Vfb2JqZWN0Lm1lc3NhZ2UuYm9keSwgXCJcIi5jb25jYXQoYXNzZXJ0UHJlZml4LCBcIiwgYW5kIGhhdmUgXFxcIm1lc3NhZ2VcXFwiIGZpZWxkIHdpdGggXFxcImJvZHlcXFwiXCIpKTtcbiAgdmFyIHR5cGUgPSBxdW90ZWRfbWVzc2FnZV9vYmplY3QubWVzc2FnZS50eXBlO1xuICB2YXIgYm9keSA9IHF1b3RlZF9tZXNzYWdlX29iamVjdC5tZXNzYWdlLmJvZHk7XG5cbiAgaWYgKHR5cGUgIT09ICdpbWFnZScpIHtcbiAgICBib2R5ID0gKDAsIF90cnVuY2F0ZS5kZWZhdWx0KShib2R5LCB7XG4gICAgICBsZW5ndGg6IE1BWF9URVhUX1FVT1RFX0xFTkdUSCxcbiAgICAgIG9taXNzaW9uOiAnLi4uJ1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChib2R5Lmxlbmd0aCA+IE1BWF9JTUFHRV9RVU9URV9MRU5HVEgpIHtcbiAgICAgIGJvZHkgPSAoMCwgX3RydW5jYXRlLmRlZmF1bHQpKGJvZHksIHtcbiAgICAgICAgbGVuZ3RoOiBNQVhfVEVYVF9RVU9URV9MRU5HVEgsXG4gICAgICAgIG9taXNzaW9uOiAnLi4uJ1xuICAgICAgfSk7XG4gICAgICB0eXBlID0gdW5kZWZpbmVkOyAvLyBtYWtlIGl0IHRleHRcbiAgICB9XG4gIH1cblxuICBpZiAoIW1zZykgbXNnID0ge307XG4gIG1zZy5xdW90ZSA9IHtcbiAgICBmcm9tOiBxdW90ZWRfbWVzc2FnZV9vYmplY3QuZnJvbSxcbiAgICBub25jZTogcXVvdGVkX21lc3NhZ2Vfb2JqZWN0Lm5vbmNlLFxuICAgIGJvZHk6IGJvZHlcbiAgfTtcbiAgaWYgKHR5cGUpIG1zZy5xdW90ZS50eXBlID0gdHlwZTtcbiAgcmV0dXJuIG1zZztcbn1cblxuZnVuY3Rpb24gZm9yRWFjaE1lc3NhZ2UobWVzc2FnZV9vYmplY3RzLCBiZWdpbl9pZHgsIGVuZF9pZHgsIGNhbGxiYWNrKSB7XG4gIGlmIChiZWdpbl9pZHggPT09IHVuZGVmaW5lZCkgYmVnaW5faWR4ID0gMDtcbiAgaWYgKGVuZF9pZHggPT09IHVuZGVmaW5lZCkgZW5kX2lkeCA9IG1lc3NhZ2Vfb2JqZWN0cy5sZW5ndGg7XG4gIHZhciBzdGVwID0gZW5kX2lkeCA+IGJlZ2luX2lkeCA/IDEgOiAtMTtcblxuICBmb3IgKHZhciBpID0gYmVnaW5faWR4OyBpICE9IGVuZF9pZHg7IGkgKz0gc3RlcCkge1xuICAgIHZhciBtZXNzYWdlX29iamVjdCA9IG1lc3NhZ2Vfb2JqZWN0c1tpXTsgLy8gcmV0dXJuIHRydWUgaXMgYGNvbnRpbnVlYFxuICAgIC8vIHJldHVybiBmYWxzZSBpcyBgYnJlYWtgXG5cbiAgICBpZiAoIWNhbGxiYWNrKG1lc3NhZ2Vfb2JqZWN0LCBpKSkgYnJlYWs7XG4gIH1cbn1cbi8qKlxuICAgIERlY29kZXMgbWVzc2FnZXMgb2YgZm9ybWF0IHVzZWQgYnkgZ29sb3MubWVzc2FnZXMuZW5jb2RlKCksIHdoaWNoIGFyZSBsZW5ndGgtcHJlZml4ZWQsIGFuZCBhbHNvIG1lc3NhZ2VzIHNlbnQgYnkgYW5vdGhlciB3YXkgKG5vdCBsZW5ndGgtcHJlZml4ZWQpLjxicj5cbiAgICBBbHNvLCBwYXJzZXMgKEpTT04pIGFuZCB2YWxpZGF0ZXMgZWFjaCBtZXNzYWdlIChhcHAsIHZlcnNpb24uLi4pLiAoSW52YWxpZCBtZXNzYWdlcyBhcmUgYWxzbyBhZGRlZCB0byByZXN1bHQsIGl0IGlzIG5lZWQgdG8gbWFyayB0aGVtIGFzIHJlYWQuIFRvIGNoYW5nZSBpdCwgdXNlIDxjb2RlPm9uX2Vycm9yPC9jb2RlPikuPGJyPlxuICAgIFByb2Nlc3NlcyB3aG9sZSBpbmNvbWluZyBhcnJheSwgb3Igb25seSBwYXJ0IG9mIGl0Ljxicj5cbiAgICBDYW4gcHJvY2VzcyBpbiByZXZlcnNlZCBvcmRlci5cbiAgICBAYXJnIHtzdHJpbmd8UHJpdmF0ZUtleX0gcHJpdmF0ZV9tZW1vX2tleSAtIHByaXZhdGUgbWVtbyBrZXkgb2YgXCJmcm9tXCIgb3IgXCJ0b1wiLlxuICAgIEBhcmcge3N0cmluZ3xQdWJsaWNLZXl9IHNlY29uZF91c2VyX3B1YmxpY19tZW1vX2tleSAtIHB1YmxpYyBtZW1vIGtleSBvZiBzZWNvbmQgdXNlci5cbiAgICBAYXJnIHthcnJheX0gbWVzc2FnZV9vYmplY3RzIC0gYXJyYXkgb2Ygb2JqZWN0cy4gRWFjaCBvYmplY3Qgc2hvdWxkIGNvbnRhaW4gbm9uY2UsIGNoZWNrc3VtIGFuZCBlbmNyeXB0ZWRfbWVzc2FnZSAoc3VjaCBvYmplY3QgcmV0dXJucyBmcm9tIHByaXZhdGVfbWVzc2FnZSBBUEkpLlxuICAgIEBhcmcge2Z1bmN0aW9ufSBbYmVmb3JlX2RlY29kZSA9IHVuZGVmaW5lZF0gLSBjYWxsYmFjaywgY2FsbGluZyBvbiBlYWNoIG1lc3NhZ2UgYmVmb3JlIHByb2Nlc3NpbmcuIFBhcmFtcyBhcmUgPGNvZGU+KG1lc3NhZ2UsIGlkeCwgcmVzdWx0cyk8L2NvZGU+LiBJZiByZXR1cm5zIHRydWUsIG1lc3NhZ2Ugd2lsbCBub3QgYmUgcHJvY2Vzc2VkLiBBbHNvLCB5b3UgY2FuIHB1c2ggaXQgdG8gPGNvZGU+cmVzdWx0czwvY29kZT4gbWFudWFsbHkuXG4gICAgQGFyZyB7ZnVuY3Rpb259IFtmb3JfZWFjaCA9IHVuZGVmaW5lZF0gLSBjYWxsYmFjaywgY2FsbGluZyBvbiBlYWNoIG1lc3NhZ2UsIGFmdGVyIG1lc3NhZ2UgaXMgZGVjb2RlZCwgcGFyc2VkIGFuZCB2YWxpZGF0ZWQsIGJ1dCBiZWZvcmUgYWRkIGl0IHRvIHJlc3VsdCBhcnJheS4gUGFyYW1zIGFyZSA8Y29kZT4obWVzc2FnZSwgaWR4KTwvY29kZT4uIElmIHJldHVybnMgdHJ1ZSwgbWVzc2FnZSB3aWxsbid0IGJlIGFkZGVkIHRvIHJlc3VsdCBhcnJheS5cbiAgICBAYXJnIHtmdW5jdGlvbn0gW29uX2Vycm9yID0gdW5kZWZpbmVkXSAtIGNhbGxiYWNrLCBjYWxsaW5nIG9uIGVhY2ggbWVzc2FnZSB3aGljaCBjYW4ndCBiZSBkZWNyeXB0ZWQsIHBhcnNlZCwgdmFsaWRhdGVkLCBvciBpZiA8Y29kZT5mb3JfZWFjaDwvY29kZT4gdGhyb3dzLiBQYXJhbXMgYXJlIDxjb2RlPihtZXNzYWdlLCBpZHgsIGV4Y2VwdGlvbik8L2NvZGU+LiBJZiByZXR1cm5zIHRydWUsIG1lc3NhZ2Ugd2lsbG4ndCBiZSBhZGRlZCB0byByZXN1bHQgYXJyYXkuXG4gICAgQGFyZyB7aW50fSBbYmVnaW5faWR4ID0gdW5kZWZpbmVkXSAtIGlmIHNldCwgZnVuY3Rpb24gd2lsbCBwcm9jZXNzIG1lc3NhZ2VzIG9ubHkgZnJvbSB0aGlzIGluZGV4IChpbmNsLikuIElmIGJlZ2luX2lkeCA+IGVuZF9pZHgsIG1lc3NhZ2VzIHdpbGwgYmUgcHJvY2Vzc2VkIGluIHJldmVyc2VkIG9yZGVyLlxuICAgIEBhcmcge2ludH0gW2VuZF9pZHggPSB1bmRlZmluZWRdIC0gaWYgc2V0LCBmdW5jdGlvbiB3aWxsIHByb2Nlc3MgbWVzc2FnZXMgb25seSBiZWZvcmUgdGhpcyBpbmRleCAoZXhjbC4pLiBJZiBlbmRfaWR4IDwgYmVnaW5faWR4LCBtZXNzYWdlcyB3aWxsIGJlIHByb2Nlc3NlZCBpbiByZXZlcnNlZCBvcmRlci5cbiAgICBAYXJnIHtib29sfSBbcmF3X21lc3NhZ2VzID0gZmFsc2VdIC0gaWYgc2V0LCBmdW5jdGlvbiB3aWxsIG5vdCBwYXJzZSBtZXNzYWdlcyBhcyBKU09OIGFuZCB2YWxpZGF0ZSB0aGVtLlxuICAgIEByZXR1cm4ge2FycmF5fSAtIHJlc3VsdCBhcnJheSBvZiBtZXNzYWdlX29iamVjdHMuIEVhY2ggb2JqZWN0IGhhcyBcIm1lc3NhZ2VcIiBhbmQgXCJyYXdfbWVzc2FnZVwiIGZpZWxkcy4gSWYgbWVzc2FnZSBpcyBpbnZhbGlkLCBpdCBoYXMgb25seSBcInJhd19tZXNzYWdlXCIgZmllbGQuIEFuZCBpZiBtZXNzYWdlIGNhbm5vdCBiZSBkZWNvZGVkIGF0IGFsbCwgaXQgaGFzbid0IGFueSBvZiB0aGVzZSBmaWVsZHMuXG4qL1xuXG5cbmZ1bmN0aW9uIGRlY29kZShwcml2YXRlX21lbW9fa2V5LCBzZWNvbmRfdXNlcl9wdWJsaWNfbWVtb19rZXksIG1lc3NhZ2Vfb2JqZWN0cykge1xuICB2YXIgYmVmb3JlX2RlY29kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICB2YXIgZm9yX2VhY2ggPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgdmFyIG9uX2Vycm9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB1bmRlZmluZWQ7XG4gIHZhciBiZWdpbl9pZHggPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZF9pZHggPSBhcmd1bWVudHMubGVuZ3RoID4gNyAmJiBhcmd1bWVudHNbN10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s3XSA6IHVuZGVmaW5lZDtcbiAgdmFyIHJhd19tZXNzYWdlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA4ICYmIGFyZ3VtZW50c1s4XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzhdIDogZmFsc2U7XG4gICgwLCBfYXNzZXJ0LmRlZmF1bHQpKHByaXZhdGVfbWVtb19rZXksICdwcml2YXRlX21lbW9fa2V5IGlzIHJlcXVpcmVkJyk7XG4gICgwLCBfYXNzZXJ0LmRlZmF1bHQpKHNlY29uZF91c2VyX3B1YmxpY19tZW1vX2tleSwgJ3NlY29uZF91c2VyX3B1YmxpY19tZW1vX2tleSBpcyByZXF1aXJlZCcpO1xuICAoMCwgX2Fzc2VydC5kZWZhdWx0KShtZXNzYWdlX29iamVjdHMsICdtZXNzYWdlX29iamVjdHMgaXMgcmVxdWlyZWQnKTsgLy8gTW9zdCBcImhlYXZ5XCIgbGluZXNcblxuICB2YXIgcHJpdmF0ZV9rZXkgPSB0b1ByaXZhdGVPYmoocHJpdmF0ZV9tZW1vX2tleSk7XG4gIHZhciBwdWJsaWNfa2V5ID0gdG9QdWJsaWNPYmooc2Vjb25kX3VzZXJfcHVibGljX21lbW9fa2V5KTtcbiAgdmFyIHNoYXJlZF9zZWNyZXQgPSBwcml2YXRlX2tleS5nZXRfc2hhcmVkX3NlY3JldChwdWJsaWNfa2V5KTtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgZm9yRWFjaE1lc3NhZ2UobWVzc2FnZV9vYmplY3RzLCBiZWdpbl9pZHgsIGVuZF9pZHgsIGZ1bmN0aW9uIChtZXNzYWdlX29iamVjdCwgaSkge1xuICAgIC8vIFJldHVybiB0cnVlIGlmIGZvcl9lYWNoIHNob3VsZCBub3QgYmUgY2FsbGVkXG4gICAgdmFyIHByb2Nlc3NPbkVycm9yID0gZnVuY3Rpb24gcHJvY2Vzc09uRXJyb3IoZXhjZXB0aW9uKSB7XG4gICAgICBpZiAob25fZXJyb3IpIHtcbiAgICAgICAgaWYgKCFvbl9lcnJvcihtZXNzYWdlX29iamVjdCwgaSwgZXhjZXB0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChtZXNzYWdlX29iamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgbWVzc2FnZV9vYmplY3QucmF3X21lc3NhZ2UgPSBudWxsOyAvLyBXaWxsIGJlIHNldCBpZiBtZXNzYWdlIHdpbGwgYmUgc3VjY2Vzc2Z1bGx5IGRlY29kZWRcblxuICAgICAgbWVzc2FnZV9vYmplY3QubWVzc2FnZSA9IG51bGw7IC8vIFdpbGwgYmUgc2V0IGlmIG1lc3NhZ2Ugd2lsbCBiZSBhbHNvIHN1Y2Nlc3NmdWxseSBwYXJzZWQgYW5kIHZhbGlkYXRlZFxuXG4gICAgICBpZiAoYmVmb3JlX2RlY29kZSAmJiBiZWZvcmVfZGVjb2RlKG1lc3NhZ2Vfb2JqZWN0LCBpLCByZXN1bHRzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlY3J5cHRlZCA9IF9lY2MuQWVzLmRlY3J5cHQoc2hhcmVkX3NlY3JldCwgbnVsbCwgbWVzc2FnZV9vYmplY3Qubm9uY2UudG9TdHJpbmcoKSwgQnVmZmVyLmZyb20obWVzc2FnZV9vYmplY3QuZW5jcnlwdGVkX21lc3NhZ2UsICdoZXgnKSwgbWVzc2FnZV9vYmplY3QuY2hlY2tzdW0pO1xuXG4gICAgICB2YXIgbWJ1ZiA9IF9ieXRlYnVmZmVyLmRlZmF1bHQuZnJvbUJpbmFyeShkZWNyeXB0ZWQudG9TdHJpbmcoJ2JpbmFyeScpLCBfYnl0ZWJ1ZmZlci5kZWZhdWx0LkRFRkFVTFRfQ0FQQUNJVFksIF9ieXRlYnVmZmVyLmRlZmF1bHQuTElUVExFX0VORElBTik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG1idWYubWFyaygpO1xuICAgICAgICBkZWNyeXB0ZWQgPSBtYnVmLnJlYWRWU3RyaW5nKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIG1idWYucmVzZXQoKTsgLy8gU2VuZGVyIGRpZCBub3QgbGVuZ3RoLXByZWZpeCB0aGUgbWVtb1xuXG4gICAgICAgIGRlY3J5cHRlZCA9IG5ldyBCdWZmZXIobWJ1Zi50b1N0cmluZygnYmluYXJ5JyksICdiaW5hcnknKS50b1N0cmluZygndXRmLTgnKTtcbiAgICAgIH1cblxuICAgICAgZGVjcnlwdGVkID0gZGVjcnlwdGVkLnRvU3RyaW5nKCk7XG4gICAgICBtZXNzYWdlX29iamVjdC5yYXdfbWVzc2FnZSA9IGRlY3J5cHRlZDtcblxuICAgICAgaWYgKCFyYXdfbWVzc2FnZXMpIHtcbiAgICAgICAgdmFyIG1zZyA9IEpTT04ucGFyc2UobWVzc2FnZV9vYmplY3QucmF3X21lc3NhZ2UpO1xuICAgICAgICBtc2cudHlwZSA9IG1zZy50eXBlIHx8ICd0ZXh0JztcbiAgICAgICAgdmFsaWRhdGVCb2R5KG1zZy5ib2R5KTtcbiAgICAgICAgaWYgKG1zZy50eXBlID09PSAnaW1hZ2UnKSB2YWxpZGF0ZUltYWdlTXNnKG1zZyk7XG4gICAgICAgIHZhbGlkYXRlQXBwVmVyc2lvbihtc2cuYXBwLCBtc2cudmVyc2lvbik7XG4gICAgICAgIHZhbGlkYXRlTXNnV2l0aFF1b3RlKG1zZyk7XG4gICAgICAgIG1lc3NhZ2Vfb2JqZWN0Lm1lc3NhZ2UgPSBtc2c7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICBpZiAocHJvY2Vzc09uRXJyb3IoZXhjZXB0aW9uKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICghZm9yX2VhY2ggfHwgIWZvcl9lYWNoKG1lc3NhZ2Vfb2JqZWN0LCBpKSkge1xuICAgICAgICByZXN1bHRzLnB1c2gobWVzc2FnZV9vYmplY3QpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgcHJvY2Vzc09uRXJyb3IoZXhjZXB0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHRzO1xufVxuLyoqXG4gICAgRW5jb2RlcyBtZXNzYWdlIHRvIHNlbmQgd2l0aCBwcml2YXRlX21lc3NhZ2Vfb3BlcmF0aW9uLiBDb252ZXJ0cyBvYmplY3QgdG8gSlNPTiBzdHJpbmcuIFVzZXMgd3JpdGVWU3RyaW5nLCBzbyBmb3JtYXQgb2YgZGF0YSB0byBlbmNvZGUgaXMgc3RyaW5nIGxlbmd0aCArIHN0cmluZy5cbiAgICBAYXJnIHtzdHJpbmd8UHJpdmF0ZUtleX0gZnJvbV9wcml2YXRlX21lbW9fa2V5IC0gcHJpdmF0ZSBtZW1vIGtleSBvZiBcImZyb21cIlxuICAgIEBhcmcge3N0cmluZ3xQdWJsaWNLZXl9IHRvX3B1YmxpY19tZW1vX2tleSAtIHByaXZhdGUgbWVtbyBrZXkgb2YgXCJ0b1wiXG4gICAgQGFyZyB7b2JqZWN0fSBtZXNzYWdlIC0gbWVzc2FnZSB0byBlbmNvZGUuXG4gICAgQGFyZyB7c3RyaW5nfHVuZGVmaW5lZH0gbm9uY2UgLSB1bmlxdWUgaWRlbnRpZmllciBvZiBtZXNzYWdlLiBXaGVuIGVkaXRpbmcgbWVzc2FnZSwgc2V0IHRvIGl0cyBub25jZS4gT3RoZXJ3aXNlIGtlZXAgdW5kZWZpbmVkLlxuICAgIEByZXR1cm4ge29iamVjdH0gLSBPYmplY3Qgd2l0aCBmaWVsZHM6IG5vbmNlLCBjaGVja3N1bSBhbmQgbWVzc2FnZS5cbiovXG5cblxuZnVuY3Rpb24gZW5jb2RlKGZyb21fcHJpdmF0ZV9tZW1vX2tleSwgdG9fcHVibGljX21lbW9fa2V5LCBtZXNzYWdlKSB7XG4gIHZhciBub25jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAoMCwgX2Fzc2VydC5kZWZhdWx0KShmcm9tX3ByaXZhdGVfbWVtb19rZXksICdmcm9tX3ByaXZhdGVfbWVtb19rZXkgaXMgcmVxdWlyZWQnKTtcbiAgKDAsIF9hc3NlcnQuZGVmYXVsdCkodG9fcHVibGljX21lbW9fa2V5LCAndG9fcHVibGljX21lbW9fa2V5IGlzIHJlcXVpcmVkJyk7XG4gICgwLCBfYXNzZXJ0LmRlZmF1bHQpKG1lc3NhZ2UsICdtZXNzYWdlIGlzIHJlcXVpcmVkJyk7XG4gIHZhciBmcm9tS2V5ID0gdG9Qcml2YXRlT2JqKGZyb21fcHJpdmF0ZV9tZW1vX2tleSk7XG4gIHZhciB0b0tleSA9IHRvUHVibGljT2JqKHRvX3B1YmxpY19tZW1vX2tleSk7XG4gIHZhciBtYnVmID0gbmV3IF9ieXRlYnVmZmVyLmRlZmF1bHQoX2J5dGVidWZmZXIuZGVmYXVsdC5ERUZBVUxUX0NBUEFDSVRZLCBfYnl0ZWJ1ZmZlci5kZWZhdWx0LkxJVFRMRV9FTkRJQU4pO1xuICBtYnVmLndyaXRlVlN0cmluZyhKU09OLnN0cmluZ2lmeShtZXNzYWdlKSk7XG4gIG1lc3NhZ2UgPSBuZXcgQnVmZmVyKG1idWYuY29weSgwLCBtYnVmLm9mZnNldCkudG9CaW5hcnkoKSwgJ2JpbmFyeScpO1xuXG4gIHZhciBkYXRhID0gX2VjYy5BZXMuZW5jcnlwdChmcm9tS2V5LCB0b0tleSwgbWVzc2FnZSwgbm9uY2UpO1xuXG4gIHJldHVybiB7XG4gICAgbm9uY2U6IGRhdGEubm9uY2UudG9TdHJpbmcoKSxcbiAgICBlbmNyeXB0ZWRfbWVzc2FnZTogZGF0YS5tZXNzYWdlLnRvU3RyaW5nKCdoZXgnKSxcbiAgICBjaGVja3N1bTogZGF0YS5jaGVja3N1bVxuICB9O1xufVxuLyoqXG4gICAgU2VsZWN0cyBtZXNzYWdlcyBieSBjb25kaXRpb24gKGUuZyB1bnJlYWQsIG9yIHNlbGVjdGVkIGJ5IHVzZXIpLCBhbmQgZ3JvdXBzIHRoZW0gaW50byByYW5nZXMgd2l0aCBgbm9uY2VgIChpZiByYW5nZSBoYXMgMSBtZXNzYWdlKSBvciBgc3RhcnRfZGF0ZWArYHN0b3BfZGF0ZWAgKGlmIHJhbmdlIGhhcyBmZXcgbWVzc2FnZXMpLiBDYW4gd3JhcCB0aGVzZSByYW5nZXMgaW50byBvcGVyYXRpb25zOiBgcHJpdmF0ZV9tYXJrX21lc3NhZ2VgIGFuZCBgcHJpdmF0ZV9kZWxldGVfbWVzc2FnZWAuXG4gICAgQGFyZyB7YXJyYXl9IG1lc3NhZ2Vfb2JqZWN0cyAtIGFycmF5IG9mIG1lc3NhZ2Ugb2JqZWN0cy4gSXQgY2FuIGJlIHJlc3VsdCBhcnJheSBmcm9tIGBnb2xvcy5tZXNzYWdlcy5kZWNvZGVgLlxuICAgIEBhcmcge2Z1bmN0aW9ufSBjb25kaXRpb24gLSBjYWxsYmFjaywgY2FsbGluZyBvbiBlYWNoIG1lc3NhZ2UuIFBhcmFtcyBhcmUgKG1lc3NhZ2UsIGlkeCkuIElmIHJldHVybnMgdHJ1ZSwgbWVzc2FnZSBpcyBhZGRpbmcgdG8gcmFuZ2VzLiBJZiByZXR1cm5zIGZhbHNlL3VuZGVmaW5lZC9udWxsLCBtZXNzYWdlIGlzIHNraXBwaW5nLiBJZiByZXR1cm5zIC0xLCBwcm9jZXNzaW5nIGxvb3AgYnJlYWtzLlxuICAgIEBhcmcge2Z1bmN0aW9ufSB3cmFwcGVyIC0gY2FsbGJhY2ssIGNhbGxpbmcgb24gZWFjaCByYW5nZSwgd2hlbiBhZGRpbmcgaXQgdG8gcmVzdWx0IGFycmF5LiBBbGxvd3MgdG8gd3JhcCByYW5nZSBhcyBhbiBvcGVyYXRpb24uIFBhcmFtcyBhcmUgKHJhbmdlKS4gU2hvdWxkIHJldHVybiB3cmFwcGVkIHJlc3VsdC4gSWYgcmV0dXJucyBmYWxzZS91bmRlZmluZWQvbnVsbCwgcmFuZ2Ugc2tpcHBpbmcuXG4gICAgQGFyZyB7aW50fHVuZGVmaW5lZH0gYmVnaW5faWR4IC0gaWYgc2V0LCBmdW5jdGlvbiB3aWxsIHByb2Nlc3MgbWVzc2FnZXMgb25seSBmcm9tIGl0IGluZGV4IChpbmNsLikuIElmIGJlZ2luX2lkeCA+IGVuZF9pZHgsIG1lc3NhZ2VzIHdpbGwgYmUgcHJvY2Vzc2VkIGluIHJldmVyc2VkIG9yZGVyLlxuICAgIEBhcmcge2ludHx1bmRlZmluZWR9IGVuZF9pZHggLSBpZiBzZXQsIGZ1bmN0aW9uIHdpbGwgcHJvY2VzcyBtZXNzYWdlcyBvbmx5IGJlZm9yZSBpdCBpbmRleCAoZXhjbC4pLiBJZiBlbmRfaWR4IDwgYmVnaW5faWR4LCBtZXNzYWdlcyB3aWxsIGJlIHByb2Nlc3NlZCBpbiByZXZlcnNlZCBvcmRlci5cbiAgICBAcmV0dXJuIHthcnJheX0gLSByZXN1bHQgYXJyYXkgb2Ygb3BlcmF0aW9ucywgd2hpY2ggY2FuIGJlIHNlbnQgaW4gc2luZ2xlIHRyYW5zYWN0aW9uLlxuKi9cblxuXG5mdW5jdGlvbiBtYWtlRGF0ZWRHcm91cHMobWVzc2FnZV9vYmplY3RzLCBjb25kaXRpb24sIHdyYXBwZXIsIGJlZ2luX2lkeCwgZW5kX2lkeCkge1xuICAoMCwgX2Fzc2VydC5kZWZhdWx0KShtZXNzYWdlX29iamVjdHMsICdtZXNzYWdlX29iamVjdHMgaXMgcmVxdWlyZWQnKTtcbiAgKDAsIF9hc3NlcnQuZGVmYXVsdCkoY29uZGl0aW9uLCAnY29uZGl0aW9uIGlzIHJlcXVpcmVkJyk7XG4gICgwLCBfYXNzZXJ0LmRlZmF1bHQpKHdyYXBwZXIsICd3cmFwcGVyIGlzIHJlcXVpcmVkJyk7XG4gIHZhciByZXN1bHRzID0gW107XG4gIHZhciBncm91cCA9IG51bGw7XG4gIHZhciBiZWZvcmUgPSBudWxsO1xuXG4gIHZhciBmaXhTdGFydERhdGUgPSBmdW5jdGlvbiBmaXhTdGFydERhdGUoc3RhcnRfZGF0ZSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShuZXcgRGF0ZShzdGFydF9kYXRlICsgJ1onKS5nZXRUaW1lKCkgLSAxMDAwKS50b0lTT1N0cmluZygpLnNwbGl0KCcuJylbMF07XG4gIH07XG5cbiAgdmFyIHRpbWVfcG9pbnRfbWluID0gJzE5NzAtMDEtMDFUMDA6MDA6MDAnO1xuXG4gIHZhciBwdXNoUmVzdWx0ID0gZnVuY3Rpb24gcHVzaFJlc3VsdChub25jZXMsIHN0YXJ0X2RhdGUsIHN0b3BfZGF0ZSkge1xuICAgIGlmIChub25jZXMpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihub25jZXMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBub25jZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciB3cmFwcGVkID0gd3JhcHBlcih7XG4gICAgICAgICAgICBzdGFydF9kYXRlOiB0aW1lX3BvaW50X21pbixcbiAgICAgICAgICAgIHN0b3BfZGF0ZTogdGltZV9wb2ludF9taW4sXG4gICAgICAgICAgICBub25jZTogbm9uY2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAod3JhcHBlZCkgcmVzdWx0cy5wdXNoKHdyYXBwZWQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfd3JhcHBlZCA9IHdyYXBwZXIoe1xuICAgICAgICBzdGFydF9kYXRlOiBzdGFydF9kYXRlLFxuICAgICAgICBzdG9wX2RhdGU6IHN0b3BfZGF0ZSxcbiAgICAgICAgbm9uY2U6IDBcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoX3dyYXBwZWQpIHJlc3VsdHMucHVzaChfd3JhcHBlZCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBwdXNoR3JvdXAgPSBmdW5jdGlvbiBwdXNoR3JvdXAobmV4dENyZWF0ZURhdGUpIHtcbiAgICBpZiAoIWdyb3VwKSByZXR1cm47XG4gICAgdmFyIF9ncm91cCA9IGdyb3VwLFxuICAgICAgICBiZWZvcmVOb25jZXMgPSBfZ3JvdXAuYmVmb3JlTm9uY2VzLFxuICAgICAgICBub25jZXMgPSBfZ3JvdXAubm9uY2VzLFxuICAgICAgICBhZnRlck5vbmNlcyA9IF9ncm91cC5hZnRlck5vbmNlcztcblxuICAgIGlmICghbmV4dENyZWF0ZURhdGUgfHwgbmV4dENyZWF0ZURhdGUgIT09IGdyb3VwLnN0YXJ0X2RhdGUpIHtcbiAgICAgIG5vbmNlcy5wdXNoLmFwcGx5KG5vbmNlcywgX3RvQ29uc3VtYWJsZUFycmF5KGFmdGVyTm9uY2VzKSk7XG4gICAgICBhZnRlck5vbmNlcyA9IFtdO1xuICAgIH1cblxuICAgIHB1c2hSZXN1bHQoYmVmb3JlTm9uY2VzKTtcblxuICAgIGlmIChub25jZXMubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKCFhZnRlck5vbmNlcy5sZW5ndGgpIGdyb3VwLnN0YXJ0X2RhdGUgPSBmaXhTdGFydERhdGUoZ3JvdXAuc3RhcnRfZGF0ZSk7XG4gICAgICBwdXNoUmVzdWx0KG51bGwsIGdyb3VwLnN0YXJ0X2RhdGUsIGdyb3VwLnN0b3BfZGF0ZSk7XG4gICAgfSBlbHNlIGlmIChub25jZXNbMF0pIHtcbiAgICAgIHB1c2hSZXN1bHQoW25vbmNlc1swXV0pO1xuICAgIH1cblxuICAgIHB1c2hSZXN1bHQoYWZ0ZXJOb25jZXMpO1xuICAgIGdyb3VwID0gbnVsbDtcbiAgfTtcblxuICBmb3JFYWNoTWVzc2FnZShtZXNzYWdlX29iamVjdHMsIGJlZ2luX2lkeCwgZW5kX2lkeCwgZnVuY3Rpb24gKG1lc3NhZ2Vfb2JqZWN0LCBpKSB7XG4gICAgdmFyIGNvbmQgPSBjb25kaXRpb24obWVzc2FnZV9vYmplY3QsIGkpO1xuICAgIHZhciBjcmVhdGVfZGF0ZSA9IG1lc3NhZ2Vfb2JqZWN0LmNyZWF0ZV9kYXRlLFxuICAgICAgICBub25jZSA9IG1lc3NhZ2Vfb2JqZWN0Lm5vbmNlO1xuXG4gICAgaWYgKGNvbmQgPT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChjb25kKSB7XG4gICAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgIGdyb3VwID0ge1xuICAgICAgICAgIHN0b3BfZGF0ZTogY3JlYXRlX2RhdGUsXG4gICAgICAgICAgYmVmb3JlTm9uY2VzOiBbXSxcbiAgICAgICAgICBhZnRlck5vbmNlczogW10sXG4gICAgICAgICAgbm9uY2VzOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoY3JlYXRlX2RhdGUgPT09IGJlZm9yZSkge1xuICAgICAgICBncm91cC5iZWZvcmVOb25jZXMucHVzaChub25jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgYmVmb3JlID0gbnVsbDtcbiAgICAgICAgICBncm91cC5zdG9wX2RhdGUgPSBjcmVhdGVfZGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjcmVhdGVfZGF0ZSAhPT0gZ3JvdXAuc3RhcnRfZGF0ZSkge1xuICAgICAgICAgIHZhciBfZ3JvdXAkbm9uY2VzO1xuXG4gICAgICAgICAgKF9ncm91cCRub25jZXMgPSBncm91cC5ub25jZXMpLnB1c2guYXBwbHkoX2dyb3VwJG5vbmNlcywgX3RvQ29uc3VtYWJsZUFycmF5KGdyb3VwLmFmdGVyTm9uY2VzKSk7XG5cbiAgICAgICAgICBncm91cC5hZnRlck5vbmNlcyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JvdXAuYWZ0ZXJOb25jZXMucHVzaChub25jZSk7XG4gICAgICB9XG5cbiAgICAgIGdyb3VwLnN0YXJ0X2RhdGUgPSBjcmVhdGVfZGF0ZTtcbiAgICB9IGVsc2UgaWYgKGNvbmQgPT09IGZhbHNlKSB7XG4gICAgICBwdXNoR3JvdXAoY3JlYXRlX2RhdGUpO1xuICAgICAgYmVmb3JlID0gY3JlYXRlX2RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICBwdXNoR3JvdXAoKTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBQcmltYXJ5IGNsYXNzIGZvciBjcmVhdGluZyBvcGVyYXRpb25zXG4gIFNlcmlhbGl6ZXI6IHJlcXVpcmUoJy4vc3JjL3NlcmlhbGl6ZXInKSxcbiAgLy8gaGVscGVyIGZ1bmN0aW9ucyBmb3IgY3JlYXRpbmcgb3BlcmF0aW9uc1xuICBmcDogcmVxdWlyZSgnLi9zcmMvZmFzdF9wYXJzZXInKSxcbiAgLy8gTG93IGxldmVsIHR5cGVzXG4gIHR5cGVzOiByZXF1aXJlKCcuL3NyYy90eXBlcycpLFxuICAvLyBIaWdoZXIgbGV2ZWwgb3BlcmF0aW9ucyAobWFkZSBvdXQgb2YgZ2VuZXJpYyB0eXBlcylcbiAgb3BzOiByZXF1aXJlKCcuL3NyYy9vcGVyYXRpb25zJyksXG4gIC8vIFV0aWxpdHkgdGhhdCBnZW5lcmF0ZXMgSlNPTiBleGFtcGxlc1xuICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9zcmMvdGVtcGxhdGUnKSxcbiAgbnVtYmVyX3V0aWxzOiByZXF1aXJlKCcuL3NyYy9udW1iZXJfdXRpbHMnKVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIENoYWluVHlwZXM7XG5tb2R1bGUuZXhwb3J0cyA9IENoYWluVHlwZXMgPSB7fTtcbkNoYWluVHlwZXMucmVzZXJ2ZWRfc3BhY2VzID0ge1xuICByZWxhdGl2ZV9wcm90b2NvbF9pZHM6IDAsXG4gIHByb3RvY29sX2lkczogMSxcbiAgaW1wbGVtZW50YXRpb25faWRzOiAyXG59O1xuQ2hhaW5UeXBlcy5vcGVyYXRpb25zID0ge1xuICB2b3RlOiAwLFxuICBjb21tZW50OiAxLFxuICB0cmFuc2ZlcjogMixcbiAgdHJhbnNmZXJfdG9fdmVzdGluZzogMyxcbiAgd2l0aGRyYXdfdmVzdGluZzogNCxcbiAgbGltaXRfb3JkZXJfY3JlYXRlOiA1LFxuICBsaW1pdF9vcmRlcl9jYW5jZWw6IDYsXG4gIGZlZWRfcHVibGlzaDogNyxcbiAgY29udmVydDogOCxcbiAgYWNjb3VudF9jcmVhdGU6IDksXG4gIGFjY291bnRfdXBkYXRlOiAxMCxcbiAgd2l0bmVzc191cGRhdGU6IDExLFxuICBhY2NvdW50X3dpdG5lc3Nfdm90ZTogMTIsXG4gIGFjY291bnRfd2l0bmVzc19wcm94eTogMTMsXG4gIHBvdzogMTQsXG4gIGN1c3RvbTogMTUsXG4gIHJlcG9ydF9vdmVyX3Byb2R1Y3Rpb246IDE2LFxuICBkZWxldGVfY29tbWVudDogMTcsXG4gIGN1c3RvbV9qc29uOiAxOCxcbiAgY29tbWVudF9vcHRpb25zOiAxOSxcbiAgc2V0X3dpdGhkcmF3X3Zlc3Rpbmdfcm91dGU6IDIwLFxuICBsaW1pdF9vcmRlcl9jcmVhdGUyOiAyMSxcbiAgY2hhbGxlbmdlX2F1dGhvcml0eTogMjIsXG4gIHByb3ZlX2F1dGhvcml0eTogMjMsXG4gIHJlcXVlc3RfYWNjb3VudF9yZWNvdmVyeTogMjQsXG4gIHJlY292ZXJfYWNjb3VudDogMjUsXG4gIGNoYW5nZV9yZWNvdmVyeV9hY2NvdW50OiAyNixcbiAgZXNjcm93X3RyYW5zZmVyOiAyNyxcbiAgZXNjcm93X2Rpc3B1dGU6IDI4LFxuICBlc2Nyb3dfcmVsZWFzZTogMjksXG4gIHBvdzI6IDMwLFxuICBlc2Nyb3dfYXBwcm92ZTogMzEsXG4gIHRyYW5zZmVyX3RvX3NhdmluZ3M6IDMyLFxuICB0cmFuc2Zlcl9mcm9tX3NhdmluZ3M6IDMzLFxuICBjYW5jZWxfdHJhbnNmZXJfZnJvbV9zYXZpbmdzOiAzNCxcbiAgY3VzdG9tX2JpbmFyeTogMzUsXG4gIGRlY2xpbmVfdm90aW5nX3JpZ2h0czogMzYsXG4gIHJlc2V0X2FjY291bnQ6IDM3LFxuICBzZXRfcmVzZXRfYWNjb3VudDogMzgsXG4gIGRlbGVnYXRlX3Zlc3Rpbmdfc2hhcmVzOiAzOSxcbiAgYWNjb3VudF9jcmVhdGVfd2l0aF9kZWxlZ2F0aW9uOiA0MCxcbiAgYWNjb3VudF9tZXRhZGF0YTogNDEsXG4gIHByb3Bvc2FsX2NyZWF0ZTogNDIsXG4gIHByb3Bvc2FsX3VwZGF0ZTogNDMsXG4gIHByb3Bvc2FsX2RlbGV0ZTogNDQsXG4gIGNoYWluX3Byb3BlcnRpZXNfdXBkYXRlOiA0NSxcbiAgYnJlYWtfZnJlZV9yZWZlcnJhbDogNDYsXG4gIGRlbGVnYXRlX3Zlc3Rpbmdfc2hhcmVzX3dpdGhfaW50ZXJlc3Q6IDQ3LFxuICByZWplY3RfdmVzdGluZ19zaGFyZXNfZGVsZWdhdGlvbjogNDgsXG4gIHRyYW5zaXRfdG9fY3liZXJ3YXk6IDQ5LFxuICB3b3JrZXJfcmVxdWVzdDogNTAsXG4gIHdvcmtlcl9yZXF1ZXN0X2RlbGV0ZTogNTEsXG4gIHdvcmtlcl9yZXF1ZXN0X3ZvdGU6IDUyLFxuICBjbGFpbTogNTMsXG4gIGRvbmF0ZTogNTQsXG4gIHRyYW5zZmVyX3RvX3RpcDogNTUsXG4gIHRyYW5zZmVyX2Zyb21fdGlwOiA1NixcbiAgaW52aXRlOiA1NyxcbiAgaW52aXRlX2NsYWltOiA1OCxcbiAgYWNjb3VudF9jcmVhdGVfd2l0aF9pbnZpdGU6IDU5LFxuICBhc3NldF9jcmVhdGU6IDYwLFxuICBhc3NldF91cGRhdGU6IDYxLFxuICBhc3NldF9pc3N1ZTogNjIsXG4gIGFzc2V0X3RyYW5zZmVyOiA2MyxcbiAgb3ZlcnJpZGVfdHJhbnNmZXI6IDY0LFxuICBpbnZpdGVfZG9uYXRlOiA2NSxcbiAgaW52aXRlX3RyYW5zZmVyOiA2NixcbiAgbGltaXRfb3JkZXJfY2FuY2VsX2V4OiA2NyxcbiAgZmlsbF9jb252ZXJ0X3JlcXVlc3Q6IDY4LFxuICBhdXRob3JfcmV3YXJkOiA2OSxcbiAgY3VyYXRpb25fcmV3YXJkOiA3MCxcbiAgY29tbWVudF9yZXdhcmQ6IDcxLFxuICBsaXF1aWRpdHlfcmV3YXJkOiA3MixcbiAgaW50ZXJlc3Q6IDczLFxuICBmaWxsX3Zlc3Rpbmdfd2l0aGRyYXc6IDc0LFxuICBmaWxsX29yZGVyOiA3NSxcbiAgc2h1dGRvd25fd2l0bmVzczogNzYsXG4gIGZpbGxfdHJhbnNmZXJfZnJvbV9zYXZpbmdzOiA3NyxcbiAgaGFyZGZvcms6IDc4LFxuICBjb21tZW50X3BheW91dF91cGRhdGU6IDc5LFxuICBjb21tZW50X2JlbmVmYWN0b3JfcmV3YXJkOiA4MCxcbiAgcmV0dXJuX3Zlc3RpbmdfZGVsZWdhdGlvbjogODEsXG4gIHByb2R1Y2VyX3Jld2FyZDogODIsXG4gIGRlbGVnYXRpb25fcmV3YXJkOiA4MyxcbiAgYXVjdGlvbl93aW5kb3dfcmV3YXJkOiA4NFxufTsgLy90eXBlcy5ocHBcblxuQ2hhaW5UeXBlcy5vYmplY3RfdHlwZSA9IHtcbiAgXCJudWxsXCI6IDAsXG4gIGJhc2U6IDFcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLyoqIEV4Y2VwdGlvbiBuZXN0aW5nLiAgKi9cbnZhciBFcnJvcldpdGhDYXVzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVycm9yV2l0aENhdXNlKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVycm9yV2l0aENhdXNlKTtcblxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cbiAgICBpZiAodHlwZW9mIGNhdXNlICE9PSBcInVuZGVmaW5lZFwiICYmIGNhdXNlICE9PSBudWxsID8gY2F1c2UubWVzc2FnZSA6IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gXCJjYXVzZVxcdFwiLmNvbmNhdChjYXVzZS5tZXNzYWdlLCBcIlxcdFwiKSArIHRoaXMubWVzc2FnZTtcbiAgICB9XG5cbiAgICB2YXIgc3RhY2sgPSBcIlwiOyAvLyhuZXcgRXJyb3IpLnN0YWNrXG5cbiAgICBpZiAodHlwZW9mIGNhdXNlICE9PSBcInVuZGVmaW5lZFwiICYmIGNhdXNlICE9PSBudWxsID8gY2F1c2Uuc3RhY2sgOiB1bmRlZmluZWQpIHtcbiAgICAgIHN0YWNrID0gXCJjYXVzZWQgYnlcXG5cXHRcIi5jb25jYXQoY2F1c2Uuc3RhY2ssIFwiXFx0XCIpICsgc3RhY2s7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFjayA9IHRoaXMubWVzc2FnZSArIFwiXFxuXCIgKyBzdGFjaztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFcnJvcldpdGhDYXVzZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwidGhyb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Rocm93KG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgICB2YXIgbXNnID0gbWVzc2FnZTtcblxuICAgICAgaWYgKHR5cGVvZiBjYXVzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYXVzZSAhPT0gbnVsbCA/IGNhdXNlLm1lc3NhZ2UgOiB1bmRlZmluZWQpIHtcbiAgICAgICAgbXNnICs9IFwiXFx0IGNhdXNlOiBcIi5jb25jYXQoY2F1c2UubWVzc2FnZSwgXCIgXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNhdXNlICE9PSBcInVuZGVmaW5lZFwiICYmIGNhdXNlICE9PSBudWxsID8gY2F1c2Uuc3RhY2sgOiB1bmRlZmluZWQpIHtcbiAgICAgICAgbXNnICs9IFwiXFxuIHN0YWNrOiBcIi5jb25jYXQoY2F1c2Uuc3RhY2ssIFwiIFwiKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVycm9yV2l0aENhdXNlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVycm9yV2l0aENhdXNlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qc1wiKTtcblxudmFyIF9lY2MgPSByZXF1aXJlKFwiLi4vLi4vZWNjXCIpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBGYXN0UGFyc2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmFzdFBhcnNlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmFzdFBhcnNlcik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRmFzdFBhcnNlciwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZml4ZWRfZGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXhlZF9kYXRhKGIsIGxlbiwgYnVmZmVyKSB7XG4gICAgICBpZiAoIWIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgIHZhciBkYXRhID0gYnVmZmVyLnNsaWNlKDAsIGxlbikudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgICAgICBiLmFwcGVuZChkYXRhLCAnYmluYXJ5Jyk7XG5cbiAgICAgICAgd2hpbGUgKGxlbi0tID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBiLndyaXRlVWludDgoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBiX2NvcHkgPSBiLmNvcHkoYi5vZmZzZXQsIGIub2Zmc2V0ICsgbGVuKTtcbiAgICAgICAgYi5za2lwKGxlbik7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGJfY29weS50b0JpbmFyeSgpLCAnYmluYXJ5Jyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1YmxpY19rZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGljX2tleShiLCBfcHVibGljX2tleSkge1xuICAgICAgaWYgKCFiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKF9wdWJsaWNfa2V5KSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBfcHVibGljX2tleS50b0J1ZmZlcigpO1xuXG4gICAgICAgIGIuYXBwZW5kKGJ1ZmZlci50b1N0cmluZygnYmluYXJ5JyksICdiaW5hcnknKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyID0gRmFzdFBhcnNlci5maXhlZF9kYXRhKGIsIDMzKTtcbiAgICAgICAgcmV0dXJuIF9lY2MuUHVibGljS2V5LmZyb21CdWZmZXIoYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmlwZW1kMTYwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJpcGVtZDE2MChiLCBfcmlwZW1kKSB7XG4gICAgICBpZiAoIWIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3JpcGVtZCkge1xuICAgICAgICBGYXN0UGFyc2VyLmZpeGVkX2RhdGEoYiwgMjAsIF9yaXBlbWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gRmFzdFBhcnNlci5maXhlZF9kYXRhKGIsIDIwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGltZV9wb2ludF9zZWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGltZV9wb2ludF9zZWMoYiwgZXBvY2gpIHtcbiAgICAgIGlmIChlcG9jaCkge1xuICAgICAgICBlcG9jaCA9IE1hdGguY2VpbChlcG9jaCAvIDEwMDApO1xuICAgICAgICBiLndyaXRlSW50MzIoZXBvY2gpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcG9jaCA9IGIucmVhZEludDMyKCk7IC8vIGZjOjp0aW1lX3BvaW50X3NlY1xuXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShlcG9jaCAqIDEwMDApO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGYXN0UGFyc2VyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhc3RQYXJzZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5mcm9tSW1wbGllZERlY2ltYWwgPSBmcm9tSW1wbGllZERlY2ltYWw7XG5leHBvcnRzLnRvSW1wbGllZERlY2ltYWwgPSB0b0ltcGxpZWREZWNpbWFsO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcudHJpbS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXQuanNcIik7XG5cbnZhciBfYXNzZXJ0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9zLCBfZTsgdHJ5IHsgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qKlxuICAgIENvbnZlcnQgMTIuMzQgd2l0aCBhIHByZWNpc2lvbiBvZiAzIGludG8gMTIzNDBcblxuICAgIEBhcmcge251bWJlcnxzdHJpbmd9IG51bWJlciAtIFVzZSBzdHJpbmdzIGZvciBsYXJnZSBudW1iZXJzLiAgVGhpcyBtYXkgY29udGFpbiBvbmUgZGVjaW1hbCBidXQgbm8gc2lnblxuICAgIEBhcmcge251bWJlcn0gcHJlY2lzaW9uIC0gbnVtYmVyIG9mIGltcGxpZWQgZGVjaW1hbCBwbGFjZXMgKHVzdWFsbHkgY2F1c2VzIHJpZ2h0IHplcm8gcGFkZGluZylcbiAgICBAcmV0dXJuIHtzdHJpbmd9IC1cbiovXG5mdW5jdGlvbiB0b0ltcGxpZWREZWNpbWFsKG51bWJlciwgcHJlY2lzaW9uKSB7XG4gIGlmICh0eXBlb2YgbnVtYmVyID09PSBcIm51bWJlclwiKSB7XG4gICAgKDAsIF9hc3NlcnQuZGVmYXVsdCkobnVtYmVyIDw9IDkwMDcxOTkyNTQ3NDA5OTEsIFwib3ZlcmZsb3dcIik7XG4gICAgbnVtYmVyID0gXCJcIiArIG51bWJlcjtcbiAgfSBlbHNlIGlmIChudW1iZXIudG9TdHJpbmcpIG51bWJlciA9IG51bWJlci50b1N0cmluZygpO1xuXG4gICgwLCBfYXNzZXJ0LmRlZmF1bHQpKHR5cGVvZiBudW1iZXIgPT09IFwic3RyaW5nXCIsIFwibnVtYmVyIHNob3VsZCBiZSBhbiBhY3R1YWwgbnVtYmVyIG9yIHN0cmluZzogXCIgKyBfdHlwZW9mKG51bWJlcikpO1xuICBudW1iZXIgPSBudW1iZXIudHJpbSgpO1xuICAoMCwgX2Fzc2VydC5kZWZhdWx0KSgvXlswLTldKlxcLj9bMC05XSokLy50ZXN0KG51bWJlciksIFwiSW52YWxpZCBkZWNpbWFsIG51bWJlciBcIiArIG51bWJlcik7XG5cbiAgdmFyIF9udW1iZXIkc3BsaXQgPSBudW1iZXIuc3BsaXQoXCIuXCIpLFxuICAgICAgX251bWJlciRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfbnVtYmVyJHNwbGl0LCAyKSxcbiAgICAgIF9udW1iZXIkc3BsaXQyJCA9IF9udW1iZXIkc3BsaXQyWzBdLFxuICAgICAgd2hvbGUgPSBfbnVtYmVyJHNwbGl0MiQgPT09IHZvaWQgMCA/IFwiXCIgOiBfbnVtYmVyJHNwbGl0MiQsXG4gICAgICBfbnVtYmVyJHNwbGl0MiQyID0gX251bWJlciRzcGxpdDJbMV0sXG4gICAgICBkZWNpbWFsID0gX251bWJlciRzcGxpdDIkMiA9PT0gdm9pZCAwID8gXCJcIiA6IF9udW1iZXIkc3BsaXQyJDI7XG5cbiAgdmFyIHBhZGRpbmcgPSBwcmVjaXNpb24gLSBkZWNpbWFsLmxlbmd0aDtcbiAgKDAsIF9hc3NlcnQuZGVmYXVsdCkocGFkZGluZyA+PSAwLCBcIlRvbyBtYW55IGRlY2ltYWwgZGlnaXRzIGluIFwiICsgbnVtYmVyICsgXCIgdG8gY3JlYXRlIGFuIGltcGxpZWQgZGVjaW1hbCBvZiBcIiArIHByZWNpc2lvbik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRkaW5nOyBpKyspIHtcbiAgICBkZWNpbWFsICs9IFwiMFwiO1xuICB9XG5cbiAgd2hpbGUgKHdob2xlLmNoYXJBdCgwKSA9PT0gXCIwXCIpIHtcbiAgICB3aG9sZSA9IHdob2xlLnN1YnN0cmluZygxKTtcbiAgfVxuXG4gIHJldHVybiB3aG9sZSArIGRlY2ltYWw7XG59XG5cbmZ1bmN0aW9uIGZyb21JbXBsaWVkRGVjaW1hbChudW1iZXIsIHByZWNpc2lvbikge1xuICBpZiAodHlwZW9mIG51bWJlciA9PT0gXCJudW1iZXJcIikge1xuICAgICgwLCBfYXNzZXJ0LmRlZmF1bHQpKG51bWJlciA8PSA5MDA3MTk5MjU0NzQwOTkxLCBcIm92ZXJmbG93XCIpO1xuICAgIG51bWJlciA9IFwiXCIgKyBudW1iZXI7XG4gIH0gZWxzZSBpZiAobnVtYmVyLnRvU3RyaW5nKSBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKTtcblxuICB3aGlsZSAobnVtYmVyLmxlbmd0aCA8IHByZWNpc2lvbiArIDEpIHtcbiAgICAvLyAwLjEyM1xuICAgIG51bWJlciA9IFwiMFwiICsgbnVtYmVyO1xuICB9IC8vIDQ0MDAwID0+IDQ0LjAwMFxuXG5cbiAgdmFyIGRlY19zdHJpbmcgPSBudW1iZXIuc3Vic3RyaW5nKG51bWJlci5sZW5ndGggLSBwcmVjaXNpb24pO1xuICByZXR1cm4gbnVtYmVyLnN1YnN0cmluZygwLCBudW1iZXIubGVuZ3RoIC0gcHJlY2lzaW9uKSArIChkZWNfc3RyaW5nID8gXCIuXCIgKyBkZWNfc3RyaW5nIDogXCJcIik7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qc1wiKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgTG9uZyA9IHJlcXVpcmUoJ2J5dGVidWZmZXInKS5Mb25nO1xuXG52YXIgdiA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG52YXIgREJfTUFYX0lOU1RBTkNFX0lEID0gTG9uZy5mcm9tTnVtYmVyKE1hdGgucG93KDIsIDQ4KSAtIDEpO1xuXG52YXIgT2JqZWN0SWQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPYmplY3RJZChzcGFjZSwgdHlwZSwgaW5zdGFuY2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0SWQpO1xuXG4gICAgdGhpcy5zcGFjZSA9IHNwYWNlO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIHZhciBpbnN0YW5jZV9zdHJpbmcgPSB0aGlzLmluc3RhbmNlLnRvU3RyaW5nKCk7XG4gICAgdmFyIG9iamVjdF9pZCA9IFwiXCIuY29uY2F0KHRoaXMuc3BhY2UsIFwiLlwiKS5jb25jYXQodGhpcy50eXBlLCBcIi5cIikuY29uY2F0KGluc3RhbmNlX3N0cmluZyk7XG5cbiAgICBpZiAoIXYuaXNfZGlnaXRzKGluc3RhbmNlX3N0cmluZykpIHtcbiAgICAgIHRocm93IG5ldyAoXCJJbnZhbGlkIG9iamVjdCBpZCBcIi5jb25jYXQob2JqZWN0X2lkKSkoKTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoT2JqZWN0SWQsIFt7XG4gICAga2V5OiBcInRvTG9uZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0xvbmcoKSB7XG4gICAgICByZXR1cm4gTG9uZy5mcm9tTnVtYmVyKHRoaXMuc3BhY2UpLnNoaWZ0TGVmdCg1Nikub3IoTG9uZy5mcm9tTnVtYmVyKHRoaXMudHlwZSkuc2hpZnRMZWZ0KDQ4KS5vcih0aGlzLmluc3RhbmNlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGVuZEJ5dGVCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICByZXR1cm4gYi53cml0ZVVpbnQ2NCh0aGlzLnRvTG9uZygpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5zcGFjZSwgXCIuXCIpLmNvbmNhdCh0aGlzLnR5cGUsIFwiLlwiKS5jb25jYXQodGhpcy5pbnN0YW5jZS50b1N0cmluZygpKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZS5zcGFjZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLnR5cGUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5pbnN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmFtcyA9IHYucmVxdWlyZV9tYXRjaCgvXihbMC05XSspXFwuKFswLTldKylcXC4oWzAtOV0rKSQvLCB2LnJlcXVpcmVkKHZhbHVlLCBcIm9iamVjdF9pZFwiKSwgXCJvYmplY3RfaWRcIik7XG4gICAgICByZXR1cm4gbmV3IE9iamVjdElkKHBhcnNlSW50KHBhcmFtc1sxXSksIHBhcnNlSW50KHBhcmFtc1syXSksIExvbmcuZnJvbVN0cmluZyhwYXJhbXNbM10pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUxvbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUxvbmcobG9uZykge1xuICAgICAgdmFyIHNwYWNlID0gbG9uZy5zaGlmdFJpZ2h0KDU2KS50b0ludCgpO1xuICAgICAgdmFyIHR5cGUgPSBsb25nLnNoaWZ0UmlnaHQoNDgpLnRvSW50KCkgJiAweDAwZmY7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBsb25nLmFuZChEQl9NQVhfSU5TVEFOQ0VfSUQpO1xuICAgICAgcmV0dXJuIG5ldyBPYmplY3RJZChzcGFjZSwgdHlwZSwgaW5zdGFuY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tQnl0ZUJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICByZXR1cm4gT2JqZWN0SWQuZnJvbUxvbmcoYi5yZWFkVWludDY0KCkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPYmplY3RJZDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RJZDsiLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXAuanNcIik7XG5cbnZhciBfdHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3R5cGVzXCIpKTtcblxudmFyIF9zZXJpYWxpemVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zZXJpYWxpemVyXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gVGhpcyBmaWxlIGlzIG1lcmdlIHVwZGF0ZWQgZnJvbSBzdGVlbWQncyBqc19vcGVyYXRpb25fc2VyaWFsaXplciBwcm9ncmFtLlxuXG4vKlxuXG4uL2pzX29wZXJhdGlvbl9zZXJpYWxpemVyIHxcbnNlZCAncy92b2lkL2Z1dHVyZV9leHRlbnNpb25zL2cnfFxuc2VkICdzL3N0ZWVtaXRfcHJvdG9jb2w6Oi8vZyd8XG5zZWQgJ3MvMTRzdGF0aWNfdmFyaWFudElKTlNfMTJmaXhlZF9zdHJpbmdJTlN0M19fMTRwYWlySXl5RUVFRUVFRS9zdHJpbmcvZyd8XG5zZWQgJ3Mvc3RlZW1pdF9mdXR1cmVfZXh0ZW5zaW9ucy9mdXR1cmVfZXh0ZW5zaW9ucy9nJ3xcbnNlZCAncy9zdGVlbWl0X3Byb3RvY29sXy8vZycgPiB0bXAuY29mZmVlXG5cbiovXG4vLyBjb2ZmZWUgdG1wLmNvZmZlZSAjIGZpeCBlcnJvcnMgdW50aWwgeW91IHNlZTogYENoYWluVHlwZXMgaXMgbm90IGRlZmluZWRgXG5cbi8qXG5cbiAgIHJlbW92ZSB0aGVzZSA3IGxpbmVzIGZyb20gdG1wLmNvZmZlZTpcblxuc3RhdGljX3ZhcmlhbnQgW1xuICAgIHBvdzJcbiAgICBlcXVpaGFzaF9wb3dcbl0gPSBzdGF0aWNfdmFyaWFudCBbXG4gICAgcG93MlxuICAgIGVxdWloYXNoX3Bvd1xuXVxuXG4qL1xuLy8gbnBtIGkgLWcgZGVjYWZmZWluYXRlXG4vLyBkZWNhZmZlaW5hdGUgdG1wLmNvZmZlZVxuLy8gTWVyZ2UgdG1wLmpzIC0gU2VlIFwiR2VuZXJhdGVkIGNvZGUgZm9sbG93c1wiIGJlbG93XG52YXIgaW50MTYgPSBfdHlwZXMuZGVmYXVsdC5pbnQxNixcbiAgICB1aW50OCA9IF90eXBlcy5kZWZhdWx0LnVpbnQ4LFxuICAgIHVpbnQxNiA9IF90eXBlcy5kZWZhdWx0LnVpbnQxNixcbiAgICB1aW50MzIgPSBfdHlwZXMuZGVmYXVsdC51aW50MzIsXG4gICAgdWludDY0ID0gX3R5cGVzLmRlZmF1bHQudWludDY0LFxuICAgIHN0cmluZyA9IF90eXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgICBmaXhlZF9zdHJpbmcgPSBfdHlwZXMuZGVmYXVsdC5maXhlZF9zdHJpbmcsXG4gICAgc3RyaW5nX2JpbmFyeSA9IF90eXBlcy5kZWZhdWx0LnN0cmluZ19iaW5hcnksXG4gICAgYnl0ZXMgPSBfdHlwZXMuZGVmYXVsdC5ieXRlcyxcbiAgICBib29sID0gX3R5cGVzLmRlZmF1bHQuYm9vbCxcbiAgICBhcnJheSA9IF90eXBlcy5kZWZhdWx0LmFycmF5LFxuICAgIHN0YXRpY192YXJpYW50ID0gX3R5cGVzLmRlZmF1bHQuc3RhdGljX3ZhcmlhbnQsXG4gICAgdmFyaWFudF9vYmplY3QgPSBfdHlwZXMuZGVmYXVsdC52YXJpYW50X29iamVjdCxcbiAgICBtYXAgPSBfdHlwZXMuZGVmYXVsdC5tYXAsXG4gICAgc2V0ID0gX3R5cGVzLmRlZmF1bHQuc2V0LFxuICAgIHB1YmxpY19rZXkgPSBfdHlwZXMuZGVmYXVsdC5wdWJsaWNfa2V5LFxuICAgIHRpbWVfcG9pbnRfc2VjID0gX3R5cGVzLmRlZmF1bHQudGltZV9wb2ludF9zZWMsXG4gICAgb3B0aW9uYWwgPSBfdHlwZXMuZGVmYXVsdC5vcHRpb25hbCxcbiAgICBhc3NldCA9IF90eXBlcy5kZWZhdWx0LmFzc2V0LFxuICAgIGFzc2V0XzE2ID0gX3R5cGVzLmRlZmF1bHQuYXNzZXRfMTY7XG52YXIgZnV0dXJlX2V4dGVuc2lvbnMgPSBfdHlwZXMuZGVmYXVsdC52b2lkO1xudmFyIGhhcmRmb3JrX3ZlcnNpb25fdm90ZSA9IF90eXBlcy5kZWZhdWx0LnZvaWQ7XG52YXIgdmVyc2lvbiA9IF90eXBlcy5kZWZhdWx0LnZvaWQ7IC8vIFBsYWNlLWhvbGRlciwgdGhlaXIgYXJlIGRlcGVuZGVuY2llcyBvbiBcIm9wZXJhdGlvblwiIC4uIFRoZSBmaW5hbCBsaXN0IG9mXG4vLyBvcGVyYXRpb25zIGlzIG5vdCBhdmlhbGJsZSB1bnRpbCB0aGUgdmVyeSBlbmQgb2YgdGhlIGdlbmVyYXRlZCBjb2RlLlxuLy8gU2VlOiBvcGVyYXRpb24uc3Rfb3BlcmF0aW9ucyA9IC4uLlxuXG52YXIgb3BlcmF0aW9uID0gc3RhdGljX3ZhcmlhbnQoKTtcbm1vZHVsZS5leHBvcnRzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjsgLy8gRm9yIG1vZHVsZS5leHBvcnRzXG5cbnZhciBTZXJpYWxpemVyID0gZnVuY3Rpb24gU2VyaWFsaXplcihvcGVyYXRpb25fbmFtZSwgc2VyaWxpemF0aW9uX3R5cGVzX29iamVjdCkge1xuICB2YXIgcyA9IG5ldyBfc2VyaWFsaXplci5kZWZhdWx0KG9wZXJhdGlvbl9uYW1lLCBzZXJpbGl6YXRpb25fdHlwZXNfb2JqZWN0KTtcbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzW29wZXJhdGlvbl9uYW1lXSA9IHM7XG59O1xuXG52YXIgYmVuZWZpY2lhcmllcyA9IG5ldyBTZXJpYWxpemVyKFwiYmVuZWZpY2lhcmllc1wiLCB7XG4gIGFjY291bnQ6IHN0cmluZyxcbiAgd2VpZ2h0OiB1aW50MTZcbn0pO1xudmFyIGNvbW1lbnRfcGF5b3V0X2JlbmVmaWNpYXJpZXMgPSBuZXcgU2VyaWFsaXplcigwLCB7XG4gIGJlbmVmaWNpYXJpZXM6IHNldChiZW5lZmljaWFyaWVzKVxufSk7XG52YXIgY29tbWVudF9hdWN0aW9uX3dpbmRvd19yZXdhcmRfZGVzdGluYXRpb24gPSBuZXcgU2VyaWFsaXplcigxLCB7XG4gIGRlc3RpbmF0aW9uOiB1aW50NjRcbn0pO1xudmFyIGNvbW1lbnRfY3VyYXRpb25fcmV3YXJkc19wZXJjZW50ID0gbmV3IFNlcmlhbGl6ZXIoMiwge1xuICBwZXJjZW50OiB1aW50MTZcbn0pO1xudmFyIGFjY291bnRfcmVmZXJyYWwgPSBuZXcgU2VyaWFsaXplcigwLCB7XG4gIHJlZmVycmVyOiBzdHJpbmcsXG4gIGludGVyZXN0X3JhdGU6IHVpbnQxNixcbiAgZW5kX2RhdGU6IHRpbWVfcG9pbnRfc2VjLFxuICBicmVha19mZWU6IGFzc2V0XG59KTtcbnZhciB0cmFuc2FjdGlvbiA9IG5ldyBTZXJpYWxpemVyKFwidHJhbnNhY3Rpb25cIiwge1xuICByZWZfYmxvY2tfbnVtOiB1aW50MTYsXG4gIHJlZl9ibG9ja19wcmVmaXg6IHVpbnQzMixcbiAgZXhwaXJhdGlvbjogdGltZV9wb2ludF9zZWMsXG4gIG9wZXJhdGlvbnM6IGFycmF5KG9wZXJhdGlvbiksXG4gIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucylcbn0pO1xudmFyIGVuY3J5cHRlZF9tZW1vID0gbmV3IFNlcmlhbGl6ZXIoXCJlbmNyeXB0ZWRfbWVtb1wiLCB7XG4gIGZyb206IHB1YmxpY19rZXksXG4gIHRvOiBwdWJsaWNfa2V5LFxuICBub25jZTogdWludDY0LFxuICBjaGVjazogdWludDMyLFxuICBlbmNyeXB0ZWQ6IHN0cmluZ19iaW5hcnlcbn0pOyAvLyBDdXN0b20tdHlwZXMgYWZ0ZXIgR2VuZXJhdGVkIGNvZGVcbi8vICMjICBHZW5lcmF0ZWQgY29kZSBmb2xsb3dzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qXG5XaGVuIHVwZGF0aW5nIGdlbmVyYXRlZCBjb2RlIChmaXggY2xvc2luZyBub3RhdGlvbilcblJlcGxhY2U6ICB2YXIgb3BlcmF0aW9uID0gc3RhdGljX3ZhcmlhbnQoW1xud2l0aDogICAgIG9wZXJhdGlvbi5zdF9vcGVyYXRpb25zID0gW1xuXG5EZWxldGUgKHRoZXNlIGFyZSBjdXN0b20gdHlwZXMgaW5zdGVhZCk6XG5sZXQgcHVibGljX2tleSA9IG5ldyBTZXJpYWxpemVyKCBcbiAgICBcInB1YmxpY19rZXlcIixcbiAgICB7a2V5X2RhdGE6IGJ5dGVzKDMzKX1cbik7XG5cbmxldCBhc3NldCA9IG5ldyBTZXJpYWxpemVyKCBcbiAgICBcImFzc2V0XCIsXG4gICAge2Ftb3VudDogaW50NjQsXG4gICAgc3ltYm9sOiB1aW50NjR9XG4pO1xuXG5SZXBsYWNlOiBhdXRob3JpdHkucHJvdG90eXBlLmFjY291bnRfYXV0aG9yaXR5X21hcFxuV2l0aDogbWFwKChzdHJpbmcpLCAodWludDE2KSlcbiovXG5cbnZhciBzaWduZWRfdHJhbnNhY3Rpb24gPSBuZXcgU2VyaWFsaXplcihcInNpZ25lZF90cmFuc2FjdGlvblwiLCB7XG4gIHJlZl9ibG9ja19udW06IHVpbnQxNixcbiAgcmVmX2Jsb2NrX3ByZWZpeDogdWludDMyLFxuICBleHBpcmF0aW9uOiB0aW1lX3BvaW50X3NlYyxcbiAgb3BlcmF0aW9uczogYXJyYXkob3BlcmF0aW9uKSxcbiAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKSxcbiAgc2lnbmF0dXJlczogYXJyYXkoYnl0ZXMoNjUpKVxufSk7XG52YXIgc2lnbmVkX2Jsb2NrID0gbmV3IFNlcmlhbGl6ZXIoXCJzaWduZWRfYmxvY2tcIiwge1xuICBwcmV2aW91czogYnl0ZXMoMjApLFxuICB0aW1lc3RhbXA6IHRpbWVfcG9pbnRfc2VjLFxuICB3aXRuZXNzOiBzdHJpbmcsXG4gIHRyYW5zYWN0aW9uX21lcmtsZV9yb290OiBieXRlcygyMCksXG4gIGV4dGVuc2lvbnM6IHNldChzdGF0aWNfdmFyaWFudChbZnV0dXJlX2V4dGVuc2lvbnMsIHZlcnNpb24sIGhhcmRmb3JrX3ZlcnNpb25fdm90ZV0pKSxcbiAgd2l0bmVzc19zaWduYXR1cmU6IGJ5dGVzKDY1KSxcbiAgdHJhbnNhY3Rpb25zOiBhcnJheShzaWduZWRfdHJhbnNhY3Rpb24pXG59KTtcbnZhciBibG9ja19oZWFkZXIgPSBuZXcgU2VyaWFsaXplcihcImJsb2NrX2hlYWRlclwiLCB7XG4gIHByZXZpb3VzOiBieXRlcygyMCksXG4gIHRpbWVzdGFtcDogdGltZV9wb2ludF9zZWMsXG4gIHdpdG5lc3M6IHN0cmluZyxcbiAgdHJhbnNhY3Rpb25fbWVya2xlX3Jvb3Q6IGJ5dGVzKDIwKSxcbiAgZXh0ZW5zaW9uczogc2V0KHN0YXRpY192YXJpYW50KFtmdXR1cmVfZXh0ZW5zaW9ucywgdmVyc2lvbiwgaGFyZGZvcmtfdmVyc2lvbl92b3RlXSkpXG59KTtcbnZhciBzaWduZWRfYmxvY2tfaGVhZGVyID0gbmV3IFNlcmlhbGl6ZXIoXCJzaWduZWRfYmxvY2tfaGVhZGVyXCIsIHtcbiAgcHJldmlvdXM6IGJ5dGVzKDIwKSxcbiAgdGltZXN0YW1wOiB0aW1lX3BvaW50X3NlYyxcbiAgd2l0bmVzczogc3RyaW5nLFxuICB0cmFuc2FjdGlvbl9tZXJrbGVfcm9vdDogYnl0ZXMoMjApLFxuICBleHRlbnNpb25zOiBzZXQoc3RhdGljX3ZhcmlhbnQoW2Z1dHVyZV9leHRlbnNpb25zLCB2ZXJzaW9uLCBoYXJkZm9ya192ZXJzaW9uX3ZvdGVdKSksXG4gIHdpdG5lc3Nfc2lnbmF0dXJlOiBieXRlcyg2NSlcbn0pO1xudmFyIHZvdGUgPSBuZXcgU2VyaWFsaXplcihcInZvdGVcIiwge1xuICB2b3Rlcjogc3RyaW5nLFxuICBhdXRob3I6IHN0cmluZyxcbiAgcGVybWxpbms6IHN0cmluZyxcbiAgd2VpZ2h0OiBpbnQxNlxufSk7XG52YXIgY29tbWVudCA9IG5ldyBTZXJpYWxpemVyKFwiY29tbWVudFwiLCB7XG4gIHBhcmVudF9hdXRob3I6IHN0cmluZyxcbiAgcGFyZW50X3Blcm1saW5rOiBzdHJpbmcsXG4gIGF1dGhvcjogc3RyaW5nLFxuICBwZXJtbGluazogc3RyaW5nLFxuICB0aXRsZTogc3RyaW5nLFxuICBib2R5OiBzdHJpbmcsXG4gIGpzb25fbWV0YWRhdGE6IHN0cmluZ1xufSk7XG52YXIgdHJhbnNmZXIgPSBuZXcgU2VyaWFsaXplcihcInRyYW5zZmVyXCIsIHtcbiAgZnJvbTogc3RyaW5nLFxuICB0bzogc3RyaW5nLFxuICBhbW91bnQ6IGFzc2V0LFxuICBtZW1vOiBzdHJpbmdcbn0pO1xudmFyIHRyYW5zZmVyX3RvX3Zlc3RpbmcgPSBuZXcgU2VyaWFsaXplcihcInRyYW5zZmVyX3RvX3Zlc3RpbmdcIiwge1xuICBmcm9tOiBzdHJpbmcsXG4gIHRvOiBzdHJpbmcsXG4gIGFtb3VudDogYXNzZXRcbn0pO1xudmFyIHdpdGhkcmF3X3Zlc3RpbmcgPSBuZXcgU2VyaWFsaXplcihcIndpdGhkcmF3X3Zlc3RpbmdcIiwge1xuICBhY2NvdW50OiBzdHJpbmcsXG4gIHZlc3Rpbmdfc2hhcmVzOiBhc3NldFxufSk7XG52YXIgbGltaXRfb3JkZXJfY3JlYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJsaW1pdF9vcmRlcl9jcmVhdGVcIiwge1xuICBvd25lcjogc3RyaW5nLFxuICBvcmRlcmlkOiB1aW50MzIsXG4gIGFtb3VudF90b19zZWxsOiBhc3NldCxcbiAgbWluX3RvX3JlY2VpdmU6IGFzc2V0LFxuICBmaWxsX29yX2tpbGw6IGJvb2wsXG4gIGV4cGlyYXRpb246IHRpbWVfcG9pbnRfc2VjXG59KTtcbnZhciBsaW1pdF9vcmRlcl9jYW5jZWwgPSBuZXcgU2VyaWFsaXplcihcImxpbWl0X29yZGVyX2NhbmNlbFwiLCB7XG4gIG93bmVyOiBzdHJpbmcsXG4gIG9yZGVyaWQ6IHVpbnQzMlxufSk7XG52YXIgcHJpY2UgPSBuZXcgU2VyaWFsaXplcihcInByaWNlXCIsIHtcbiAgYmFzZTogYXNzZXQsXG4gIHF1b3RlOiBhc3NldFxufSk7XG52YXIgZmVlZF9wdWJsaXNoID0gbmV3IFNlcmlhbGl6ZXIoXCJmZWVkX3B1Ymxpc2hcIiwge1xuICBwdWJsaXNoZXI6IHN0cmluZyxcbiAgZXhjaGFuZ2VfcmF0ZTogcHJpY2Vcbn0pO1xudmFyIGNvbnZlcnQgPSBuZXcgU2VyaWFsaXplcihcImNvbnZlcnRcIiwge1xuICBvd25lcjogc3RyaW5nLFxuICByZXF1ZXN0aWQ6IHVpbnQzMixcbiAgYW1vdW50OiBhc3NldFxufSk7XG52YXIgYXV0aG9yaXR5ID0gbmV3IFNlcmlhbGl6ZXIoXCJhdXRob3JpdHlcIiwge1xuICB3ZWlnaHRfdGhyZXNob2xkOiB1aW50MzIsXG4gIGFjY291bnRfYXV0aHM6IG1hcChzdHJpbmcsIHVpbnQxNiksXG4gIGtleV9hdXRoczogbWFwKHB1YmxpY19rZXksIHVpbnQxNilcbn0pO1xudmFyIGFjY291bnRfY3JlYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJhY2NvdW50X2NyZWF0ZVwiLCB7XG4gIGZlZTogYXNzZXQsXG4gIGNyZWF0b3I6IHN0cmluZyxcbiAgbmV3X2FjY291bnRfbmFtZTogZml4ZWRfc3RyaW5nLFxuICBvd25lcjogYXV0aG9yaXR5LFxuICBhY3RpdmU6IGF1dGhvcml0eSxcbiAgcG9zdGluZzogYXV0aG9yaXR5LFxuICBtZW1vX2tleTogcHVibGljX2tleSxcbiAganNvbl9tZXRhZGF0YTogc3RyaW5nXG59KTtcbnZhciBhY2NvdW50X3VwZGF0ZSA9IG5ldyBTZXJpYWxpemVyKFwiYWNjb3VudF91cGRhdGVcIiwge1xuICBhY2NvdW50OiBzdHJpbmcsXG4gIG93bmVyOiBvcHRpb25hbChhdXRob3JpdHkpLFxuICBhY3RpdmU6IG9wdGlvbmFsKGF1dGhvcml0eSksXG4gIHBvc3Rpbmc6IG9wdGlvbmFsKGF1dGhvcml0eSksXG4gIG1lbW9fa2V5OiBwdWJsaWNfa2V5LFxuICBqc29uX21ldGFkYXRhOiBzdHJpbmdcbn0pO1xudmFyIGNoYWluX3Byb3BlcnRpZXMgPSBuZXcgU2VyaWFsaXplcihcImNoYWluX3Byb3BlcnRpZXNcIiwge1xuICBhY2NvdW50X2NyZWF0aW9uX2ZlZTogYXNzZXQsXG4gIG1heGltdW1fYmxvY2tfc2l6ZTogdWludDMyLFxuICBzYmRfaW50ZXJlc3RfcmF0ZTogdWludDE2XG59KTtcbnZhciB3aXRuZXNzX3VwZGF0ZSA9IG5ldyBTZXJpYWxpemVyKFwid2l0bmVzc191cGRhdGVcIiwge1xuICBvd25lcjogc3RyaW5nLFxuICB1cmw6IHN0cmluZyxcbiAgYmxvY2tfc2lnbmluZ19rZXk6IHB1YmxpY19rZXksXG4gIHByb3BzOiBjaGFpbl9wcm9wZXJ0aWVzLFxuICBmZWU6IGFzc2V0XG59KTtcbnZhciBhY2NvdW50X3dpdG5lc3Nfdm90ZSA9IG5ldyBTZXJpYWxpemVyKFwiYWNjb3VudF93aXRuZXNzX3ZvdGVcIiwge1xuICBhY2NvdW50OiBzdHJpbmcsXG4gIHdpdG5lc3M6IHN0cmluZyxcbiAgYXBwcm92ZTogYm9vbFxufSk7XG52YXIgYWNjb3VudF93aXRuZXNzX3Byb3h5ID0gbmV3IFNlcmlhbGl6ZXIoXCJhY2NvdW50X3dpdG5lc3NfcHJveHlcIiwge1xuICBhY2NvdW50OiBzdHJpbmcsXG4gIHByb3h5OiBzdHJpbmdcbn0pO1xudmFyIHBvdyA9IG5ldyBTZXJpYWxpemVyKFwicG93XCIsIHtcbiAgd29ya2VyOiBwdWJsaWNfa2V5LFxuICBpbnB1dDogYnl0ZXMoMzIpLFxuICBzaWduYXR1cmU6IGJ5dGVzKDY1KSxcbiAgd29yazogYnl0ZXMoMzIpXG59KTtcbnZhciBjdXN0b20gPSBuZXcgU2VyaWFsaXplcihcImN1c3RvbVwiLCB7XG4gIHJlcXVpcmVkX2F1dGhzOiBzZXQoc3RyaW5nKSxcbiAgaWQ6IHVpbnQxNixcbiAgZGF0YTogYnl0ZXMoKVxufSk7XG52YXIgcmVwb3J0X292ZXJfcHJvZHVjdGlvbiA9IG5ldyBTZXJpYWxpemVyKFwicmVwb3J0X292ZXJfcHJvZHVjdGlvblwiLCB7XG4gIHJlcG9ydGVyOiBzdHJpbmcsXG4gIGZpcnN0X2Jsb2NrOiBzaWduZWRfYmxvY2tfaGVhZGVyLFxuICBzZWNvbmRfYmxvY2s6IHNpZ25lZF9ibG9ja19oZWFkZXJcbn0pO1xudmFyIGRlbGV0ZV9jb21tZW50ID0gbmV3IFNlcmlhbGl6ZXIoXCJkZWxldGVfY29tbWVudFwiLCB7XG4gIGF1dGhvcjogc3RyaW5nLFxuICBwZXJtbGluazogc3RyaW5nXG59KTtcbnZhciBjdXN0b21fanNvbiA9IG5ldyBTZXJpYWxpemVyKFwiY3VzdG9tX2pzb25cIiwge1xuICByZXF1aXJlZF9hdXRoczogc2V0KHN0cmluZyksXG4gIHJlcXVpcmVkX3Bvc3RpbmdfYXV0aHM6IHNldChzdHJpbmcpLFxuICBpZDogc3RyaW5nLFxuICBqc29uOiBzdHJpbmdcbn0pO1xudmFyIGNvbW1lbnRfb3B0aW9ucyA9IG5ldyBTZXJpYWxpemVyKFwiY29tbWVudF9vcHRpb25zXCIsIHtcbiAgYXV0aG9yOiBzdHJpbmcsXG4gIHBlcm1saW5rOiBzdHJpbmcsXG4gIG1heF9hY2NlcHRlZF9wYXlvdXQ6IGFzc2V0LFxuICBwZXJjZW50X3N0ZWVtX2RvbGxhcnM6IHVpbnQxNixcbiAgYWxsb3dfdm90ZXM6IGJvb2wsXG4gIGFsbG93X2N1cmF0aW9uX3Jld2FyZHM6IGJvb2wsXG4gIGV4dGVuc2lvbnM6IHNldChzdGF0aWNfdmFyaWFudChbY29tbWVudF9wYXlvdXRfYmVuZWZpY2lhcmllcywgY29tbWVudF9hdWN0aW9uX3dpbmRvd19yZXdhcmRfZGVzdGluYXRpb24sIGNvbW1lbnRfY3VyYXRpb25fcmV3YXJkc19wZXJjZW50XSkpXG59KTtcbnZhciBzZXRfd2l0aGRyYXdfdmVzdGluZ19yb3V0ZSA9IG5ldyBTZXJpYWxpemVyKFwic2V0X3dpdGhkcmF3X3Zlc3Rpbmdfcm91dGVcIiwge1xuICBmcm9tX2FjY291bnQ6IHN0cmluZyxcbiAgdG9fYWNjb3VudDogc3RyaW5nLFxuICBwZXJjZW50OiB1aW50MTYsXG4gIGF1dG9fdmVzdDogYm9vbFxufSk7XG52YXIgbGltaXRfb3JkZXJfY3JlYXRlMiA9IG5ldyBTZXJpYWxpemVyKFwibGltaXRfb3JkZXJfY3JlYXRlMlwiLCB7XG4gIG93bmVyOiBzdHJpbmcsXG4gIG9yZGVyaWQ6IHVpbnQzMixcbiAgYW1vdW50X3RvX3NlbGw6IGFzc2V0LFxuICBleGNoYW5nZV9yYXRlOiBwcmljZSxcbiAgZmlsbF9vcl9raWxsOiBib29sLFxuICBleHBpcmF0aW9uOiB0aW1lX3BvaW50X3NlY1xufSk7XG52YXIgY2hhbGxlbmdlX2F1dGhvcml0eSA9IG5ldyBTZXJpYWxpemVyKFwiY2hhbGxlbmdlX2F1dGhvcml0eVwiLCB7XG4gIGNoYWxsZW5nZXI6IHN0cmluZyxcbiAgY2hhbGxlbmdlZDogc3RyaW5nLFxuICByZXF1aXJlX293bmVyOiBib29sXG59KTtcbnZhciBwcm92ZV9hdXRob3JpdHkgPSBuZXcgU2VyaWFsaXplcihcInByb3ZlX2F1dGhvcml0eVwiLCB7XG4gIGNoYWxsZW5nZWQ6IHN0cmluZyxcbiAgcmVxdWlyZV9vd25lcjogYm9vbFxufSk7XG52YXIgcmVxdWVzdF9hY2NvdW50X3JlY292ZXJ5ID0gbmV3IFNlcmlhbGl6ZXIoXCJyZXF1ZXN0X2FjY291bnRfcmVjb3ZlcnlcIiwge1xuICByZWNvdmVyeV9hY2NvdW50OiBzdHJpbmcsXG4gIGFjY291bnRfdG9fcmVjb3Zlcjogc3RyaW5nLFxuICBuZXdfb3duZXJfYXV0aG9yaXR5OiBhdXRob3JpdHksXG4gIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucylcbn0pO1xudmFyIHJlY292ZXJfYWNjb3VudCA9IG5ldyBTZXJpYWxpemVyKFwicmVjb3Zlcl9hY2NvdW50XCIsIHtcbiAgYWNjb3VudF90b19yZWNvdmVyOiBzdHJpbmcsXG4gIG5ld19vd25lcl9hdXRob3JpdHk6IGF1dGhvcml0eSxcbiAgcmVjZW50X293bmVyX2F1dGhvcml0eTogYXV0aG9yaXR5LFxuICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpXG59KTtcbnZhciBjaGFuZ2VfcmVjb3ZlcnlfYWNjb3VudCA9IG5ldyBTZXJpYWxpemVyKFwiY2hhbmdlX3JlY292ZXJ5X2FjY291bnRcIiwge1xuICBhY2NvdW50X3RvX3JlY292ZXI6IHN0cmluZyxcbiAgbmV3X3JlY292ZXJ5X2FjY291bnQ6IHN0cmluZyxcbiAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKVxufSk7XG52YXIgZXNjcm93X3RyYW5zZmVyID0gbmV3IFNlcmlhbGl6ZXIoXCJlc2Nyb3dfdHJhbnNmZXJcIiwge1xuICBmcm9tOiBzdHJpbmcsXG4gIHRvOiBzdHJpbmcsXG4gIHNiZF9hbW91bnQ6IGFzc2V0LFxuICBzdGVlbV9hbW91bnQ6IGFzc2V0LFxuICBlc2Nyb3dfaWQ6IHVpbnQzMixcbiAgYWdlbnQ6IHN0cmluZyxcbiAgZmVlOiBhc3NldCxcbiAganNvbl9tZXRhOiBzdHJpbmcsXG4gIHJhdGlmaWNhdGlvbl9kZWFkbGluZTogdGltZV9wb2ludF9zZWMsXG4gIGVzY3Jvd19leHBpcmF0aW9uOiB0aW1lX3BvaW50X3NlY1xufSk7XG52YXIgZXNjcm93X2Rpc3B1dGUgPSBuZXcgU2VyaWFsaXplcihcImVzY3Jvd19kaXNwdXRlXCIsIHtcbiAgZnJvbTogc3RyaW5nLFxuICB0bzogc3RyaW5nLFxuICBhZ2VudDogc3RyaW5nLFxuICB3aG86IHN0cmluZyxcbiAgZXNjcm93X2lkOiB1aW50MzJcbn0pO1xudmFyIGVzY3Jvd19yZWxlYXNlID0gbmV3IFNlcmlhbGl6ZXIoXCJlc2Nyb3dfcmVsZWFzZVwiLCB7XG4gIGZyb206IHN0cmluZyxcbiAgdG86IHN0cmluZyxcbiAgYWdlbnQ6IHN0cmluZyxcbiAgd2hvOiBzdHJpbmcsXG4gIHJlY2VpdmVyOiBzdHJpbmcsXG4gIGVzY3Jvd19pZDogdWludDMyLFxuICBzYmRfYW1vdW50OiBhc3NldCxcbiAgc3RlZW1fYW1vdW50OiBhc3NldFxufSk7XG52YXIgcG93Ml9pbnB1dCA9IG5ldyBTZXJpYWxpemVyKFwicG93Ml9pbnB1dFwiLCB7XG4gIHdvcmtlcl9hY2NvdW50OiBzdHJpbmcsXG4gIHByZXZfYmxvY2s6IGJ5dGVzKDIwKSxcbiAgbm9uY2U6IHVpbnQ2NFxufSk7XG52YXIgcG93MiA9IG5ldyBTZXJpYWxpemVyKFwicG93MlwiLCB7XG4gIGlucHV0OiBwb3cyX2lucHV0LFxuICBwb3dfc3VtbWFyeTogdWludDMyXG59KTtcbnZhciBlcXVpaGFzaF9wcm9vZiA9IG5ldyBTZXJpYWxpemVyKFwiZXF1aWhhc2hfcHJvb2ZcIiwge1xuICBuOiB1aW50MzIsXG4gIGs6IHVpbnQzMixcbiAgc2VlZDogYnl0ZXMoMzIpLFxuICBpbnB1dHM6IGFycmF5KHVpbnQzMilcbn0pO1xudmFyIGVxdWloYXNoX3BvdyA9IG5ldyBTZXJpYWxpemVyKFwiZXF1aWhhc2hfcG93XCIsIHtcbiAgaW5wdXQ6IHBvdzJfaW5wdXQsXG4gIHByb29mOiBlcXVpaGFzaF9wcm9vZixcbiAgcHJldl9ibG9jazogYnl0ZXMoMjApLFxuICBwb3dfc3VtbWFyeTogdWludDMyXG59KTtcbnZhciBlc2Nyb3dfYXBwcm92ZSA9IG5ldyBTZXJpYWxpemVyKFwiZXNjcm93X2FwcHJvdmVcIiwge1xuICBmcm9tOiBzdHJpbmcsXG4gIHRvOiBzdHJpbmcsXG4gIGFnZW50OiBzdHJpbmcsXG4gIHdobzogc3RyaW5nLFxuICBlc2Nyb3dfaWQ6IHVpbnQzMixcbiAgYXBwcm92ZTogYm9vbFxufSk7XG52YXIgdHJhbnNmZXJfdG9fc2F2aW5ncyA9IG5ldyBTZXJpYWxpemVyKFwidHJhbnNmZXJfdG9fc2F2aW5nc1wiLCB7XG4gIGZyb206IHN0cmluZyxcbiAgdG86IHN0cmluZyxcbiAgYW1vdW50OiBhc3NldCxcbiAgbWVtbzogc3RyaW5nXG59KTtcbnZhciB0cmFuc2Zlcl9mcm9tX3NhdmluZ3MgPSBuZXcgU2VyaWFsaXplcihcInRyYW5zZmVyX2Zyb21fc2F2aW5nc1wiLCB7XG4gIGZyb206IHN0cmluZyxcbiAgcmVxdWVzdF9pZDogdWludDMyLFxuICB0bzogc3RyaW5nLFxuICBhbW91bnQ6IGFzc2V0LFxuICBtZW1vOiBzdHJpbmdcbn0pO1xudmFyIGNhbmNlbF90cmFuc2Zlcl9mcm9tX3NhdmluZ3MgPSBuZXcgU2VyaWFsaXplcihcImNhbmNlbF90cmFuc2Zlcl9mcm9tX3NhdmluZ3NcIiwge1xuICBmcm9tOiBzdHJpbmcsXG4gIHJlcXVlc3RfaWQ6IHVpbnQzMlxufSk7XG52YXIgY3VzdG9tX2JpbmFyeSA9IG5ldyBTZXJpYWxpemVyKFwiY3VzdG9tX2JpbmFyeVwiLCB7XG4gIHJlcXVpcmVkX293bmVyX2F1dGhzOiBzZXQoc3RyaW5nKSxcbiAgcmVxdWlyZWRfYWN0aXZlX2F1dGhzOiBzZXQoc3RyaW5nKSxcbiAgcmVxdWlyZWRfcG9zdGluZ19hdXRoczogc2V0KHN0cmluZyksXG4gIHJlcXVpcmVkX2F1dGhzOiBhcnJheShhdXRob3JpdHkpLFxuICBpZDogc3RyaW5nLFxuICBkYXRhOiBieXRlcygpXG59KTtcbnZhciBkZWNsaW5lX3ZvdGluZ19yaWdodHMgPSBuZXcgU2VyaWFsaXplcihcImRlY2xpbmVfdm90aW5nX3JpZ2h0c1wiLCB7XG4gIGFjY291bnQ6IHN0cmluZyxcbiAgZGVjbGluZTogYm9vbFxufSk7XG52YXIgcmVzZXRfYWNjb3VudCA9IG5ldyBTZXJpYWxpemVyKFwicmVzZXRfYWNjb3VudFwiLCB7XG4gIHJlc2V0X2FjY291bnQ6IHN0cmluZyxcbiAgYWNjb3VudF90b19yZXNldDogc3RyaW5nLFxuICBuZXdfb3duZXJfYXV0aG9yaXR5OiBhdXRob3JpdHlcbn0pO1xudmFyIHNldF9yZXNldF9hY2NvdW50ID0gbmV3IFNlcmlhbGl6ZXIoXCJzZXRfcmVzZXRfYWNjb3VudFwiLCB7XG4gIGFjY291bnQ6IHN0cmluZyxcbiAgY3VycmVudF9yZXNldF9hY2NvdW50OiBzdHJpbmcsXG4gIHJlc2V0X2FjY291bnQ6IHN0cmluZ1xufSk7XG52YXIgZGVsZWdhdGVfdmVzdGluZ19zaGFyZXMgPSBuZXcgU2VyaWFsaXplcihcImRlbGVnYXRlX3Zlc3Rpbmdfc2hhcmVzXCIsIHtcbiAgZGVsZWdhdG9yOiBzdHJpbmcsXG4gIGRlbGVnYXRlZTogc3RyaW5nLFxuICB2ZXN0aW5nX3NoYXJlczogYXNzZXRcbn0pO1xudmFyIGFjY291bnRfY3JlYXRlX3dpdGhfZGVsZWdhdGlvbiA9IG5ldyBTZXJpYWxpemVyKFwiYWNjb3VudF9jcmVhdGVfd2l0aF9kZWxlZ2F0aW9uXCIsIHtcbiAgZmVlOiBhc3NldCxcbiAgZGVsZWdhdGlvbjogYXNzZXQsXG4gIGNyZWF0b3I6IHN0cmluZyxcbiAgbmV3X2FjY291bnRfbmFtZTogZml4ZWRfc3RyaW5nLFxuICBvd25lcjogYXV0aG9yaXR5LFxuICBhY3RpdmU6IGF1dGhvcml0eSxcbiAgcG9zdGluZzogYXV0aG9yaXR5LFxuICBtZW1vX2tleTogcHVibGljX2tleSxcbiAganNvbl9tZXRhZGF0YTogc3RyaW5nLFxuICBleHRlbnNpb25zOiBzZXQoc3RhdGljX3ZhcmlhbnQoW2FjY291bnRfcmVmZXJyYWxdKSlcbn0pO1xudmFyIGFjY291bnRfY3JlYXRlX3dpdGhfaW52aXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJhY2NvdW50X2NyZWF0ZV93aXRoX2ludml0ZVwiLCB7XG4gIGludml0ZV9zZWNyZXQ6IHN0cmluZyxcbiAgY3JlYXRvcjogc3RyaW5nLFxuICBuZXdfYWNjb3VudF9uYW1lOiBmaXhlZF9zdHJpbmcsXG4gIG93bmVyOiBhdXRob3JpdHksXG4gIGFjdGl2ZTogYXV0aG9yaXR5LFxuICBwb3N0aW5nOiBhdXRob3JpdHksXG4gIG1lbW9fa2V5OiBwdWJsaWNfa2V5LFxuICBqc29uX21ldGFkYXRhOiBzdHJpbmcsXG4gIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucylcbn0pO1xudmFyIGFjY291bnRfbWV0YWRhdGEgPSBuZXcgU2VyaWFsaXplcihcImFjY291bnRfbWV0YWRhdGFcIiwge1xuICBhY2NvdW50OiBzdHJpbmcsXG4gIGpzb25fbWV0YWRhdGE6IHN0cmluZ1xufSk7XG52YXIgb3BlcmF0aW9uX3dyYXBwZXIgPSBuZXcgU2VyaWFsaXplcihcIm9wZXJhdGlvbl93cmFwcGVyXCIsIHtcbiAgb3A6IG9wZXJhdGlvblxufSk7XG52YXIgcHJvcG9zYWxfY3JlYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJwcm9wb3NhbF9jcmVhdGVcIiwge1xuICBhdXRob3I6IHN0cmluZyxcbiAgdGl0bGU6IHN0cmluZyxcbiAgbWVtbzogc3RyaW5nLFxuICBleHBpcmF0aW9uX3RpbWU6IHRpbWVfcG9pbnRfc2VjLFxuICBwcm9wb3NlZF9vcGVyYXRpb25zOiBhcnJheShvcGVyYXRpb25fd3JhcHBlciksXG4gIHJldmlld19wZXJpb2RfdGltZTogb3B0aW9uYWwodGltZV9wb2ludF9zZWMpLFxuICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpXG59KTtcbnZhciBwcm9wb3NhbF91cGRhdGUgPSBuZXcgU2VyaWFsaXplcihcInByb3Bvc2FsX3VwZGF0ZVwiLCB7XG4gIGF1dGhvcjogc3RyaW5nLFxuICB0aXRsZTogc3RyaW5nLFxuICBhY3RpdmVfYXBwcm92YWxzX3RvX2FkZDogc2V0KHN0cmluZyksXG4gIGFjdGl2ZV9hcHByb3ZhbHNfdG9fcmVtb3ZlOiBzZXQoc3RyaW5nKSxcbiAgb3duZXJfYXBwcm92YWxzX3RvX2FkZDogc2V0KHN0cmluZyksXG4gIG93bmVyX2FwcHJvdmFsc190b19yZW1vdmU6IHNldChzdHJpbmcpLFxuICBwb3N0aW5nX2FwcHJvdmFsc190b19hZGQ6IHNldChzdHJpbmcpLFxuICBwb3N0aW5nX2FwcHJvdmFsc190b19yZW1vdmU6IHNldChzdHJpbmcpLFxuICBrZXlfYXBwcm92YWxzX3RvX2FkZDogc2V0KHB1YmxpY19rZXkpLFxuICBrZXlfYXBwcm92YWxzX3RvX3JlbW92ZTogc2V0KHB1YmxpY19rZXkpLFxuICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpXG59KTtcbnZhciBwcm9wb3NhbF9kZWxldGUgPSBuZXcgU2VyaWFsaXplcihcInByb3Bvc2FsX2RlbGV0ZVwiLCB7XG4gIGF1dGhvcjogc3RyaW5nLFxuICB0aXRsZTogc3RyaW5nLFxuICByZXF1ZXN0ZXI6IHN0cmluZyxcbiAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKVxufSk7XG52YXIgY2hhaW5fcHJvcGVydGllc18xOCA9IG5ldyBTZXJpYWxpemVyKDEsIHtcbiAgYWNjb3VudF9jcmVhdGlvbl9mZWU6IGFzc2V0LFxuICBtYXhpbXVtX2Jsb2NrX3NpemU6IHVpbnQzMixcbiAgc2JkX2ludGVyZXN0X3JhdGU6IHVpbnQxNixcbiAgY3JlYXRlX2FjY291bnRfbWluX2dvbG9zX2ZlZTogYXNzZXQsXG4gIGNyZWF0ZV9hY2NvdW50X21pbl9kZWxlZ2F0aW9uOiBhc3NldCxcbiAgY3JlYXRlX2FjY291bnRfZGVsZWdhdGlvbl90aW1lOiB1aW50MzIsXG4gIG1pbl9kZWxlZ2F0aW9uOiBhc3NldFxufSk7XG52YXIgY2hhaW5fcHJvcGVydGllc18xOSA9IG5ldyBTZXJpYWxpemVyKDIsIHtcbiAgYWNjb3VudF9jcmVhdGlvbl9mZWU6IGFzc2V0LFxuICBtYXhpbXVtX2Jsb2NrX3NpemU6IHVpbnQzMixcbiAgc2JkX2ludGVyZXN0X3JhdGU6IHVpbnQxNixcbiAgY3JlYXRlX2FjY291bnRfbWluX2dvbG9zX2ZlZTogYXNzZXQsXG4gIGNyZWF0ZV9hY2NvdW50X21pbl9kZWxlZ2F0aW9uOiBhc3NldCxcbiAgY3JlYXRlX2FjY291bnRfZGVsZWdhdGlvbl90aW1lOiB1aW50MzIsXG4gIG1pbl9kZWxlZ2F0aW9uOiBhc3NldCxcbiAgbWF4X3JlZmVycmFsX2ludGVyZXN0X3JhdGU6IHVpbnQxNixcbiAgbWF4X3JlZmVycmFsX3Rlcm1fc2VjOiB1aW50MzIsXG4gIG1pbl9yZWZlcnJhbF9icmVha19mZWU6IGFzc2V0LFxuICBtYXhfcmVmZXJyYWxfYnJlYWtfZmVlOiBhc3NldCxcbiAgcG9zdHNfd2luZG93OiB1aW50MTYsXG4gIHBvc3RzX3Blcl93aW5kb3c6IHVpbnQxNixcbiAgY29tbWVudHNfd2luZG93OiB1aW50MTYsXG4gIGNvbW1lbnRzX3Blcl93aW5kb3c6IHVpbnQxNixcbiAgdm90ZXNfd2luZG93OiB1aW50MTYsXG4gIHZvdGVzX3Blcl93aW5kb3c6IHVpbnQxNixcbiAgYXVjdGlvbl93aW5kb3dfc2l6ZTogdWludDE2LFxuICBtYXhfZGVsZWdhdGVkX3Zlc3RpbmdfaW50ZXJlc3RfcmF0ZTogdWludDE2LFxuICBjdXN0b21fb3BzX2JhbmR3aWR0aF9tdWx0aXBsaWVyOiB1aW50MTYsXG4gIG1pbl9jdXJhdGlvbl9wZXJjZW50OiB1aW50MTYsXG4gIG1heF9jdXJhdGlvbl9wZXJjZW50OiB1aW50MTYsXG4gIGN1cmF0aW9uX3Jld2FyZF9jdXJ2ZTogdWludDY0LFxuICBhbGxvd19kaXN0cmlidXRlX2F1Y3Rpb25fcmV3YXJkOiBib29sLFxuICBhbGxvd19yZXR1cm5fYXVjdGlvbl9yZXdhcmRfdG9fZnVuZDogYm9vbFxufSk7XG52YXIgY2hhaW5fcHJvcGVydGllc18yMiA9IG5ldyBTZXJpYWxpemVyKDMsIHtcbiAgYWNjb3VudF9jcmVhdGlvbl9mZWU6IGFzc2V0LFxuICBtYXhpbXVtX2Jsb2NrX3NpemU6IHVpbnQzMixcbiAgc2JkX2ludGVyZXN0X3JhdGU6IHVpbnQxNixcbiAgY3JlYXRlX2FjY291bnRfbWluX2dvbG9zX2ZlZTogYXNzZXQsXG4gIGNyZWF0ZV9hY2NvdW50X21pbl9kZWxlZ2F0aW9uOiBhc3NldCxcbiAgY3JlYXRlX2FjY291bnRfZGVsZWdhdGlvbl90aW1lOiB1aW50MzIsXG4gIG1pbl9kZWxlZ2F0aW9uOiBhc3NldCxcbiAgbWF4X3JlZmVycmFsX2ludGVyZXN0X3JhdGU6IHVpbnQxNixcbiAgbWF4X3JlZmVycmFsX3Rlcm1fc2VjOiB1aW50MzIsXG4gIG1pbl9yZWZlcnJhbF9icmVha19mZWU6IGFzc2V0LFxuICBtYXhfcmVmZXJyYWxfYnJlYWtfZmVlOiBhc3NldCxcbiAgcG9zdHNfd2luZG93OiB1aW50MTYsXG4gIHBvc3RzX3Blcl93aW5kb3c6IHVpbnQxNixcbiAgY29tbWVudHNfd2luZG93OiB1aW50MTYsXG4gIGNvbW1lbnRzX3Blcl93aW5kb3c6IHVpbnQxNixcbiAgdm90ZXNfd2luZG93OiB1aW50MTYsXG4gIHZvdGVzX3Blcl93aW5kb3c6IHVpbnQxNixcbiAgYXVjdGlvbl93aW5kb3dfc2l6ZTogdWludDE2LFxuICBtYXhfZGVsZWdhdGVkX3Zlc3RpbmdfaW50ZXJlc3RfcmF0ZTogdWludDE2LFxuICBjdXN0b21fb3BzX2JhbmR3aWR0aF9tdWx0aXBsaWVyOiB1aW50MTYsXG4gIG1pbl9jdXJhdGlvbl9wZXJjZW50OiB1aW50MTYsXG4gIG1heF9jdXJhdGlvbl9wZXJjZW50OiB1aW50MTYsXG4gIGN1cmF0aW9uX3Jld2FyZF9jdXJ2ZTogdWludDY0LFxuICBhbGxvd19kaXN0cmlidXRlX2F1Y3Rpb25fcmV3YXJkOiBib29sLFxuICBhbGxvd19yZXR1cm5fYXVjdGlvbl9yZXdhcmRfdG9fZnVuZDogYm9vbCxcbiAgd29ya2VyX3Jld2FyZF9wZXJjZW50OiB1aW50MTYsXG4gIHdpdG5lc3NfcmV3YXJkX3BlcmNlbnQ6IHVpbnQxNixcbiAgdmVzdGluZ19yZXdhcmRfcGVyY2VudDogdWludDE2LFxuICB3b3JrZXJfcmVxdWVzdF9jcmVhdGlvbl9mZWU6IGFzc2V0LFxuICB3b3JrZXJfcmVxdWVzdF9hcHByb3ZlX21pbl9wZXJjZW50OiB1aW50MTYsXG4gIHNiZF9kZWJ0X2NvbnZlcnRfcmF0ZTogdWludDE2LFxuICB2b3RlX3JlZ2VuZXJhdGlvbl9wZXJfZGF5OiB1aW50MzIsXG4gIHdpdG5lc3Nfc2tpcHBpbmdfcmVzZXRfdGltZTogdWludDMyLFxuICB3aXRuZXNzX2lkbGVuZXNzX3RpbWU6IHVpbnQzMixcbiAgYWNjb3VudF9pZGxlbmVzc190aW1lOiB1aW50MzJcbn0pO1xudmFyIGNoYWluX3Byb3BlcnRpZXNfMjMgPSBuZXcgU2VyaWFsaXplcig0LCB7XG4gIGFjY291bnRfY3JlYXRpb25fZmVlOiBhc3NldCxcbiAgbWF4aW11bV9ibG9ja19zaXplOiB1aW50MzIsXG4gIHNiZF9pbnRlcmVzdF9yYXRlOiB1aW50MTYsXG4gIGNyZWF0ZV9hY2NvdW50X21pbl9nb2xvc19mZWU6IGFzc2V0LFxuICBjcmVhdGVfYWNjb3VudF9taW5fZGVsZWdhdGlvbjogYXNzZXQsXG4gIGNyZWF0ZV9hY2NvdW50X2RlbGVnYXRpb25fdGltZTogdWludDMyLFxuICBtaW5fZGVsZWdhdGlvbjogYXNzZXQsXG4gIG1heF9yZWZlcnJhbF9pbnRlcmVzdF9yYXRlOiB1aW50MTYsXG4gIG1heF9yZWZlcnJhbF90ZXJtX3NlYzogdWludDMyLFxuICBtaW5fcmVmZXJyYWxfYnJlYWtfZmVlOiBhc3NldCxcbiAgbWF4X3JlZmVycmFsX2JyZWFrX2ZlZTogYXNzZXQsXG4gIHBvc3RzX3dpbmRvdzogdWludDE2LFxuICBwb3N0c19wZXJfd2luZG93OiB1aW50MTYsXG4gIGNvbW1lbnRzX3dpbmRvdzogdWludDE2LFxuICBjb21tZW50c19wZXJfd2luZG93OiB1aW50MTYsXG4gIHZvdGVzX3dpbmRvdzogdWludDE2LFxuICB2b3Rlc19wZXJfd2luZG93OiB1aW50MTYsXG4gIGF1Y3Rpb25fd2luZG93X3NpemU6IHVpbnQxNixcbiAgbWF4X2RlbGVnYXRlZF92ZXN0aW5nX2ludGVyZXN0X3JhdGU6IHVpbnQxNixcbiAgY3VzdG9tX29wc19iYW5kd2lkdGhfbXVsdGlwbGllcjogdWludDE2LFxuICBtaW5fY3VyYXRpb25fcGVyY2VudDogdWludDE2LFxuICBtYXhfY3VyYXRpb25fcGVyY2VudDogdWludDE2LFxuICBjdXJhdGlvbl9yZXdhcmRfY3VydmU6IHVpbnQ2NCxcbiAgYWxsb3dfZGlzdHJpYnV0ZV9hdWN0aW9uX3Jld2FyZDogYm9vbCxcbiAgYWxsb3dfcmV0dXJuX2F1Y3Rpb25fcmV3YXJkX3RvX2Z1bmQ6IGJvb2wsXG4gIHdvcmtlcl9yZXdhcmRfcGVyY2VudDogdWludDE2LFxuICB3aXRuZXNzX3Jld2FyZF9wZXJjZW50OiB1aW50MTYsXG4gIHZlc3RpbmdfcmV3YXJkX3BlcmNlbnQ6IHVpbnQxNixcbiAgd29ya2VyX3JlcXVlc3RfY3JlYXRpb25fZmVlOiBhc3NldCxcbiAgd29ya2VyX3JlcXVlc3RfYXBwcm92ZV9taW5fcGVyY2VudDogdWludDE2LFxuICBzYmRfZGVidF9jb252ZXJ0X3JhdGU6IHVpbnQxNixcbiAgdm90ZV9yZWdlbmVyYXRpb25fcGVyX2RheTogdWludDMyLFxuICB3aXRuZXNzX3NraXBwaW5nX3Jlc2V0X3RpbWU6IHVpbnQzMixcbiAgd2l0bmVzc19pZGxlbmVzc190aW1lOiB1aW50MzIsXG4gIGFjY291bnRfaWRsZW5lc3NfdGltZTogdWludDMyLFxuICBjbGFpbV9pZGxlbmVzc190aW1lOiB1aW50MzIsXG4gIG1pbl9pbnZpdGVfYmFsYW5jZTogYXNzZXRcbn0pO1xudmFyIGNoYWluX3Byb3BlcnRpZXNfMjQgPSBuZXcgU2VyaWFsaXplcig1LCB7XG4gIGFjY291bnRfY3JlYXRpb25fZmVlOiBhc3NldCxcbiAgbWF4aW11bV9ibG9ja19zaXplOiB1aW50MzIsXG4gIHNiZF9pbnRlcmVzdF9yYXRlOiB1aW50MTYsXG4gIGNyZWF0ZV9hY2NvdW50X21pbl9nb2xvc19mZWU6IGFzc2V0LFxuICBjcmVhdGVfYWNjb3VudF9taW5fZGVsZWdhdGlvbjogYXNzZXQsXG4gIGNyZWF0ZV9hY2NvdW50X2RlbGVnYXRpb25fdGltZTogdWludDMyLFxuICBtaW5fZGVsZWdhdGlvbjogYXNzZXQsXG4gIG1heF9yZWZlcnJhbF9pbnRlcmVzdF9yYXRlOiB1aW50MTYsXG4gIG1heF9yZWZlcnJhbF90ZXJtX3NlYzogdWludDMyLFxuICBtaW5fcmVmZXJyYWxfYnJlYWtfZmVlOiBhc3NldCxcbiAgbWF4X3JlZmVycmFsX2JyZWFrX2ZlZTogYXNzZXQsXG4gIHBvc3RzX3dpbmRvdzogdWludDE2LFxuICBwb3N0c19wZXJfd2luZG93OiB1aW50MTYsXG4gIGNvbW1lbnRzX3dpbmRvdzogdWludDE2LFxuICBjb21tZW50c19wZXJfd2luZG93OiB1aW50MTYsXG4gIHZvdGVzX3dpbmRvdzogdWludDE2LFxuICB2b3Rlc19wZXJfd2luZG93OiB1aW50MTYsXG4gIGF1Y3Rpb25fd2luZG93X3NpemU6IHVpbnQxNixcbiAgbWF4X2RlbGVnYXRlZF92ZXN0aW5nX2ludGVyZXN0X3JhdGU6IHVpbnQxNixcbiAgY3VzdG9tX29wc19iYW5kd2lkdGhfbXVsdGlwbGllcjogdWludDE2LFxuICBtaW5fY3VyYXRpb25fcGVyY2VudDogdWludDE2LFxuICBtYXhfY3VyYXRpb25fcGVyY2VudDogdWludDE2LFxuICBjdXJhdGlvbl9yZXdhcmRfY3VydmU6IHVpbnQ2NCxcbiAgYWxsb3dfZGlzdHJpYnV0ZV9hdWN0aW9uX3Jld2FyZDogYm9vbCxcbiAgYWxsb3dfcmV0dXJuX2F1Y3Rpb25fcmV3YXJkX3RvX2Z1bmQ6IGJvb2wsXG4gIHdvcmtlcl9yZXdhcmRfcGVyY2VudDogdWludDE2LFxuICB3aXRuZXNzX3Jld2FyZF9wZXJjZW50OiB1aW50MTYsXG4gIHZlc3RpbmdfcmV3YXJkX3BlcmNlbnQ6IHVpbnQxNixcbiAgd29ya2VyX3JlcXVlc3RfY3JlYXRpb25fZmVlOiBhc3NldCxcbiAgd29ya2VyX3JlcXVlc3RfYXBwcm92ZV9taW5fcGVyY2VudDogdWludDE2LFxuICBzYmRfZGVidF9jb252ZXJ0X3JhdGU6IHVpbnQxNixcbiAgdm90ZV9yZWdlbmVyYXRpb25fcGVyX2RheTogdWludDMyLFxuICB3aXRuZXNzX3NraXBwaW5nX3Jlc2V0X3RpbWU6IHVpbnQzMixcbiAgd2l0bmVzc19pZGxlbmVzc190aW1lOiB1aW50MzIsXG4gIGFjY291bnRfaWRsZW5lc3NfdGltZTogdWludDMyLFxuICBjbGFpbV9pZGxlbmVzc190aW1lOiB1aW50MzIsXG4gIG1pbl9pbnZpdGVfYmFsYW5jZTogYXNzZXQsXG4gIGFzc2V0X2NyZWF0aW9uX2ZlZTogYXNzZXQsXG4gIGludml0ZV90cmFuc2Zlcl9pbnRlcnZhbF9zZWM6IHVpbnQzMlxufSk7XG52YXIgY2hhaW5fcHJvcGVydGllc18yNiA9IG5ldyBTZXJpYWxpemVyKDYsIHtcbiAgYWNjb3VudF9jcmVhdGlvbl9mZWU6IGFzc2V0LFxuICBtYXhpbXVtX2Jsb2NrX3NpemU6IHVpbnQzMixcbiAgc2JkX2ludGVyZXN0X3JhdGU6IHVpbnQxNixcbiAgY3JlYXRlX2FjY291bnRfbWluX2dvbG9zX2ZlZTogYXNzZXQsXG4gIGNyZWF0ZV9hY2NvdW50X21pbl9kZWxlZ2F0aW9uOiBhc3NldCxcbiAgY3JlYXRlX2FjY291bnRfZGVsZWdhdGlvbl90aW1lOiB1aW50MzIsXG4gIG1pbl9kZWxlZ2F0aW9uOiBhc3NldCxcbiAgbWF4X3JlZmVycmFsX2ludGVyZXN0X3JhdGU6IHVpbnQxNixcbiAgbWF4X3JlZmVycmFsX3Rlcm1fc2VjOiB1aW50MzIsXG4gIG1pbl9yZWZlcnJhbF9icmVha19mZWU6IGFzc2V0LFxuICBtYXhfcmVmZXJyYWxfYnJlYWtfZmVlOiBhc3NldCxcbiAgcG9zdHNfd2luZG93OiB1aW50MTYsXG4gIHBvc3RzX3Blcl93aW5kb3c6IHVpbnQxNixcbiAgY29tbWVudHNfd2luZG93OiB1aW50MTYsXG4gIGNvbW1lbnRzX3Blcl93aW5kb3c6IHVpbnQxNixcbiAgdm90ZXNfd2luZG93OiB1aW50MTYsXG4gIHZvdGVzX3Blcl93aW5kb3c6IHVpbnQxNixcbiAgYXVjdGlvbl93aW5kb3dfc2l6ZTogdWludDE2LFxuICBtYXhfZGVsZWdhdGVkX3Zlc3RpbmdfaW50ZXJlc3RfcmF0ZTogdWludDE2LFxuICBjdXN0b21fb3BzX2JhbmR3aWR0aF9tdWx0aXBsaWVyOiB1aW50MTYsXG4gIG1pbl9jdXJhdGlvbl9wZXJjZW50OiB1aW50MTYsXG4gIG1heF9jdXJhdGlvbl9wZXJjZW50OiB1aW50MTYsXG4gIGN1cmF0aW9uX3Jld2FyZF9jdXJ2ZTogdWludDY0LFxuICBhbGxvd19kaXN0cmlidXRlX2F1Y3Rpb25fcmV3YXJkOiBib29sLFxuICBhbGxvd19yZXR1cm5fYXVjdGlvbl9yZXdhcmRfdG9fZnVuZDogYm9vbCxcbiAgd29ya2VyX3Jld2FyZF9wZXJjZW50OiB1aW50MTYsXG4gIHdpdG5lc3NfcmV3YXJkX3BlcmNlbnQ6IHVpbnQxNixcbiAgdmVzdGluZ19yZXdhcmRfcGVyY2VudDogdWludDE2LFxuICB3b3JrZXJfcmVxdWVzdF9jcmVhdGlvbl9mZWU6IGFzc2V0LFxuICB3b3JrZXJfcmVxdWVzdF9hcHByb3ZlX21pbl9wZXJjZW50OiB1aW50MTYsXG4gIHNiZF9kZWJ0X2NvbnZlcnRfcmF0ZTogdWludDE2LFxuICB2b3RlX3JlZ2VuZXJhdGlvbl9wZXJfZGF5OiB1aW50MzIsXG4gIHdpdG5lc3Nfc2tpcHBpbmdfcmVzZXRfdGltZTogdWludDMyLFxuICB3aXRuZXNzX2lkbGVuZXNzX3RpbWU6IHVpbnQzMixcbiAgYWNjb3VudF9pZGxlbmVzc190aW1lOiB1aW50MzIsXG4gIGNsYWltX2lkbGVuZXNzX3RpbWU6IHVpbnQzMixcbiAgbWluX2ludml0ZV9iYWxhbmNlOiBhc3NldCxcbiAgYXNzZXRfY3JlYXRpb25fZmVlOiBhc3NldCxcbiAgaW52aXRlX3RyYW5zZmVyX2ludGVydmFsX3NlYzogdWludDMyLFxuICBjb252ZXJ0X2ZlZV9wZXJjZW50OiB1aW50MTYsXG4gIG1pbl9nb2xvc19wb3dlcl90b19jdXJhdGU6IGFzc2V0LFxuICB3b3JrZXJfZW1pc3Npb25fcGVyY2VudDogdWludDE2LFxuICB2ZXN0aW5nX29mX3JlbWFpbl9wZXJjZW50OiB1aW50MTYsXG4gIG5lZ3JlcF9wb3N0aW5nX3dpbmRvdzogdWludDE2LFxuICBuZWdyZXBfcG9zdGluZ19wZXJfd2luZG93OiB1aW50MTZcbn0pO1xudmFyIGNoYWluX3Byb3BlcnRpZXNfdXBkYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJjaGFpbl9wcm9wZXJ0aWVzX3VwZGF0ZVwiLCB7XG4gIG93bmVyOiBzdHJpbmcsXG4gIHByb3BzOiBzdGF0aWNfdmFyaWFudChbY2hhaW5fcHJvcGVydGllcywgY2hhaW5fcHJvcGVydGllc18xOCwgY2hhaW5fcHJvcGVydGllc18xOSwgY2hhaW5fcHJvcGVydGllc18yMiwgY2hhaW5fcHJvcGVydGllc18yMywgY2hhaW5fcHJvcGVydGllc18yNCwgY2hhaW5fcHJvcGVydGllc18yNl0pXG59KTtcbnZhciBicmVha19mcmVlX3JlZmVycmFsID0gbmV3IFNlcmlhbGl6ZXIoXCJicmVha19mcmVlX3JlZmVycmFsXCIsIHtcbiAgcmVmZXJyYWw6IHN0cmluZyxcbiAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKVxufSk7XG52YXIgZGVsZWdhdGVfdmVzdGluZ19zaGFyZXNfd2l0aF9pbnRlcmVzdCA9IG5ldyBTZXJpYWxpemVyKFwiZGVsZWdhdGVfdmVzdGluZ19zaGFyZXNfd2l0aF9pbnRlcmVzdFwiLCB7XG4gIGRlbGVnYXRvcjogc3RyaW5nLFxuICBkZWxlZ2F0ZWU6IHN0cmluZyxcbiAgdmVzdGluZ19zaGFyZXM6IGFzc2V0LFxuICBpbnRlcmVzdF9yYXRlOiB1aW50MTYsXG4gIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucylcbn0pO1xudmFyIHJlamVjdF92ZXN0aW5nX3NoYXJlc19kZWxlZ2F0aW9uID0gbmV3IFNlcmlhbGl6ZXIoXCJyZWplY3RfdmVzdGluZ19zaGFyZXNfZGVsZWdhdGlvblwiLCB7XG4gIGRlbGVnYXRvcjogc3RyaW5nLFxuICBkZWxlZ2F0ZWU6IHN0cmluZyxcbiAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKVxufSk7XG52YXIgdHJhbnNpdF90b19jeWJlcndheSA9IG5ldyBTZXJpYWxpemVyKFwidHJhbnNpdF90b19jeWJlcndheVwiLCB7XG4gIG93bmVyOiBzdHJpbmcsXG4gIHZvdGVfdG9fdHJhbnNpdDogYm9vbFxufSk7XG52YXIgd29ya2VyX3JlcXVlc3QgPSBuZXcgU2VyaWFsaXplcihcIndvcmtlcl9yZXF1ZXN0XCIsIHtcbiAgYXV0aG9yOiBzdHJpbmcsXG4gIHBlcm1saW5rOiBzdHJpbmcsXG4gIHdvcmtlcjogc3RyaW5nLFxuICByZXF1aXJlZF9hbW91bnRfbWluOiBhc3NldCxcbiAgcmVxdWlyZWRfYW1vdW50X21heDogYXNzZXQsXG4gIHZlc3RfcmV3YXJkOiBib29sLFxuICBkdXJhdGlvbjogdWludDMyLFxuICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpXG59KTtcbnZhciB3b3JrZXJfcmVxdWVzdF9kZWxldGUgPSBuZXcgU2VyaWFsaXplcihcIndvcmtlcl9yZXF1ZXN0X2RlbGV0ZVwiLCB7XG4gIGF1dGhvcjogc3RyaW5nLFxuICBwZXJtbGluazogc3RyaW5nLFxuICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpXG59KTtcbnZhciB3b3JrZXJfcmVxdWVzdF92b3RlID0gbmV3IFNlcmlhbGl6ZXIoXCJ3b3JrZXJfcmVxdWVzdF92b3RlXCIsIHtcbiAgdm90ZXI6IHN0cmluZyxcbiAgYXV0aG9yOiBzdHJpbmcsXG4gIHBlcm1saW5rOiBzdHJpbmcsXG4gIHZvdGVfcGVyY2VudDogaW50MTYsXG4gIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucylcbn0pO1xudmFyIGNsYWltID0gbmV3IFNlcmlhbGl6ZXIoXCJjbGFpbVwiLCB7XG4gIGZyb206IHN0cmluZyxcbiAgdG86IHN0cmluZyxcbiAgYW1vdW50OiBhc3NldCxcbiAgdG9fdmVzdGluZzogYm9vbCxcbiAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKVxufSk7XG52YXIgZG9uYXRlX21lbW8gPSBuZXcgU2VyaWFsaXplcihcImRvbmF0ZV9tZW1vXCIsIHtcbiAgYXBwOiBzdHJpbmcsXG4gIHZlcnNpb246IHVpbnQxNixcbiAgdGFyZ2V0OiBfdHlwZXMuZGVmYXVsdC52YXJpYW50X29iamVjdCxcbiAgY29tbWVudDogb3B0aW9uYWwoc3RyaW5nKVxufSk7XG52YXIgZG9uYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJkb25hdGVcIiwge1xuICBmcm9tOiBzdHJpbmcsXG4gIHRvOiBzdHJpbmcsXG4gIGFtb3VudDogYXNzZXQsXG4gIG1lbW86IGRvbmF0ZV9tZW1vLFxuICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpXG59KTtcbnZhciB0cmFuc2Zlcl90b190aXAgPSBuZXcgU2VyaWFsaXplcihcInRyYW5zZmVyX3RvX3RpcFwiLCB7XG4gIGZyb206IHN0cmluZyxcbiAgdG86IHN0cmluZyxcbiAgYW1vdW50OiBhc3NldCxcbiAgbWVtbzogc3RyaW5nLFxuICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpXG59KTtcbnZhciB0cmFuc2Zlcl9mcm9tX3RpcCA9IG5ldyBTZXJpYWxpemVyKFwidHJhbnNmZXJfZnJvbV90aXBcIiwge1xuICBmcm9tOiBzdHJpbmcsXG4gIHRvOiBzdHJpbmcsXG4gIGFtb3VudDogYXNzZXQsXG4gIG1lbW86IHN0cmluZyxcbiAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKVxufSk7XG52YXIgaXNfaW52aXRlX3JlZmVycmFsID0gbmV3IFNlcmlhbGl6ZXIoMCwge1xuICBpc19yZWZlcnJhbDogYm9vbFxufSk7XG52YXIgaW52aXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJpbnZpdGVcIiwge1xuICBjcmVhdG9yOiBzdHJpbmcsXG4gIGJhbGFuY2U6IGFzc2V0LFxuICBpbnZpdGVfa2V5OiBwdWJsaWNfa2V5LFxuICBleHRlbnNpb25zOiBzZXQoc3RhdGljX3ZhcmlhbnQoW2lzX2ludml0ZV9yZWZlcnJhbF0pKVxufSk7XG52YXIgaW52aXRlX2NsYWltID0gbmV3IFNlcmlhbGl6ZXIoXCJpbnZpdGVfY2xhaW1cIiwge1xuICBpbml0aWF0b3I6IHN0cmluZyxcbiAgcmVjZWl2ZXI6IHN0cmluZyxcbiAgaW52aXRlX3NlY3JldDogc3RyaW5nLFxuICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpXG59KTtcbnZhciBhc3NldF9jcmVhdGUgPSBuZXcgU2VyaWFsaXplcihcImFzc2V0X2NyZWF0ZVwiLCB7XG4gIGNyZWF0b3I6IHN0cmluZyxcbiAgbWF4X3N1cHBseTogYXNzZXQsXG4gIGFsbG93X2ZlZTogYm9vbCxcbiAgYWxsb3dfb3ZlcnJpZGVfdHJhbnNmZXI6IGJvb2wsXG4gIGpzb25fbWV0YWRhdGE6IHN0cmluZyxcbiAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKVxufSk7XG52YXIgYXNzZXRfdXBkYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJhc3NldF91cGRhdGVcIiwge1xuICBjcmVhdG9yOiBzdHJpbmcsXG4gIHN5bWJvbDogc3RyaW5nLFxuICBzeW1ib2xzX3doaXRlbGlzdDogc2V0KHN0cmluZyksXG4gIGZlZV9wZXJjZW50OiB1aW50MTYsXG4gIGpzb25fbWV0YWRhdGE6IHN0cmluZyxcbiAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKVxufSk7XG52YXIgYXNzZXRfaXNzdWUgPSBuZXcgU2VyaWFsaXplcihcImFzc2V0X2lzc3VlXCIsIHtcbiAgY3JlYXRvcjogc3RyaW5nLFxuICBhbW91bnQ6IGFzc2V0LFxuICB0bzogc3RyaW5nLFxuICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpXG59KTtcbnZhciBhc3NldF90cmFuc2ZlciA9IG5ldyBTZXJpYWxpemVyKFwiYXNzZXRfdHJhbnNmZXJcIiwge1xuICBjcmVhdG9yOiBzdHJpbmcsXG4gIHN5bWJvbDogc3RyaW5nLFxuICBuZXdfb3duZXI6IHN0cmluZyxcbiAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKVxufSk7XG52YXIgb3ZlcnJpZGVfdHJhbnNmZXIgPSBuZXcgU2VyaWFsaXplcihcIm92ZXJyaWRlX3RyYW5zZmVyXCIsIHtcbiAgY3JlYXRvcjogc3RyaW5nLFxuICBmcm9tOiBzdHJpbmcsXG4gIHRvOiBzdHJpbmcsXG4gIGFtb3VudDogYXNzZXQsXG4gIG1lbW86IHN0cmluZyxcbiAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKVxufSk7XG52YXIgaW52aXRlX2RvbmF0ZSA9IG5ldyBTZXJpYWxpemVyKFwiaW52aXRlX2RvbmF0ZVwiLCB7XG4gIGZyb206IHN0cmluZyxcbiAgaW52aXRlX2tleTogcHVibGljX2tleSxcbiAgYW1vdW50OiBhc3NldCxcbiAgbWVtbzogc3RyaW5nLFxuICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpXG59KTtcbnZhciBpbnZpdGVfdHJhbnNmZXIgPSBuZXcgU2VyaWFsaXplcihcImludml0ZV90cmFuc2ZlclwiLCB7XG4gIGZyb206IHB1YmxpY19rZXksXG4gIHRvOiBwdWJsaWNfa2V5LFxuICBhbW91bnQ6IGFzc2V0LFxuICBtZW1vOiBzdHJpbmcsXG4gIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucylcbn0pO1xudmFyIHBhaXJfdG9fY2FuY2VsID0gbmV3IFNlcmlhbGl6ZXIoMCwge1xuICBiYXNlOiBzdHJpbmcsXG4gIHF1b3RlOiBzdHJpbmcsXG4gIHJldmVyc2U6IGJvb2xcbn0pO1xudmFyIGxpbWl0X29yZGVyX2NhbmNlbF9leCA9IG5ldyBTZXJpYWxpemVyKFwibGltaXRfb3JkZXJfY2FuY2VsX2V4XCIsIHtcbiAgb3duZXI6IHN0cmluZyxcbiAgb3JkZXJpZDogdWludDMyLFxuICBleHRlbnNpb25zOiBzZXQoc3RhdGljX3ZhcmlhbnQoW3BhaXJfdG9fY2FuY2VsXSkpXG59KTtcbnZhciBmaWxsX2NvbnZlcnRfcmVxdWVzdCA9IG5ldyBTZXJpYWxpemVyKFwiZmlsbF9jb252ZXJ0X3JlcXVlc3RcIiwge1xuICBvd25lcjogc3RyaW5nLFxuICByZXF1ZXN0aWQ6IHVpbnQzMixcbiAgYW1vdW50X2luOiBhc3NldCxcbiAgYW1vdW50X291dDogYXNzZXRcbn0pO1xudmFyIGF1dGhvcl9yZXdhcmQgPSBuZXcgU2VyaWFsaXplcihcImF1dGhvcl9yZXdhcmRcIiwge1xuICBhdXRob3I6IHN0cmluZyxcbiAgcGVybWxpbms6IHN0cmluZyxcbiAgc2JkX3BheW91dDogYXNzZXQsXG4gIHN0ZWVtX3BheW91dDogYXNzZXQsXG4gIHZlc3RpbmdfcGF5b3V0OiBhc3NldFxufSk7XG52YXIgY3VyYXRpb25fcmV3YXJkID0gbmV3IFNlcmlhbGl6ZXIoXCJjdXJhdGlvbl9yZXdhcmRcIiwge1xuICBjdXJhdG9yOiBzdHJpbmcsXG4gIHJld2FyZDogYXNzZXQsXG4gIGNvbW1lbnRfYXV0aG9yOiBzdHJpbmcsXG4gIGNvbW1lbnRfcGVybWxpbms6IHN0cmluZ1xufSk7XG52YXIgY29tbWVudF9yZXdhcmQgPSBuZXcgU2VyaWFsaXplcihcImNvbW1lbnRfcmV3YXJkXCIsIHtcbiAgYXV0aG9yOiBzdHJpbmcsXG4gIHBlcm1saW5rOiBzdHJpbmcsXG4gIHBheW91dDogYXNzZXRcbn0pO1xudmFyIGxpcXVpZGl0eV9yZXdhcmQgPSBuZXcgU2VyaWFsaXplcihcImxpcXVpZGl0eV9yZXdhcmRcIiwge1xuICBvd25lcjogc3RyaW5nLFxuICBwYXlvdXQ6IGFzc2V0XG59KTtcbnZhciBpbnRlcmVzdCA9IG5ldyBTZXJpYWxpemVyKFwiaW50ZXJlc3RcIiwge1xuICBvd25lcjogc3RyaW5nLFxuICBpbnRlcmVzdDogYXNzZXRcbn0pO1xudmFyIGZpbGxfdmVzdGluZ193aXRoZHJhdyA9IG5ldyBTZXJpYWxpemVyKFwiZmlsbF92ZXN0aW5nX3dpdGhkcmF3XCIsIHtcbiAgZnJvbV9hY2NvdW50OiBzdHJpbmcsXG4gIHRvX2FjY291bnQ6IHN0cmluZyxcbiAgd2l0aGRyYXduOiBhc3NldCxcbiAgZGVwb3NpdGVkOiBhc3NldFxufSk7XG52YXIgZmlsbF9vcmRlciA9IG5ldyBTZXJpYWxpemVyKFwiZmlsbF9vcmRlclwiLCB7XG4gIGN1cnJlbnRfb3duZXI6IHN0cmluZyxcbiAgY3VycmVudF9vcmRlcmlkOiB1aW50MzIsXG4gIGN1cnJlbnRfcGF5czogYXNzZXQsXG4gIGN1cnJlbnRfdHJhZGVfZmVlOiBhc3NldCxcbiAgY3VycmVudF90cmFkZV9mZWVfcmVjZWl2ZXI6IHN0cmluZyxcbiAgb3Blbl9vd25lcjogc3RyaW5nLFxuICBvcGVuX29yZGVyaWQ6IHVpbnQzMixcbiAgb3Blbl9wYXlzOiBhc3NldCxcbiAgb3Blbl90cmFkZV9mZWU6IGFzc2V0LFxuICBvcGVuX3RyYWRlX2ZlZV9yZWNlaXZlcjogc3RyaW5nXG59KTtcbnZhciBzaHV0ZG93bl93aXRuZXNzID0gbmV3IFNlcmlhbGl6ZXIoXCJzaHV0ZG93bl93aXRuZXNzXCIsIHtcbiAgb3duZXI6IHN0cmluZ1xufSk7XG52YXIgZmlsbF90cmFuc2Zlcl9mcm9tX3NhdmluZ3MgPSBuZXcgU2VyaWFsaXplcihcImZpbGxfdHJhbnNmZXJfZnJvbV9zYXZpbmdzXCIsIHtcbiAgZnJvbTogc3RyaW5nLFxuICB0bzogc3RyaW5nLFxuICBhbW91bnQ6IGFzc2V0LFxuICByZXF1ZXN0X2lkOiB1aW50MzIsXG4gIG1lbW86IHN0cmluZ1xufSk7XG52YXIgaGFyZGZvcmsgPSBuZXcgU2VyaWFsaXplcihcImhhcmRmb3JrXCIsIHtcbiAgaGFyZGZvcmtfaWQ6IHVpbnQzMlxufSk7XG52YXIgY29tbWVudF9wYXlvdXRfdXBkYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJjb21tZW50X3BheW91dF91cGRhdGVcIiwge1xuICBhdXRob3I6IHN0cmluZyxcbiAgcGVybWxpbms6IHN0cmluZ1xufSk7XG52YXIgY29tbWVudF9iZW5lZmFjdG9yX3Jld2FyZCA9IG5ldyBTZXJpYWxpemVyKFwiY29tbWVudF9iZW5lZmFjdG9yX3Jld2FyZFwiLCB7XG4gIGJlbmVmYWN0b3I6IHN0cmluZyxcbiAgYXV0aG9yOiBzdHJpbmcsXG4gIHBlcm1saW5rOiBzdHJpbmcsXG4gIHJld2FyZDogYXNzZXRcbn0pO1xudmFyIHJldHVybl92ZXN0aW5nX2RlbGVnYXRpb24gPSBuZXcgU2VyaWFsaXplcihcInJldHVybl92ZXN0aW5nX2RlbGVnYXRpb25cIiwge1xuICBhY2NvdW50OiBzdHJpbmcsXG4gIHZlc3Rpbmdfc2hhcmVzOiBhc3NldFxufSk7XG5vcGVyYXRpb24uc3Rfb3BlcmF0aW9ucyA9IFt2b3RlLCBjb21tZW50LCB0cmFuc2ZlciwgdHJhbnNmZXJfdG9fdmVzdGluZywgd2l0aGRyYXdfdmVzdGluZywgbGltaXRfb3JkZXJfY3JlYXRlLCBsaW1pdF9vcmRlcl9jYW5jZWwsIGZlZWRfcHVibGlzaCwgY29udmVydCwgYWNjb3VudF9jcmVhdGUsIGFjY291bnRfdXBkYXRlLCB3aXRuZXNzX3VwZGF0ZSwgYWNjb3VudF93aXRuZXNzX3ZvdGUsIGFjY291bnRfd2l0bmVzc19wcm94eSwgcG93LCBjdXN0b20sIHJlcG9ydF9vdmVyX3Byb2R1Y3Rpb24sIGRlbGV0ZV9jb21tZW50LCBjdXN0b21fanNvbiwgY29tbWVudF9vcHRpb25zLCBzZXRfd2l0aGRyYXdfdmVzdGluZ19yb3V0ZSwgbGltaXRfb3JkZXJfY3JlYXRlMiwgY2hhbGxlbmdlX2F1dGhvcml0eSwgcHJvdmVfYXV0aG9yaXR5LCByZXF1ZXN0X2FjY291bnRfcmVjb3ZlcnksIHJlY292ZXJfYWNjb3VudCwgY2hhbmdlX3JlY292ZXJ5X2FjY291bnQsIGVzY3Jvd190cmFuc2ZlciwgZXNjcm93X2Rpc3B1dGUsIGVzY3Jvd19yZWxlYXNlLCBwb3cyLCBlc2Nyb3dfYXBwcm92ZSwgdHJhbnNmZXJfdG9fc2F2aW5ncywgdHJhbnNmZXJfZnJvbV9zYXZpbmdzLCBjYW5jZWxfdHJhbnNmZXJfZnJvbV9zYXZpbmdzLCBjdXN0b21fYmluYXJ5LCBkZWNsaW5lX3ZvdGluZ19yaWdodHMsIHJlc2V0X2FjY291bnQsIHNldF9yZXNldF9hY2NvdW50LCBkZWxlZ2F0ZV92ZXN0aW5nX3NoYXJlcywgYWNjb3VudF9jcmVhdGVfd2l0aF9kZWxlZ2F0aW9uLCBhY2NvdW50X21ldGFkYXRhLCBwcm9wb3NhbF9jcmVhdGUsIHByb3Bvc2FsX3VwZGF0ZSwgcHJvcG9zYWxfZGVsZXRlLCBjaGFpbl9wcm9wZXJ0aWVzX3VwZGF0ZSwgYnJlYWtfZnJlZV9yZWZlcnJhbCwgZGVsZWdhdGVfdmVzdGluZ19zaGFyZXNfd2l0aF9pbnRlcmVzdCwgcmVqZWN0X3Zlc3Rpbmdfc2hhcmVzX2RlbGVnYXRpb24sIHRyYW5zaXRfdG9fY3liZXJ3YXksIHdvcmtlcl9yZXF1ZXN0LCB3b3JrZXJfcmVxdWVzdF9kZWxldGUsIHdvcmtlcl9yZXF1ZXN0X3ZvdGUsIGNsYWltLCBkb25hdGUsIHRyYW5zZmVyX3RvX3RpcCwgdHJhbnNmZXJfZnJvbV90aXAsIGludml0ZSwgaW52aXRlX2NsYWltLCBhY2NvdW50X2NyZWF0ZV93aXRoX2ludml0ZSwgYXNzZXRfY3JlYXRlLCBhc3NldF91cGRhdGUsIGFzc2V0X2lzc3VlLCBhc3NldF90cmFuc2Zlciwgb3ZlcnJpZGVfdHJhbnNmZXIsIGludml0ZV9kb25hdGUsIGludml0ZV90cmFuc2ZlciwgbGltaXRfb3JkZXJfY2FuY2VsX2V4LCBmaWxsX2NvbnZlcnRfcmVxdWVzdCwgYXV0aG9yX3Jld2FyZCwgY3VyYXRpb25fcmV3YXJkLCBjb21tZW50X3Jld2FyZCwgbGlxdWlkaXR5X3Jld2FyZCwgaW50ZXJlc3QsIGZpbGxfdmVzdGluZ193aXRoZHJhdywgZmlsbF9vcmRlciwgc2h1dGRvd25fd2l0bmVzcywgZmlsbF90cmFuc2Zlcl9mcm9tX3NhdmluZ3MsIGhhcmRmb3JrLCBjb21tZW50X3BheW91dF91cGRhdGUsIGNvbW1lbnRfYmVuZWZhY3Rvcl9yZXdhcmQsIHJldHVybl92ZXN0aW5nX2RlbGVnYXRpb25dOyAvLyMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8jICBHZW5lcmF0ZWQgY29kZSBlbmQgIFMgVCBPIFBcbi8vIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBNYWtlIHN1cmUgYWxsIHRlc3RzIHBhc3Ncbi8vIG5wbSB0ZXN0IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzXCIpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBCeXRlQnVmZmVyID0gcmVxdWlyZSgnYnl0ZWJ1ZmZlcicpO1xuXG52YXIgRUMgPSByZXF1aXJlKCcuL2Vycm9yX3dpdGhfY2F1c2UnKTtcblxudmFyIEhFWF9EVU1QID0gcHJvY2Vzcy5lbnYubnBtX2NvbmZpZ19fZ3JhcGhlbmVfc2VyaWFsaXplcl9oZXhfZHVtcDtcblxudmFyIFNlcmlhbGl6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTZXJpYWxpemVyKG9wZXJhdGlvbl9uYW1lLCB0eXBlcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZXJpYWxpemVyKTtcblxuICAgIHRoaXMub3BlcmF0aW9uX25hbWUgPSBvcGVyYXRpb25fbmFtZTtcbiAgICB0aGlzLnR5cGVzID0gdHlwZXM7XG4gICAgaWYgKHRoaXMudHlwZXMpIHRoaXMua2V5cyA9IE9iamVjdC5rZXlzKHRoaXMudHlwZXMpO1xuICAgIFNlcmlhbGl6ZXIucHJpbnREZWJ1ZyA9IHRydWU7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2VyaWFsaXplciwgW3tcbiAgICBrZXk6IFwiZnJvbUJ5dGVCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgdmFyIGZpZWxkID0gbnVsbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGl0ZXJhYmxlID0gdGhpcy5rZXlzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBmaWVsZDsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZmllbGQgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZXNbZmllbGRdO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChIRVhfRFVNUCkge1xuICAgICAgICAgICAgICBpZiAodHlwZS5vcGVyYXRpb25fbmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IodHlwZS5vcGVyYXRpb25fbmFtZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG8xID0gYi5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgdHlwZS5mcm9tQnl0ZUJ1ZmZlcihiKTtcbiAgICAgICAgICAgICAgICB2YXIgbzIgPSBiLm9mZnNldDtcbiAgICAgICAgICAgICAgICBiLm9mZnNldCA9IG8xOyAvL2IucmVzZXQoKVxuXG4gICAgICAgICAgICAgICAgdmFyIF9iID0gYi5jb3B5KG8xLCBvMik7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiXCIuY29uY2F0KHRoaXMub3BlcmF0aW9uX25hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQsIFwiXFx0XCIpLCBfYi50b0hleCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmplY3RbZmllbGRdID0gdHlwZS5mcm9tQnl0ZUJ1ZmZlcihiKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoU2VyaWFsaXplci5wcmludERlYnVnKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZWFkaW5nIFwiLmNvbmNhdCh0aGlzLm9wZXJhdGlvbl9uYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLCBcIiBpbiBkYXRhOlwiKSk7XG4gICAgICAgICAgICAgIGIucHJpbnREZWJ1ZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgRUMudGhyb3codGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkLCBlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGVuZEJ5dGVCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgIHZhciBmaWVsZCA9IG51bGw7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBpdGVyYWJsZSA9IHRoaXMua2V5cztcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgZmllbGQ7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZpZWxkID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGVzW2ZpZWxkXTtcbiAgICAgICAgICB0eXBlLmFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0W2ZpZWxkXSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRUMudGhyb3codGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkICsgXCIgPSBcIiArIEpTT04uc3RyaW5naWZ5KG9iamVjdFtmaWVsZF0pLCBlcnJvcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBjaXJjdWxhciByZWZcbiAgICAgICAgICBFQy50aHJvdyh0aGlzLm9wZXJhdGlvbl9uYW1lICsgJy4nICsgZmllbGQgKyBcIiA9IFwiICsgb2JqZWN0W2ZpZWxkXSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbU9iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tT2JqZWN0KHNlcmlhbGl6ZWRfb2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICB2YXIgZmllbGQgPSBudWxsO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgaXRlcmFibGUgPSB0aGlzLmtleXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGZpZWxkOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBmaWVsZCA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlc1tmaWVsZF07XG4gICAgICAgICAgdmFyIHZhbHVlID0gc2VyaWFsaXplZF9vYmplY3RbZmllbGRdOyAvL0RFQlVHIHZhbHVlID0gdmFsdWUucmVzb2x2ZSBpZiB2YWx1ZS5yZXNvbHZlXG4gICAgICAgICAgLy9ERUJVRyBjb25zb2xlLmxvZygnLi4uIHZhbHVlJyxmaWVsZCx2YWx1ZSlcblxuICAgICAgICAgIHZhciBvYmplY3QgPSB0eXBlLmZyb21PYmplY3QodmFsdWUpO1xuICAgICAgICAgIHJlc3VsdFtmaWVsZF0gPSBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIEVDLnRocm93KHRoaXMub3BlcmF0aW9uX25hbWUgKyAnLicgKyBmaWVsZCwgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgICAgQGFyZyB7Ym9vbGVhbn0gW2RlYnVnLnVzZV9kZWZhdWx0ID0gZmFsc2VdIC0gbW9yZSB0ZW1wbGF0ZSBmcmllbmRseVxuICAgICAgICBAYXJnIHtib29sZWFufSBbZGVidWcuYW5ub3RhdGUgPSBmYWxzZV0gLSBhZGQgdXNlci1mcmllbmRseSBpbmZvcm1hdGlvblxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b09iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgICAgIHZhciBzZXJpYWxpemVkX29iamVjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICAgICAgdXNlX2RlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBhbm5vdGF0ZTogZmFsc2VcbiAgICAgIH07XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICB2YXIgZmllbGQgPSBudWxsO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXRoaXMudHlwZXMpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHZhciBpdGVyYWJsZSA9IHRoaXMua2V5cztcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgZmllbGQ7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZpZWxkID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGVzW2ZpZWxkXTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0gdHlwZS50b09iamVjdCh0eXBlb2Ygc2VyaWFsaXplZF9vYmplY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VyaWFsaXplZF9vYmplY3QgIT09IG51bGwgPyBzZXJpYWxpemVkX29iamVjdFtmaWVsZF0gOiB1bmRlZmluZWQsIGRlYnVnKTtcbiAgICAgICAgICByZXN1bHRbZmllbGRdID0gb2JqZWN0O1xuXG4gICAgICAgICAgaWYgKEhFWF9EVU1QKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBCeXRlQnVmZmVyKEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWSwgQnl0ZUJ1ZmZlci5MSVRUTEVfRU5ESUFOKTtcbiAgICAgICAgICAgIHZhciBoYXNfdmFsdWUgPSB0eXBlb2Ygc2VyaWFsaXplZF9vYmplY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VyaWFsaXplZF9vYmplY3QgIT09IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChoYXNfdmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VyaWFsaXplZF9vYmplY3RbZmllbGRdO1xuICAgICAgICAgICAgICBpZiAodmFsdWUpIHR5cGUuYXBwZW5kQnl0ZUJ1ZmZlcihiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGIgPSBiLmNvcHkoMCwgYi5vZmZzZXQpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcih0aGlzLm9wZXJhdGlvbl9uYW1lICsgJy4nICsgZmllbGQsIGIudG9IZXgoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBFQy50aHJvdyh0aGlzLm9wZXJhdGlvbl9uYW1lICsgJy4nICsgZmllbGQsIGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqIFNvcnQgYnkgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSBvcGVyYXRpb24gKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbXBhcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICB2YXIgZmlyc3Rfa2V5ID0gdGhpcy5rZXlzWzBdO1xuICAgICAgdmFyIGZpcnN0X3R5cGUgPSB0aGlzLnR5cGVzW2ZpcnN0X2tleV07XG4gICAgICB2YXIgdmFsQSA9IGFbZmlyc3Rfa2V5XTtcbiAgICAgIHZhciB2YWxCID0gYltmaXJzdF9rZXldO1xuICAgICAgaWYgKGZpcnN0X3R5cGUuY29tcGFyZSkgcmV0dXJuIGZpcnN0X3R5cGUuY29tcGFyZSh2YWxBLCB2YWxCKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsQSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgdmFsQiA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHZhbEEgLSB2YWxCO1xuICAgICAgdmFyIGVuY29kaW5nO1xuXG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbEEpICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWxCKSkge1xuICAgICAgICAvLyBBIGJpbmFyeSBzdHJpbmcgY29tcGFyZSBkb2VzIG5vdCB3b3JrLiAgSWYgbG9jYWxlQ29tcGFyZSBpcyB3ZWxsIHN1cHBvcnRlZCB0aGF0IGNvdWxkIHJlcGxhY2UgSEVYLiAgUGVyZm9ybWFuYW5jZSBpcyB2ZXJ5IGdvb2Qgc28gY29tcGFyaW5nIEhFWCB3b3Jrcy5cbiAgICAgICAgZW5jb2RpbmcgPSBcImhleFwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RyQSA9IHZhbEEudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgICAgdmFyIHN0ckIgPSB2YWxCLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICAgIHJldHVybiBzdHJBID4gc3RyQiA/IDEgOiBzdHJBIDwgc3RyQiA/IC0xIDogMDtcbiAgICB9IC8vIDxoZWxwZXJfZnVuY3Rpb25zPlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUhleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSGV4KGhleCkge1xuICAgICAgdmFyIGIgPSBCeXRlQnVmZmVyLmZyb21IZXgoaGV4LCBCeXRlQnVmZmVyLkxJVFRMRV9FTkRJQU4pO1xuICAgICAgcmV0dXJuIHRoaXMuZnJvbUJ5dGVCdWZmZXIoYik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21CdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgIHZhciBiID0gQnl0ZUJ1ZmZlci5mcm9tQmluYXJ5KGJ1ZmZlci50b1N0cmluZyhcImJpbmFyeVwiKSwgQnl0ZUJ1ZmZlci5MSVRUTEVfRU5ESUFOKTtcbiAgICAgIHJldHVybiB0aGlzLmZyb21CeXRlQnVmZmVyKGIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0hleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0hleChvYmplY3QpIHtcbiAgICAgIC8vIHJldHVybiB0aGlzLnRvQnVmZmVyKG9iamVjdCkudG9TdHJpbmcoXCJoZXhcIilcbiAgICAgIHZhciBiID0gdGhpcy50b0J5dGVCdWZmZXIob2JqZWN0KTtcbiAgICAgIHJldHVybiBiLnRvSGV4KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvQnl0ZUJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J5dGVCdWZmZXIob2JqZWN0KSB7XG4gICAgICB2YXIgYiA9IG5ldyBCeXRlQnVmZmVyKEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWSwgQnl0ZUJ1ZmZlci5MSVRUTEVfRU5ESUFOKTtcbiAgICAgIHRoaXMuYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpO1xuICAgICAgcmV0dXJuIGIuY29weSgwLCBiLm9mZnNldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvQnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvQnVmZmVyKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodGhpcy50b0J5dGVCdWZmZXIob2JqZWN0KS50b0JpbmFyeSgpLCAnYmluYXJ5Jyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNlcmlhbGl6ZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VyaWFsaXplcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqIENvbnNvbGUgcHJpbnQgYW55IHRyYW5zYWN0aW9uIG9iamVjdCB3aXRoIHplcm8gZGVmYXVsdCB2YWx1ZXMuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRlbXBsYXRlKG9wKSB7XG4gIHZhciBvYmplY3QgPSBvcC50b09iamVjdCh2b2lkIDAsIHtcbiAgICB1c2VfZGVmYXVsdDogdHJ1ZSxcbiAgICBhbm5vdGF0ZTogdHJ1ZVxuICB9KTsgLy8gdmlzdWFsICh3aXRoIGRlc2NyaXB0aW9ucylcblxuICBjb25zb2xlLmVycm9yKEpTT04uc3RyaW5naWZ5KG9iamVjdCwgbnVsbCwgNCkpOyAvLyB1c2FibGUgaW4gYSBjb3B5LXBhc3RlXG5cbiAgb2JqZWN0ID0gb3AudG9PYmplY3Qodm9pZCAwLCB7XG4gICAgdXNlX2RlZmF1bHQ6IHRydWUsXG4gICAgYW5ub3RhdGU6IGZhbHNlXG4gIH0pOyAvLyBjb3B5LXBhc3RlIG9uZS1saW5lZXJcblxuICBjb25zb2xlLmVycm9yKEpTT04uc3RyaW5naWZ5KG9iamVjdCkpO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20uanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2UuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZW50cmllcy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zb3J0LmpzXCIpO1xuXG52YXIgX2VjYyA9IHJlcXVpcmUoXCIuLi8uLi9lY2NcIik7XG5cbnZhciBfbnVtYmVyX3V0aWxzID0gcmVxdWlyZShcIi4vbnVtYmVyX3V0aWxzXCIpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyB0aHJvdyBfZTI7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTMpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UzOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9zLCBfZTsgdHJ5IHsgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG4vLyBMb3ctbGV2ZWwgdHlwZXMgdGhhdCBtYWtlIHVwIG9wZXJhdGlvbnNcbnZhciB2ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbnZhciBPYmplY3RJZCA9IHJlcXVpcmUoJy4vb2JqZWN0X2lkJyk7XG5cbnZhciBmcCA9IHJlcXVpcmUoJy4vZmFzdF9wYXJzZXInKTtcblxudmFyIGNoYWluX3R5cGVzID0gcmVxdWlyZSgnLi9DaGFpblR5cGVzJyk7XG5cbnZhciBUeXBlcyA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBUeXBlcztcbnZhciBIRVhfRFVNUCA9IHByb2Nlc3MuZW52Lm5wbV9jb25maWdfX2dyYXBoZW5lX3NlcmlhbGl6ZXJfaGV4X2R1bXA7XG52YXIgVEVTVCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIjtcbi8qKlxuKiBBc3NldCBzeW1ib2xzIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBpbmZvcm1hdGlvblxuKlxuKiAgNCBiaXQgUFJFQ0lTSU9OIChmcm9tIDAgdG8gMTUpXG4qICA0IGJpdCBWRVJTSU9OIChpZiB3aG9sZSBmaXJzdCBieXRlID49IDEwMCwgdGhlbiB2ZXJzaW9uIGlzIDIsIGFuZCB5b3Ugc2hvdWxkIHN1YnRyYWN0IDEwMCB0byBvYnRhaW4gUFJFQ0lTSU9OKVxuKiAgQ0hBUltdIHVwIHRvIDYgKHYxKSBvciAxNCAodjIpIHVwcGVyIGNhc2UgYWxwaGEgbnVtZXJpYyBhc2NpaSBjaGFyYWN0ZXJzLFxuKiAgY2hhciA9IFxcMCAgbnVsbCB0ZXJtaW5hdGVkXG4qXG4qICBJdCBpcyB0cmVhdGVkIGFzIGEgdWludDY0X3QgKHYxKSBvciB1aW50MTI4X3QgKHYyKSBmb3IgYWxsIGludGVybmFsIG9wZXJhdGlvbnMsIGJ1dFxuKiAgaXMgZWFzaWx5IGNvbnZlcnRlZCB0byBzb21ldGhpbmcgdGhhdCBjYW4gYmUgZGlzcGxheWVkLlxuKi9cblxuVHlwZXMuYXNzZXQgPSB7XG4gIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgdmFyIGFtb3VudCA9IGIucmVhZEludDY0KCk7XG4gICAgdmFyIHByZWNpc2lvbiA9IGIucmVhZFVpbnQ4KCk7XG4gICAgdmFyIGlzX3YyID0gcHJlY2lzaW9uID49IDEwMDtcbiAgICBpZiAoaXNfdjIpIHByZWNpc2lvbiAtPSAxMDA7XG4gICAgdmFyIHN5bWJvbF9zaXplID0gaXNfdjIgPyAxNSA6IDc7XG4gICAgdmFyIGJfY29weSA9IGIuY29weShiLm9mZnNldCwgYi5vZmZzZXQgKyBzeW1ib2xfc2l6ZSk7XG4gICAgdmFyIHN5bWJvbCA9IG5ldyBCdWZmZXIoYl9jb3B5LnRvQmluYXJ5KCksIFwiYmluYXJ5XCIpLnRvU3RyaW5nKCkucmVwbGFjZSgvXFx4MDAvZywgXCJcIik7XG4gICAgYi5za2lwKHN5bWJvbF9zaXplKTsgLy8gXCIxLjAwMCBHT0xPU1wiIGFsd2F5cyB3cml0dGVuIHdpdGggZnVsbCBwcmVjaXNpb25cblxuICAgIHZhciBhbW91bnRfc3RyaW5nID0gKDAsIF9udW1iZXJfdXRpbHMuZnJvbUltcGxpZWREZWNpbWFsKShhbW91bnQsIHByZWNpc2lvbik7XG4gICAgcmV0dXJuIGFtb3VudF9zdHJpbmcgKyBcIiBcIiArIHN5bWJvbDtcbiAgfSxcbiAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0LmFzc2V0KSB7XG4gICAgICAvLyBnb2xvcy51dGlscy5Bc3NldEVkaXRvclxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmFzc2V0LnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIGlmIChvYmplY3Quc3ltYm9sKSB7XG4gICAgICAvLyBnb2xvcy51dGlscy5Bc3NldFxuICAgICAgb2JqZWN0ID0gb2JqZWN0LnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdCA9IG9iamVjdC50cmltKCk7XG4gICAgICBpZiAoIS9eWzAtOV0rXFwuP1swLTldKiBbQS1aYS16MC05XStcXC4/W0EtWmEtejAtOV0qJC8udGVzdChvYmplY3QpKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RpbmcgYW1vdW50IGxpa2UgJzk5LjAwMCBTWU1CT0wnIG9yICc5OS4wMDAgU1lNQk9MLlNVQlNZTScsIGluc3RlYWQgZ290ICdcIiArIG9iamVjdCArIFwiJ1wiKTtcbiAgICB9XG5cbiAgICB2YXIgX29iamVjdCRzcGxpdCA9IG9iamVjdC5zcGxpdChcIiBcIiksXG4gICAgICAgIF9vYmplY3Qkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX29iamVjdCRzcGxpdCwgMiksXG4gICAgICAgIGFtb3VudCA9IF9vYmplY3Qkc3BsaXQyWzBdLFxuICAgICAgICBzeW1ib2wgPSBfb2JqZWN0JHNwbGl0MlsxXTtcblxuICAgIGlmIChzeW1ib2wubGVuZ3RoID4gMTQpIHRocm93IG5ldyBFcnJvcihcIlN5bWJvbHMgYXJlIG5vdCBsb25nZXIgdGhhbiAxNCBjaGFyYWN0ZXJzIFwiICsgc3ltYm9sICsgXCItXCIgKyBzeW1ib2wubGVuZ3RoKTtcbiAgICB2YXIgaXNfdjIgPSBzeW1ib2wubGVuZ3RoID4gNjtcbiAgICB2YXIgc3ltYm9sX3NpemUgPSBpc192MiA/IDE1IDogNztcbiAgICBiLndyaXRlSW50NjQodi50b19sb25nKGFtb3VudC5yZXBsYWNlKFwiLlwiLCBcIlwiKSkpO1xuICAgIHZhciBkb3QgPSBhbW91bnQuaW5kZXhPZihcIi5cIik7IC8vIDAuMDAwXG5cbiAgICB2YXIgcHJlY2lzaW9uID0gZG90ID09PSAtMSA/IDAgOiBhbW91bnQubGVuZ3RoIC0gZG90IC0gMTtcbiAgICBpZiAoaXNfdjIpIHByZWNpc2lvbiArPSAxMDA7XG4gICAgYi53cml0ZVVpbnQ4KHByZWNpc2lvbik7XG4gICAgYi5hcHBlbmQoc3ltYm9sLnRvVXBwZXJDYXNlKCksICdiaW5hcnknKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9sX3NpemUgLSBzeW1ib2wubGVuZ3RoOyBpKyspIHtcbiAgICAgIGIud3JpdGVVaW50OCgwKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0sXG4gIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSxcbiAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBcIjAuMDAwIEdPTE9TXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxufTtcblR5cGVzLnVpbnQ4ID0ge1xuICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgIHJldHVybiBiLnJlYWRVaW50OCgpO1xuICB9LFxuICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgIHYucmVxdWlyZV9yYW5nZSgwLCAweEZGLCBvYmplY3QsIFwidWludDggXCIuY29uY2F0KG9iamVjdCkpO1xuICAgIGIud3JpdGVVaW50OChvYmplY3QpO1xuICAgIHJldHVybjtcbiAgfSxcbiAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRiwgb2JqZWN0LCBcInVpbnQ4IFwiLmNvbmNhdChvYmplY3QpKTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9LFxuICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4RkYsIG9iamVjdCwgXCJ1aW50OCBcIi5jb25jYXQob2JqZWN0KSk7XG4gICAgcmV0dXJuIHBhcnNlSW50KG9iamVjdCk7XG4gIH1cbn07XG5UeXBlcy51aW50MTYgPSB7XG4gIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgcmV0dXJuIGIucmVhZFVpbnQxNigpO1xuICB9LFxuICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgIHYucmVxdWlyZV9yYW5nZSgwLCAweEZGRkYsIG9iamVjdCwgXCJ1aW50MTYgXCIuY29uY2F0KG9iamVjdCkpO1xuICAgIGIud3JpdGVVaW50MTYob2JqZWN0KTtcbiAgICByZXR1cm47XG4gIH0sXG4gIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4RkZGRiwgb2JqZWN0LCBcInVpbnQxNiBcIi5jb25jYXQob2JqZWN0KSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSxcbiAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHYucmVxdWlyZV9yYW5nZSgwLCAweEZGRkYsIG9iamVjdCwgXCJ1aW50MTYgXCIuY29uY2F0KG9iamVjdCkpO1xuICAgIHJldHVybiBwYXJzZUludChvYmplY3QpO1xuICB9XG59O1xuVHlwZXMudWludDMyID0ge1xuICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgIHJldHVybiBiLnJlYWRVaW50MzIoKTtcbiAgfSxcbiAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRkZGRkZGRiwgb2JqZWN0LCBcInVpbnQzMiBcIi5jb25jYXQob2JqZWN0KSk7XG4gICAgYi53cml0ZVVpbnQzMihvYmplY3QpO1xuICAgIHJldHVybjtcbiAgfSxcbiAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRkZGRkZGRiwgb2JqZWN0LCBcInVpbnQzMiBcIi5jb25jYXQob2JqZWN0KSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSxcbiAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHYucmVxdWlyZV9yYW5nZSgwLCAweEZGRkZGRkZGLCBvYmplY3QsIFwidWludDMyIFwiLmNvbmNhdChvYmplY3QpKTtcbiAgICByZXR1cm4gcGFyc2VJbnQob2JqZWN0KTtcbiAgfVxufTtcbnZhciBNSU5fU0lHTkVEXzMyID0gLTEgKiBNYXRoLnBvdygyLCAzMSk7XG52YXIgTUFYX1NJR05FRF8zMiA9IE1hdGgucG93KDIsIDMxKSAtIDE7XG5UeXBlcy52YXJpbnQzMiA9IHtcbiAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICByZXR1cm4gYi5yZWFkVmFyaW50MzIoKTtcbiAgfSxcbiAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICB2LnJlcXVpcmVfcmFuZ2UoTUlOX1NJR05FRF8zMiwgTUFYX1NJR05FRF8zMiwgb2JqZWN0LCBcInVpbnQzMiBcIi5jb25jYXQob2JqZWN0KSk7XG4gICAgYi53cml0ZVZhcmludDMyKG9iamVjdCk7XG4gICAgcmV0dXJuO1xuICB9LFxuICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgIHYucmVxdWlyZV9yYW5nZShNSU5fU0lHTkVEXzMyLCBNQVhfU0lHTkVEXzMyLCBvYmplY3QsIFwidWludDMyIFwiLmNvbmNhdChvYmplY3QpKTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9LFxuICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdi5yZXF1aXJlX3JhbmdlKE1JTl9TSUdORURfMzIsIE1BWF9TSUdORURfMzIsIG9iamVjdCwgXCJ1aW50MzIgXCIuY29uY2F0KG9iamVjdCkpO1xuICAgIHJldHVybiBwYXJzZUludChvYmplY3QpO1xuICB9XG59O1xuVHlwZXMuaW50MTYgPSB7XG4gIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgcmV0dXJuIGIucmVhZEludDE2KCk7XG4gIH0sXG4gIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgYi53cml0ZUludDE2KG9iamVjdCk7XG4gICAgcmV0dXJuO1xuICB9LFxuICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH0sXG4gIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VJbnQob2JqZWN0KTtcbiAgfVxufTtcblR5cGVzLmludDY0ID0ge1xuICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgIHJldHVybiBiLnJlYWRJbnQ2NCgpO1xuICB9LFxuICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICBiLndyaXRlSW50NjQodi50b19sb25nKG9iamVjdCkpO1xuICAgIHJldHVybjtcbiAgfSxcbiAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgcmV0dXJuIHYudG9fbG9uZyhvYmplY3QpO1xuICB9LFxuICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIFwiMFwiO1xuICAgIH1cblxuICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICByZXR1cm4gdi50b19sb25nKG9iamVjdCkudG9TdHJpbmcoKTtcbiAgfVxufTtcblR5cGVzLnVpbnQ2NCA9IHtcbiAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICByZXR1cm4gYi5yZWFkVWludDY0KCk7XG4gIH0sXG4gIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgYi53cml0ZVVpbnQ2NCh2LnRvX2xvbmcodi51bnNpZ25lZChvYmplY3QpKSk7XG4gICAgcmV0dXJuO1xuICB9LFxuICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgIHJldHVybiB2LnRvX2xvbmcodi51bnNpZ25lZChvYmplY3QpKTtcbiAgfSxcbiAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBcIjBcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gdi50b19sb25nKG9iamVjdCkudG9TdHJpbmcoKTtcbiAgfVxufTtcblR5cGVzLnN0cmluZyA9IHtcbiAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihiLnJlYWRWU3RyaW5nKCksICd1dGY4Jyk7XG4gIH0sXG4gIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgIGIud3JpdGVWU3RyaW5nKG9iamVjdC50b1N0cmluZygpKTtcbiAgICByZXR1cm47XG4gIH0sXG4gIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgIHJldHVybiBuZXcgQnVmZmVyKG9iamVjdCwgJ3V0ZjgnKTtcbiAgfSxcbiAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHJldHVybiBvYmplY3QudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgfVxufTtcblR5cGVzLmZpeGVkX3N0cmluZyA9IHtcbiAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICByZXR1cm4gVHlwZXMuc3RyaW5nLmZyb21CeXRlQnVmZmVyKGIpO1xuICB9LFxuICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0Lmxlbmd0aCA+IDE2KSB0aHJvdyBuZXcgRXJyb3IoXCJhY2NvdW50IG5hbWUgY2Fubm90IGJlIGxvbmdlciB0aGFuIDE2IGNoYXJhY3RlcnNcIik7XG4gICAgVHlwZXMuc3RyaW5nLmFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KTtcbiAgICByZXR1cm47XG4gIH0sXG4gIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgIGlmIChvYmplY3QubGVuZ3RoID4gMTYpIHRocm93IG5ldyBFcnJvcihcImFjY291bnQgbmFtZSBjYW5ub3QgYmUgbG9uZ2VyIHRoYW4gMTYgY2hhcmFjdGVyc1wiKTtcbiAgICByZXR1cm4gVHlwZXMuc3RyaW5nLmZyb21PYmplY3Qob2JqZWN0KTtcbiAgfSxcbiAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIFR5cGVzLnN0cmluZy50b09iamVjdChvYmplY3QsIGRlYnVnKTtcbiAgfVxufTtcblR5cGVzLnN0cmluZ19iaW5hcnkgPSB7XG4gIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgdmFyIGJfY29weTtcbiAgICB2YXIgbGVuID0gYi5yZWFkVmFyaW50MzIoKTtcbiAgICBiX2NvcHkgPSBiLmNvcHkoYi5vZmZzZXQsIGIub2Zmc2V0ICsgbGVuKSwgYi5za2lwKGxlbik7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYl9jb3B5LnRvQmluYXJ5KCksICdiaW5hcnknKTtcbiAgfSxcbiAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICBiLndyaXRlVmFyaW50MzIob2JqZWN0Lmxlbmd0aCk7XG4gICAgYi5hcHBlbmQob2JqZWN0LnRvU3RyaW5nKCdiaW5hcnknKSwgJ2JpbmFyeScpO1xuICAgIHJldHVybjtcbiAgfSxcbiAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIob2JqZWN0KTtcbiAgfSxcbiAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHJldHVybiBvYmplY3QudG9TdHJpbmcoKTtcbiAgfVxufTtcblxuVHlwZXMuYnl0ZXMgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBiX2NvcHk7XG4gICAgICAgIHZhciBsZW4gPSBiLnJlYWRWYXJpbnQzMigpO1xuICAgICAgICBiX2NvcHkgPSBiLmNvcHkoYi5vZmZzZXQsIGIub2Zmc2V0ICsgbGVuKSwgYi5za2lwKGxlbik7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGJfY29weS50b0JpbmFyeSgpLCAnYmluYXJ5Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiX2NvcHkgPSBiLmNvcHkoYi5vZmZzZXQsIGIub2Zmc2V0ICsgc2l6ZSksIGIuc2tpcChzaXplKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYl9jb3B5LnRvQmluYXJ5KCksICdiaW5hcnknKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJzdHJpbmdcIikgb2JqZWN0ID0gbmV3IEJ1ZmZlcihvYmplY3QsIFwiaGV4XCIpO1xuXG4gICAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGIud3JpdGVWYXJpbnQzMihvYmplY3QubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgYi5hcHBlbmQob2JqZWN0LnRvU3RyaW5nKCdiaW5hcnknKSwgJ2JpbmFyeScpO1xuICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqZWN0KSkgcmV0dXJuIG9iamVjdDtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKG9iamVjdCwgJ2hleCcpO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB6ZXJvcyA9IGZ1bmN0aW9uIHplcm9zKG51bSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQXJyYXkobnVtKS5qb2luKFwiMDBcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHplcm9zKHNpemUpO1xuICAgICAgfVxuXG4gICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICByZXR1cm4gb2JqZWN0LnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9XG4gIH07XG59O1xuXG5UeXBlcy5ib29sID0ge1xuICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgIHJldHVybiBiLnJlYWRVaW50OCgpID09PSAxO1xuICB9LFxuICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgIC8vIHN1cHBvcnRzIGJvb2xlYW4gb3IgaW50ZWdlclxuICAgIGIud3JpdGVVaW50OChKU09OLnBhcnNlKG9iamVjdCkgPyAxIDogMCk7XG4gICAgcmV0dXJuO1xuICB9LFxuICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKG9iamVjdCkgPyB0cnVlIDogZmFsc2U7XG4gIH0sXG4gIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIEpTT04ucGFyc2Uob2JqZWN0KSA/IHRydWUgOiBmYWxzZTtcbiAgfVxufTtcblR5cGVzLnZvaWQgPSB7XG4gIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiKHZvaWQpIHVuZGVmaW5lZCB0eXBlXCIpO1xuICB9LFxuICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIih2b2lkKSB1bmRlZmluZWQgdHlwZVwiKTtcbiAgfSxcbiAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCIodm9pZCkgdW5kZWZpbmVkIHR5cGVcIik7XG4gIH0sXG4gIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcIih2b2lkKSB1bmRlZmluZWQgdHlwZVwiKTtcbiAgfVxufTtcblxuVHlwZXMuYXJyYXkgPSBmdW5jdGlvbiAoc3Rfb3BlcmF0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgIHZhciBzaXplID0gYi5yZWFkVmFyaW50MzIoKTtcblxuICAgICAgaWYgKEhFWF9EVU1QKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwidmFyaW50MzIgc2l6ZSA9IFwiICsgc2l6ZS50b1N0cmluZygxNikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyAwIDwgc2l6ZSA/IGkgPCBzaXplIDogaSA+IHNpemU7IDAgPCBzaXplID8gaSsrIDogaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHN0X29wZXJhdGlvbi5mcm9tQnl0ZUJ1ZmZlcihiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzb3J0T3BlcmF0aW9uKHJlc3VsdCwgc3Rfb3BlcmF0aW9uKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICBvYmplY3QgPSBzb3J0T3BlcmF0aW9uKG9iamVjdCwgc3Rfb3BlcmF0aW9uKTtcbiAgICAgIGIud3JpdGVWYXJpbnQzMihvYmplY3QubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAgc3Rfb3BlcmF0aW9uLmFwcGVuZEJ5dGVCdWZmZXIoYiwgbyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgb2JqZWN0ID0gc29ydE9wZXJhdGlvbihvYmplY3QsIHN0X29wZXJhdGlvbik7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG8gPSBvYmplY3RbaV07XG4gICAgICAgIHJlc3VsdC5wdXNoKHN0X29wZXJhdGlvbi5mcm9tT2JqZWN0KG8pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW3N0X29wZXJhdGlvbi50b09iamVjdChvYmplY3QsIGRlYnVnKV07XG4gICAgICB9XG5cbiAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgIG9iamVjdCA9IHNvcnRPcGVyYXRpb24ob2JqZWN0LCBzdF9vcGVyYXRpb24pO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IG9iamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBvID0gb2JqZWN0W2ldO1xuICAgICAgICByZXN1bHQucHVzaChzdF9vcGVyYXRpb24udG9PYmplY3QobywgZGVidWcpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG59O1xuXG5UeXBlcy50aW1lX3BvaW50X3NlYyA9IHtcbiAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICByZXR1cm4gYi5yZWFkVWludDMyKCk7XG4gIH0sXG4gIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgIT09IFwibnVtYmVyXCIpIG9iamVjdCA9IFR5cGVzLnRpbWVfcG9pbnRfc2VjLmZyb21PYmplY3Qob2JqZWN0KTtcbiAgICBiLndyaXRlVWludDMyKG9iamVjdCk7XG4gICAgcmV0dXJuO1xuICB9LFxuICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIG9iamVjdDtcbiAgICBpZiAob2JqZWN0LmdldFRpbWUpIHJldHVybiBNYXRoLmZsb29yKG9iamVjdC5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgICBpZiAodHlwZW9mIG9iamVjdCAhPT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRlIHR5cGU6IFwiICsgb2JqZWN0KTtcbiAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJzdHJpbmdcIiAmJiAhL1okLy50ZXN0KG9iamVjdCkpIG9iamVjdCA9IG9iamVjdCArIFwiWlwiO1xuICAgIHJldHVybiBNYXRoLmZsb29yKG5ldyBEYXRlKG9iamVjdCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gIH0sXG4gIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG5ldyBEYXRlKDApLnRvSVNPU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcbiAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwic3RyaW5nXCIpIHJldHVybiBvYmplY3Q7XG4gICAgaWYgKG9iamVjdC5nZXRUaW1lKSByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcbiAgICB2YXIgaW50ID0gcGFyc2VJbnQob2JqZWN0KTtcbiAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRkZGRkZGRiwgaW50LCBcInVpbnQzMiBcIi5jb25jYXQob2JqZWN0KSk7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGludCAqIDEwMDApLnRvSVNPU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcbiAgfVxufTtcblxuVHlwZXMuc2V0ID0gZnVuY3Rpb24gKHN0X29wZXJhdGlvbikge1xuICByZXR1cm4ge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShhcnJheSkge1xuICAgICAgdmFyIGR1cF9tYXAgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBvID0gYXJyYXlbaV07XG4gICAgICAgIHZhciByZWY7XG5cbiAgICAgICAgaWYgKHJlZiA9IF90eXBlb2YobyksIFsnc3RyaW5nJywgJ251bWJlciddLmluZGV4T2YocmVmKSA+PSAwKSB7XG4gICAgICAgICAgaWYgKGR1cF9tYXBbb10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZHVwbGljYXRlIChzZXQpXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGR1cF9tYXBbb10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzb3J0T3BlcmF0aW9uKGFycmF5LCBzdF9vcGVyYXRpb24pO1xuICAgIH0sXG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgIHZhciBzaXplID0gYi5yZWFkVmFyaW50MzIoKTtcblxuICAgICAgaWYgKEhFWF9EVU1QKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwidmFyaW50MzIgc2l6ZSA9IFwiICsgc2l6ZS50b1N0cmluZygxNikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgMCA8IHNpemUgPyBpIDwgc2l6ZSA6IGkgPiBzaXplOyAwIDwgc2l6ZSA/IGkrKyA6IGkrKykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHN0X29wZXJhdGlvbi5mcm9tQnl0ZUJ1ZmZlcihiKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSgpKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICBvYmplY3QgPSBbXTtcbiAgICAgIH1cblxuICAgICAgYi53cml0ZVZhcmludDMyKG9iamVjdC5sZW5ndGgpO1xuICAgICAgdmFyIGl0ZXJhYmxlID0gdGhpcy52YWxpZGF0ZShvYmplY3QpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG8gPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgc3Rfb3BlcmF0aW9uLmFwcGVuZEJ5dGVCdWZmZXIoYiwgbyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICBvYmplY3QgPSBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvID0gb2JqZWN0W2ldO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHN0X29wZXJhdGlvbi5mcm9tT2JqZWN0KG8pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KCkpO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KG9iamVjdCwgZGVidWcpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0ID0gW107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAgICByZXN1bHQucHVzaChzdF9vcGVyYXRpb24udG9PYmplY3QobywgZGVidWcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KCkpO1xuICAgIH1cbiAgfTtcbn07IC8vIGdsb2JhbF9wYXJhbWV0ZXJzX3VwZGF0ZV9vcGVyYXRpb24gY3VycmVudF9mZWVzXG5cblxuVHlwZXMuZml4ZWRfYXJyYXkgPSBmdW5jdGlvbiAoY291bnQsIHN0X29wZXJhdGlvbikge1xuICByZXR1cm4ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICB2YXIgaSwgaiwgcmVmLCByZXN1bHRzO1xuICAgICAgcmVzdWx0cyA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gY291bnQ7IGogPCByZWY7IGkgPSBqICs9IDEpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHN0X29wZXJhdGlvbi5mcm9tQnl0ZUJ1ZmZlcihiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzb3J0T3BlcmF0aW9uKHJlc3VsdHMsIHN0X29wZXJhdGlvbik7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgdmFyIGksIGosIHJlZjtcblxuICAgICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgb2JqZWN0ID0gc29ydE9wZXJhdGlvbihvYmplY3QsIHN0X29wZXJhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBjb3VudDsgaiA8IHJlZjsgaSA9IGogKz0gMSkge1xuICAgICAgICBzdF9vcGVyYXRpb24uYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3RbaV0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgIHZhciBpLCBqLCByZWYsIHJlc3VsdHM7XG5cbiAgICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdHMgPSBbXTtcblxuICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGNvdW50OyBqIDwgcmVmOyBpID0gaiArPSAxKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChzdF9vcGVyYXRpb24uZnJvbU9iamVjdChvYmplY3RbaV0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0LCBkZWJ1Zykge1xuICAgICAgdmFyIGksIGosIGssIHJlZiwgcmVmMSwgcmVzdWx0cywgcmVzdWx0czE7XG5cbiAgICAgIGlmIChkZWJ1ZyA9PSBudWxsKSB7XG4gICAgICAgIGRlYnVnID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHZvaWQgMCkge1xuICAgICAgICByZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGNvdW50OyBqIDwgcmVmOyBpID0gaiArPSAxKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHN0X29wZXJhdGlvbi50b09iamVjdCh2b2lkIDAsIGRlYnVnKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH1cblxuICAgICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0czEgPSBbXTtcblxuICAgICAgZm9yIChpID0gayA9IDAsIHJlZjEgPSBjb3VudDsgayA8IHJlZjE7IGkgPSBrICs9IDEpIHtcbiAgICAgICAgcmVzdWx0czEucHVzaChzdF9vcGVyYXRpb24udG9PYmplY3Qob2JqZWN0W2ldLCBkZWJ1ZykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0czE7XG4gICAgfVxuICB9O1xufTtcbi8qIFN1cHBvcnRzIGluc3RhbmNlIG51bWJlcnMgKDExKSBvciBvYmplY3QgdHlwZXMgKDEuMi4xMSkuICBPYmplY3QgdHlwZVxudmFsaWRhdGlvbiBpcyBlbmZvcmNlZCB3aGVuIGFuIG9iamVjdCB0eXBlIGlzIHVzZWQuICovXG5cblxudmFyIGlkX3R5cGUgPSBmdW5jdGlvbiBpZF90eXBlKHJlc2VydmVkX3NwYWNlcywgb2JqZWN0X3R5cGUpIHtcbiAgdi5yZXF1aXJlZChyZXNlcnZlZF9zcGFjZXMsIFwicmVzZXJ2ZWRfc3BhY2VzXCIpO1xuICB2LnJlcXVpcmVkKG9iamVjdF90eXBlLCBcIm9iamVjdF90eXBlXCIpO1xuICByZXR1cm4ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICByZXR1cm4gYi5yZWFkVmFyaW50MzIoKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG5cbiAgICAgIGlmIChvYmplY3QucmVzb2x2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdC5yZXNvbHZlO1xuICAgICAgfSAvLyBjb252ZXJ0IDEuMi5uIGludG8ganVzdCBuXG5cblxuICAgICAgaWYgKC9eWzAtOV0rXFwuWzAtOV0rXFwuWzAtOV0rJC8udGVzdChvYmplY3QpKSB7XG4gICAgICAgIG9iamVjdCA9IHYuZ2V0X2luc3RhbmNlKHJlc2VydmVkX3NwYWNlcywgb2JqZWN0X3R5cGUsIG9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIGIud3JpdGVWYXJpbnQzMih2LnRvX251bWJlcihvYmplY3QpKTtcbiAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG5cbiAgICAgIGlmIChvYmplY3QucmVzb2x2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdC5yZXNvbHZlO1xuICAgICAgfVxuXG4gICAgICBpZiAodi5pc19kaWdpdHMob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gdi50b19udW1iZXIob2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHYuZ2V0X2luc3RhbmNlKHJlc2VydmVkX3NwYWNlcywgb2JqZWN0X3R5cGUsIG9iamVjdCk7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIG9iamVjdF90eXBlX2lkID0gY2hhaW5fdHlwZXMub2JqZWN0X3R5cGVbb2JqZWN0X3R5cGVdO1xuXG4gICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHJlc2VydmVkX3NwYWNlcywgXCIuXCIpLmNvbmNhdChvYmplY3RfdHlwZV9pZCwgXCIuMFwiKTtcbiAgICAgIH1cblxuICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuXG4gICAgICBpZiAob2JqZWN0LnJlc29sdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvYmplY3QgPSBvYmplY3QucmVzb2x2ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKC9eWzAtOV0rXFwuWzAtOV0rXFwuWzAtOV0rJC8udGVzdChvYmplY3QpKSB7XG4gICAgICAgIG9iamVjdCA9IHYuZ2V0X2luc3RhbmNlKHJlc2VydmVkX3NwYWNlcywgb2JqZWN0X3R5cGUsIG9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChyZXNlcnZlZF9zcGFjZXMsIFwiLlwiKS5jb25jYXQob2JqZWN0X3R5cGVfaWQsIFwiLlwiKSArIG9iamVjdDtcbiAgICB9XG4gIH07XG59O1xuXG5UeXBlcy5wcm90b2NvbF9pZF90eXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdi5yZXF1aXJlZChuYW1lLCBcIm5hbWVcIik7XG4gIHJldHVybiBpZF90eXBlKGNoYWluX3R5cGVzLnJlc2VydmVkX3NwYWNlcy5wcm90b2NvbF9pZHMsIG5hbWUpO1xufTtcblxuVHlwZXMub2JqZWN0X2lkX3R5cGUgPSB7XG4gIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgcmV0dXJuIE9iamVjdElkLmZyb21CeXRlQnVmZmVyKGIpO1xuICB9LFxuICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgIHYucmVxdWlyZWQob2JqZWN0KTtcblxuICAgIGlmIChvYmplY3QucmVzb2x2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvYmplY3QgPSBvYmplY3QucmVzb2x2ZTtcbiAgICB9XG5cbiAgICBvYmplY3QgPSBPYmplY3RJZC5mcm9tU3RyaW5nKG9iamVjdCk7XG4gICAgb2JqZWN0LmFwcGVuZEJ5dGVCdWZmZXIoYik7XG4gICAgcmV0dXJuO1xuICB9LFxuICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgIHYucmVxdWlyZWQob2JqZWN0KTtcblxuICAgIGlmIChvYmplY3QucmVzb2x2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvYmplY3QgPSBvYmplY3QucmVzb2x2ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0SWQuZnJvbVN0cmluZyhvYmplY3QpO1xuICB9LFxuICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIFwiMC4wLjBcIjtcbiAgICB9XG5cbiAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG5cbiAgICBpZiAob2JqZWN0LnJlc29sdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb2JqZWN0ID0gb2JqZWN0LnJlc29sdmU7XG4gICAgfVxuXG4gICAgb2JqZWN0ID0gT2JqZWN0SWQuZnJvbVN0cmluZyhvYmplY3QpO1xuICAgIHJldHVybiBvYmplY3QudG9TdHJpbmcoKTtcbiAgfVxufTtcblR5cGVzLnZvdGVfaWQgPSB7XG4gIFRZUEU6IDB4MDAwMDAwRkYsXG4gIElEOiAweEZGRkZGRjAwLFxuICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgIHZhciB2YWx1ZSA9IGIucmVhZFVpbnQzMigpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB2YWx1ZSAmIHRoaXMuVFlQRSxcbiAgICAgIGlkOiB2YWx1ZSAmIHRoaXMuSURcbiAgICB9O1xuICB9LFxuICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0ID09PSBcInN0cmluZ1wiKSBvYmplY3QgPSBUeXBlcy52b3RlX2lkLmZyb21PYmplY3Qob2JqZWN0KTtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QuaWQgPDwgOCB8IG9iamVjdC50eXBlO1xuICAgIGIud3JpdGVVaW50MzIodmFsdWUpO1xuICAgIHJldHVybjtcbiAgfSxcbiAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICB2LnJlcXVpcmVkKG9iamVjdCwgXCIodHlwZSB2b3RlX2lkKVwiKTtcblxuICAgIGlmIChfdHlwZW9mKG9iamVjdCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHYucmVxdWlyZWQob2JqZWN0LnR5cGUsIFwidHlwZVwiKTtcbiAgICAgIHYucmVxdWlyZWQob2JqZWN0LmlkLCBcImlkXCIpO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICB2LnJlcXVpcmVfdGVzdCgvXlswLTldKzpbMC05XSskLywgb2JqZWN0LCBcInZvdGVfaWQgZm9ybWF0IFwiLmNvbmNhdChvYmplY3QpKTtcblxuICAgIHZhciBfb2JqZWN0JHNwbGl0MyA9IG9iamVjdC5zcGxpdCgnOicpLFxuICAgICAgICBfb2JqZWN0JHNwbGl0NCA9IF9zbGljZWRUb0FycmF5KF9vYmplY3Qkc3BsaXQzLCAyKSxcbiAgICAgICAgdHlwZSA9IF9vYmplY3Qkc3BsaXQ0WzBdLFxuICAgICAgICBpZCA9IF9vYmplY3Qkc3BsaXQ0WzFdO1xuXG4gICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4ZmYsIHR5cGUsIFwidm90ZSB0eXBlIFwiLmNvbmNhdChvYmplY3QpKTtcbiAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhmZmZmZmYsIGlkLCBcInZvdGUgaWQgXCIuY29uY2F0KG9iamVjdCkpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgaWQ6IGlkXG4gICAgfTtcbiAgfSxcbiAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBcIjA6MFwiO1xuICAgIH1cblxuICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJzdHJpbmdcIikgb2JqZWN0ID0gVHlwZXMudm90ZV9pZC5mcm9tT2JqZWN0KG9iamVjdCk7XG4gICAgcmV0dXJuIG9iamVjdC50eXBlICsgXCI6XCIgKyBvYmplY3QuaWQ7XG4gIH0sXG4gIGNvbXBhcmU6IGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgIGlmIChfdHlwZW9mKGEpICE9PSBcIm9iamVjdFwiKSBhID0gVHlwZXMudm90ZV9pZC5mcm9tT2JqZWN0KGEpO1xuICAgIGlmIChfdHlwZW9mKGIpICE9PSBcIm9iamVjdFwiKSBiID0gVHlwZXMudm90ZV9pZC5mcm9tT2JqZWN0KGIpO1xuICAgIHJldHVybiBwYXJzZUludChhLmlkKSAtIHBhcnNlSW50KGIuaWQpO1xuICB9XG59O1xuXG5UeXBlcy5vcHRpb25hbCA9IGZ1bmN0aW9uIChzdF9vcGVyYXRpb24pIHtcbiAgdi5yZXF1aXJlZChzdF9vcGVyYXRpb24sIFwic3Rfb3BlcmF0aW9uXCIpO1xuICByZXR1cm4ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICBpZiAoIShiLnJlYWRVaW50OCgpID09PSAxKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3Rfb3BlcmF0aW9uLmZyb21CeXRlQnVmZmVyKGIpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYi53cml0ZVVpbnQ4KDEpO1xuICAgICAgICBzdF9vcGVyYXRpb24uYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYi53cml0ZVVpbnQ4KDApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdF9vcGVyYXRpb24uZnJvbU9iamVjdChvYmplY3QpO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgLy8gdG9PYmplY3QgaXMgb25seSBudWxsIHNhdmUgaWYgdXNlX2RlZmF1bHQgaXMgdHJ1ZVxuICAgICAgdmFyIHJlc3VsdF9vYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzdF9vcGVyYXRpb24udG9PYmplY3Qob2JqZWN0LCBkZWJ1Zyk7XG4gICAgICAgIH1cbiAgICAgIH0oKTtcblxuICAgICAgaWYgKGRlYnVnLmFubm90YXRlKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKHJlc3VsdF9vYmplY3QpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgcmVzdWx0X29iamVjdC5fX29wdGlvbmFsID0gXCJwYXJlbnQgaXMgb3B0aW9uYWxcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRfb2JqZWN0ID0ge1xuICAgICAgICAgICAgX19vcHRpb25hbDogcmVzdWx0X29iamVjdFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdF9vYmplY3Q7XG4gICAgfVxuICB9O1xufTtcblxuVHlwZXMudmFyaWFudF9vYmplY3QgPSB7XG4gIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBjb3VudCA9IGIucmVhZFVpbnQ4KCk7XG4gICAgaWYgKCFjb3VudCkgcmV0dXJuIHJlcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgdmFyIGtleSA9IHN0cmluZy5mcm9tQnl0ZUJ1ZmZlcihiKTtcbiAgICAgIHZhciB2YWxfdHlwZSA9IGIucmVhZFVpbnQ4KCk7XG5cbiAgICAgIGlmICh2YWxfdHlwZSA9PSA1KSB7XG4gICAgICAgIHJlc1trZXldID0gc3RyaW5nLmZyb21CeXRlQnVmZmVyKGIpO1xuICAgICAgfSBlbHNlIGlmICh2YWxfdHlwZSA9PSAyKSB7XG4gICAgICAgIHJlc1trZXldID0gdWludDY0LmZyb21CeXRlQnVmZmVyKGIpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICBiLndyaXRlVWludDgoT2JqZWN0LmVudHJpZXMob2JqZWN0KS5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMCwgX09iamVjdCRlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMob2JqZWN0KTsgX2kyIDwgX09iamVjdCRlbnRyaWVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBfT2JqZWN0JGVudHJpZXMkX2kgPSBfc2xpY2VkVG9BcnJheShfT2JqZWN0JGVudHJpZXNbX2kyXSwgMiksXG4gICAgICAgICAga2V5ID0gX09iamVjdCRlbnRyaWVzJF9pWzBdLFxuICAgICAgICAgIHZhbHVlID0gX09iamVjdCRlbnRyaWVzJF9pWzFdO1xuXG4gICAgICBUeXBlcy5zdHJpbmcuYXBwZW5kQnl0ZUJ1ZmZlcihiLCBrZXkpO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBiLndyaXRlVWludDgoNSk7XG4gICAgICAgIFR5cGVzLnN0cmluZy5hcHBlbmRCeXRlQnVmZmVyKGIsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBiLndyaXRlVWludDgoMik7XG4gICAgICAgIFR5cGVzLnVpbnQ2NC5hcHBlbmRCeXRlQnVmZmVyKGIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0sXG4gIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSxcbiAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxufTtcblxuVHlwZXMuc3RhdGljX3ZhcmlhbnQgPSBmdW5jdGlvbiAoX3N0X29wZXJhdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBub3NvcnQ6IHRydWUsXG4gICAgc3Rfb3BlcmF0aW9uczogX3N0X29wZXJhdGlvbnMsXG4gICAgb3BUeXBlSWQ6IGZ1bmN0aW9uIG9wVHlwZUlkKHZhbHVlKSB7XG4gICAgICB2YXIgcG9zID0gMCxcbiAgICAgICAgICB0eXBlX2lkO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikgdHlwZV9pZCA9IHZhbHVlO2Vsc2Uge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5zdF9vcGVyYXRpb25zKSxcbiAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBvcCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAob3Aub3BlcmF0aW9uX25hbWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIHR5cGVfaWQgPSBwb3M7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVfaWQ7XG4gICAgfSxcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgdmFyIHR5cGVfaWQgPSBiLnJlYWRWYXJpbnQzMigpO1xuICAgICAgdmFyIHN0X29wZXJhdGlvbiA9IHRoaXMuc3Rfb3BlcmF0aW9uc1t0eXBlX2lkXTtcblxuICAgICAgaWYgKEhFWF9EVU1QKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJzdGF0aWNfdmFyaWFudCBpZCAweFwiLmNvbmNhdCh0eXBlX2lkLnRvU3RyaW5nKDE2KSwgXCIgKFwiKS5jb25jYXQodHlwZV9pZCwgXCIpXCIpKTtcbiAgICAgIH1cblxuICAgICAgdi5yZXF1aXJlZChzdF9vcGVyYXRpb24sIFwib3BlcmF0aW9uIFwiLmNvbmNhdCh0eXBlX2lkKSk7XG4gICAgICByZXR1cm4gW3R5cGVfaWQsIHN0X29wZXJhdGlvbi5mcm9tQnl0ZUJ1ZmZlcihiKV07XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgdmFyIHR5cGVfaWQgPSB0aGlzLm9wVHlwZUlkKG9iamVjdFswXSk7XG4gICAgICB2YXIgc3Rfb3BlcmF0aW9uID0gdGhpcy5zdF9vcGVyYXRpb25zW3R5cGVfaWRdO1xuICAgICAgdi5yZXF1aXJlZChzdF9vcGVyYXRpb24sIFwib3BlcmF0aW9uIFwiLmNvbmNhdCh0eXBlX2lkKSk7XG4gICAgICBiLndyaXRlVmFyaW50MzIodHlwZV9pZCk7XG4gICAgICBzdF9vcGVyYXRpb24uYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3RbMV0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgIHZhciB0eXBlX2lkID0gdGhpcy5vcFR5cGVJZChvYmplY3RbMF0pO1xuICAgICAgdmFyIHN0X29wZXJhdGlvbiA9IHRoaXMuc3Rfb3BlcmF0aW9uc1t0eXBlX2lkXTtcbiAgICAgIHYucmVxdWlyZWQoc3Rfb3BlcmF0aW9uLCBcIm9wZXJhdGlvbiBcIi5jb25jYXQodHlwZV9pZCkpO1xuICAgICAgcmV0dXJuIFt0eXBlX2lkLCBzdF9vcGVyYXRpb24uZnJvbU9iamVjdChvYmplY3RbMV0pXTtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuc3Rfb3BlcmF0aW9uc1swXS5vcGVyYXRpb25fbmFtZSwgdGhpcy5zdF9vcGVyYXRpb25zWzBdLnRvT2JqZWN0KHVuZGVmaW5lZCwgZGVidWcpXTtcbiAgICAgIH1cblxuICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgdmFyIHR5cGVfaWQgPSB0aGlzLm9wVHlwZUlkKG9iamVjdFswXSk7XG4gICAgICB2YXIgc3Rfb3BlcmF0aW9uID0gdGhpcy5zdF9vcGVyYXRpb25zW3R5cGVfaWRdO1xuICAgICAgdi5yZXF1aXJlZChzdF9vcGVyYXRpb24sIFwib3BlcmF0aW9uIFwiLmNvbmNhdCh0eXBlX2lkKSk7XG4gICAgICByZXR1cm4gW3N0X29wZXJhdGlvbi5vcGVyYXRpb25fbmFtZSwgc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KG9iamVjdFsxXSwgZGVidWcpXTtcbiAgICB9LFxuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgcmV0dXJuIHN0ckNtcCh0aGlzLm9wVHlwZUlkKGFbMF0pLCB0aGlzLm9wVHlwZUlkKGJbMF0pKTtcbiAgICB9XG4gIH07XG59O1xuXG5UeXBlcy5tYXAgPSBmdW5jdGlvbiAoa2V5X3N0X29wZXJhdGlvbiwgdmFsdWVfc3Rfb3BlcmF0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGFycmF5KSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGluZyBhcnJheVwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGR1cF9tYXAgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBvID0gYXJyYXlbaV07XG4gICAgICAgIHZhciByZWY7XG5cbiAgICAgICAgaWYgKCEoby5sZW5ndGggPT09IDIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0aW5nIHR3byBlbGVtZW50c1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWYgPSBfdHlwZW9mKG9bMF0pLCBbJ251bWJlcicsICdzdHJpbmcnXS5pbmRleE9mKHJlZikgPj0gMCkge1xuICAgICAgICAgIGlmIChkdXBfbWFwW29bMF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImR1cGxpY2F0ZSAobWFwKVwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkdXBfbWFwW29bMF1dID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc29ydE9wZXJhdGlvbihhcnJheSwga2V5X3N0X29wZXJhdGlvbik7XG4gICAgfSxcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIGVuZCA9IGIucmVhZFZhcmludDMyKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyAwIDwgZW5kID8gaSA8IGVuZCA6IGkgPiBlbmQ7IDAgPCBlbmQgPyBpKysgOiBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goW2tleV9zdF9vcGVyYXRpb24uZnJvbUJ5dGVCdWZmZXIoYiksIHZhbHVlX3N0X29wZXJhdGlvbi5mcm9tQnl0ZUJ1ZmZlcihiKV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZShyZXN1bHQpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgIHRoaXMudmFsaWRhdGUob2JqZWN0KTtcbiAgICAgIGIud3JpdGVWYXJpbnQzMihvYmplY3QubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAga2V5X3N0X29wZXJhdGlvbi5hcHBlbmRCeXRlQnVmZmVyKGIsIG9bMF0pO1xuICAgICAgICB2YWx1ZV9zdF9vcGVyYXRpb24uYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvWzFdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAgcmVzdWx0LnB1c2goW2tleV9zdF9vcGVyYXRpb24uZnJvbU9iamVjdChvWzBdKSwgdmFsdWVfc3Rfb3BlcmF0aW9uLmZyb21PYmplY3Qob1sxXSldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGUocmVzdWx0KTtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW1trZXlfc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KHVuZGVmaW5lZCwgZGVidWcpLCB2YWx1ZV9zdF9vcGVyYXRpb24udG9PYmplY3QodW5kZWZpbmVkLCBkZWJ1ZyldXTtcbiAgICAgIH1cblxuICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgb2JqZWN0ID0gdGhpcy52YWxpZGF0ZShvYmplY3QpO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IG9iamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBvID0gb2JqZWN0W2ldO1xuICAgICAgICByZXN1bHQucHVzaChba2V5X3N0X29wZXJhdGlvbi50b09iamVjdChvWzBdLCBkZWJ1ZyksIHZhbHVlX3N0X29wZXJhdGlvbi50b09iamVjdChvWzFdLCBkZWJ1ZyldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG59O1xuXG5UeXBlcy5wdWJsaWNfa2V5ID0ge1xuICB0b1B1YmxpYzogZnVuY3Rpb24gdG9QdWJsaWMob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdC5yZXNvbHZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9iamVjdCA9IG9iamVjdC5yZXNvbHZlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IG9iamVjdC5RID8gb2JqZWN0IDogX2VjYy5QdWJsaWNLZXkuZnJvbVN0cmluZ09yVGhyb3cob2JqZWN0KTtcbiAgfSxcbiAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICByZXR1cm4gZnAucHVibGljX2tleShiKTtcbiAgfSxcbiAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgZnAucHVibGljX2tleShiLCBUeXBlcy5wdWJsaWNfa2V5LnRvUHVibGljKG9iamVjdCkpO1xuICAgIHJldHVybjtcbiAgfSxcbiAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG5cbiAgICBpZiAob2JqZWN0LlEpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIFR5cGVzLnB1YmxpY19rZXkudG9QdWJsaWMob2JqZWN0KTtcbiAgfSxcbiAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBfZWNjLmVjY19jb25maWcuZ2V0KCdhZGRyZXNzX3ByZWZpeCcpICsgXCI4NTlneGZuWHlVcmlNZ1VlVGhoMWZXdjNvcWNwTEZ5SGEzVGZGWUM0UEsySHFoVG9WTVwiO1xuICAgIH1cblxuICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICByZXR1cm4gb2JqZWN0LnRvU3RyaW5nKCk7XG4gIH0sXG4gIGNvbXBhcmU6IGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgIC8vIHNvcnQgZGVjZW5kaW5nXG4gICAgcmV0dXJuIC0xICogc3RyQ21wKGEudG9TdHJpbmcoKSwgYi50b1N0cmluZygpKTtcbiAgfVxufTtcblR5cGVzLmFkZHJlc3MgPSB7XG4gIF90b19hZGRyZXNzOiBmdW5jdGlvbiBfdG9fYWRkcmVzcyhvYmplY3QpIHtcbiAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG5cbiAgICBpZiAob2JqZWN0LmFkZHkpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9lY2MuQWRkcmVzcy5mcm9tU3RyaW5nKG9iamVjdCk7XG4gIH0sXG4gIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgcmV0dXJuIG5ldyBfZWNjLkFkZHJlc3MoZnAucmlwZW1kMTYwKGIpKTtcbiAgfSxcbiAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICBmcC5yaXBlbWQxNjAoYiwgVHlwZXMuYWRkcmVzcy5fdG9fYWRkcmVzcyhvYmplY3QpLnRvQnVmZmVyKCkpO1xuICAgIHJldHVybjtcbiAgfSxcbiAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICByZXR1cm4gVHlwZXMuYWRkcmVzcy5fdG9fYWRkcmVzcyhvYmplY3QpO1xuICB9LFxuICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIF9lY2MuZWNjX2NvbmZpZy5nZXQoJ2FkZHJlc3NfcHJlZml4JykgKyBcIjY2NEttSHhTdVF5RHNmd280V0VKdldwemcxUUtkZzY3U1wiO1xuICAgIH1cblxuICAgIHJldHVybiBUeXBlcy5hZGRyZXNzLl90b19hZGRyZXNzKG9iamVjdCkudG9TdHJpbmcoKTtcbiAgfSxcbiAgY29tcGFyZTogZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgLy8gc29ydCBkZWNlbmRpbmdcbiAgICByZXR1cm4gLTEgKiBzdHJDbXAoYS50b1N0cmluZygpLCBiLnRvU3RyaW5nKCkpO1xuICB9XG59O1xuXG52YXIgc3RyQ21wID0gZnVuY3Rpb24gc3RyQ21wKGEsIGIpIHtcbiAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xufTtcblxudmFyIGZpcnN0RWwgPSBmdW5jdGlvbiBmaXJzdEVsKGVsKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGVsKSA/IGVsWzBdIDogZWw7XG59O1xuXG52YXIgc29ydE9wZXJhdGlvbiA9IGZ1bmN0aW9uIHNvcnRPcGVyYXRpb24oYXJyYXksIHN0X29wZXJhdGlvbikge1xuICAvLyBjb25zb2xlLmxvZygnb3BlcmF0aW9uLm5vc29ydCcsIHN0X29wZXJhdGlvbi5ub3NvcnQpXG4gIHJldHVybiBzdF9vcGVyYXRpb24ubm9zb3J0ID8gYXJyYXkgOiBzdF9vcGVyYXRpb24uY29tcGFyZSA/IGFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gc3Rfb3BlcmF0aW9uLmNvbXBhcmUoZmlyc3RFbChhKSwgZmlyc3RFbChiKSk7XG4gIH0pIDogLy8gY3VzdG9tIGNvbXBhcmUgb3BlcmF0aW9uXG4gIGFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gdHlwZW9mIGZpcnN0RWwoYSkgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGZpcnN0RWwoYikgPT09IFwibnVtYmVyXCIgPyBmaXJzdEVsKGEpIC0gZmlyc3RFbChiKSA6IC8vIEEgYmluYXJ5IHN0cmluZyBjb21wYXJlIGRvZXMgbm90IHdvcmsuIFBlcmZvcm1hbmFuY2UgaXMgdmVyeSBnb29kIHNvIEhFWCBpcyB1c2VkLi4gIGxvY2FsZUNvbXBhcmUgaXMgYW5vdGhlciBvcHRpb24uXG4gICAgQnVmZmVyLmlzQnVmZmVyKGZpcnN0RWwoYSkpICYmIEJ1ZmZlci5pc0J1ZmZlcihmaXJzdEVsKGIpKSA/IHN0ckNtcChmaXJzdEVsKGEpLnRvU3RyaW5nKFwiaGV4XCIpLCBmaXJzdEVsKGIpLnRvU3RyaW5nKFwiaGV4XCIpKSA6IHN0ckNtcChmaXJzdEVsKGEpLnRvU3RyaW5nKCksIGZpcnN0RWwoYikudG9TdHJpbmcoKSk7XG4gIH0pO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuY29uc3RydWN0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltLmpzXCIpO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBfbXk7XG5cbnZhciBpc19lbXB0eTtcbnZhciBpc19kaWdpdHM7XG52YXIgdG9fbnVtYmVyO1xudmFyIHJlcXVpcmVfbWF0Y2g7XG52YXIgcmVxdWlyZV9vYmplY3RfaWQ7XG52YXIgcmVxdWlyZV9vYmplY3RfdHlwZTtcbnZhciBnZXRfaW5zdGFuY2U7XG52YXIgcmVxdWlyZV9yZWxhdGl2ZV90eXBlO1xudmFyIGdldF9yZWxhdGl2ZV9pbnN0YW5jZTtcbnZhciByZXF1aXJlX3Byb3RvY29sX3R5cGU7XG52YXIgZ2V0X3Byb3RvY29sX2luc3RhbmNlO1xudmFyIGdldF9wcm90b2NvbF90eXBlO1xudmFyIHJlcXVpcmVfaW1wbGVtZW50YXRpb25fdHlwZTtcbnZhciBnZXRfaW1wbGVtZW50YXRpb25faW5zdGFuY2U7XG5cbnZhciBMb25nID0gcmVxdWlyZSgnYnl0ZWJ1ZmZlcicpLkxvbmc7IC8vIHZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnYmlnaScpO1xuXG5cbnZhciBjaGFpbl90eXBlcyA9IHJlcXVpcmUoJy4vQ2hhaW5UeXBlcycpO1xuXG52YXIgTUFYX1NBRkVfSU5UID0gOTAwNzE5OTI1NDc0MDk5MTtcbnZhciBNSU5fU0FGRV9JTlQgPSAtOTAwNzE5OTI1NDc0MDk5MTtcbi8qKlxuICAgIE1vc3QgdmFsaWRhdGlvbnMgYXJlIHNraXBwZWQgYW5kIHRoZSB2YWx1ZSByZXR1cm5lZCB1bmNoYW5nZWQgd2hlbiBhbiBlbXB0eSBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCBpcyBlbmNvdW50ZXJlZCAoZXhjZXB0IFwicmVxdWlyZWRcIikuIFxuXG4gICAgVmFsaWRhdGlvbnMgc3VwcG9ydCBhIHN0cmluZyBmb3JtYXQgZm9yIGRlYWxpbmcgd2l0aCBsYXJnZSBudW1iZXJzLlxuKi9cblxubW9kdWxlLmV4cG9ydHMgPSBfbXkgPSB7XG4gIGlzX2VtcHR5OiBpc19lbXB0eSA9IGZ1bmN0aW9uIGlzX2VtcHR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG4gIH0sXG4gIHJlcXVpcmVkOiBmdW5jdGlvbiByZXF1aXJlZCh2YWx1ZSkge1xuICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlwiO1xuXG4gICAgaWYgKGlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmFsdWUgcmVxdWlyZWQgXCIuY29uY2F0KGZpZWxkX25hbWUsIFwiIFwiKS5jb25jYXQodmFsdWUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIHJlcXVpcmVfbG9uZzogZnVuY3Rpb24gcmVxdWlyZV9sb25nKHZhbHVlKSB7XG4gICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICBpZiAoIUxvbmcuaXNMb25nKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9uZyB2YWx1ZSByZXF1aXJlZCBcIi5jb25jYXQoZmllbGRfbmFtZSwgXCIgXCIpLmNvbmNhdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgc3RyaW5nOiBmdW5jdGlvbiBzdHJpbmcodmFsdWUpIHtcbiAgICBpZiAoaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nIHJlcXVpcmVkOiBcIi5jb25jYXQodmFsdWUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIG51bWJlcjogZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKGlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm51bWJlciByZXF1aXJlZDogXCIuY29uY2F0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICB3aG9sZV9udW1iZXI6IGZ1bmN0aW9uIHdob2xlX251bWJlcih2YWx1ZSkge1xuICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlwiO1xuXG4gICAgaWYgKGlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICgvXFwuLy50ZXN0KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2hvbGUgbnVtYmVyIHJlcXVpcmVkIFwiLmNvbmNhdChmaWVsZF9uYW1lLCBcIiBcIikuY29uY2F0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICB1bnNpZ25lZDogZnVuY3Rpb24gdW5zaWduZWQodmFsdWUpIHtcbiAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJcIjtcblxuICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoLy0vLnRlc3QodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnNpZ25lZCByZXF1aXJlZCBcIi5jb25jYXQoZmllbGRfbmFtZSwgXCIgXCIpLmNvbmNhdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgaXNfZGlnaXRzOiBpc19kaWdpdHMgPSBmdW5jdGlvbiBpc19kaWdpdHModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWVyaWNcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIC9eWzAtOV0rJC8udGVzdCh2YWx1ZSk7XG4gIH0sXG4gIHRvX251bWJlcjogdG9fbnVtYmVyID0gZnVuY3Rpb24gdG9fbnVtYmVyKHZhbHVlKSB7XG4gICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICBpZiAoaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgX215Lm5vX292ZXJmbG93NTModmFsdWUsIGZpZWxkX25hbWUpO1xuXG4gICAgdmFyIGludF92YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KCk7XG5cbiAgICByZXR1cm4gaW50X3ZhbHVlO1xuICB9LFxuICB0b19sb25nOiBmdW5jdGlvbiB0b19sb25nKHZhbHVlKSB7XG4gICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICBpZiAoaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKExvbmcuaXNMb25nKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIF9teS5ub19vdmVyZmxvdzY0KHZhbHVlLCBmaWVsZF9uYW1lKTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhbHVlID0gXCJcIiArIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBMb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICB9LFxuICB0b19zdHJpbmc6IGZ1bmN0aW9uIHRvX3N0cmluZyh2YWx1ZSkge1xuICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlwiO1xuXG4gICAgaWYgKGlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBfbXkubm9fb3ZlcmZsb3c1Myh2YWx1ZSwgZmllbGRfbmFtZSk7XG5cbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKExvbmcuaXNMb25nKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgdGhyb3cgXCJ1bnN1cHBvcnRlZCB0eXBlIFwiLmNvbmNhdChmaWVsZF9uYW1lLCBcIjogKFwiKS5jb25jYXQoX3R5cGVvZih2YWx1ZSksIFwiKSBcIikuY29uY2F0KHZhbHVlKTtcbiAgfSxcbiAgcmVxdWlyZV90ZXN0OiBmdW5jdGlvbiByZXF1aXJlX3Rlc3QocmVnZXgsIHZhbHVlKSB7XG4gICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiXCI7XG5cbiAgICBpZiAoaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKCFyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5tYXRjaGVkIFwiLmNvbmNhdChyZWdleCwgXCIgXCIpLmNvbmNhdChmaWVsZF9uYW1lLCBcIiBcIikuY29uY2F0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICByZXF1aXJlX21hdGNoOiByZXF1aXJlX21hdGNoID0gZnVuY3Rpb24gcmVxdWlyZV9tYXRjaChyZWdleCwgdmFsdWUpIHtcbiAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJcIjtcblxuICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaChyZWdleCk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVubWF0Y2hlZCBcIi5jb25jYXQocmVnZXgsIFwiIFwiKS5jb25jYXQoZmllbGRfbmFtZSwgXCIgXCIpLmNvbmNhdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaDtcbiAgfSxcbiAgLy8gcmVxdWlyZV9vYmplY3RfaWQ6IHJlcXVpcmVfb2JqZWN0X2lkPWZ1bmN0aW9uKHZhbHVlLCBmaWVsZF9uYW1lKXtcbiAgLy8gICAgIHJldHVybiByZXF1aXJlX21hdGNoKFxuICAvLyAgICAgICAgIC9eKFswLTldKylcXC4oWzAtOV0rKVxcLihbMC05XSspJC8sXG4gIC8vICAgICAgICAgdmFsdWUsXG4gIC8vICAgICAgICAgZmllbGRfbmFtZVxuICAvLyAgICAgKTtcbiAgLy8gfSxcbiAgLy8gRG9lcyBub3Qgc3VwcG9ydCBvdmVyIDUzIGJpdHNcbiAgcmVxdWlyZV9yYW5nZTogZnVuY3Rpb24gcmVxdWlyZV9yYW5nZShtaW4sIG1heCwgdmFsdWUpIHtcbiAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCJcIjtcblxuICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgbnVtYmVyID0gdG9fbnVtYmVyKHZhbHVlKTtcblxuICAgIGlmICh2YWx1ZSA8IG1pbiB8fCB2YWx1ZSA+IG1heCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3V0IG9mIHJhbmdlIFwiLmNvbmNhdCh2YWx1ZSwgXCIgXCIpLmNvbmNhdChmaWVsZF9uYW1lLCBcIiBcIikuY29uY2F0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICByZXF1aXJlX29iamVjdF90eXBlOiByZXF1aXJlX29iamVjdF90eXBlID0gZnVuY3Rpb24gcmVxdWlyZV9vYmplY3RfdHlwZSgpIHtcbiAgICB2YXIgcmVzZXJ2ZWRfc3BhY2VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFwiXCI7XG5cbiAgICBpZiAoaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIG9iamVjdF90eXBlID0gY2hhaW5fdHlwZXMub2JqZWN0X3R5cGVbdHlwZV07XG5cbiAgICBpZiAoIW9iamVjdF90eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdCB0eXBlOiBcIi5jb25jYXQodHlwZSwgXCIsIFwiKS5jb25jYXQoZmllbGRfbmFtZSwgXCIsIFwiKS5jb25jYXQodmFsdWUpKTtcbiAgICB9XG5cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiXCIuY29uY2F0KHJlc2VydmVkX3NwYWNlcywgXCIuXCIpLmNvbmNhdChvYmplY3RfdHlwZSwgXCIuWzAtOV0rJFwiKSk7XG5cbiAgICBpZiAoIXJlLnRlc3QodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RpbmcgXCIuY29uY2F0KHR5cGUsIFwiIGluIGZvcm1hdCBcIikgKyBcIlwiLmNvbmNhdChyZXNlcnZlZF9zcGFjZXMsIFwiLlwiKS5jb25jYXQob2JqZWN0X3R5cGUsIFwiLlswLTldKyBcIikgKyBcImluc3RlYWQgb2YgXCIuY29uY2F0KHZhbHVlLCBcIiBcIikuY29uY2F0KGZpZWxkX25hbWUsIFwiIFwiKS5jb25jYXQodmFsdWUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGdldF9pbnN0YW5jZTogZ2V0X2luc3RhbmNlID0gZnVuY3Rpb24gZ2V0X2luc3RhbmNlKHJlc2VydmVfc3BhY2VzLCB0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXF1aXJlX29iamVjdF90eXBlKHJlc2VydmVfc3BhY2VzLCB0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgcmV0dXJuIHRvX251bWJlcih2YWx1ZS5zcGxpdCgnLicpWzJdKTtcbiAgfSxcbiAgcmVxdWlyZV9yZWxhdGl2ZV90eXBlOiByZXF1aXJlX3JlbGF0aXZlX3R5cGUgPSBmdW5jdGlvbiByZXF1aXJlX3JlbGF0aXZlX3R5cGUodHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpIHtcbiAgICByZXF1aXJlX29iamVjdF90eXBlKDAsIHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGdldF9yZWxhdGl2ZV9pbnN0YW5jZTogZ2V0X3JlbGF0aXZlX2luc3RhbmNlID0gZnVuY3Rpb24gZ2V0X3JlbGF0aXZlX2luc3RhbmNlKHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgaWYgKGlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJlcXVpcmVfb2JqZWN0X3R5cGUoMCwgdHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpO1xuICAgIHJldHVybiB0b19udW1iZXIodmFsdWUuc3BsaXQoJy4nKVsyXSk7XG4gIH0sXG4gIHJlcXVpcmVfcHJvdG9jb2xfdHlwZTogcmVxdWlyZV9wcm90b2NvbF90eXBlID0gZnVuY3Rpb24gcmVxdWlyZV9wcm90b2NvbF90eXBlKHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgcmVxdWlyZV9vYmplY3RfdHlwZSgxLCB0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBnZXRfcHJvdG9jb2xfaW5zdGFuY2U6IGdldF9wcm90b2NvbF9pbnN0YW5jZSA9IGZ1bmN0aW9uIGdldF9wcm90b2NvbF9pbnN0YW5jZSh0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXF1aXJlX29iamVjdF90eXBlKDEsIHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICByZXR1cm4gdG9fbnVtYmVyKHZhbHVlLnNwbGl0KCcuJylbMl0pO1xuICB9LFxuICBnZXRfcHJvdG9jb2xfdHlwZTogZ2V0X3Byb3RvY29sX3R5cGUgPSBmdW5jdGlvbiBnZXRfcHJvdG9jb2xfdHlwZSh2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXF1aXJlX29iamVjdF9pZCh2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgdmFyIHZhbHVlcyA9IHZhbHVlLnNwbGl0KCcuJyk7XG4gICAgcmV0dXJuIHRvX251bWJlcih2YWx1ZXNbMV0pO1xuICB9LFxuICBnZXRfcHJvdG9jb2xfdHlwZV9uYW1lOiBmdW5jdGlvbiBnZXRfcHJvdG9jb2xfdHlwZV9uYW1lKHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgaWYgKGlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciB0eXBlX2lkID0gZ2V0X3Byb3RvY29sX3R5cGUodmFsdWUsIGZpZWxkX25hbWUpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhjaGFpbl90eXBlcy5vYmplY3RfdHlwZSlbdHlwZV9pZF07XG4gIH0sXG4gIHJlcXVpcmVfaW1wbGVtZW50YXRpb25fdHlwZTogcmVxdWlyZV9pbXBsZW1lbnRhdGlvbl90eXBlID0gZnVuY3Rpb24gcmVxdWlyZV9pbXBsZW1lbnRhdGlvbl90eXBlKHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgcmVxdWlyZV9vYmplY3RfdHlwZSgyLCB0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBnZXRfaW1wbGVtZW50YXRpb25faW5zdGFuY2U6IGdldF9pbXBsZW1lbnRhdGlvbl9pbnN0YW5jZSA9IGZ1bmN0aW9uIGdldF9pbXBsZW1lbnRhdGlvbl9pbnN0YW5jZSh0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXF1aXJlX29iamVjdF90eXBlKDIsIHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICByZXR1cm4gdG9fbnVtYmVyKHZhbHVlLnNwbGl0KCcuJylbMl0pO1xuICB9LFxuICAvLyBzaWduZWQgLyB1bnNpZ25lZCBkZWNpbWFsXG4gIG5vX292ZXJmbG93NTM6IGZ1bmN0aW9uIG5vX292ZXJmbG93NTModmFsdWUpIHtcbiAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJcIjtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmICh2YWx1ZSA+IE1BWF9TQUZFX0lOVCB8fCB2YWx1ZSA8IE1JTl9TQUZFX0lOVCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdmVyZmxvdyBcIi5jb25jYXQoZmllbGRfbmFtZSwgXCIgXCIpLmNvbmNhdCh2YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFyIGludCA9IHBhcnNlSW50KHZhbHVlKTtcblxuICAgICAgaWYgKHZhbHVlID4gTUFYX1NBRkVfSU5UIHx8IHZhbHVlIDwgTUlOX1NBRkVfSU5UKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm92ZXJmbG93IFwiLmNvbmNhdChmaWVsZF9uYW1lLCBcIiBcIikuY29uY2F0KHZhbHVlKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoTG9uZy5pc0xvbmcodmFsdWUpKSB7XG4gICAgICAvLyB0eXBlb2YgdmFsdWUudG9JbnQoKSBpcyAnbnVtYmVyJ1xuICAgICAgX215Lm5vX292ZXJmbG93NTModmFsdWUudG9JbnQoKSwgZmllbGRfbmFtZSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aHJvdyBcInVuc3VwcG9ydGVkIHR5cGUgXCIuY29uY2F0KGZpZWxkX25hbWUsIFwiOiAoXCIpLmNvbmNhdChfdHlwZW9mKHZhbHVlKSwgXCIpIFwiKS5jb25jYXQodmFsdWUpO1xuICB9LFxuICAvLyBzaWduZWQgLyB1bnNpZ25lZCB3aG9sZSBudW1iZXJzIG9ubHlcbiAgbm9fb3ZlcmZsb3c2NDogZnVuY3Rpb24gbm9fb3ZlcmZsb3c2NCh2YWx1ZSkge1xuICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlwiO1xuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vTG9uZy5qcy9pc3N1ZXMvMjBcbiAgICBpZiAoTG9uZy5pc0xvbmcodmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBCaWdJbnRlZ2VyI2lzQmlnSW50ZWdlciBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL2JpZ2kvaXNzdWVzLzIwXG5cblxuICAgIGlmICh2YWx1ZS50ICE9PSB1bmRlZmluZWQgJiYgdmFsdWUucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBfbXkubm9fb3ZlcmZsb3c2NCh2YWx1ZS50b1N0cmluZygpLCBmaWVsZF9uYW1lKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIC8vIHJlbW92ZSBsZWFkaW5nIHplcm9zLCB3aWxsIGNhdXNlIGEgZmFsc2UgcG9zaXRpdmVcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXjArLywgJycpOyAvLyByZW1vdmUgdHJhaWxpbmcgemVyb3NcblxuICAgICAgd2hpbGUgKC8wJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgvXFwuJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIGRvdFxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCB2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgIHZhbHVlID0gXCIwXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBsb25nX3N0cmluZyA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSkudG9TdHJpbmcoKTtcblxuICAgICAgaWYgKGxvbmdfc3RyaW5nICE9PSB2YWx1ZS50cmltKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3ZlcmZsb3cgXCIuY29uY2F0KGZpZWxkX25hbWUsIFwiIFwiKS5jb25jYXQodmFsdWUpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmICh2YWx1ZSA+IE1BWF9TQUZFX0lOVCB8fCB2YWx1ZSA8IE1JTl9TQUZFX0lOVCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdmVyZmxvdyBcIi5jb25jYXQoZmllbGRfbmFtZSwgXCIgXCIpLmNvbmNhdCh2YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhyb3cgXCJ1bnN1cHBvcnRlZCB0eXBlIFwiLmNvbmNhdChmaWVsZF9uYW1lLCBcIjogKFwiKS5jb25jYXQoX3R5cGVvZih2YWx1ZSksIFwiKSBcIikuY29uY2F0KHZhbHVlKTtcbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZmxlY3QuY29uc3RydWN0LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0LmpzXCIpO1xuXG52YXIgX2VjYyA9IHJlcXVpcmUoXCIuL2VjY1wiKTtcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIHRvV2lmKGtleSkge1xuICByZXR1cm4ga2V5LnRvV2lmID8ga2V5LnRvV2lmKCkgOiBrZXk7XG59XG5cbjtcblxudmFyIFNlc3Npb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTZXNzaW9uKCkge1xuICAgIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdhdXRvcG9zdDInO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlc3Npb24pO1xuXG4gICAgLy8ga2V5IGlzIGNvbXBhdGlibGUgd2l0aCBHb2xvcyBVSVxuICAgIHRoaXMua2V5ID0ga2V5O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNlc3Npb24sIFt7XG4gICAga2V5OiBcImVuc3VyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbnN1cmUoKSB7XG4gICAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcignQnJvd3NlciBzaG91bGQgc3VwcG9ydCBsb2NhbFN0b3JhZ2UuJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2F2ZSh1c2VybmFtZSwgcG9zdGluZ0tleSwgbWVtb0tleSwgbG9naW5Pd25lclB1YktleSkge1xuICAgICAgdGhpcy5lbnN1cmUoKTtcbiAgICAgIG1lbW9LZXkgPSBtZW1vS2V5ID8gdG9XaWYobWVtb0tleSkgOiAnJztcbiAgICAgIGxvZ2luT3duZXJQdWJLZXkgPSBsb2dpbk93bmVyUHViS2V5IHx8ICcnO1xuICAgICAgdmFyIGRhdGEgPSBuZXcgQnVmZmVyKFwiXCIuY29uY2F0KHVzZXJuYW1lLCBcIlxcdFwiKS5jb25jYXQodG9XaWYocG9zdGluZ0tleSksIFwiXFx0XCIpLmNvbmNhdChtZW1vS2V5LCBcIlxcdFwiKS5jb25jYXQobG9naW5Pd25lclB1YktleSkpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMua2V5LCBkYXRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgdGhpcy5lbnN1cmUoKTtcbiAgICAgIHZhciBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5rZXkpO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihkYXRhLCAnaGV4JykudG9TdHJpbmcoKS5zcGxpdCgnXFx0Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuZW5zdXJlKCk7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLmtleSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNlc3Npb247XG59KCk7XG5cbnZhciBQYWdlU2Vzc2lvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1Nlc3Npb24pIHtcbiAgX2luaGVyaXRzKFBhZ2VTZXNzaW9uLCBfU2Vzc2lvbik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihQYWdlU2Vzc2lvbik7XG5cbiAgZnVuY3Rpb24gUGFnZVNlc3Npb24oKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ3Nlc3Npb25faWQnO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhZ2VTZXNzaW9uKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMua2V5ID0ga2V5O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQYWdlU2Vzc2lvbiwgW3tcbiAgICBrZXk6IFwiZW5zdXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZSgpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vzc2lvblN0b3JhZ2UgPT09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgc2hvdWxkIHN1cHBvcnQgc2Vzc2lvblN0b3JhZ2UuJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2F2ZShwYXNzd29yZCwgdXNlcm5hbWUpIHtcbiAgICAgIHZhciBhdXRoVHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ2FjdGl2ZSc7XG4gICAgICB0aGlzLmVuc3VyZSgpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBfZWNjLlByaXZhdGVLZXkuZnJvbVdpZihwYXNzd29yZCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHBhc3N3b3JkID0gX2VjYy5Qcml2YXRlS2V5LmZyb21TZWVkKHVzZXJuYW1lICsgYXV0aFR5cGUgKyBwYXNzd29yZCkudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSBEYXRlLm5vdygpLnRvU3RyaW5nKCkgKyAnXFx0JyArIG5ldyBCdWZmZXIocGFzc3dvcmQpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0odGhpcy5rZXksIGRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICB0aGlzLmVuc3VyZSgpO1xuICAgICAgdmFyIHNhdmVkID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmtleSk7XG5cbiAgICAgIGlmIChzYXZlZCkge1xuICAgICAgICB2YXIgYXJyID0gc2F2ZWQuc3BsaXQoJ1xcdCcpO1xuICAgICAgICBhcnJbMF0gPSBwYXJzZUludChhcnJbMF0pO1xuICAgICAgICBhcnJbMV0gPSBuZXcgQnVmZmVyKGFyclsxXSwgJ2hleCcpLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuZW5zdXJlKCk7XG4gICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMua2V5KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGFnZVNlc3Npb247XG59KFNlc3Npb24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2Vzc2lvbjogbmV3IFNlc3Npb24oKSxcbiAgU2Vzc2lvbjogU2Vzc2lvbixcbiAgcGFnZVNlc3Npb246IG5ldyBQYWdlU2Vzc2lvbigpLFxuICBQYWdlU2Vzc2lvbjogUGFnZVNlc3Npb25cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZS5qc1wiKTtcblxudmFyIF9hcGkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9hcGlcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbnZhciBkZWZhdWx0V2VpZ2h0ID0gMTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0ZWVtQnJvYWRjYXN0KSB7XG4gIHN0ZWVtQnJvYWRjYXN0LmFkZEFjY291bnRBdXRoID0gZnVuY3Rpb24gKGFjdGl2ZVdpZiwgdXNlcm5hbWUsIGF1dGhvcml6ZWRVc2VybmFtZSkge1xuICAgIHZhciByb2xlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBcInBvc3RpbmdcIjtcbiAgICB2YXIgY2IgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcblxuICAgIF9hcGkuZGVmYXVsdC5nZXRBY2NvdW50c0FzeW5jKFt1c2VybmFtZV0pLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDEpLFxuICAgICAgICAgIHVzZXJBY2NvdW50ID0gX3JlZjJbMF07XG5cbiAgICAgIHZhciB1cGRhdGVkQXV0aG9yaXR5ID0gdXNlckFjY291bnRbcm9sZV07XG4gICAgICB2YXIgYXV0aG9yaXplZEFjY291bnRzID0gdXBkYXRlZEF1dGhvcml0eS5hY2NvdW50X2F1dGhzLm1hcChmdW5jdGlvbiAoYXV0aCkge1xuICAgICAgICByZXR1cm4gYXV0aFswXTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGhhc0F1dGhvcml0eSA9IGF1dGhvcml6ZWRBY2NvdW50cy5pbmRleE9mKGF1dGhvcml6ZWRVc2VybmFtZSkgIT09IC0xO1xuXG4gICAgICBpZiAoaGFzQXV0aG9yaXR5KSB7XG4gICAgICAgIC8vIHVzZXIgZG9lcyBhbHJlYWR5IGV4aXN0IGluIGF1dGhvcml6ZWQgbGlzdFxuICAgICAgICByZXR1cm4gY2IobnVsbCwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZWRBdXRob3JpdHkuYWNjb3VudF9hdXRocy5wdXNoKFthdXRob3JpemVkVXNlcm5hbWUsIGRlZmF1bHRXZWlnaHRdKTtcbiAgICAgIHZhciBvd25lciA9IHJvbGUgPT09IFwib3duZXJcIiA/IHVwZGF0ZWRBdXRob3JpdHkgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWN0aXZlID0gcm9sZSA9PT0gXCJhY3RpdmVcIiA/IHVwZGF0ZWRBdXRob3JpdHkgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgcG9zdGluZyA9IHJvbGUgPT09IFwicG9zdGluZ1wiID8gdXBkYXRlZEF1dGhvcml0eSA6IHVuZGVmaW5lZDtcbiAgICAgIC8qKiBBZGQgYXV0aG9yaXR5IG9uIHVzZXIgYWNjb3VudCAqL1xuXG4gICAgICBzdGVlbUJyb2FkY2FzdC5hY2NvdW50VXBkYXRlKGFjdGl2ZVdpZiwgdXNlckFjY291bnQubmFtZSwgb3duZXIsIGFjdGl2ZSwgcG9zdGluZywgdXNlckFjY291bnQubWVtb19rZXksIHVzZXJBY2NvdW50Lmpzb25fbWV0YWRhdGEsIGNiKTtcbiAgICB9KTtcbiAgfTtcblxuICBzdGVlbUJyb2FkY2FzdC5yZW1vdmVBY2NvdW50QXV0aCA9IGZ1bmN0aW9uIChhY3RpdmVXaWYsIHVzZXJuYW1lLCBhdXRob3JpemVkVXNlcm5hbWUpIHtcbiAgICB2YXIgcm9sZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCJwb3N0aW5nXCI7XG4gICAgdmFyIGNiID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG5cbiAgICBfYXBpLmRlZmF1bHQuZ2V0QWNjb3VudHNBc3luYyhbdXNlcm5hbWVdKS50aGVuKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDEpLFxuICAgICAgICAgIHVzZXJBY2NvdW50ID0gX3JlZjRbMF07XG5cbiAgICAgIHZhciB1cGRhdGVkQXV0aG9yaXR5ID0gdXNlckFjY291bnRbcm9sZV07XG4gICAgICB2YXIgdG90YWxBdXRob3JpemVkVXNlciA9IHVwZGF0ZWRBdXRob3JpdHkuYWNjb3VudF9hdXRocy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxBdXRob3JpemVkVXNlcjsgaSsrKSB7XG4gICAgICAgIHZhciB1c2VyID0gdXBkYXRlZEF1dGhvcml0eS5hY2NvdW50X2F1dGhzW2ldO1xuXG4gICAgICAgIGlmICh1c2VyWzBdID09PSBhdXRob3JpemVkVXNlcm5hbWUpIHtcbiAgICAgICAgICB1cGRhdGVkQXV0aG9yaXR5LmFjY291bnRfYXV0aHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IC8vIHVzZXIgZG9lcyBub3QgZXhpc3QgaW4gYXV0aG9yaXplZCBsaXN0XG5cblxuICAgICAgaWYgKHRvdGFsQXV0aG9yaXplZFVzZXIgPT09IHVwZGF0ZWRBdXRob3JpdHkuYWNjb3VudF9hdXRocy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3duZXIgPSByb2xlID09PSBcIm93bmVyXCIgPyB1cGRhdGVkQXV0aG9yaXR5IDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGFjdGl2ZSA9IHJvbGUgPT09IFwiYWN0aXZlXCIgPyB1cGRhdGVkQXV0aG9yaXR5IDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHBvc3RpbmcgPSByb2xlID09PSBcInBvc3RpbmdcIiA/IHVwZGF0ZWRBdXRob3JpdHkgOiB1bmRlZmluZWQ7XG4gICAgICBzdGVlbUJyb2FkY2FzdC5hY2NvdW50VXBkYXRlKGFjdGl2ZVdpZiwgdXNlckFjY291bnQubmFtZSwgb3duZXIsIGFjdGl2ZSwgcG9zdGluZywgdXNlckFjY291bnQubWVtb19rZXksIHVzZXJBY2NvdW50Lmpzb25fbWV0YWRhdGEsIGNiKTtcbiAgICB9KTtcbiAgfTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zZXQuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3RhcnRzLXdpdGguanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2guanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnbi5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UuanNcIik7XG5cbnZhciBfZGVidWcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5cbnZhciBfbm9vcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9ub29wXCIpKTtcblxudmFyIF9oZWxwZXJzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9oZWxwZXJzXCIpKTtcblxudmFyIF9mb3JtYXR0ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9mb3JtYXR0ZXJcIikpO1xuXG52YXIgX29wZXJhdGlvbnMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL29wZXJhdGlvbnNcIikpO1xuXG52YXIgX2FwaSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2FwaVwiKSk7XG5cbnZhciBfYXV0aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2F1dGhcIikpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuXG52YXIgX3Byb21pc2lmeSA9IHJlcXVpcmUoXCIuLi9wcm9taXNpZnlcIik7XG5cbnZhciBfbWlkZGxld2FyZXMgPSByZXF1aXJlKFwiLi4vbWlkZGxld2FyZXNcIik7XG5cbnZhciBfY29uZmlnID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vY29uZmlnXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuXG52YXIgZGVidWcgPSAoMCwgX2RlYnVnLmRlZmF1bHQpKCdnb2xvczpicm9hZGNhc3QnKTtcbnZhciBmb3JtYXR0ZXIgPSAoMCwgX2Zvcm1hdHRlci5kZWZhdWx0KShfYXBpLmRlZmF1bHQpO1xudmFyIHN0ZWVtQnJvYWRjYXN0ID0ge307IC8vIEJhc2UgdHJhbnNhY3Rpb24gbG9naWMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBTaWduIGFuZCBicm9hZGNhc3QgdHJhbnNhY3Rpb25zIG9uIHRoZSBzdGVlbSBuZXR3b3JrXG4gKi9cblxuc3RlZW1Ccm9hZGNhc3Quc2VuZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBfc3RlZW1Ccm9hZGNhc3Qkc2VuZCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIodHgsIHByaXZLZXlzLCBjYWxsYmFjaykge1xuICAgIHZhciBrZXlNZXRhLCByb2xlLCBzdHIsIGtleXMsIGJyb2FkY2FzdCwgcmVzLCB0cmFuc2FjdGlvbiwgc2lnbmVkVHJhbnNhY3Rpb247XG4gICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGtleU1ldGEgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgICAgIGlmICghcHJpdktleXMpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IHJlZ2VuZXJhdG9yUnVudGltZS5rZXlzKHByaXZLZXlzKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGlmICgoX2NvbnRleHQyLnQxID0gX2NvbnRleHQyLnQwKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJvbGUgPSBfY29udGV4dDIudDEudmFsdWU7XG5cbiAgICAgICAgICAgIGlmICghcHJpdktleXNbcm9sZV0pIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0ciA9IHByaXZLZXlzW3JvbGVdLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGlmIChzdHIuc3RhcnRzV2l0aCgnKCcpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBrZXlNZXRhID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwiYnJlYWtcIiwgMTYpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIGtleXMgPSBzdHIuc2xpY2UoMSwgLTEpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goa2V5TWV0YS5hZGQsIGtleU1ldGEpO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIGJyb2FkY2FzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHNpZ25lZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9jb25maWcuZGVmYXVsdC5nZXQoJ2Jyb2FkY2FzdF90cmFuc2FjdGlvbl93aXRoX2NhbGxiYWNrJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfYXBpLmRlZmF1bHQuYnJvYWRjYXN0VHJhbnNhY3Rpb25XaXRoQ2FsbGJhY2tBc3luYyhmdW5jdGlvbiAoKSB7fSwgc2lnbmVkVHJhbnNhY3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9hcGkuZGVmYXVsdC5icm9hZGNhc3RUcmFuc2FjdGlvbkFzeW5jKHNpZ25lZFRyYW5zYWN0aW9uKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IF9jb250ZXh0LnQwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBPYmplY3QuYXNzaWduKHJlcywgc2lnbmVkVHJhbnNhY3Rpb24pKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGJyb2FkY2FzdChfeDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE3O1xuICAgICAgICAgICAgcmVzID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKCFrZXlNZXRhKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0eC5fbWV0YSA9IHtcbiAgICAgICAgICAgICAgX2tleXM6IEFycmF5LmZyb20oa2V5TWV0YSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWJ1ZygnQnJvYWRjYXN0aW5nIHRyYW5zYWN0aW9uIHdpdGhvdXQgc2lnbmluZyAodHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uLm9wZXJhdGlvbnMsIHRyYW5zYWN0aW9uLl9tZXRhKScsIHR4LCB0eC5vcGVyYXRpb25zLCB0eC5fbWV0YSk7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI0O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfbWlkZGxld2FyZXMubXcpKCkuYnJvYWRjYXN0KHtcbiAgICAgICAgICAgICAgdHg6IHR4LFxuICAgICAgICAgICAgICBwcml2S2V5czogcHJpdktleXMsXG4gICAgICAgICAgICAgIG9yaWc6IGJyb2FkY2FzdFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgcmVzID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM2O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyOTtcbiAgICAgICAgICAgIHJldHVybiBzdGVlbUJyb2FkY2FzdC5fcHJlcGFyZVRyYW5zYWN0aW9uKHR4KTtcblxuICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICB0cmFuc2FjdGlvbiA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgZGVidWcoJ1NpZ25pbmcgdHJhbnNhY3Rpb24gKHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbi5vcGVyYXRpb25zKScsIHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbi5vcGVyYXRpb25zKTtcbiAgICAgICAgICAgIHNpZ25lZFRyYW5zYWN0aW9uID0gX2F1dGguZGVmYXVsdC5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHByaXZLZXlzKTtcbiAgICAgICAgICAgIGRlYnVnKCdCcm9hZGNhc3RpbmcgdHJhbnNhY3Rpb24gKHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbi5vcGVyYXRpb25zKScsIHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbi5vcGVyYXRpb25zKTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMzU7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9taWRkbGV3YXJlcy5tdykoKS5icm9hZGNhc3Qoe1xuICAgICAgICAgICAgICB0eDogc2lnbmVkVHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgIHByaXZLZXlzOiBwcml2S2V5cyxcbiAgICAgICAgICAgICAgb3JpZzogYnJvYWRjYXN0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICByZXMgPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgIGNhc2UgMzY6XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAzOTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MiA9IF9jb250ZXh0MltcImNhdGNoXCJdKDE3KTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soX2NvbnRleHQyLnQyLCBudWxsKTtcblxuICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgbnVsbCwgW1sxNywgMzldXSk7XG4gIH0pKTtcblxuICBmdW5jdGlvbiBzdGVlbUJyb2FkY2FzdCRzZW5kKF94LCBfeDIsIF94Mykge1xuICAgIHJldHVybiBfc3RlZW1Ccm9hZGNhc3Qkc2VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIHN0ZWVtQnJvYWRjYXN0JHNlbmQ7XG59KCk7XG5cbnN0ZWVtQnJvYWRjYXN0Ll9wcmVwYXJlVHJhbnNhY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICB2YXIgX3N0ZWVtQnJvYWRjYXN0JF9wcmVwYXJlVHJhbnNhY3Rpb24gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKHR4KSB7XG4gICAgdmFyIHByb3BzLCBjaGFpbkRhdGUsIHJlZkJsb2NrTnVtLCBibG9jaywgaGVhZEJsb2NrSWQ7XG4gICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiBfYXBpLmRlZmF1bHQuZ2V0RHluYW1pY0dsb2JhbFByb3BlcnRpZXNBc3luYygpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcHJvcHMgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIC8vIFNldCBkZWZhdWx0cyBvbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIGNoYWluRGF0ZSA9IG5ldyBEYXRlKHByb3BzLnRpbWUgKyAnWicpO1xuICAgICAgICAgICAgcmVmQmxvY2tOdW0gPSBwcm9wcy5oZWFkX2Jsb2NrX251bWJlciAtIDMgJiAweEZGRkY7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gX2FwaS5kZWZhdWx0LmdldEJsb2NrQXN5bmMocHJvcHMuaGVhZF9ibG9ja19udW1iZXIgLSAyKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGJsb2NrID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICBoZWFkQmxvY2tJZCA9IGJsb2NrLnByZXZpb3VzO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgIHJlZl9ibG9ja19udW06IHJlZkJsb2NrTnVtLFxuICAgICAgICAgICAgICByZWZfYmxvY2tfcHJlZml4OiBuZXcgQnVmZmVyKGhlYWRCbG9ja0lkLCAnaGV4JykucmVhZFVJbnQzMkxFKDQpLFxuICAgICAgICAgICAgICBleHBpcmF0aW9uOiBuZXcgRGF0ZShjaGFpbkRhdGUuZ2V0VGltZSgpICsgNjAgKiAxMDAwKVxuICAgICAgICAgICAgfSwgdHgpKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMyk7XG4gIH0pKTtcblxuICBmdW5jdGlvbiBzdGVlbUJyb2FkY2FzdCRfcHJlcGFyZVRyYW5zYWN0aW9uKF94NSkge1xuICAgIHJldHVybiBfc3RlZW1Ccm9hZGNhc3QkX3ByZXBhcmVUcmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIHN0ZWVtQnJvYWRjYXN0JF9wcmVwYXJlVHJhbnNhY3Rpb247XG59KCk7XG5cbnN0ZWVtQnJvYWRjYXN0Ll9vcGVyYXRpb25zID0ge307IC8vIEdlbmVyYXRlZCB3cmFwcGVyIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEdlbmVyYXRlIG9wZXJhdGlvbnMgZnJvbSBvcGVyYXRpb25zLmpzXG5cbl9vcGVyYXRpb25zLmRlZmF1bHQuZm9yRWFjaChmdW5jdGlvbiAob3BlcmF0aW9uKSB7XG4gIHN0ZWVtQnJvYWRjYXN0Ll9vcGVyYXRpb25zW29wZXJhdGlvbi5vcGVyYXRpb25dID0gb3BlcmF0aW9uO1xuICB2YXIgb3BlcmF0aW9uTmFtZSA9ICgwLCBfdXRpbHMuY2FtZWxDYXNlKShvcGVyYXRpb24ub3BlcmF0aW9uKTtcbiAgdmFyIG9wZXJhdGlvblBhcmFtcyA9IG9wZXJhdGlvbi5wYXJhbXMgfHwgW107XG4gIHZhciB1c2VDb21tZW50UGVybWxpbmsgPSBvcGVyYXRpb25QYXJhbXMuaW5kZXhPZigncGFyZW50X3Blcm1saW5rJykgIT09IC0xICYmIG9wZXJhdGlvblBhcmFtcy5pbmRleE9mKCdwYXJlbnRfcGVybWxpbmsnKSAhPT0gLTE7XG5cbiAgc3RlZW1Ccm9hZGNhc3RbXCJcIi5jb25jYXQob3BlcmF0aW9uTmFtZSwgXCJXaXRoXCIpXSA9IGZ1bmN0aW9uIHN0ZWVtQnJvYWRjYXN0JHNwZWNpYWxpemVkU2VuZFdpdGgod2lmLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGRlYnVnKFwiU2VuZGluZyBvcGVyYXRpb24gXFxcIlwiLmNvbmNhdChvcGVyYXRpb25OYW1lLCBcIlxcXCIgd2l0aFwiKSwge1xuICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgIH0pO1xuICAgIHZhciBrZXlzID0ge307XG5cbiAgICBpZiAob3BlcmF0aW9uLnJvbGVzICYmIG9wZXJhdGlvbi5yb2xlcy5sZW5ndGgpIHtcbiAgICAgIGtleXNbb3BlcmF0aW9uLnJvbGVzWzBdXSA9IHdpZjsgLy8gVE9ETyAtIEF1dG9tYXRpY2FsbHkgcGljayBhIHJvbGU/IFNlbmQgYWxsP1xuICAgIH1cblxuICAgIHJldHVybiBzdGVlbUJyb2FkY2FzdC5zZW5kKHtcbiAgICAgIGV4dGVuc2lvbnM6IFtdLFxuICAgICAgb3BlcmF0aW9uczogW1tvcGVyYXRpb24ub3BlcmF0aW9uLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCBvcHRpb25zLmpzb25fbWV0YWRhdGEgIT0gbnVsbCA/IHtcbiAgICAgICAganNvbl9tZXRhZGF0YTogdG9TdHJpbmcob3B0aW9ucy5qc29uX21ldGFkYXRhKVxuICAgICAgfSA6IHt9LCB1c2VDb21tZW50UGVybWxpbmsgJiYgb3B0aW9ucy5wZXJtbGluayA9PSBudWxsID8ge1xuICAgICAgICBwZXJtbGluazogZm9ybWF0dGVyLmNvbW1lbnRQZXJtbGluayhvcHRpb25zLnBhcmVudF9hdXRob3IsIG9wdGlvbnMucGFyZW50X3Blcm1saW5rKVxuICAgICAgfSA6IHt9KV1dXG4gICAgfSwga2V5cywgY2FsbGJhY2spO1xuICB9O1xuXG4gIHN0ZWVtQnJvYWRjYXN0W29wZXJhdGlvbk5hbWVdID0gZnVuY3Rpb24gc3RlZW1Ccm9hZGNhc3Qkc3BlY2lhbGl6ZWRTZW5kKHdpZikge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGRlYnVnKFwiUGFyc2luZyBvcGVyYXRpb24gXFxcIlwiLmNvbmNhdChvcGVyYXRpb25OYW1lLCBcIlxcXCIgd2l0aFwiKSwge1xuICAgICAgYXJnczogYXJnc1xuICAgIH0pO1xuICAgIHZhciBvcHRpb25zID0gb3BlcmF0aW9uUGFyYW1zLnJlZHVjZShmdW5jdGlvbiAobWVtbywgcGFyYW0sIGkpIHtcbiAgICAgIG1lbW9bcGFyYW1dID0gYXJnc1tpXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LCB7fSk7XG4gICAgdmFyIGNhbGxiYWNrID0gYXJnc1tvcGVyYXRpb25QYXJhbXMubGVuZ3RoXTtcbiAgICByZXR1cm4gc3RlZW1Ccm9hZGNhc3RbXCJcIi5jb25jYXQob3BlcmF0aW9uTmFtZSwgXCJXaXRoXCIpXSh3aWYsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfTtcbn0pO1xuXG52YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvYmopIHtcbiAgcmV0dXJuIF90eXBlb2Yob2JqKSA9PT0gJ29iamVjdCcgPyBKU09OLnN0cmluZ2lmeShvYmopIDogb2JqO1xufTtcblxuKDAsIF9oZWxwZXJzLmRlZmF1bHQpKHN0ZWVtQnJvYWRjYXN0KTtcbigwLCBfcHJvbWlzaWZ5LnByb21pc2lmeUFsbCkoc3RlZW1Ccm9hZGNhc3QpO1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3RlZW1Ccm9hZGNhc3Q7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gW3tcbiAgXCJyb2xlc1wiOiBbXCJwb3N0aW5nXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcInZvdGVcIixcbiAgXCJwYXJhbXNcIjogW1widm90ZXJcIiwgXCJhdXRob3JcIiwgXCJwZXJtbGlua1wiLCBcIndlaWdodFwiXVxufSwge1xuICBcInJvbGVzXCI6IFtcInBvc3RpbmdcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwiY29tbWVudFwiLFxuICBcInBhcmFtc1wiOiBbXCJwYXJlbnRfYXV0aG9yXCIsIFwicGFyZW50X3Blcm1saW5rXCIsIFwiYXV0aG9yXCIsIFwicGVybWxpbmtcIiwgXCJ0aXRsZVwiLCBcImJvZHlcIiwgXCJqc29uX21ldGFkYXRhXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wiYWN0aXZlXCIsIFwib3duZXJcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwidHJhbnNmZXJcIixcbiAgXCJwYXJhbXNcIjogW1wiZnJvbVwiLCBcInRvXCIsIFwiYW1vdW50XCIsIFwibWVtb1wiXVxufSwge1xuICBcInJvbGVzXCI6IFtcImFjdGl2ZVwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJ0cmFuc2Zlcl90b192ZXN0aW5nXCIsXG4gIFwicGFyYW1zXCI6IFtcImZyb21cIiwgXCJ0b1wiLCBcImFtb3VudFwiXVxufSwge1xuICBcInJvbGVzXCI6IFtcImFjdGl2ZVwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJ3aXRoZHJhd192ZXN0aW5nXCIsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnRcIiwgXCJ2ZXN0aW5nX3NoYXJlc1wiXVxufSwge1xuICBcInJvbGVzXCI6IFtcImFjdGl2ZVwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJsaW1pdF9vcmRlcl9jcmVhdGVcIixcbiAgXCJwYXJhbXNcIjogW1wib3duZXJcIiwgXCJvcmRlcmlkXCIsIFwiYW1vdW50X3RvX3NlbGxcIiwgXCJtaW5fdG9fcmVjZWl2ZVwiLCBcImZpbGxfb3Jfa2lsbFwiLCBcImV4cGlyYXRpb25cIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJhY3RpdmVcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwibGltaXRfb3JkZXJfY2FuY2VsXCIsXG4gIFwicGFyYW1zXCI6IFtcIm93bmVyXCIsIFwib3JkZXJpZFwiXVxufSwge1xuICBcInJvbGVzXCI6IFtcImFjdGl2ZVwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJwcmljZVwiLFxuICBcInBhcmFtc1wiOiBbXCJiYXNlXCIsIFwicXVvdGVcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJhY3RpdmVcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwiZmVlZF9wdWJsaXNoXCIsXG4gIFwicGFyYW1zXCI6IFtcInB1Ymxpc2hlclwiLCBcImV4Y2hhbmdlX3JhdGVcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJhY3RpdmVcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwiY29udmVydFwiLFxuICBcInBhcmFtc1wiOiBbXCJvd25lclwiLCBcInJlcXVlc3RpZFwiLCBcImFtb3VudFwiXVxufSwge1xuICBcInJvbGVzXCI6IFtcImFjdGl2ZVwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJhY2NvdW50X2NyZWF0ZVwiLFxuICBcInBhcmFtc1wiOiBbXCJmZWVcIiwgXCJjcmVhdG9yXCIsIFwibmV3X2FjY291bnRfbmFtZVwiLCBcIm93bmVyXCIsIFwiYWN0aXZlXCIsIFwicG9zdGluZ1wiLCBcIm1lbW9fa2V5XCIsIFwianNvbl9tZXRhZGF0YVwiXVxufSwge1xuICBcInJvbGVzXCI6IFtcIm93bmVyXCIsIFwiYWN0aXZlXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcImFjY291bnRfdXBkYXRlXCIsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnRcIiwgXCJvd25lclwiLCBcImFjdGl2ZVwiLCBcInBvc3RpbmdcIiwgXCJtZW1vX2tleVwiLCBcImpzb25fbWV0YWRhdGFcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJhY3RpdmVcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwid2l0bmVzc191cGRhdGVcIixcbiAgXCJwYXJhbXNcIjogW1wib3duZXJcIiwgXCJ1cmxcIiwgXCJibG9ja19zaWduaW5nX2tleVwiLCBcInByb3BzXCIsIFwiZmVlXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wicG9zdGluZ1wiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJhY2NvdW50X3dpdG5lc3Nfdm90ZVwiLFxuICBcInBhcmFtc1wiOiBbXCJhY2NvdW50XCIsIFwid2l0bmVzc1wiLCBcImFwcHJvdmVcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJwb3N0aW5nXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcImFjY291bnRfd2l0bmVzc19wcm94eVwiLFxuICBcInBhcmFtc1wiOiBbXCJhY2NvdW50XCIsIFwicHJveHlcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJhY3RpdmVcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwicG93XCIsXG4gIFwicGFyYW1zXCI6IFtcIndvcmtlclwiLCBcImlucHV0XCIsIFwic2lnbmF0dXJlXCIsIFwid29ya1wiXVxufSwge1xuICBcInJvbGVzXCI6IFtcImFjdGl2ZVwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJjdXN0b21cIixcbiAgXCJwYXJhbXNcIjogW1wicmVxdWlyZWRfYXV0aHNcIiwgXCJpZFwiLCBcImRhdGFcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJwb3N0aW5nXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcImRlbGV0ZV9jb21tZW50XCIsXG4gIFwicGFyYW1zXCI6IFtcImF1dGhvclwiLCBcInBlcm1saW5rXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wicG9zdGluZ1wiLCBcImFjdGl2ZVwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJjdXN0b21fanNvblwiLFxuICBcInBhcmFtc1wiOiBbXCJyZXF1aXJlZF9hdXRoc1wiLCBcInJlcXVpcmVkX3Bvc3RpbmdfYXV0aHNcIiwgXCJpZFwiLCBcImpzb25cIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJwb3N0aW5nXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcImNvbW1lbnRfb3B0aW9uc1wiLFxuICBcInBhcmFtc1wiOiBbXCJhdXRob3JcIiwgXCJwZXJtbGlua1wiLCBcIm1heF9hY2NlcHRlZF9wYXlvdXRcIiwgXCJwZXJjZW50X3N0ZWVtX2RvbGxhcnNcIiwgXCJhbGxvd192b3Rlc1wiLCBcImFsbG93X2N1cmF0aW9uX3Jld2FyZHNcIiwgXCJleHRlbnNpb25zXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wiYWN0aXZlXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcInNldF93aXRoZHJhd192ZXN0aW5nX3JvdXRlXCIsXG4gIFwicGFyYW1zXCI6IFtcImZyb21fYWNjb3VudFwiLCBcInRvX2FjY291bnRcIiwgXCJwZXJjZW50XCIsIFwiYXV0b192ZXN0XCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wiYWN0aXZlXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcImxpbWl0X29yZGVyX2NyZWF0ZTJcIixcbiAgXCJwYXJhbXNcIjogW1wib3duZXJcIiwgXCJvcmRlcmlkXCIsIFwiYW1vdW50X3RvX3NlbGxcIiwgXCJleGNoYW5nZV9yYXRlXCIsIFwiZmlsbF9vcl9raWxsXCIsIFwiZXhwaXJhdGlvblwiXVxufSwge1xuICBcInJvbGVzXCI6IFtcInBvc3RpbmdcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwiY2hhbGxlbmdlX2F1dGhvcml0eVwiLFxuICBcInBhcmFtc1wiOiBbXCJjaGFsbGVuZ2VyXCIsIFwiY2hhbGxlbmdlZFwiLCBcInJlcXVpcmVfb3duZXJcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJhY3RpdmVcIiwgXCJvd25lclwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJwcm92ZV9hdXRob3JpdHlcIixcbiAgXCJwYXJhbXNcIjogW1wiY2hhbGxlbmdlZFwiLCBcInJlcXVpcmVfb3duZXJcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJhY3RpdmVcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwicmVxdWVzdF9hY2NvdW50X3JlY292ZXJ5XCIsXG4gIFwicGFyYW1zXCI6IFtcInJlY292ZXJ5X2FjY291bnRcIiwgXCJhY2NvdW50X3RvX3JlY292ZXJcIiwgXCJuZXdfb3duZXJfYXV0aG9yaXR5XCIsIFwiZXh0ZW5zaW9uc1wiXVxufSwge1xuICBcInJvbGVzXCI6IFtcIm93bmVyXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcInJlY292ZXJfYWNjb3VudFwiLFxuICBcInBhcmFtc1wiOiBbXCJhY2NvdW50X3RvX3JlY292ZXJcIiwgXCJuZXdfb3duZXJfYXV0aG9yaXR5XCIsIFwicmVjZW50X293bmVyX2F1dGhvcml0eVwiLCBcImV4dGVuc2lvbnNcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJvd25lclwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJjaGFuZ2VfcmVjb3ZlcnlfYWNjb3VudFwiLFxuICBcInBhcmFtc1wiOiBbXCJhY2NvdW50X3RvX3JlY292ZXJcIiwgXCJuZXdfcmVjb3ZlcnlfYWNjb3VudFwiLCBcImV4dGVuc2lvbnNcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJhY3RpdmVcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwiZXNjcm93X3RyYW5zZmVyXCIsXG4gIFwicGFyYW1zXCI6IFtcImZyb21cIiwgXCJ0b1wiLCBcImFnZW50XCIsIFwiZXNjcm93X2lkXCIsIFwic2JkX2Ftb3VudFwiLCBcInN0ZWVtX2Ftb3VudFwiLCBcImZlZVwiLCBcInJhdGlmaWNhdGlvbl9kZWFkbGluZVwiLCBcImVzY3Jvd19leHBpcmF0aW9uXCIsIFwianNvbl9tZXRhXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wiYWN0aXZlXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcImVzY3Jvd19kaXNwdXRlXCIsXG4gIFwicGFyYW1zXCI6IFtcImZyb21cIiwgXCJ0b1wiLCBcImFnZW50XCIsIFwid2hvXCIsIFwiZXNjcm93X2lkXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wiYWN0aXZlXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcImVzY3Jvd19yZWxlYXNlXCIsXG4gIFwicGFyYW1zXCI6IFtcImZyb21cIiwgXCJ0b1wiLCBcImFnZW50XCIsIFwid2hvXCIsIFwicmVjZWl2ZXJcIiwgXCJlc2Nyb3dfaWRcIiwgXCJzYmRfYW1vdW50XCIsIFwic3RlZW1fYW1vdW50XCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wiYWN0aXZlXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcInBvdzJcIixcbiAgXCJwYXJhbXNcIjogW1wiaW5wdXRcIiwgXCJwb3dfc3VtbWFyeVwiXVxufSwge1xuICBcInJvbGVzXCI6IFtcImFjdGl2ZVwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJlc2Nyb3dfYXBwcm92ZVwiLFxuICBcInBhcmFtc1wiOiBbXCJmcm9tXCIsIFwidG9cIiwgXCJhZ2VudFwiLCBcIndob1wiLCBcImVzY3Jvd19pZFwiLCBcImFwcHJvdmVcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJhY3RpdmVcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwidHJhbnNmZXJfdG9fc2F2aW5nc1wiLFxuICBcInBhcmFtc1wiOiBbXCJmcm9tXCIsIFwidG9cIiwgXCJhbW91bnRcIiwgXCJtZW1vXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wiYWN0aXZlXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcInRyYW5zZmVyX2Zyb21fc2F2aW5nc1wiLFxuICBcInBhcmFtc1wiOiBbXCJmcm9tXCIsIFwicmVxdWVzdF9pZFwiLCBcInRvXCIsIFwiYW1vdW50XCIsIFwibWVtb1wiXVxufSwge1xuICBcInJvbGVzXCI6IFtcImFjdGl2ZVwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJjYW5jZWxfdHJhbnNmZXJfZnJvbV9zYXZpbmdzXCIsXG4gIFwicGFyYW1zXCI6IFtcImZyb21cIiwgXCJyZXF1ZXN0X2lkXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wicG9zdGluZ1wiLCBcImFjdGl2ZVwiLCBcIm93bmVyXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcImN1c3RvbV9iaW5hcnlcIixcbiAgXCJwYXJhbXNcIjogW1wicmVxdWlyZWRfb3duZXJfYXV0aHNcIiwgXCJyZXF1aXJlZF9hY3RpdmVfYXV0aHNcIiwgXCJyZXF1aXJlZF9wb3N0aW5nX2F1dGhzXCIsIFwicmVxdWlyZWRfYXV0aHNcIiwgXCJpZFwiLCBcImRhdGFcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJvd25lclwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJkZWNsaW5lX3ZvdGluZ19yaWdodHNcIixcbiAgXCJwYXJhbXNcIjogW1wiYWNjb3VudFwiLCBcImRlY2xpbmVcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJhY3RpdmVcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwicmVzZXRfYWNjb3VudFwiLFxuICBcInBhcmFtc1wiOiBbXCJyZXNldF9hY2NvdW50XCIsIFwiYWNjb3VudF90b19yZXNldFwiLCBcIm5ld19vd25lcl9hdXRob3JpdHlcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJvd25lclwiLCBcInBvc3RpbmdcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwic2V0X3Jlc2V0X2FjY291bnRcIixcbiAgXCJwYXJhbXNcIjogW1wiYWNjb3VudFwiLCBcImN1cnJlbnRfcmVzZXRfYWNjb3VudFwiLCBcInJlc2V0X2FjY291bnRcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJwb3N0aW5nXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcImNsYWltX3Jld2FyZF9iYWxhbmNlXCIsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnRcIiwgXCJyZXdhcmRfc3RlZW1cIiwgXCJyZXdhcmRfc2JkXCIsIFwicmV3YXJkX3Zlc3RzXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wiYWN0aXZlXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcImZpbGxfY29udmVydF9yZXF1ZXN0XCIsXG4gIFwicGFyYW1zXCI6IFtcIm93bmVyXCIsIFwicmVxdWVzdGlkXCIsIFwiYW1vdW50X2luXCIsIFwiYW1vdW50X291dFwiXVxufSwge1xuICBcInJvbGVzXCI6IFtcInBvc3RpbmdcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwiY29tbWVudF9yZXdhcmRcIixcbiAgXCJwYXJhbXNcIjogW1wiYXV0aG9yXCIsIFwicGVybWxpbmtcIiwgXCJwYXlvdXRcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJhY3RpdmVcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwibGlxdWlkaXR5X3Jld2FyZFwiLFxuICBcInBhcmFtc1wiOiBbXCJvd25lclwiLCBcInBheW91dFwiXVxufSwge1xuICBcInJvbGVzXCI6IFtcImFjdGl2ZVwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJpbnRlcmVzdFwiLFxuICBcInBhcmFtc1wiOiBbXCJvd25lclwiLCBcImludGVyZXN0XCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wiYWN0aXZlXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcImZpbGxfdmVzdGluZ193aXRoZHJhd1wiLFxuICBcInBhcmFtc1wiOiBbXCJmcm9tX2FjY291bnRcIiwgXCJ0b19hY2NvdW50XCIsIFwid2l0aGRyYXduXCIsIFwiZGVwb3NpdGVkXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wicG9zdGluZ1wiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJmaWxsX29yZGVyXCIsXG4gIFwicGFyYW1zXCI6IFtcImN1cnJlbnRfb3duZXJcIiwgXCJjdXJyZW50X29yZGVyaWRcIiwgXCJjdXJyZW50X3BheXNcIiwgXCJjdXJyZW50X3RyYWRlX2ZlZVwiLCBcImN1cnJlbnRfdHJhZGVfZmVlX3JlY2VpdmVyXCIsIFwib3Blbl9vd25lclwiLCBcIm9wZW5fb3JkZXJpZFwiLCBcIm9wZW5fcGF5c1wiLCBcIm9wZW5fdHJhZGVfZmVlXCIsIFwib3Blbl90cmFkZV9mZWVfcmVjZWl2ZXJcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJwb3N0aW5nXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcImZpbGxfdHJhbnNmZXJfZnJvbV9zYXZpbmdzXCIsXG4gIFwicGFyYW1zXCI6IFtcImZyb21cIiwgXCJ0b1wiLCBcImFtb3VudFwiLCBcInJlcXVlc3RfaWRcIiwgXCJtZW1vXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wiYWN0aXZlXCIsIFwib3duZXJcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwiZGVsZWdhdGVfdmVzdGluZ19zaGFyZXNcIixcbiAgXCJwYXJhbXNcIjogW1wiZGVsZWdhdG9yXCIsIFwiZGVsZWdhdGVlXCIsIFwidmVzdGluZ19zaGFyZXNcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJhY3RpdmVcIiwgXCJvd25lclwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJhY2NvdW50X2NyZWF0ZV93aXRoX2RlbGVnYXRpb25cIixcbiAgXCJwYXJhbXNcIjogW1wiZmVlXCIsIFwiZGVsZWdhdGlvblwiLCBcImNyZWF0b3JcIiwgXCJuZXdfYWNjb3VudF9uYW1lXCIsIFwib3duZXJcIiwgXCJhY3RpdmVcIiwgXCJwb3N0aW5nXCIsIFwibWVtb19rZXlcIiwgXCJqc29uX21ldGFkYXRhXCIsIFwiZXh0ZW5zaW9uc1wiXVxufSwge1xuICBcInJvbGVzXCI6IFtcImFjdGl2ZVwiLCBcIm93bmVyXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcImFjY291bnRfY3JlYXRlX3dpdGhfaW52aXRlXCIsXG4gIFwicGFyYW1zXCI6IFtcImludml0ZV9zZWNyZXRcIiwgXCJjcmVhdG9yXCIsIFwibmV3X2FjY291bnRfbmFtZVwiLCBcIm93bmVyXCIsIFwiYWN0aXZlXCIsIFwicG9zdGluZ1wiLCBcIm1lbW9fa2V5XCIsIFwianNvbl9tZXRhZGF0YVwiLCBcImV4dGVuc2lvbnNcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJwb3N0aW5nXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcImFjY291bnRfbWV0YWRhdGFcIixcbiAgXCJwYXJhbXNcIjogW1wiYWNjb3VudFwiLCBcImpzb25fbWV0YWRhdGFcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJhY3RpdmVcIiwgXCJvd25lclwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJwcm9wb3NhbF9jcmVhdGVcIixcbiAgXCJwYXJhbXNcIjogW1wiYXV0aG9yXCIsIFwidGl0bGVcIiwgXCJtZW1vXCIsIFwiZXhwaXJhdGlvbl90aW1lXCIsIFwicHJvcG9zZWRfb3BlcmF0aW9uc1wiLCBcInJldmlld19wZXJpb2RfdGltZVwiLCBcImV4dGVuc2lvbnNcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJwb3N0aW5nXCIsIFwiYWN0aXZlXCIsIFwib3duZXJcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwicHJvcG9zYWxfdXBkYXRlXCIsXG4gIFwicGFyYW1zXCI6IFtcImF1dGhvclwiLCBcInRpdGxlXCIsIFwiYWN0aXZlX2FwcHJvdmFsc190b19hZGRcIiwgXCJhY3RpdmVfYXBwcm92YWxzX3RvX3JlbW92ZVwiLCBcIm93bmVyX2FwcHJvdmFsc190b19hZGRcIiwgXCJvd25lcl9hcHByb3ZhbHNfdG9fcmVtb3ZlXCIsIFwicG9zdGluZ19hcHByb3ZhbHNfdG9fYWRkXCIsIFwicG9zdGluZ19hcHByb3ZhbHNfdG9fcmVtb3ZlXCIsIFwia2V5X2FwcHJvdmFsc190b19hZGRcIiwgXCJrZXlfYXBwcm92YWxzX3RvX3JlbW92ZVwiLCBcImV4dGVuc2lvbnNcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJhY3RpdmVcIiwgXCJvd25lclwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJwcm9wb3NhbF9kZWxldGVcIixcbiAgXCJwYXJhbXNcIjogW1wiYXV0aG9yXCIsIFwidGl0bGVcIiwgXCJyZXF1ZXN0ZXJcIiwgXCJleHRlbnNpb25zXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wiYWN0aXZlXCIsIFwib3duZXJcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwiY2hhaW5fcHJvcGVydGllc191cGRhdGVcIixcbiAgXCJwYXJhbXNcIjogW1wib3duZXJcIiwgXCJwcm9wc1wiXVxufSwge1xuICBcInJvbGVzXCI6IFtcImFjdGl2ZVwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJicmVha19mcmVlX3JlZmVycmFsXCIsXG4gIFwicGFyYW1zXCI6IFtcInJlZmVycmFsXCIsIFwiZXh0ZW5zaW9uc1wiXVxufSwge1xuICBcInJvbGVzXCI6IFtcImFjdGl2ZVwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJkZWxlZ2F0ZV92ZXN0aW5nX3NoYXJlc193aXRoX2ludGVyZXN0XCIsXG4gIFwicGFyYW1zXCI6IFtcImRlbGVnYXRvclwiLCBcImRlbGVnYXRlZVwiLCBcInZlc3Rpbmdfc2hhcmVzXCIsIFwiaW50ZXJlc3RfcmF0ZVwiLCBcImV4dGVuc2lvbnNcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJhY3RpdmVcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwicmVqZWN0X3Zlc3Rpbmdfc2hhcmVzX2RlbGVnYXRpb25cIixcbiAgXCJwYXJhbXNcIjogW1wiZGVsZWdhdG9yXCIsIFwiZGVsZWdhdGVlXCIsIFwiZXh0ZW5zaW9uc1wiXVxufSwge1xuICBcInJvbGVzXCI6IFtcInBvc3RpbmdcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwid29ya2VyX3JlcXVlc3RcIixcbiAgXCJwYXJhbXNcIjogW1wiYXV0aG9yXCIsIFwicGVybWxpbmtcIiwgXCJ3b3JrZXJcIiwgXCJyZXF1aXJlZF9hbW91bnRfbWluXCIsIFwicmVxdWlyZWRfYW1vdW50X21heFwiLCBcInZlc3RfcmV3YXJkXCIsIFwiZHVyYXRpb25cIiwgXCJleHRlbnNpb25zXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wicG9zdGluZ1wiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJ3b3JrZXJfcmVxdWVzdF9kZWxldGVcIixcbiAgXCJwYXJhbXNcIjogW1wiYXV0aG9yXCIsIFwicGVybWxpbmtcIiwgXCJleHRlbnNpb25zXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wicG9zdGluZ1wiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJ3b3JrZXJfcmVxdWVzdF92b3RlXCIsXG4gIFwicGFyYW1zXCI6IFtcInZvdGVyXCIsIFwiYXV0aG9yXCIsIFwicGVybWxpbmtcIiwgXCJ2b3RlX3BlcmNlbnRcIiwgXCJleHRlbnNpb25zXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wicG9zdGluZ1wiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJjbGFpbVwiLFxuICBcInBhcmFtc1wiOiBbXCJmcm9tXCIsIFwidG9cIiwgXCJhbW91bnRcIiwgXCJ0b192ZXN0aW5nXCIsIFwiZXh0ZW5zaW9uc1wiXVxufSwge1xuICBcInJvbGVzXCI6IFtcInBvc3RpbmdcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwiZG9uYXRlXCIsXG4gIFwicGFyYW1zXCI6IFtcImZyb21cIiwgXCJ0b1wiLCBcImFtb3VudFwiLCBcIm1lbW9cIiwgXCJleHRlbnNpb25zXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wiYWN0aXZlXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcInRyYW5zZmVyX3RvX3RpcFwiLFxuICBcInBhcmFtc1wiOiBbXCJmcm9tXCIsIFwidG9cIiwgXCJhbW91bnRcIiwgXCJtZW1vXCIsIFwiZXh0ZW5zaW9uc1wiXVxufSwge1xuICBcInJvbGVzXCI6IFtcImFjdGl2ZVwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJ0cmFuc2Zlcl9mcm9tX3RpcFwiLFxuICBcInBhcmFtc1wiOiBbXCJmcm9tXCIsIFwidG9cIiwgXCJhbW91bnRcIiwgXCJtZW1vXCIsIFwiZXh0ZW5zaW9uc1wiXVxufSwge1xuICBcInJvbGVzXCI6IFtcImFjdGl2ZVwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJpbnZpdGVcIixcbiAgXCJwYXJhbXNcIjogW1wiY3JlYXRvclwiLCBcImJhbGFuY2VcIiwgXCJpbnZpdGVfa2V5XCIsIFwiZXh0ZW5zaW9uc1wiXVxufSwge1xuICBcInJvbGVzXCI6IFtcImFjdGl2ZVwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJpbnZpdGVfY2xhaW1cIixcbiAgXCJwYXJhbXNcIjogW1wiaW5pdGlhdG9yXCIsIFwicmVjZWl2ZXJcIiwgXCJpbnZpdGVfc2VjcmV0XCIsIFwiZXh0ZW5zaW9uc1wiXVxufSwge1xuICBcInJvbGVzXCI6IFtcImFjdGl2ZVwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJhc3NldF9jcmVhdGVcIixcbiAgXCJwYXJhbXNcIjogW1wiY3JlYXRvclwiLCBcIm1heF9zdXBwbHlcIiwgXCJhbGxvd19mZWVcIiwgXCJhbGxvd19vdmVycmlkZV90cmFuc2ZlclwiLCBcImpzb25fbWV0YWRhdGFcIiwgXCJleHRlbnNpb25zXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wiYWN0aXZlXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcImFzc2V0X3VwZGF0ZVwiLFxuICBcInBhcmFtc1wiOiBbXCJjcmVhdG9yXCIsIFwic3ltYm9sXCIsIFwic3ltYm9sc193aGl0ZWxpc3RcIiwgXCJmZWVfcGVyY2VudFwiLCBcImpzb25fbWV0YWRhdGFcIiwgXCJleHRlbnNpb25zXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wiYWN0aXZlXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcImFzc2V0X2lzc3VlXCIsXG4gIFwicGFyYW1zXCI6IFtcImNyZWF0b3JcIiwgXCJhbW91bnRcIiwgXCJ0b1wiLCBcImV4dGVuc2lvbnNcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJhY3RpdmVcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwiYXNzZXRfdHJhbnNmZXJcIixcbiAgXCJwYXJhbXNcIjogW1wiY3JlYXRvclwiLCBcInN5bWJvbFwiLCBcIm5ld19vd25lclwiLCBcImV4dGVuc2lvbnNcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJhY3RpdmVcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwib3ZlcnJpZGVfdHJhbnNmZXJcIixcbiAgXCJwYXJhbXNcIjogW1wiY3JlYXRvclwiLCBcImZyb21cIiwgXCJ0b1wiLCBcImFtb3VudFwiLCBcIm1lbW9cIiwgXCJleHRlbnNpb25zXCJdXG59LCB7XG4gIFwicm9sZXNcIjogW1wiYWN0aXZlXCJdLFxuICBcIm9wZXJhdGlvblwiOiBcImludml0ZV9kb25hdGVcIixcbiAgXCJwYXJhbXNcIjogW1wiZnJvbVwiLCBcImludml0ZV9rZXlcIiwgXCJhbW91bnRcIiwgXCJtZW1vXCIsIFwiZXh0ZW5zaW9uc1wiXVxufSwge1xuICBcInJvbGVzXCI6IFtcImFjdGl2ZVwiXSxcbiAgXCJvcGVyYXRpb25cIjogXCJpbnZpdGVfdHJhbnNmZXJcIixcbiAgXCJwYXJhbXNcIjogW1wiZnJvbVwiLCBcInRvXCIsIFwiYW1vdW50XCIsIFwibWVtb1wiLCBcImV4dGVuc2lvbnNcIl1cbn0sIHtcbiAgXCJyb2xlc1wiOiBbXCJhY3RpdmVcIl0sXG4gIFwib3BlcmF0aW9uXCI6IFwibGltaXRfb3JkZXJfY2FuY2VsX2V4XCIsXG4gIFwicGFyYW1zXCI6IFtcIm93bmVyXCIsIFwib3JkZXJpZFwiLCBcImV4dGVuc2lvbnNcIl1cbn1dOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZGVmYXVsdENvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZy5qc29uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY29uZmlnID0gZGVmYXVsdENvbmZpZztcblxuICB2YXIgZ2V0ID0gZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHJldHVybiBjb25maWdba2V5XTtcbiAgfTtcblxuICB2YXIgc2V0ID0gZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICBjb25maWdba2V5XSA9IHZhbHVlO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZ2V0OiBnZXQsXG4gICAgc2V0OiBzZXRcbiAgfTtcbn0oKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZGVmYXVsdCA9ICdBR0Z6YlFFQUFBQUJyd0VhWUFKL2Z3Ri9ZQUovZndCZ0FYOEJmMkFEZjM5L0FYOWdBWDhBWUFOL2YzOEFZQVIvZjM5L0FHQUNmM3dCZjJBQUFHQUZmMzkvZjM4QVlBUi9mMzkvQVg5Z0FYOEJmbUFHZjM5L2YzOS9BR0FGZjM5L2YzOEJmMkFFZkg5L2Z3Ri9ZQWQvZjM5L2YzOS9BR0FGZjM5OWYzOEFZQVYvZjN4L2Z3QmdCWDkrZjM5L0FHQUVmMzEvZndCZ0FuOThBR0FFZjN4L2Z3QmdBQUYvWUFaL2YzOS9mMzhCZjJBQ2ZuOEJmMkFCZndGOEFzWUNDZ04zWW1jYVgxOTNZbWx1WkdkbGJsOXZZbXBsWTNSZlpISnZjRjl5WldZQUJBTjNZbWNTWDE5M1ltbHVaR2RsYmw5allsOWtjbTl3QUFJRGQySm5HMTlmZDJKblgyTmhiR3hmWlRreFpqY3haR1JtTVdZME5XTm1aZ0FBQTNkaVp4cGZYM2RpWjE5dVpYZGZPREE0TVRGa1kySTJObVF4WWpVelpnQUFBM2RpWnh0ZlgzZGlaMTlqWVd4c1gyVXpZemN5TXpVMVpEQTVNV1ExWkRRQUF3TjNZbWNwWDE5M1ltZGZhVzV6ZEdGdVkyVnZabDlRY205dGFYTmxYekJtWWpWa04yVXlObU5oT0RNMk1qWUFBZ04zWW1jYlgxOTNZbWRmZEdobGJsODJaRFV3TnpKbVpXTXpabVJpTWpNM0FBQURkMkpuRUY5ZmQySnBibVJuWlc1ZmRHaHliM2NBQVFOM1ltY1NYMTkzWW1sdVpHZGxibDl5WlhSb2NtOTNBQVFEZDJKbkhWOWZkMkpwYm1SblpXNWZZMnh2YzNWeVpWOTNjbUZ3Y0dWeU1URXpBQU1Ec3dHeEFRWUNBUUVNQUFRREF3TUZBUW9GQkFNRUJBUUFBUUFFRWdJQ0JRQUhCd0FBQUFBR0R3RUJBQUFEQlFjSEJ4Z0FBQUFCQkJZQ0FnVUJEZ0VCQ1FBR0JRRUZBUUVDQlFFQkFRRUZEQVVCQlFVQ0JRNEJBQUFBQUFBQUFSUUZBUVFGQkFRRUFBRUJBd1lEQlFNRUJRRUJCQWdCQWdFQ0FnRVpBUVFFQkFNRkZ4QU5DUkVCQkFZRkJRTUNBZ0VBQ2dFQ0FBQUVBUUFDQUFJQ0FRSUFBQUlBQ0FnQkFnSUNBZ0VEQXdBQUFnSUxDd3NFQVFRRkFYQUJLQ2dGQXdFQUVRWUpBWDhCUVlDQXdBQUxCK2tKUFFadFpXMXZjbmtDQUJGZlgzZGlaMTlmWVhOelpYUmZabkpsWlFCMEVWOWhjM05sZEY5bWNtOXRVM1J5YVc1bkFFWUtYMkZ6YzJWMFgyNWxkd0JiREY5aGMzTmxkRjlqYkc5dVpRQS9EVjloYzNObGRGOWhiVzkxYm5RQWdBRVJYMkZ6YzJWMFgzTmxkRjloYlc5MWJuUUFaQk5mWVhOelpYUmZZVzF2ZFc1MFgyWnNiMkYwQUV3WFgyRnpjMlYwWDNObGRGOWhiVzkxYm5SZlpteHZZWFFBVGhoZllYTnpaWFJmZFhCa1lYUmxRVzF2ZFc1MFJteHZZWFFBUnhCZllYTnpaWFJmY0hKbFkybHphVzl1QUg0VVgyRnpjMlYwWDNObGRGOXdjbVZqYVhOcGIyNEFmQTFmWVhOelpYUmZjM2x0WW05c0FFOFJYMkZ6YzJWMFgzTmxkRjl6ZVcxaWIyd0FVdzFmWVhOelpYUmZhWE5mZFdsaEFGa1BYMkZ6YzJWMFgzUnZVM1J5YVc1bkFDd1RYMkZ6YzJWMFgyWnNiMkYwWDNOMGNtbHVad0F1RUY5aGMzTmxkRjlmY0d4MWMxOXVkVzBBTkF4ZllYTnpaWFJmWDNCc2RYTUFPQkZmWVhOelpYUmZYMjFwYm5WelgyNTFiUUExRFY5aGMzTmxkRjlmYldsdWRYTUFPUTlmWVhOelpYUmZYMjExYkY5dWRXMEFOZ3RmWVhOelpYUmZYMjExYkFBNkQxOWhjM05sZEY5ZlpHbDJYMjUxYlFBbUMxOWhjM05sZEY5ZlpHbDJBQ2dQWDJGemMyVjBYMTl0YjJSZmJuVnRBQ2NMWDJGemMyVjBYMTl0YjJRQUtSRmZZWE56WlhSZlgyMTFiRjl3Y21salpRQVNDVjloYzNObGRGOWxjUUJkQ1Y5aGMzTmxkRjl1WlFCZUNWOWhjM05sZEY5c2RBQmZDbDloYzNObGRGOXNkR1VBWUFsZllYTnpaWFJmWjNRQVlRcGZZWE56WlhSZlozUmxBR0lLWDJGemMyVjBYMjFwYmdBd0NsOWhjM05sZEY5dFlYZ0FNUmRmWDNkaVoxOWZZWE56WlhSbFpHbDBiM0pmWm5KbFpRQnBGbDloYzNObGRHVmthWFJ2Y2w5bWNtOXRRWE56WlhRQUl4ZGZZWE56WlhSbFpHbDBiM0pmWm5KdmJWTjBjbWx1WndBckVGOWhjM05sZEdWa2FYUnZjbDl1WlhjQVFoZGZZWE56WlhSbFpHbDBiM0pmZDJsMGFFTm9ZVzVuWlFBWkVsOWhjM05sZEdWa2FYUnZjbDloYzNObGRBQS9GMTloYzNObGRHVmthWFJ2Y2w5aGJXOTFiblJmYzNSeUFGQVhYMkZ6YzJWMFpXUnBkRzl5WDJoaGMxOWphR0Z1WjJVQWZSRmZYM2RpWjE5ZmNISnBZMlZmWm5KbFpRQnFDbDl3Y21salpWOXVaWGNBSHd4ZmNISnBZMlZmWTJ4dmJtVUFJZ3RmY0hKcFkyVmZZbUZ6WlFBL0QxOXdjbWxqWlY5elpYUmZZbUZ6WlFCRERGOXdjbWxqWlY5eGRXOTBaUUErRUY5d2NtbGpaVjl6WlhSZmNYVnZkR1VBUkJwZlgzZGlaMTl6ZEhKbFlXMXBibWRvWVc1a2JHVmZabkpsWlFCckUzTjBjbVZoYlY5aWJHOWphMTl1ZFcxaVpYSUFLZzVoWlhNeU5UWmZaR1ZqY25sd2RBQXRFMTlmZDJKcGJtUm5aVzVmWlhod2IzSjBYekFCQUh4ZlpIbHVYMk52Y21WZlgyOXdjMTlmWm5WdVkzUnBiMjVmWDBadVRYVjBYMTlCWDE5ZlgwOTFkSEIxZEY5ZlgxSmZZWE5mZDJGemJWOWlhVzVrWjJWdVgxOWpiRzl6ZFhKbFgxOVhZWE50UTJ4dmMzVnlaVjlmWDJSbGMyTnlhV0psWDE5cGJuWnZhMlZmWDJoalpUSmxaRE00TjJGaE1XTXlZalk1QUpBQkVWOWZkMkpwYm1SblpXNWZiV0ZzYkc5akFIc1NYMTkzWW1sdVpHZGxibDl5WldGc2JHOWpBSVVCSDE5ZmQySnBibVJuWlc1ZllXUmtYM1J2WDNOMFlXTnJYM0J2YVc1MFpYSUFwZ0VQWDE5M1ltbHVaR2RsYmw5bWNtVmxBSmNCRkY5ZmQySnBibVJuWlc1ZlpYaHVYM04wYjNKbEFKc0JDVThDQUVFQkN3aTVBYWNCalFGV1VaQUJnUUdQQVFCQkNnc2VpUUZVaWdHSkFZY0JrUUdPQVlvQmlnR0lBWXNCdWdHREFiWUJ1UUczQVlRQlFWSjJuQUZ2blFGc3BRR2tBWmtCbndHNUFiZ0JDb0gxQXJFQitSNEJsQUYvSXdCQk1Hc2lCaVFBSUFOQkQzRUVmMEVBQlNBQ0lBTkJnSDl4SWdkcUlRVWdBMEVFZGtFSGNTRW5JQUZCN3dOcUxRQUFJUWdnQVVIdUEyb3RBQUFoQ1NBQlFlMERhaTBBQUNFS0lBRkI3QU5xTFFBQUlRc2dBVUhyQTJvdEFBQWhEQ0FCUWVvRGFpMEFBQ0VOSUFGQjZRTnFMUUFBSVE0Z0FVSG9BMm90QUFBaER5QUJRZWNEYWkwQUFDRVFJQUZCNWdOcUxRQUFJUkVnQVVIbEEyb3RBQUFoRWlBQlFlUURhaTBBQUNFVElBRkI0d05xTFFBQUlSUWdBVUhpQTJvdEFBQWhGU0FCUWVFRGFpMEFBQ0VXSUFFdEFPQURJUmNDUUNBSFJRUkFJQmNoQnlBV0lSZ2dGU0VaSUJRaEdpQVRJUnNnRWlFY0lCRWhIU0FRSVI0Z0R5RWZJQTRoSUNBTklTRWdEQ0VpSUFzaEl5QUtJU1FnQ1NFbElBZ2hKZ3dCQ3lBQ0lRUURRQ0FFTFFCL0lTWWdCQzBBZmlFbElBUXRBSDBoSkNBRUxRQjhJU01nQkMwQWV5RWlJQVF0QUhvaElTQUVMUUI1SVNBZ0JDMEFlQ0VmSUFRdEFIY2hIaUFFTFFCMklSMGdCQzBBZFNFY0lBUXRBSFFoR3lBRUxRQnpJUm9nQkMwQWNpRVpJQVF0QUhFaEdDQUVMUUJ3SVFjZ0JDMEFieUVvSUFRdEFHNGhLU0FFTFFCdElTb2dCQzBBYkNFcklBUXRBR3NoTENBRUxRQnFJUzBnQkMwQWFTRXVJQVF0QUdnaEx5QUVMUUJuSVRBZ0JDMEFaaUV4SUFRdEFHVWhNaUFFTFFCa0lUTWdCQzBBWXlFMElBUXRBR0loTlNBRUxRQmhJVFlnQkMwQVlDRTNJQVF0QUY4aE9DQUVMUUJlSVRrZ0JDMEFYU0U2SUFRdEFGd2hPeUFFTFFCYklUd2dCQzBBV2lFOUlBUXRBRmtoUGlBRUxRQllJVDhnQkMwQVZ5RkFJQVF0QUZZaFFTQUVMUUJWSVVJZ0JDMEFWQ0ZESUFRdEFGTWhSQ0FFTFFCU0lVVWdCQzBBVVNGR0lBUXRBRkFoUnlBRUxRQlBJVWdnQkMwQVRpRkpJQVF0QUUwaFNpQUVMUUJNSVVzZ0JDMEFTeUZNSUFRdEFFb2hUU0FFTFFCSklVNGdCQzBBU0NGUElBUXRBRWNoVUNBRUxRQkdJVkVnQkMwQVJTRlNJQVF0QUVRaFV5QUVMUUJESVZRZ0JDMEFRaUZWSUFRdEFFRWhWaUFFTFFCQUlWY2dCQzBBUHlGWUlBUXRBRDRoV1NBRUxRQTlJVm9nQkMwQVBDRmJJQVF0QURzaFhDQUVMUUE2SVYwZ0JDMEFPU0ZlSUFRdEFEZ2hYeUFFTFFBM0lXQWdCQzBBTmlGaElBUXRBRFVoWWlBRUxRQTBJV01nQkMwQU15RmtJQVF0QURJaFpTQUVMUUF4SVdZZ0JDMEFNQ0ZuSUFRdEFDOGhhQ0FFTFFBdUlXa2dCQzBBTFNGcUlBUXRBQ3doYXlBRUxRQXJJV3dnQkMwQUtpRnRJQVF0QUNraGJpQUVMUUFvSVc4Z0JDMEFKeUZ3SUFRdEFDWWhjU0FFTFFBbElYSWdCQzBBSkNGeklBUXRBQ01oZENBRUxRQWlJWFVnQkMwQUlTRjJJQVF0QUNBaGR5QUVMUUFmSVhnZ0JDMEFIaUY1SUFRdEFCMGhlaUFFTFFBY0lYc2dCQzBBR3lGOElBUXRBQm9oZlNBRUxRQVpJWDRnQkMwQUdDRi9JQVF0QUJjaGdBRWdCQzBBRmlHQkFTQUVMUUFWSVlJQklBUXRBQlFoZ3dFZ0JDMEFFeUdFQVNBRUxRQVNJWVVCSUFRdEFCRWhoZ0VnQkMwQUVDR0hBU0FFTFFBUElZZ0JJQVF0QUE0aGlRRWdCQzBBRFNHS0FTQUVMUUFNSVlzQklBUXRBQXNoakFFZ0JDMEFDaUdOQVNBRUxRQUpJWTRCSUFRdEFBZ2hqd0VnQkMwQUJ5R1FBU0FFTFFBR0laRUJJQVF0QUFVaGtnRWdCQzBBQkNHVEFTQUVMUUFESVpRQklBUXRBQUlobFFFZ0JDMEFBU0dXQVNBRUxRQUFJWmNCSUFFZ0JCQU5JQUVnQkVFZ2FoQU5JQUVnQkVGQWF4QU5JQUVnQkVIZ0FHb1FEU0FFSUFRdEFBQWdGM002QUFBZ0JDQUVMUUFCSUJaek9nQUJJQVFnQkMwQUFpQVZjem9BQWlBRUlBUXRBQU1nRkhNNkFBTWdCQ0FFTFFBRUlCTnpPZ0FFSUFRZ0JDMEFCU0FTY3pvQUJTQUVJQVF0QUFZZ0VYTTZBQVlnQkNBRUxRQUhJQkJ6T2dBSElBUWdCQzBBQ0NBUGN6b0FDQ0FFSUFRdEFBa2dEbk02QUFrZ0JDQUVMUUFLSUExek9nQUtJQVFnQkMwQUN5QU1jem9BQ3lBRUlBUXRBQXdnQzNNNkFBd2dCQ0FFTFFBTklBcHpPZ0FOSUFRZ0JDMEFEaUFKY3pvQURpQUVJQVF0QUE4Z0NITTZBQThnQkNDWEFTQUVMUUFRY3pvQUVDQUVJSllCSUFRdEFCRnpPZ0FSSUFRZ2xRRWdCQzBBRW5NNkFCSWdCQ0NVQVNBRUxRQVRjem9BRXlBRUlKTUJJQVF0QUJSek9nQVVJQVFna2dFZ0JDMEFGWE02QUJVZ0JDQ1JBU0FFTFFBV2N6b0FGaUFFSUpBQklBUXRBQmR6T2dBWElBUWdqd0VnQkMwQUdITTZBQmdnQkNDT0FTQUVMUUFaY3pvQUdTQUVJSTBCSUFRdEFCcHpPZ0FhSUFRZ2pBRWdCQzBBRzNNNkFCc2dCQ0NMQVNBRUxRQWNjem9BSENBRUlJb0JJQVF0QUIxek9nQWRJQVFnaVFFZ0JDMEFIbk02QUI0Z0JDQ0lBU0FFTFFBZmN6b0FIeUFFSUljQklBUXRBQ0J6T2dBZ0lBUWdoZ0VnQkMwQUlYTTZBQ0VnQkNDRkFTQUVMUUFpY3pvQUlpQUVJSVFCSUFRdEFDTnpPZ0FqSUFRZ2d3RWdCQzBBSkhNNkFDUWdCQ0NDQVNBRUxRQWxjem9BSlNBRUlJRUJJQVF0QUNaek9nQW1JQVFnZ0FFZ0JDMEFKM002QUNjZ0JDQi9JQVF0QUNoek9nQW9JQVFnZmlBRUxRQXBjem9BS1NBRUlIMGdCQzBBS25NNkFDb2dCQ0I4SUFRdEFDdHpPZ0FySUFRZ2V5QUVMUUFzY3pvQUxDQUVJSG9nQkMwQUxYTTZBQzBnQkNCNUlBUXRBQzV6T2dBdUlBUWdlQ0FFTFFBdmN6b0FMeUFFSUhjZ0JDMEFNSE02QURBZ0JDQjJJQVF0QURGek9nQXhJQVFnZFNBRUxRQXljem9BTWlBRUlIUWdCQzBBTTNNNkFETWdCQ0J6SUFRdEFEUnpPZ0EwSUFRZ2NpQUVMUUExY3pvQU5TQUVJSEVnQkMwQU5uTTZBRFlnQkNCd0lBUXRBRGR6T2dBM0lBUWdieUFFTFFBNGN6b0FPQ0FFSUc0Z0JDMEFPWE02QURrZ0JDQnRJQVF0QURwek9nQTZJQVFnYkNBRUxRQTdjem9BT3lBRUlHc2dCQzBBUEhNNkFEd2dCQ0JxSUFRdEFEMXpPZ0E5SUFRZ2FTQUVMUUErY3pvQVBpQUVJR2dnQkMwQVAzTTZBRDhnQkNCbklBUXRBRUJ6T2dCQUlBUWdaaUFFTFFCQmN6b0FRU0FFSUdVZ0JDMEFRbk02QUVJZ0JDQmtJQVF0QUVOek9nQkRJQVFnWXlBRUxRQkVjem9BUkNBRUlHSWdCQzBBUlhNNkFFVWdCQ0JoSUFRdEFFWnpPZ0JHSUFRZ1lDQUVMUUJIY3pvQVJ5QUVJRjhnQkMwQVNITTZBRWdnQkNCZUlBUXRBRWx6T2dCSklBUWdYU0FFTFFCS2N6b0FTaUFFSUZ3Z0JDMEFTM002QUVzZ0JDQmJJQVF0QUV4ek9nQk1JQVFnV2lBRUxRQk5jem9BVFNBRUlGa2dCQzBBVG5NNkFFNGdCQ0JZSUFRdEFFOXpPZ0JQSUFRZ1Z5QUVMUUJRY3pvQVVDQUVJRllnQkMwQVVYTTZBRkVnQkNCVklBUXRBRkp6T2dCU0lBUWdWQ0FFTFFCVGN6b0FVeUFFSUZNZ0JDMEFWSE02QUZRZ0JDQlNJQVF0QUZWek9nQlZJQVFnVVNBRUxRQldjem9BVmlBRUlGQWdCQzBBVjNNNkFGY2dCQ0JQSUFRdEFGaHpPZ0JZSUFRZ1RpQUVMUUJaY3pvQVdTQUVJRTBnQkMwQVduTTZBRm9nQkNCTUlBUXRBRnR6T2dCYklBUWdTeUFFTFFCY2N6b0FYQ0FFSUVvZ0JDMEFYWE02QUYwZ0JDQkpJQVF0QUY1ek9nQmVJQVFnU0NBRUxRQmZjem9BWHlBRUlFY2dCQzBBWUhNNkFHQWdCQ0JHSUFRdEFHRnpPZ0JoSUFRZ1JTQUVMUUJpY3pvQVlpQUVJRVFnQkMwQVkzTTZBR01nQkNCRElBUXRBR1J6T2dCa0lBUWdRaUFFTFFCbGN6b0FaU0FFSUVFZ0JDMEFabk02QUdZZ0JDQkFJQVF0QUdkek9nQm5JQVFnUHlBRUxRQm9jem9BYUNBRUlENGdCQzBBYVhNNkFHa2dCQ0E5SUFRdEFHcHpPZ0JxSUFRZ1BDQUVMUUJyY3pvQWF5QUVJRHNnQkMwQWJITTZBR3dnQkNBNklBUXRBRzF6T2dCdElBUWdPU0FFTFFCdWN6b0FiaUFFSURnZ0JDMEFiM002QUc4Z0JDQTNJQVF0QUhCek9nQndJQVFnTmlBRUxRQnhjem9BY1NBRUlEVWdCQzBBY25NNkFISWdCQ0EwSUFRdEFITnpPZ0J6SUFRZ015QUVMUUIwY3pvQWRDQUVJRElnQkMwQWRYTTZBSFVnQkNBeElBUXRBSFp6T2dCMklBUWdNQ0FFTFFCM2N6b0FkeUFFSUM4Z0JDMEFlSE02QUhnZ0JDQXVJQVF0QUhsek9nQjVJQVFnTFNBRUxRQjZjem9BZWlBRUlDd2dCQzBBZTNNNkFIc2dCQ0FySUFRdEFIeHpPZ0I4SUFRZ0tpQUVMUUI5Y3pvQWZTQUVJQ2tnQkMwQWZuTTZBSDRnQkNBb0lBUXRBSDl6T2dCL0lBY2hGeUFZSVJZZ0dTRVZJQm9oRkNBYklSTWdIQ0VTSUIwaEVTQWVJUkFnSHlFUElDQWhEaUFoSVEwZ0lpRU1JQ01oQ3lBa0lRb2dKU0VKSUNZaENDQUVRWUFCYWlJRUlBVkhEUUFMQ3lBQklDWTZBTzhESUFFZ0pUb0E3Z01nQVNBa09nRHRBeUFCSUNNNkFPd0RJQUVnSWpvQTZ3TWdBU0FoT2dEcUF5QUJJQ0E2QU9rRElBRWdIem9BNkFNZ0FTQWVPZ0RuQXlBQklCMDZBT1lESUFFZ0hEb0E1UU1nQVNBYk9nRGtBeUFCSUJvNkFPTURJQUVnR1RvQTRnTWdBU0FZT2dEaEF5QUJJQWM2QU9BREFrQWdKMFVFUUNBSElSWWdHQ0VYSUJraENDQWFJUWtnR3lFS0lCd2hDeUFkSVF3Z0hpRU5JQjhoRGlBZ0lROGdJU0VRSUNJaEVTQWpJUklnSkNFVElDVWhGQ0FtSVJVTUFRc2dCU0FuUVFSMGFpRTJJQVpCSUdvaEp3TkFJQVZCRDJvaUtDMEFBQ0VWSUFWQkRtb2lLUzBBQUNFVUlBVkJEV29pS2kwQUFDRVRJQVZCREdvaUt5MEFBQ0VTSUFWQkMyb2lMQzBBQUNFUklBVkJDbW9pTFMwQUFDRVFJQVZCQ1dvaUxpMEFBQ0VQSUFWQkNHb2lCQzBBQUNFT0lBVkJCMm9pTHkwQUFDRU5JQVZCQm1vaU1DMEFBQ0VNSUFWQkJXb2lNUzBBQUNFTElBVkJCR29pTWkwQUFDRUtJQVZCQTJvaU15MEFBQ0VKSUFWQkFtb2lOQzBBQUNFSUlBVkJBV29pTlMwQUFDRVhJQVV0QUFBaEZpQW5RUWhxUWdBM0FBQWdKMElBTndBQUlBWkJHR29pTnlBRUtRQUFOd01BSUFZZ0JTa0FBRGNERUNBQklBWkJFR29RRFNBRklBWXBBeEEzQUFBZ0JDQTNLUU1BTndBQUlBVWdCUzBBQUNBSGN6b0FBQ0ExSURVdEFBQWdHSE02QUFBZ05DQTBMUUFBSUJsek9nQUFJRE1nTXkwQUFDQWFjem9BQUNBeUlESXRBQUFnRzNNNkFBQWdNU0F4TFFBQUlCeHpPZ0FBSURBZ01DMEFBQ0FkY3pvQUFDQXZJQzh0QUFBZ0huTTZBQUFnQkNBRUxRQUFJQjl6T2dBQUlDNGdMaTBBQUNBZ2N6b0FBQ0F0SUMwdEFBQWdJWE02QUFBZ0xDQXNMUUFBSUNKek9nQUFJQ3NnS3kwQUFDQWpjem9BQUNBcUlDb3RBQUFnSkhNNkFBQWdLU0FwTFFBQUlDVnpPZ0FBSUNnZ0tDMEFBQ0FtY3pvQUFDQVdJUWNnRnlFWUlBZ2hHU0FKSVJvZ0NpRWJJQXNoSENBTUlSMGdEU0VlSUE0aEh5QVBJU0FnRUNFaElCRWhJaUFTSVNNZ0V5RWtJQlFoSlNBVklTWWdCVUVRYWlJRklEWkhEUUFMQ3lBQklCVTZBTzhESUFFZ0ZEb0E3Z01nQVNBVE9nRHRBeUFCSUJJNkFPd0RJQUVnRVRvQTZ3TWdBU0FRT2dEcUF5QUJJQTg2QU9rRElBRWdEam9BNkFNZ0FTQU5PZ0RuQXlBQklBdzZBT1lESUFFZ0N6b0E1UU1nQVNBS09nRGtBeUFCSUFrNkFPTURJQUVnQ0RvQTRnTWdBU0FYT2dEaEF5QUJJQlk2QU9BRElBWkJDR29nQWlBREVGZ2dCaWdDRENFRklBWW9BZ2dMSVFRZ0FDQUZOZ0lFSUFBZ0JEWUNBQ0FHUVRCcUpBQUx2Q0FDRDM4QmZpTUFRUkJySWdza0FBSkFBa0FnQUVIMUFVOEVRRUdBZ0h4QkNFRUlFSlVCUVJSQkNCQ1ZBV3BCRUVFSUVKVUJhbXRCZDNGQmZXb2lBa0VBUVJCQkNCQ1ZBVUVDZEdzaUFTQUJJQUpMR3lBQVRRMENJQUJCQkdwQkNCQ1ZBU0VFUVlDU3dBQW9BZ0JGRFFGQkFDQUVheUVEQWtBQ1FBSi9RUUFnQkVHQUFra05BQnBCSHlBRVFmLy8vd2RMRFFBYUlBUkJCaUFFUVFoMlp5SUFhM1pCQVhFZ0FFRUJkR3RCUG1vTElnWkJBblJCakpUQUFHb29BZ0FpQUFSQUlBUWdCaENUQVhRaEIwRUFJUUVEUUFKQUlBQVFxd0VpQWlBRVNRMEFJQUlnQkdzaUFpQURUdzBBSUFBaEFTQUNJZ01OQUVFQUlRTU1Bd3NnQUVFVWFpZ0NBQ0lDSUFVZ0FpQUFJQWRCSFhaQkJIRnFRUkJxS0FJQUlnQkhHeUFGSUFJYklRVWdCMEVCZENFSElBQU5BQXNnQlFSQUlBVWhBQXdDQ3lBQkRRSUxRUUFoQVVFQklBWjBFSmdCUVlDU3dBQW9BZ0J4SWdCRkRRTWdBQkNnQVdoQkFuUkJqSlRBQUdvb0FnQWlBRVVOQXdzRFFDQUFJQUVnQUJDckFTSUJJQVJQSUFFZ0JHc2lCU0FEU1hFaUFoc2hBU0FGSUFNZ0Foc2hBeUFBRUpJQklnQU5BQXNnQVVVTkFndEJqSlhBQUNnQ0FDSUFJQVJQUVFBZ0F5QUFJQVJyVHhzTkFTQUJJZ0FnQkJDeUFTRUdJQUFRUEFKQUlBTkJFRUVJRUpVQlR3UkFJQUFnQkJDaUFTQUdJQU1RbEFFZ0EwR0FBazhFUUNBR0lBTVFPd3dDQ3lBRFFRTjJJZ0ZCQTNSQmhKTEFBR29oQlFKL1FmeVJ3QUFvQWdBaUFrRUJJQUYwSWdGeEJFQWdCU2dDQ0F3QkMwSDhrY0FBSUFFZ0FuSTJBZ0FnQlFzaEFTQUZJQVkyQWdnZ0FTQUdOZ0lNSUFZZ0JUWUNEQ0FHSUFFMkFnZ01BUXNnQUNBRElBUnFFSXdCQ3lBQUVMUUJJZ05GRFFFTUFndEJFQ0FBUVFScVFSQkJDQkNWQVVGN2FpQUFTeHRCQ0JDVkFTRUVBa0FDUUFKQUFuOENRQUpBUWZ5UndBQW9BZ0FpQVNBRVFRTjJJZ0IySWdKQkEzRkZCRUFnQkVHTWxjQUFLQUlBVFEwSElBSU5BVUdBa3NBQUtBSUFJZ0JGRFFjZ0FCQ2dBV2hCQW5SQmpKVEFBR29vQWdBaUFSQ3JBU0FFYXlFRElBRVFrZ0VpQUFSQUEwQWdBQkNyQVNBRWF5SUNJQU1nQWlBRFNTSUNHeUVESUFBZ0FTQUNHeUVCSUFBUWtnRWlBQTBBQ3dzZ0FTSUFJQVFRc2dFaEJTQUFFRHdnQTBFUVFRZ1FsUUZKRFFVZ0FDQUVFS0lCSUFVZ0F4Q1VBVUdNbGNBQUtBSUFJZ0ZGRFFRZ0FVRURkaUlCUVFOMFFZU1N3QUJxSVFkQmxKWEFBQ2dDQUNFR1FmeVJ3QUFvQWdBaUFrRUJJQUYwSWdGeFJRMENJQWNvQWdnTUF3c0NRQ0FDUVg5elFRRnhJQUJxSWdOQkEzUWlBRUdNa3NBQWFpZ0NBQ0lGUVFocUtBSUFJZ0lnQUVHRWtzQUFhaUlBUndSQUlBSWdBRFlDRENBQUlBSTJBZ2dNQVF0Qi9KSEFBQ0FCUVg0Z0EzZHhOZ0lBQ3lBRklBTkJBM1FRakFFZ0JSQzBBU0VEREFjTEFrQkJBU0FBUVI5eElnQjBFSmdCSUFJZ0FIUnhFS0FCYUNJQ1FRTjBJZ0JCakpMQUFHb29BZ0FpQTBFSWFpZ0NBQ0lCSUFCQmhKTEFBR29pQUVjRVFDQUJJQUEyQWd3Z0FDQUJOZ0lJREFFTFFmeVJ3QUJCL0pIQUFDZ0NBRUYrSUFKM2NUWUNBQXNnQXlBRUVLSUJJQU1nQkJDeUFTSUZJQUpCQTNRZ0JHc2lBaENVQVVHTWxjQUFLQUlBSWdBRVFDQUFRUU4ySWdCQkEzUkJoSkxBQUdvaEIwR1VsY0FBS0FJQUlRWUNmMEg4a2NBQUtBSUFJZ0ZCQVNBQWRDSUFjUVJBSUFjb0FnZ01BUXRCL0pIQUFDQUFJQUZ5TmdJQUlBY0xJUUFnQnlBR05nSUlJQUFnQmpZQ0RDQUdJQWMyQWd3Z0JpQUFOZ0lJQzBHVWxjQUFJQVUyQWdCQmpKWEFBQ0FDTmdJQUlBTVF0QUVoQXd3R0MwSDhrY0FBSUFFZ0FuSTJBZ0FnQndzaEFTQUhJQVkyQWdnZ0FTQUdOZ0lNSUFZZ0J6WUNEQ0FHSUFFMkFnZ0xRWlNWd0FBZ0JUWUNBRUdNbGNBQUlBTTJBZ0FNQVFzZ0FDQURJQVJxRUl3QkN5QUFFTFFCSWdNTkFRc0NRQUpBQWtBQ1FBSkFBa0FDUUFKQVFZeVZ3QUFvQWdBaUFDQUVTUVJBUVpDVndBQW9BZ0FpQUNBRVN3MENJQXRCQ0VFSUVKVUJJQVJxUVJSQkNCQ1ZBV3BCRUVFSUVKVUJha0dBZ0FRUWxRRVFkeUFMS0FJQUlnZ05BVUVBSVFNTUNRdEJsSlhBQUNnQ0FDRUNJQUFnQkdzaUFVRVFRUWdRbFFGSkJFQkJsSlhBQUVFQU5nSUFRWXlWd0FBb0FnQWhBRUdNbGNBQVFRQTJBZ0FnQWlBQUVJd0JJQUlRdEFFaEF3d0pDeUFDSUFRUXNnRWhBRUdNbGNBQUlBRTJBZ0JCbEpYQUFDQUFOZ0lBSUFBZ0FSQ1VBU0FDSUFRUW9nRWdBaEMwQVNFRERBZ0xJQXNvQWdnaERFR2NsY0FBSUFzb0FnUWlDa0djbGNBQUtBSUFhaUlCTmdJQVFhQ1Z3QUJCb0pYQUFDZ0NBQ0lBSUFFZ0FDQUJTeHMyQWdBQ1FBSkFRWmlWd0FBb0FnQUVRRUdrbGNBQUlRQURRQ0FBRUtNQklBaEdEUUlnQUNnQ0NDSUFEUUFMREFJTFFiaVZ3QUFvQWdBaUFFVWdDQ0FBU1hJTkF3d0hDeUFBRUswQkRRQWdBQkN1QVNBTVJ3MEFJQUFpQVNnQ0FDSUZRWmlWd0FBb0FnQWlBazBFZnlBRklBRW9BZ1JxSUFKTEJVRUFDdzBEQzBHNGxjQUFRYmlWd0FBb0FnQWlBQ0FJSUFnZ0FFc2JOZ0lBSUFnZ0Ntb2hBVUdrbGNBQUlRQUNRQUpBQTBBZ0FTQUFLQUlBUndSQUlBQW9BZ2dpQUEwQkRBSUxDeUFBRUswQkRRQWdBQkN1QVNBTVJnMEJDMEdZbGNBQUtBSUFJUWxCcEpYQUFDRUFBa0FEUUNBQUtBSUFJQWxOQkVBZ0FCQ2pBU0FKU3cwQ0N5QUFLQUlJSWdBTkFBdEJBQ0VBQ3lBSklBQVFvd0VpQmtFVVFRZ1FsUUVpRDJ0QmFXb2lBUkMwQVNJQVFRZ1FsUUVnQUdzZ0FXb2lBQ0FBUVJCQkNCQ1ZBU0FKYWtrYklnMFF0QUVoRGlBTklBOFFzZ0VoQUVFSVFRZ1FsUUVoQTBFVVFRZ1FsUUVoQlVFUVFRZ1FsUUVoQWtHWWxjQUFJQWdnQ0JDMEFTSUJRUWdRbFFFZ0FXc2lBUkN5QVNJSE5nSUFRWkNWd0FBZ0NrRUlhaUFDSUFNZ0JXcHFJQUZxYXlJRE5nSUFJQWNnQTBFQmNqWUNCRUVJUVFnUWxRRWhCVUVVUVFnUWxRRWhBa0VRUVFnUWxRRWhBU0FISUFNUXNnRWdBU0FDSUFWQkNHdHFhallDQkVHMGxjQUFRWUNBZ0FFMkFnQWdEU0FQRUtJQlFhU1Z3QUFwQWdBaEVDQU9RUWhxUWF5VndBQXBBZ0EzQWdBZ0RpQVFOd0lBUWJDVndBQWdERFlDQUVHb2xjQUFJQW8yQWdCQnBKWEFBQ0FJTmdJQVFheVZ3QUFnRGpZQ0FBTkFJQUJCQkJDeUFTRUJJQUJCQnpZQ0JDQUdJQUVpQUVFRWFrc05BQXNnQ1NBTlJnMEhJQWtnRFNBSmF5SUFJQWtnQUJDeUFSQ0dBU0FBUVlBQ1R3UkFJQWtnQUJBN0RBZ0xJQUJCQTNZaUFFRURkRUdFa3NBQWFpRUNBbjlCL0pIQUFDZ0NBQ0lCUVFFZ0FIUWlBSEVFUUNBQ0tBSUlEQUVMUWZ5UndBQWdBQ0FCY2pZQ0FDQUNDeUVBSUFJZ0NUWUNDQ0FBSUFrMkFnd2dDU0FDTmdJTUlBa2dBRFlDQ0F3SEN5QUFLQUlBSVFNZ0FDQUlOZ0lBSUFBZ0FDZ0NCQ0FLYWpZQ0JDQUlFTFFCSWdWQkNCQ1ZBU0VDSUFNUXRBRWlBVUVJRUpVQklRQWdDQ0FDSUFWcmFpSUdJQVFRc2dFaEJ5QUdJQVFRb2dFZ0F5QUFJQUZyYWlJQUlBUWdCbXBySVFRZ0FFR1lsY0FBS0FJQVJ3UkFRWlNWd0FBb0FnQWdBRVlOQkNBQUtBSUVRUU54UVFGSERRVUNRQ0FBRUtzQklnVkJnQUpQQkVBZ0FCQThEQUVMSUFCQkRHb29BZ0FpQWlBQVFRaHFLQUlBSWdGSEJFQWdBU0FDTmdJTUlBSWdBVFlDQ0F3QkMwSDhrY0FBUWZ5UndBQW9BZ0JCZmlBRlFRTjJkM0UyQWdBTElBUWdCV29oQkNBQUlBVVFzZ0VoQUF3RkMwR1lsY0FBSUFjMkFnQkJrSlhBQUVHUWxjQUFLQUlBSUFScUlnQTJBZ0FnQnlBQVFRRnlOZ0lFSUFZUXRBRWhBd3dIQzBHUWxjQUFJQUFnQkdzaUFUWUNBRUdZbGNBQVFaaVZ3QUFvQWdBaUFpQUVFTElCSWdBMkFnQWdBQ0FCUVFGeU5nSUVJQUlnQkJDaUFTQUNFTFFCSVFNTUJndEJ1SlhBQUNBSU5nSUFEQU1MSUFBZ0FDZ0NCQ0FLYWpZQ0JFR1lsY0FBS0FJQVFaQ1Z3QUFvQWdBZ0Ntb1FZd3dEQzBHVWxjQUFJQWMyQWdCQmpKWEFBRUdNbGNBQUtBSUFJQVJxSWdBMkFnQWdCeUFBRUpRQklBWVF0QUVoQXd3REN5QUhJQVFnQUJDR0FTQUVRWUFDVHdSQUlBY2dCQkE3SUFZUXRBRWhBd3dEQ3lBRVFRTjJJZ0JCQTNSQmhKTEFBR29oQWdKL1FmeVJ3QUFvQWdBaUFVRUJJQUIwSWdCeEJFQWdBaWdDQ0F3QkMwSDhrY0FBSUFBZ0FYSTJBZ0FnQWdzaEFDQUNJQWMyQWdnZ0FDQUhOZ0lNSUFjZ0FqWUNEQ0FISUFBMkFnZ2dCaEMwQVNFRERBSUxRYnlWd0FCQi94ODJBZ0JCc0pYQUFDQU1OZ0lBUWFpVndBQWdDallDQUVHa2xjQUFJQWcyQWdCQmtKTEFBRUdFa3NBQU5nSUFRWmlTd0FCQmpKTEFBRFlDQUVHTWtzQUFRWVNTd0FBMkFnQkJvSkxBQUVHVWtzQUFOZ0lBUVpTU3dBQkJqSkxBQURZQ0FFR29rc0FBUVp5U3dBQTJBZ0JCbkpMQUFFR1Vrc0FBTmdJQVFiQ1N3QUJCcEpMQUFEWUNBRUdra3NBQVFaeVN3QUEyQWdCQnVKTEFBRUdza3NBQU5nSUFRYXlTd0FCQnBKTEFBRFlDQUVIQWtzQUFRYlNTd0FBMkFnQkJ0SkxBQUVHc2tzQUFOZ0lBUWNpU3dBQkJ2SkxBQURZQ0FFRzhrc0FBUWJTU3dBQTJBZ0JCMEpMQUFFSEVrc0FBTmdJQVFjU1N3QUJCdkpMQUFEWUNBRUhNa3NBQVFjU1N3QUEyQWdCQjJKTEFBRUhNa3NBQU5nSUFRZFNTd0FCQnpKTEFBRFlDQUVIZ2tzQUFRZFNTd0FBMkFnQkIzSkxBQUVIVWtzQUFOZ0lBUWVpU3dBQkIzSkxBQURZQ0FFSGtrc0FBUWR5U3dBQTJBZ0JCOEpMQUFFSGtrc0FBTmdJQVFleVN3QUJCNUpMQUFEWUNBRUg0a3NBQVFleVN3QUEyQWdCQjlKTEFBRUhza3NBQU5nSUFRWUNUd0FCQjlKTEFBRFlDQUVIOGtzQUFRZlNTd0FBMkFnQkJpSlBBQUVIOGtzQUFOZ0lBUVlTVHdBQkIvSkxBQURZQ0FFR1FrOEFBUVlTVHdBQTJBZ0JCbUpQQUFFR01rOEFBTmdJQVFZeVR3QUJCaEpQQUFEWUNBRUdnazhBQVFaU1R3QUEyQWdCQmxKUEFBRUdNazhBQU5nSUFRYWlUd0FCQm5KUEFBRFlDQUVHY2s4QUFRWlNUd0FBMkFnQkJzSlBBQUVHa2s4QUFOZ0lBUWFTVHdBQkJuSlBBQURZQ0FFRzRrOEFBUWF5VHdBQTJBZ0JCckpQQUFFR2trOEFBTmdJQVFjQ1R3QUJCdEpQQUFEWUNBRUcwazhBQVFheVR3QUEyQWdCQnlKUEFBRUc4azhBQU5nSUFRYnlUd0FCQnRKUEFBRFlDQUVIUWs4QUFRY1NUd0FBMkFnQkJ4SlBBQUVHOGs4QUFOZ0lBUWRpVHdBQkJ6SlBBQURZQ0FFSE1rOEFBUWNTVHdBQTJBZ0JCNEpQQUFFSFVrOEFBTmdJQVFkU1R3QUJCekpQQUFEWUNBRUhvazhBQVFkeVR3QUEyQWdCQjNKUEFBRUhVazhBQU5nSUFRZkNUd0FCQjVKUEFBRFlDQUVIa2s4QUFRZHlUd0FBMkFnQkIrSlBBQUVIc2s4QUFOZ0lBUWV5VHdBQkI1SlBBQURZQ0FFR0FsTUFBUWZTVHdBQTJBZ0JCOUpQQUFFSHNrOEFBTmdJQVFZaVV3QUJCL0pQQUFEWUNBRUg4azhBQVFmU1R3QUEyQWdCQmhKVEFBRUg4azhBQU5nSUFRUWhCQ0JDVkFTRUZRUlJCQ0JDVkFTRUNRUkJCQ0JDVkFTRUJRWmlWd0FBZ0NDQUlFTFFCSWdCQkNCQ1ZBU0FBYXlJQUVMSUJJZ00yQWdCQmtKWEFBQ0FLUVFocUlBRWdBaUFGYW1vZ0FHcHJJZ1UyQWdBZ0F5QUZRUUZ5TmdJRVFRaEJDQkNWQVNFQ1FSUkJDQkNWQVNFQlFSQkJDQkNWQVNFQUlBTWdCUkN5QVNBQUlBRWdBa0VJYTJwcU5nSUVRYlNWd0FCQmdJQ0FBVFlDQUF0QkFDRURRWkNWd0FBb0FnQWlBQ0FFVFEwQVFaQ1Z3QUFnQUNBRWF5SUJOZ0lBUVppVndBQkJtSlhBQUNnQ0FDSUNJQVFRc2dFaUFEWUNBQ0FBSUFGQkFYSTJBZ1FnQWlBRUVLSUJJQUlRdEFFaEF3c2dDMEVRYWlRQUlBTUx1aGdCQjM4Z0FCQk5JZ01nQVNBQkVDUWdBMEVnYWlBQlFSQnFJZ0FnQUJBa1FSZ2hBVUhBQUNFRUFrQURRQUpBSUFNZ0Jtb2lBRUhZQUdvaUJTQUFRVGhxS1FJQU53SUFJQUJCMEFCcUlBQkJNR29wQWdBM0FnQWdBRUhJQUdvZ0FFRW9haWtDQURjQ0FDQUFRVUJySWdJZ0FFRWdhaWtDQURjQ0FDQUNFQndnQWlBQ0tBSUFRWDl6TmdJQUlBQkJ4QUJxSWdnZ0NDZ0NBRUYvY3pZQ0FDQUFRZFFBYWlJSElBY29BZ0JCZjNNMkFnQWdCU0FGS0FJQVFYOXpOZ0lBSUFNZ0JHb2lCU0FGS0FJQVFZQ0FBM00yQWdBZ0F5QUJRWGhxUVE0UUZDQUdRWUFEUmdSQVFRZ2hBRUVBSVFFRFFDQUJRUUZ4QkVBZ0FFSEpBRThOQXlBQVFSOXFJUUFMSUFNZ0FFRUNkR29pQVVFZ2FpSUNJQUlvQWdBaUFrRUVkaUFDYzBHQW5vRDRBSEVpQkNBQ2N5QUVRUVIwY3pZQ0FDQUJJQUVvQWdBaUFrRUVkaUFDYzBHQW1Md1ljU0lFSUFKeklBUkJCSFJ6SWdKQkFuWWdBbk5CZ09hQW1BTnhJZ1FnQW5NZ0JFRUNkSE0yQWdBZ0FTQUJLQUlFSWdKQkJIWWdBbk5CZ0ppOEdIRWlCQ0FDY3lBRVFRUjBjeUlDUVFKMklBSnpRWURtZ0pnRGNTSUVJQUp6SUFSQkFuUnpOZ0lFSUFFZ0FTZ0NDQ0lDUVFSMklBSnpRWUNZdkJoeElnUWdBbk1nQkVFRWRITWlBa0VDZGlBQ2MwR0E1b0NZQTNFaUJDQUNjeUFFUVFKMGN6WUNDQ0FCSUFFb0Fnd2lBa0VFZGlBQ2MwR0FtTHdZY1NJRUlBSnpJQVJCQkhSeklnSkJBbllnQW5OQmdPYUFtQU54SWdRZ0FuTWdCRUVDZEhNMkFnd2dBU0FCS0FJUUlnSkJCSFlnQW5OQmdKaThHSEVpQkNBQ2N5QUVRUVIwY3lJQ1FRSjJJQUp6UVlEbWdKZ0RjU0lFSUFKeklBUkJBblJ6TmdJUUlBRWdBU2dDRkNJQ1FRUjJJQUp6UVlDWXZCaHhJZ1FnQW5NZ0JFRUVkSE1pQWtFQ2RpQUNjMEdBNW9DWUEzRWlCQ0FDY3lBRVFRSjBjellDRkNBQklBRW9BaGdpQWtFRWRpQUNjMEdBbUx3WWNTSUVJQUp6SUFSQkJIUnpJZ0pCQW5ZZ0FuTkJnT2FBbUFOeElnUWdBbk1nQkVFQ2RITTJBaGdnQVNBQktBSWNJZ0pCQkhZZ0FuTkJnSmk4R0hFaUJDQUNjeUFFUVFSMGN5SUNRUUoySUFKelFZRG1nSmdEY1NJRUlBSnpJQVJCQW5Sek5nSWNJQUZCSkdvaUFpQUNLQUlBSWdKQkJIWWdBbk5CZ0o2QStBQnhJZ1FnQW5NZ0JFRUVkSE0yQWdBZ0FVRW9haUlDSUFJb0FnQWlBa0VFZGlBQ2MwR0Fub0Q0QUhFaUJDQUNjeUFFUVFSMGN6WUNBQ0FCUVN4cUlnSWdBaWdDQUNJQ1FRUjJJQUp6UVlDZWdQZ0FjU0lFSUFKeklBUkJCSFJ6TmdJQUlBRkJNR29pQWlBQ0tBSUFJZ0pCQkhZZ0FuTkJnSjZBK0FCeElnUWdBbk1nQkVFRWRITTJBZ0FnQVVFMGFpSUNJQUlvQWdBaUFrRUVkaUFDYzBHQW5vRDRBSEVpQkNBQ2N5QUVRUVIwY3pZQ0FDQUJRVGhxSWdJZ0FpZ0NBQ0lDUVFSMklBSnpRWUNlZ1BnQWNTSUVJQUp6SUFSQkJIUnpOZ0lBSUFGQlBHb2lBaUFDS0FJQUlnSkJCSFlnQW5OQmdKNkErQUJ4SWdRZ0FuTWdCRUVFZEhNMkFnQWdBRUhoQUU4TkJDQUJRVUJySWdJZ0FpZ0NBQ0lDUVFSMklBSnpRWUNHdk9BQWNTSUVJQUp6SUFSQkJIUnpJZ0pCQW5ZZ0FuTkJnT2FBbUFOeElnUWdBbk1nQkVFQ2RITTJBZ0FnQVVIRUFHb2lBaUFDS0FJQUlnSkJCSFlnQW5OQmdJYTg0QUJ4SWdRZ0FuTWdCRUVFZEhNaUFrRUNkaUFDYzBHQTVvQ1lBM0VpQkNBQ2N5QUVRUUowY3pZQ0FDQUJRY2dBYWlJQ0lBSW9BZ0FpQWtFRWRpQUNjMEdBaHJ6Z0FIRWlCQ0FDY3lBRVFRUjBjeUlDUVFKMklBSnpRWURtZ0pnRGNTSUVJQUp6SUFSQkFuUnpOZ0lBSUFGQnpBQnFJZ0lnQWlnQ0FDSUNRUVIySUFKelFZQ0d2T0FBY1NJRUlBSnpJQVJCQkhSeklnSkJBbllnQW5OQmdPYUFtQU54SWdRZ0FuTWdCRUVDZEhNMkFnQWdBVUhRQUdvaUFpQUNLQUlBSWdKQkJIWWdBbk5CZ0lhODRBQnhJZ1FnQW5NZ0JFRUVkSE1pQWtFQ2RpQUNjMEdBNW9DWUEzRWlCQ0FDY3lBRVFRSjBjellDQUNBQlFkUUFhaUlDSUFJb0FnQWlBa0VFZGlBQ2MwR0FocnpnQUhFaUJDQUNjeUFFUVFSMGN5SUNRUUoySUFKelFZRG1nSmdEY1NJRUlBSnpJQVJCQW5Sek5nSUFJQUZCMkFCcUlnSWdBaWdDQUNJQ1FRUjJJQUp6UVlDR3ZPQUFjU0lFSUFKeklBUkJCSFJ6SWdKQkFuWWdBbk5CZ09hQW1BTnhJZ1FnQW5NZ0JFRUNkSE0yQWdBZ0FVSGNBR29pQVNBQktBSUFJZ0ZCQkhZZ0FYTkJnSWE4NEFCeElnSWdBWE1nQWtFRWRITWlBVUVDZGlBQmMwR0E1b0NZQTNFaUFpQUJjeUFDUVFKMGN6WUNBRUVCSVFFZ0FFRUJhaUVBREFBTEFBVWdBRUhnQUdvaUJTQUNLQUlBTmdJQUlBQkIvQUJxSUFCQjNBQnFLQUlBTmdJQUlBQkI5QUJxSWdJZ0J5a0NBRGNDQUNBQVFld0FhaUFBUWN3QWFpa0NBRGNDQUNBQVFlUUFhaUlISUFncEFnQTNBZ0FnQlJBY0lBVWdCU2dDQUVGL2N6WUNBQ0FISUFjb0FnQkJmM00yQWdBZ0FpQUNLQUlBUVg5ek5nSUFJQUJCK0FCcUlnQWdBQ2dDQUVGL2N6WUNBQ0FESUFGQkJoQVVJQVJCeEFCcUlRUWdBVUVRYWlFQklBWkJRR3NoQmd3Q0N3QUxDeUFESUFNb0FpQkJmM00yQWlBZ0F5QURLQUlrUVg5ek5nSWtJQU1nQXlnQ05FRi9jellDTkNBRElBTW9BcWdESWdCQkJIWWdBSE5CZ0ppOEdIRWlBU0FBY3lBQlFRUjBjeUlBUVFKMklBQnpRWURtZ0pnRGNTSUJJQUJ6SUFGQkFuUnpOZ0tvQXlBRElBTW9BcXdESWdCQkJIWWdBSE5CZ0ppOEdIRWlBU0FBY3lBQlFRUjBjeUlBUVFKMklBQnpRWURtZ0pnRGNTSUJJQUJ6SUFGQkFuUnpOZ0tzQXlBRElBTW9BckFESWdCQkJIWWdBSE5CZ0ppOEdIRWlBU0FBY3lBQlFRUjBjeUlBUVFKMklBQnpRWURtZ0pnRGNTSUJJQUJ6SUFGQkFuUnpOZ0t3QXlBRElBTW9BcndESWdCQkJIWWdBSE5CZ0ppOEdIRWlBU0FBY3lBQlFRUjBjeUlBUVFKMklBQnpRWURtZ0pnRGNTSUJJQUJ6SUFGQkFuUnpOZ0s4QXlBREtBS2dBeUVBSUFNb0FxUURJUUVnQXlnQ3RBTWhBaUFES0FLNEF5RUVJQU1nQXlnQ09FRi9jellDT0NBRElBTW9Ba0JCZjNNMkFrQWdBeUFES0FKRVFYOXpOZ0pFSUFNZ0F5Z0NWRUYvY3pZQ1ZDQURJQU1vQWxoQmYzTTJBbGdnQXlBREtBSmdRWDl6TmdKZ0lBTWdBeWdDWkVGL2N6WUNaQ0FESUFNb0FuUkJmM00yQW5RZ0F5QURLQUo0UVg5ek5nSjRJQU1nQXlnQ2dBRkJmM00yQW9BQklBTWdBeWdDaEFGQmYzTTJBb1FCSUFNZ0F5Z0NsQUZCZjNNMkFwUUJJQU1nQXlnQ21BRkJmM00yQXBnQklBTWdBeWdDb0FGQmYzTTJBcUFCSUFNZ0F5Z0NwQUZCZjNNMkFxUUJJQU1nQXlnQ3RBRkJmM00yQXJRQklBTWdBeWdDdUFGQmYzTTJBcmdCSUFNZ0F5Z0N3QUZCZjNNMkFzQUJJQU1nQXlnQ3hBRkJmM00yQXNRQklBTWdBeWdDMUFGQmYzTTJBdFFCSUFNZ0F5Z0MyQUZCZjNNMkF0Z0JJQU1nQXlnQzRBRkJmM00yQXVBQklBTWdBeWdDNUFGQmYzTTJBdVFCSUFNZ0F5Z0M5QUZCZjNNMkF2UUJJQU1nQXlnQytBRkJmM00yQXZnQklBTWdBeWdDZ0FKQmYzTTJBb0FDSUFNZ0F5Z0NoQUpCZjNNMkFvUUNJQU1nQXlnQ2xBSkJmM00yQXBRQ0lBTWdBeWdDbUFKQmYzTTJBcGdDSUFNZ0F5Z0NvQUpCZjNNMkFxQUNJQU1nQXlnQ3BBSkJmM00yQXFRQ0lBTWdBeWdDdEFKQmYzTTJBclFDSUFNZ0F5Z0N1QUpCZjNNMkFyZ0NJQU1nQXlnQ3dBSkJmM00yQXNBQ0lBTWdBeWdDeEFKQmYzTTJBc1FDSUFNZ0F5Z0MxQUpCZjNNMkF0UUNJQU1nQXlnQzJBSkJmM00yQXRnQ0lBTWdBeWdDNEFKQmYzTTJBdUFDSUFNZ0F5Z0M1QUpCZjNNMkF1UUNJQU1nQXlnQzlBSkJmM00yQXZRQ0lBTWdBeWdDK0FKQmYzTTJBdmdDSUFNZ0F5Z0NnQU5CZjNNMkFvQURJQU1nQXlnQ2hBTkJmM00yQW9RRElBTWdBeWdDbEFOQmYzTTJBcFFESUFNb0FwZ0RJUVlnQXlBRUlBUWdCRUVFZG5OQmdKaThHSEVpQlhNZ0JVRUVkSE1pQkVFQ2RpQUVjMEdBNW9DWUEzRWlCU0FFY3lBRlFRSjBjMEYvY3pZQ3VBTWdBeUFDSUFJZ0FrRUVkbk5CZ0ppOEdIRWlCSE1nQkVFRWRITWlBa0VDZGlBQ2MwR0E1b0NZQTNFaUJDQUNjeUFFUVFKMGMwRi9jellDdEFNZ0F5QUJJQUVnQVVFRWRuTkJnSmk4R0hFaUFuTWdBa0VFZEhNaUFVRUNkaUFCYzBHQTVvQ1lBM0VpQWlBQmN5QUNRUUowYzBGL2N6WUNwQU1nQXlBQUlBQWdBRUVFZG5OQmdKaThHSEVpQVhNZ0FVRUVkSE1pQUVFQ2RpQUFjMEdBNW9DWUEzRWlBU0FBY3lBQlFRSjBjMEYvY3pZQ29BTWdBeUFHUVg5ek5nS1lBeUFESUFNb0FzQURRWDl6TmdMQUF5QURJQU1vQXNRRFFYOXpOZ0xFQXlBRElBTW9BdFFEUVg5ek5nTFVBeUFESUFNb0F0Z0RRWDl6TmdMWUF3OExJQUJCR0dvUVp3QUwvQkVCRW44akFFRWdheUlDSkFBZ0FpQUFLQUxNQXlBQlFSeHFLQUFBSWdNZ0FTZ0FEQ0lFUVFGMmMwSFZxdFdxQlhFaUNpQURjeUlESUFGQkdHb29BQUFpQ1NBQktBQUlJZ1pCQVhaelFkV3ExYW9GY1NJSElBbHpJZ2xCQW5aelFiUG16SmtEY1NJSUlBTnpJZ01nQVVFVWFpZ0FBQ0lGSUFFb0FBUWlDMEVCZG5OQjFhclZxZ1Z4SWcwZ0JYTWlCU0FCS0FBUUlnd2dBU2dBQUNJT1FRRjJjMEhWcXRXcUJYRWlFQ0FNY3lJTVFRSjJjMEd6NXN5WkEzRWlEeUFGY3lJRlFRUjJjMEdQbnJ6NEFIRWlFVUVFZENBRmMzTTJBZ3dnQWlBQUtBTEVBeUFJUVFKMElBbHpJZ2tnRDBFQ2RDQU1jeUlJUVFSMmMwR1Bucno0QUhFaUJVRUVkQ0FJYzNNMkFnUWdBaUFBS0FMSUF5QUVJQXBCQVhSeklnUWdCaUFIUVFGMGN5SUtRUUoyYzBHejVzeVpBM0VpQmlBRWN5SUVJQXNnRFVFQmRITWlCeUFPSUJCQkFYUnpJZ2hCQW5aelFiUG16SmtEY1NJTElBZHpJZ2RCQkhaelFZK2V2UGdBY1NJTlFRUjBJQWR6Y3pZQ0NDQUNJQUFvQXRBRElBWkJBblFnQ25NaUNpQUxRUUowSUFoeklnWkJCSFp6UVkrZXZQZ0FjU0lISUFwemN6WUNFQ0FDSUFBb0FzQURJQWRCQkhRZ0JuTnpOZ0lBSUFJZ0FDZ0MxQU1nQlNBSmMzTTJBaFFnQWlBQUtBTFlBeUFFSUExemN6WUNHQ0FDSUFBb0F0d0RJQU1nRVhOek5nSWNJQUlRR0NBQ0tBSWNJZ05CQkhZZ0EzTkJnSjZBK0FCeElnUWdBM01nQkVFRWRITWhDU0FDS0FJWUlnTkJCSFlnQTNOQmdKNkErQUJ4SWdRZ0EzTWdCRUVFZEhNaEJpQUNLQUlVSWdOQkJIWWdBM05CZ0o2QStBQnhJZ1FnQTNNZ0JFRUVkSE1oQnlBQ0tBSVFJZ05CQkhZZ0EzTkJnSjZBK0FCeElnUWdBM01nQkVFRWRITWhDQ0FDS0FJTUlnTkJCSFlnQTNOQmdKNkErQUJ4SWdRZ0EzTWdCRUVFZEhNaEJTQUNLQUlJSWdOQkJIWWdBM05CZ0o2QStBQnhJZ1FnQTNNZ0JFRUVkSE1oQ3lBQ0tBSUVJZ05CQkhZZ0EzTkJnSjZBK0FCeElnUWdBM01nQkVFRWRITWhEU0FDS0FJQUlnTkJCSFlnQTNOQmdKNkErQUJ4SWdRZ0EzTWdCRUVFZEhNaERFRUFJUXBCMEFBaEJBSkFBa0FEUUFKQUlBSWdEQ0FBSUFwcUlnTkJvQU5xS0FJQWN6WUNBQ0FDSUEwZ0EwR2tBMm9vQWdCek5nSUVJQUlnQ3lBRFFhZ0RhaWdDQUhNMkFnZ2dBaUFGSUFOQnJBTnFLQUlBY3pZQ0RDQUNJQWdnQTBHd0Eyb29BZ0J6TmdJUUlBSWdCeUFEUWJRRGFpZ0NBSE0yQWhRZ0FpQUdJQU5CdUFOcUtBSUFjellDR0NBQ0lBa2dBMEc4QTJvb0FnQnpOZ0ljSUFJUUdpQUNFQmdnQ2tHQWZVWU5BQ0FDSUFJb0Fod2dBMEdjQTJvb0FnQnpJZ1pCR0hjZ0JuTWlDU0FDS0FJUUlBTkJrQU5xS0FJQWN5SUlRUmgzSUFoeklnMGdBaWdDRkNBRFFaUURhaWdDQUhNaUIzTWlESE1pQ3lBQ0tBSVlJQU5CbUFOcUtBSUFjeUlGUVJoM0lBVnpJZzRnQm5NaUJuTWdDMEVRZDNNMkFod2dBaUFKSUFJb0FnQWdBMEdBQTJvb0FnQnpJZ3R6SWhBZ0JTQUhRUmgzSUFkeklnOXpJZ2NnQzBFWWR5QUxjeUlMY3lJRmN5QUZRUkIzY3pZQ0FDQUNJQTRnQ0NBQ0tBSU1JQU5CakFOcUtBSUFjeUlGUVJoM0lBVnpJaEZ6SUFsekloSnpJZ2dnQjNNZ0NFRVFkM00yQWhnZ0FpQU1JQVVnQWlnQ0NDQURRWWdEYWlnQ0FITWlDRUVZZHlBSWN5SU9jeUFKY3lJVElBWWdEM056SWdWeklBVkJFSGR6TmdJVUlBSWdFaUFHSUFkeklnd2dEU0FJSUFJb0FnUWdBMEdFQTJvb0FnQnpJZ1ZCR0hjZ0JYTWlEM01pQ0hOeklnMXpJQTFCRUhkek5nSVFJQUlnQlNBTGN5QUpjeUlKSUFjZ0VYTnpJZ2NnRTNNZ0IwRVFkM00yQWd3Z0FpQUdJQTV6SUJCeklnWWdDSE1nQmtFUWQzTTJBZ2dnQWlBSklBd2dEM01pQm5NZ0JrRVFkM00yQWdRZ0FoQVlJQUlnQWlnQ0FDQURRZUFDYWlnQ0FITTJBZ0FnQWlBQ0tBSUVJQU5CNUFKcUtBSUFjellDQkNBQ0lBSW9BZ2dnQTBIb0Ftb29BZ0J6TmdJSUlBSWdBaWdDRENBRFFld0NhaWdDQUhNMkFnd2dBaUFDS0FJUUlBTkI4QUpxS0FJQWN6WUNFQ0FDSUFJb0FoUWdBMEgwQW1vb0FnQnpOZ0lVSUFJZ0FpZ0NHQ0FEUWZnQ2FpZ0NBSE0yQWhnZ0FpQUNLQUljSUFOQi9BSnFLQUlBY3pZQ0hDQUNFQnNnQWhBWUlBUkJDR29nQkVrTkFpQUNJQUlvQWdBZ0EwSEFBbW9vQWdCek5nSUFJQUlnQWlnQ0JDQURRY1FDYWlnQ0FITTJBZ1FnQWlBQ0tBSUlJQU5CeUFKcUtBSUFjellDQ0NBQ0lBSW9BZ3dnQTBITUFtb29BZ0J6TmdJTUlBSWdBaWdDRUNBRFFkQUNhaWdDQUhNMkFoQWdBaUFDS0FJVUlBTkIxQUpxS0FJQWN6WUNGQ0FDSUFJb0FoZ2dBMEhZQW1vb0FnQnpOZ0lZSUFJZ0FpZ0NIQ0FEUWR3Q2FpZ0NBSE0yQWh3Z0FoQWdJQUlRR0NBS1FjQjlSZzBESUFSQllHb2hCQ0FLUVlCL2FpRUtJQUlvQWh3aENTQUNLQUlZSVFZZ0FpZ0NGQ0VISUFJb0FoQWhDQ0FDS0FJTUlRVWdBaWdDQ0NFTElBSW9BZ1FoRFNBQ0tBSUFJUXdNQVFzTElBRkJIR29nQWlnQ0hDQUFLQUljY3lJRElBSW9BaGdnQUNnQ0dITWlCRUVCZG5OQjFhclZxZ1Z4SWdvZ0EzTWlBeUFDS0FJVUlBQW9BaFJ6SWdrZ0FpZ0NFQ0FBS0FJUWN5SUdRUUYyYzBIVnF0V3FCWEVpQnlBSmN5SUpRUUoyYzBHejVzeVpBM0VpQ0NBRGN5SURJQUlvQWd3Z0FDZ0NESE1pQlNBQ0tBSUlJQUFvQWdoeklndEJBWFp6UWRXcTFhb0ZjU0lOSUFWeklnVWdBaWdDQkNBQUtBSUVjeUlNSUFJb0FnQWdBQ2dDQUhNaUFFRUJkbk5CMWFyVnFnVnhJZzRnREhNaURFRUNkbk5CcytiTW1RTnhJaEFnQlhNaUJVRUVkbk5CajU2OCtBQnhJZzhnQTNNMkFBQWdBVUVZYWlBSVFRSjBJQWx6SWdNZ0VFRUNkQ0FNY3lJSlFRUjJjMEdQbnJ6NEFIRWlDQ0FEY3pZQUFDQUJRUlJxSUE5QkJIUWdCWE0yQUFBZ0FVRU1haUFLUVFGMElBUnpJZ01nQjBFQmRDQUdjeUlFUVFKMmMwR3o1c3laQTNFaUNpQURjeUlESUExQkFYUWdDM01pQmlBT1FRRjBJQUJ6SWdCQkFuWnpRYlBtekprRGNTSUhJQVp6SWdaQkJIWnpRWStldlBnQWNTSUZJQU56TmdBQUlBRWdDRUVFZENBSmN6WUFFQ0FCSUFwQkFuUWdCSE1pQXlBSFFRSjBJQUJ6SWdCQkJIWnpRWStldlBnQWNTSUVJQU56TmdBSUlBRWdCVUVFZENBR2N6WUFCQ0FCSUFSQkJIUWdBSE0yQUFBZ0FrRWdhaVFBRHdzZ0JDQUVRUWhxUWFDS3dBQVFhQUFMUVhnZ0JFR1Fpc0FBRUdnQUM2SUlBZ3QvQW40akFFRWdheUlHSkFBZ0JFRUFOZ0lBQWtBQ1FBSitBa0FDUUNBQlFRaHFLQUlBSWdoQkFFNEVRQ0FEUVFBZ0Foc2hDeUFJRFFFZ0JrRUFOZ0lJSUFZZ0NEWUNCQ0FHUVFFMkFnQWdBU2dDQUNFTkRBSUxFSGtBQ3dKQUlBaEJBUkNhQVNJREJFQWdCa0VBTmdJSUlBWWdBellDQUNBR0lBZzJBZ1FnQVNnQ0FDSU5JQWhxSVE5Q0FTRVNJQTBoQ0FOQUFuOGdDQ3dBQUNJRFFYOUtCRUFnQTBIL0FYRWhBeUFJUVFGcURBRUxJQWd0QUFGQlAzRWhDaUFEUVI5eElRNGdBMEZmVFFSQUlBNUJCblFnQ25JaEF5QUlRUUpxREFFTElBZ3RBQUpCUDNFZ0NrRUdkSEloQ2lBRFFYQkpCRUFnQ2lBT1FReDBjaUVESUFoQkEyb01BUXNnRGtFU2RFR0FnUEFBY1NBSUxRQURRVDl4SUFwQkJuUnljaUlEUVlDQXhBQkdEUVFnQ0VFRWFnc2hDQUpBQW44Q1FBSkFBa0FDUUFKQUFrQUNRQ0FKUVFGckRnSUNBUUFMSUJCRlFRQWdBMEV0UmhzTkFpQURRVkJxSWdsQkNra05BeUFEUWYzLy93QnhRU3hHRFFSQkFDRUpJQU5CQ1VZTkJ5QURRU0JIRFFvTUJ3c2dBMEZRYWlJSlFRcFBCRUJCQWlFSklBTkJDVVlnQTBFZ1JuSWdBMEg5Ly84QWNVRXNSbklOQnd3S0N5QUVJQXhCQVdvaUREWUNBQ0FDUVFGR1FRQWdEQ0FMU3hzTkNpQVJRZ3ArSUJJZ0NhMUMvd0dEZm53aEVTQUdLQUlFSUFkR0JIOGdCaUFIRUVrZ0JpZ0NDQVVnQndzZ0JpZ0NBR29nQXpvQUFBd0VDd0pBSUFOQlVHb2lDVUVLVHdSQUlBTkIvZi8vQUhGQkxFWU5BVUVCSVFrZ0EwRUpSZzBISUFOQklFY05DZ3dIQ3lBUlFncCtJQklnQ2ExQy93R0RmbndoRVNBR0tBSUVJQWRHQkg4Z0JpQUhFRWtnQmlnQ0NBVWdCd3NnQmlnQ0FHb2dBem9BQUVFQkRBVUxJQVlvQWdRZ0IwWUVmeUFHSUFjUVNTQUdLQUlJQlNBSEN5QUdLQUlBYWtFdU9nQUFEQU1MSUFZb0FnUWdCMFlFZnlBR0lBY1FTU0FHS0FJSUJTQUhDeUFHS0FJQWFrRXRPZ0FBUW44aEVrRUJJUkJCQUF3REN5QVNJQW10UXY4QmczNGdFWHdoRVNBR0tBSUVJQWRHQkg4Z0JpQUhFRWtnQmlnQ0NBVWdCd3NnQmlnQ0FHb2dBem9BQUVFQkRBSUxJQVlvQWdRZ0IwWUVmeUFHSUFjUVNTQUdLQUlJQlNBSEN5QUdLQUlBYWtFdU9nQUFDMEVDQ3lFSklBWWdCaWdDQ0VFQmFpSUhOZ0lJQ3lBSUlBOUhEUUFMREFJTElBaEJBUkN2QVFBTFFnRU1BUXNDUUNBTElBeE5EUUFnQ3lBTWF5SUNRUTVOQkVBZ0JDQUxOZ0lBSUFKQkEzUkJ3SVRBQUdvcEF3QWdFWDRoRVF3QkN5QUNRUTlCeklYQUFCQmxBQXNnQlEwQlFnQUxJUklnQmlnQ0JFVU5BU0FHS0FJQUVCQU1BUXNnQmtFWWFpSUNJQVpCQ0dvb0FnQTJBZ0FnQmlBR0tRTUFOd01RSUFWQkJHb29BZ0FFUUNBRktBSUFFQkFMSUFVZ0Jpa0RFRGNDQUNBRlFRaHFJQUlvQWdBMkFnQkNBQ0VTQ3lBQlFRUnFLQUlBQkVBZ0RSQVFDeUFBSUJFM0F3Z2dBQ0FTTndNQUlBWkJJR29rQUF2L0J3RUlmd0pBQWtBZ0FFRURha0Y4Y1NJQ0lBQnJJZ01nQVVzZ0EwRUVTM0lOQUNBQklBTnJJZ1pCQkVrTkFDQUdRUU54SVFkQkFDRUJBa0FnQTBVTkFDQURRUU54SVFnQ1FDQUNJQUJCZjNOcVFRTkpCRUFnQUNFQ0RBRUxJQU5CZkhFaEJDQUFJUUlEUUNBQklBSXNBQUJCdjM5S2FpQUNRUUZxTEFBQVFiOS9TbW9nQWtFQ2Fpd0FBRUcvZjBwcUlBSkJBMm9zQUFCQnYzOUthaUVCSUFKQkJHb2hBaUFFUVh4cUlnUU5BQXNMSUFoRkRRQURRQ0FCSUFJc0FBQkJ2MzlLYWlFQklBSkJBV29oQWlBSVFYOXFJZ2dOQUFzTElBQWdBMm9oQUFKQUlBZEZEUUFnQUNBR1FYeHhhaUlDTEFBQVFiOS9TaUVGSUFkQkFVWU5BQ0FGSUFJc0FBRkJ2MzlLYWlFRklBZEJBa1lOQUNBRklBSXNBQUpCdjM5S2FpRUZDeUFHUVFKMklRTWdBU0FGYWlFRUEwQWdBQ0VCSUFORkRRSWdBMEhBQVNBRFFjQUJTUnNpQlVFRGNTRUdJQVZCQW5RaEJ3SkFJQVZCL0FGeElnaEJBblFpQUVVRVFFRUFJUUlNQVFzZ0FDQUJhaUVKUVFBaEFpQUJJUUFEUUNBQ0lBQW9BZ0FpQWtGL2MwRUhkaUFDUVFaMmNrR0Jnb1FJY1dvZ0FFRUVhaWdDQUNJQ1FYOXpRUWQySUFKQkJuWnlRWUdDaEFoeGFpQUFRUWhxS0FJQUlnSkJmM05CQjNZZ0FrRUdkbkpCZ1lLRUNIRnFJQUJCREdvb0FnQWlBa0YvYzBFSGRpQUNRUVoyY2tHQmdvUUljV29oQWlBQVFSQnFJZ0FnQ1VjTkFBc0xJQUVnQjJvaEFDQURJQVZySVFNZ0FrRUlka0gvZ2Z3SGNTQUNRZitCL0FkeGFrR0JnQVJzUVJCMklBUnFJUVFnQmtVTkFBc2dBU0FJUVFKMGFpRUFJQVpCLy8vLy93TnFJZ05CLy8vLy93TnhJZ0ZCQVdvaUFrRURjUUpBSUFGQkEwa0VRRUVBSVFJTUFRc2dBa0g4Ly8vL0IzRWhBVUVBSVFJRFFDQUNJQUFvQWdBaUFrRi9jMEVIZGlBQ1FRWjJja0dCZ29RSWNXb2dBRUVFYWlnQ0FDSUNRWDl6UVFkMklBSkJCblp5UVlHQ2hBaHhhaUFBUVFocUtBSUFJZ0pCZjNOQkIzWWdBa0VHZG5KQmdZS0VDSEZxSUFCQkRHb29BZ0FpQWtGL2MwRUhkaUFDUVFaMmNrR0Jnb1FJY1dvaEFpQUFRUkJxSVFBZ0FVRjhhaUlCRFFBTEN3UkFJQU5CZ1lDQWdIeHFJUUVEUUNBQ0lBQW9BZ0FpQWtGL2MwRUhkaUFDUVFaMmNrR0Jnb1FJY1dvaEFpQUFRUVJxSVFBZ0FVRi9haUlCRFFBTEN5QUNRUWgyUWYrQi9BZHhJQUpCLzRIOEIzRnFRWUdBQkd4QkVIWWdCR29QQ3lBQlJRUkFRUUFQQ3lBQlFRTnhJUUlDUUNBQlFYOXFRUU5KQkVBTUFRc2dBVUY4Y1NFQkEwQWdCQ0FBTEFBQVFiOS9TbW9nQUVFQmFpd0FBRUcvZjBwcUlBQkJBbW9zQUFCQnYzOUthaUFBUVFOcUxBQUFRYjkvU21vaEJDQUFRUVJxSVFBZ0FVRjhhaUlCRFFBTEN5QUNSUTBBQTBBZ0JDQUFMQUFBUWI5L1Ntb2hCQ0FBUVFGcUlRQWdBa0YvYWlJQ0RRQUxDeUFFQzRjSEFRVi9JQUFRdFFFaUFDQUFFS3NCSWdJUXNnRWhBUUpBQWtBQ1FDQUFFS3dCRFFBZ0FDZ0NBQ0VEQWtBZ0FCQ2hBVVVFUUNBQ0lBTnFJUUlnQUNBREVMTUJJZ0JCbEpYQUFDZ0NBRWNOQVNBQktBSUVRUU54UVFOSERRSkJqSlhBQUNBQ05nSUFJQUFnQWlBQkVJWUJEd3NnQWlBRGFrRVFhaUVBREFJTElBTkJnQUpQQkVBZ0FCQThEQUVMSUFCQkRHb29BZ0FpQkNBQVFRaHFLQUlBSWdWSEJFQWdCU0FFTmdJTUlBUWdCVFlDQ0F3QkMwSDhrY0FBUWZ5UndBQW9BZ0JCZmlBRFFRTjJkM0UyQWdBTEFrQWdBUkNlQVFSQUlBQWdBaUFCRUlZQkRBRUxBa0FDUUFKQVFaaVZ3QUFvQWdBZ0FVY0VRQ0FCUVpTVndBQW9BZ0JIRFFGQmxKWEFBQ0FBTmdJQVFZeVZ3QUJCakpYQUFDZ0NBQ0FDYWlJQk5nSUFJQUFnQVJDVUFROExRWmlWd0FBZ0FEWUNBRUdRbGNBQVFaQ1Z3QUFvQWdBZ0Ftb2lBVFlDQUNBQUlBRkJBWEkyQWdRZ0FFR1VsY0FBS0FJQVJnMEJEQUlMSUFFUXF3RWlBeUFDYWlFQ0FrQWdBMEdBQWs4RVFDQUJFRHdNQVFzZ0FVRU1haWdDQUNJRUlBRkJDR29vQWdBaUFVY0VRQ0FCSUFRMkFnd2dCQ0FCTmdJSURBRUxRZnlSd0FCQi9KSEFBQ2dDQUVGK0lBTkJBM1ozY1RZQ0FBc2dBQ0FDRUpRQklBQkJsSlhBQUNnQ0FFY05Ba0dNbGNBQUlBSTJBZ0FNQXd0QmpKWEFBRUVBTmdJQVFaU1Z3QUJCQURZQ0FBdEJ0SlhBQUNnQ0FDQUJUdzBCUVlDQWZFRUlRUWdRbFFGQkZFRUlFSlVCYWtFUVFRZ1FsUUZxYTBGM2NVRjlhaUlBUVFCQkVFRUlFSlVCUVFKMGF5SUJJQUVnQUVzYlJRMEJRWmlWd0FBb0FnQkZEUUZCQ0VFSUVKVUJJUUJCRkVFSUVKVUJJUUZCRUVFSUVKVUJJUUpCQUFKQVFaQ1Z3QUFvQWdBaUJDQUNJQUVnQUVFSWEycHFJZ0pORFFCQm1KWEFBQ2dDQUNFQlFhU1Z3QUFoQUFKQUEwQWdBQ2dDQUNBQlRRUkFJQUFRb3dFZ0FVc05BZ3NnQUNnQ0NDSUFEUUFMUVFBaEFBc2dBQkN0QVEwQUlBQkJER29vQWdBYURBQUxRUUFRUFd0SERRRkJrSlhBQUNnQ0FFRzBsY0FBS0FJQVRRMEJRYlNWd0FCQmZ6WUNBQThMSUFKQmdBSkpEUUVnQUNBQ0VEdEJ2SlhBQUVHOGxjQUFLQUlBUVg5cUlnQTJBZ0FnQUEwQUVEMGFEd3NQQ3lBQ1FRTjJJZ05CQTNSQmhKTEFBR29oQVFKL1FmeVJ3QUFvQWdBaUFrRUJJQU4wSWdOeEJFQWdBU2dDQ0F3QkMwSDhrY0FBSUFJZ0EzSTJBZ0FnQVFzaEF5QUJJQUEyQWdnZ0F5QUFOZ0lNSUFBZ0FUWUNEQ0FBSUFNMkFnZ0w4Z1lCQm44Q1FBSkFBa0FDUUFKQUlBQW9BZ2dpQ0VFQlIwRUFJQUFvQWhBaUJFRUJSeHRGQkVBZ0JFRUJSdzBESUFFZ0Ftb2hCeUFBUVJScUtBSUFJZ1lOQVNBQklRUU1BZ3NnQUNnQ0dDQUJJQUlnQUVFY2FpZ0NBQ2dDREJFREFDRUREQU1MSUFFaEJBTkFJQVFpQXlBSFJnMENBbjhnQTBFQmFpQURMQUFBSWdSQmYwb05BQm9nQTBFQ2FpQUVRV0JKRFFBYUlBTkJBMm9nQkVGd1NRMEFHaUFFUWY4QmNVRVNkRUdBZ1BBQWNTQURMUUFEUVQ5eElBTXRBQUpCUDNGQkJuUWdBeTBBQVVFL2NVRU1kSEp5Y2tHQWdNUUFSZzBESUFOQkJHb0xJZ1FnQlNBRGEyb2hCU0FHUVg5cUlnWU5BQXNMSUFRZ0IwWU5BQ0FFTEFBQUlnTkJmMG9nQTBGZ1NYSWdBMEZ3U1hKRkJFQWdBMEgvQVhGQkVuUkJnSUR3QUhFZ0JDMEFBMEUvY1NBRUxRQUNRVDl4UVFaMElBUXRBQUZCUDNGQkRIUnljbkpCZ0lERUFFWU5BUXNDUUFKQUlBVkZCRUJCQUNFRURBRUxJQVVnQWs4RVFFRUFJUU1nQlNBQ0lnUkdEUUVNQWd0QkFDRURJQVVpQkNBQmFpd0FBRUZBU0EwQkN5QUVJUVVnQVNFREN5QUZJQUlnQXhzaEFpQURJQUVnQXhzaEFRc2dDRVVOQVNBQVFReHFLQUlBSVFjQ1FDQUNRUkJQQkVBZ0FTQUNFQThoQkF3QkN5QUNSUVJBUVFBaEJBd0JDeUFDUVFOeElRVUNRQ0FDUVg5cVFRTkpCRUJCQUNFRUlBRWhBd3dCQ3lBQ1FYeHhJUVpCQUNFRUlBRWhBd05BSUFRZ0F5d0FBRUcvZjBwcUlBTkJBV29zQUFCQnYzOUthaUFEUVFKcUxBQUFRYjkvU21vZ0EwRURhaXdBQUVHL2YwcHFJUVFnQTBFRWFpRURJQVpCZkdvaUJnMEFDd3NnQlVVTkFBTkFJQVFnQXl3QUFFRy9mMHBxSVFRZ0EwRUJhaUVESUFWQmYyb2lCUTBBQ3dzZ0J5QUVTd1JBUVFBaEF5QUhJQVJySWdRaEJnSkFBa0FDUUVFQUlBQXRBQ0FpQlNBRlFRTkdHMEVEY1VFQmF3NENBQUVDQzBFQUlRWWdCQ0VEREFFTElBUkJBWFloQXlBRVFRRnFRUUYySVFZTElBTkJBV29oQXlBQVFSeHFLQUlBSVFRZ0FDZ0NCQ0VGSUFBb0FoZ2hBQUpBQTBBZ0EwRi9haUlEUlEwQklBQWdCU0FFS0FJUUVRQUFSUTBBQzBFQkR3dEJBU0VESUFWQmdJREVBRVlOQVNBQUlBRWdBaUFFS0FJTUVRTUFEUUZCQUNFREEwQWdBeUFHUmdSQVFRQVBDeUFEUVFGcUlRTWdBQ0FGSUFRb0FoQVJBQUJGRFFBTElBTkJmMm9nQmtrUEN3d0JDeUFERHdzZ0FDZ0NHQ0FCSUFJZ0FFRWNhaWdDQUNnQ0RCRURBQXY4QmdJTGZ3TitJd0JCOEFCcklnTWtBQUpBQWtBQ1FDQUFSUTBBSUFBb0FnQWlCRUYvUmcwQklBQWdCRUVCYWpZQ0FDQUJSUTBBSUFFb0FnQWlCRUYvUmcwQklBRWdCRUVCYWpZQ0FDQUNSUTBBSUFJb0FnQU5BU0FDUVg4MkFnQWdBVUVJYWlJRUtRTUFJUTRnQkNnQ0NDRUZJQU5CTEdvaUNpQUVRUXhxSWdzUWJTQURJQVUyQWlnZ0F5QU9Od01nSUFRcEF4Z2hEeUFFS0FJZ0lRVWdBMEhFQUdvZ0JFRWthaUlHRUcwZ0F5QUZOZ0pBSUFNZ0R6Y0RPQ0FBUVFocUlnZEJER29oQ1NBQ1FRaHFJUVVnQjBFVWFpZ0NBQ0lJSUFOQk5Hb29BZ0JIRFFJZ0NTZ0NBQ0FES0FJc0lnd2dDQkN3QVEwQ0lBUXBBeGdoRGlBRUtBSWdJUWdnQTBIY0FHb2lEU0FHRUcwZ0F5QUlOZ0pZSUFNZ0RqY0RVQ0FEUVRCcUlnWW9BZ0FFUUNBTUVCQUxJQVlnQTBIZ0FHb3BBd0EzQXdBZ0EwRW9haUFEUWRnQWFpSUdLUU1BTndNQUlBTWdBeWtEVURjRElDQUVLUU1BSVE0Z0JDZ0NDQ0VFSUEwZ0N4QnRJQU1nQkRZQ1dDQURJQTQzQTFBZ0EwSElBR29vQWdBRVFDQURLQUpFRUJBTElBTkJ5QUJxSUFOQjRBQnFLUU1BTndNQUlBTkJRR3NnQmlrREFEY0RBQ0FESUFNcEExQTNBemdnQXlrRElDRU9EQUlMRUtnQkFBc1FxUUVBQ3lBSEtRTUFJUkFnQnlnQ0NDRUVJQU5CM0FCcUlBa1FiU0FESUFRMkFsZ2dBeUFRTndOUUlBVkJFR29pQkNnQ0FBUkFJQVVvQWd3UUVBc2dCU0FES1FOUU53TUFJQVFnQTBIZ0FHb3BBd0EzQXdBZ0JVRUlhaUFEUWRnQWFpa0RBRGNEQUFKQUlBTXBBemdpRDFCRkJFQWdEaUFRZmlJT1FvQ0FnSUNBZ0lDQWdIOVNJQTlDZjFKeURRRkJnSUxBQUVFd1FjQ0N3QUFRZFFBTFFjQ0J3QUJCT1VIQWdzQUFFSFVBQ3lBRklBNGdEaUFQZnlJT0lBOStmVGNEQUNBREtBSW9JUVFnQTBFVWFpQUtFRzBnQXlBT053TUlJQU1nQkRZQ0VDQURRY2dBYWlnQ0FBUkFJQU1vQWtRUUVBc2dBMEV3YWlnQ0FBUkFJQU1vQWl3UUVBc2dBa0VBTmdJQUlBRWdBU2dDQUVGL2FqWUNBQ0FBSUFBb0FnQkJmMm8yQWdBZ0EwSGtBR29nQTBFWWFpa0RBRGNDQUNBRFFkd0FhaUFEUVJCcUtRTUFOd0lBSUFNZ0F5a0RDRGNDVkVFZ1FRZ1FtZ0VpQUFSQUlBQkJBRFlDQUNBQUlBTXBBbEEzQWdRZ0FFRU1haUFEUWRnQWFpa0NBRGNDQUNBQVFSUnFJQU5CNEFCcUtRSUFOd0lBSUFCQkhHb2dBMEhvQUdvb0FnQTJBZ0FnQTBId0FHb2tBQ0FBRHd0QklFRUlFSzhCQUF2Q0JRRUhmMEVyUVlDQXhBQWdBQ2dDQUNJRFFRRnhJZ1FiSVFZZ0FpQUVhaUVFUWN5TndBQkJBQ0FEUVFSeEd5RUhBa0FDUUNBQUtBSUlSUVJBUVFFaEF5QUFJQVlnQnhCekRRRU1BZ3NDUUFKQUFrQUNRQ0FBUVF4cUtBSUFJZ1VnQkVzRVFDQUFMUUFBUVFoeERRUkJBQ0VESUFVZ0JHc2lCQ0VGUVFFZ0FDMEFJQ0lJSUFoQkEwWWJRUU54UVFGckRnSUJBZ01MUVFFaEF5QUFJQVlnQnhCekRRUU1CUXRCQUNFRklBUWhBd3dCQ3lBRVFRRjJJUU1nQkVFQmFrRUJkaUVGQ3lBRFFRRnFJUU1nQUVFY2FpZ0NBQ0VJSUFBb0FnUWhCQ0FBS0FJWUlRa0NRQU5BSUFOQmYyb2lBMFVOQVNBSklBUWdDQ2dDRUJFQUFFVU5BQXRCQVE4TFFRRWhBeUFFUVlDQXhBQkdEUUVnQUNBR0lBY1FjdzBCSUFBb0FoZ2dBU0FDSUFBb0Fod29BZ3dSQXdBTkFTQUFLQUljSVFFZ0FDZ0NHQ0VBUVFBaEF3Si9BMEFnQlNBRElBVkdEUUVhSUFOQkFXb2hBeUFBSUFRZ0FTZ0NFQkVBQUVVTkFBc2dBMEYvYWdzZ0JVa2hBd3dCQ3lBQUtBSUVJUWdnQUVFd05nSUVJQUF0QUNBaENVRUJJUU1nQUVFQk9nQWdJQUFnQmlBSEVITU5BRUVBSVFNZ0JTQUVheUlFSVFVQ1FBSkFBa0JCQVNBQUxRQWdJZ1lnQmtFRFJodEJBM0ZCQVdzT0FnQUJBZ3RCQUNFRklBUWhBd3dCQ3lBRVFRRjJJUU1nQkVFQmFrRUJkaUVGQ3lBRFFRRnFJUU1nQUVFY2FpZ0NBQ0VHSUFBb0FnUWhCQ0FBS0FJWUlRY0NRQU5BSUFOQmYyb2lBMFVOQVNBSElBUWdCaWdDRUJFQUFFVU5BQXRCQVE4TFFRRWhBeUFFUVlDQXhBQkdEUUFnQUNnQ0dDQUJJQUlnQUNnQ0hDZ0NEQkVEQUEwQUlBQW9BaHdoQWlBQUtBSVlJUU5CQUNFQkFrQURRQ0FCSUFWR0RRRWdBVUVCYWlFQklBTWdCQ0FDS0FJUUVRQUFSUTBBQzBFQklRTWdBVUYvYWlBRlNRMEJDeUFBSUFrNkFDQWdBQ0FJTmdJRVFRQVBDeUFERHdzZ0FDZ0NHQ0FCSUFJZ0FFRWNhaWdDQUNnQ0RCRURBQXVlQndFRGZ3SkFBa0FnQVVFUWF5SUVRZmdBVHcwQUFrQkIrQUFnQVUwTkFDQUFJQUZCQW5ScUlnTWdBQ0FFUVFKMGFpZ0NBQ0FES0FJQUlBSjRRWU9HakJoeGN5SURRUUowUWZ6NTgyZHhJQU56SUFOQkJIUkI4T0hEaDM5eGN5QURRUVowUWNDQmc0WjhjWE0yQWdBZ0FVRUJhaUlEUVJCcklnUkIrQUJQRFFGQkFFSDRBQ0FCYXlJRklBVkIrQUJMR3lJRlFRRkdCRUFnQXlFQkRBRUxJQUFnQTBFQ2RHb2lBeUFBSUFSQkFuUnFLQUlBSUFNb0FnQWdBbmhCZzRhTUdIRnpJZ05CQW5SQi9QbnpaM0VnQTNNZ0EwRUVkRUh3NGNPSGYzRnpJQU5CQm5SQndJR0Robnh4Y3pZQ0FDQUJRUUpxSWdOQkVHc2lCRUg0QUU4TkFTQUZRUUpHQkVBZ0F5RUJEQUVMSUFBZ0EwRUNkR29pQXlBQUlBUkJBblJxS0FJQUlBTW9BZ0FnQW5oQmc0YU1HSEZ6SWdOQkFuUkIvUG56WjNFZ0EzTWdBMEVFZEVIdzRjT0hmM0Z6SUFOQkJuUkJ3SUdEaG54eGN6WUNBQ0FCUVFOcUlnTkJFR3NpQkVINEFFOE5BU0FGUVFOR0JFQWdBeUVCREFFTElBQWdBMEVDZEdvaUF5QUFJQVJCQW5ScUtBSUFJQU1vQWdBZ0FuaEJnNGFNR0hGeklnTkJBblJCL1BuelozRWdBM01nQTBFRWRFSHc0Y09IZjNGeklBTkJCblJCd0lHRGhueHhjellDQUNBQlFRUnFJZ05CRUdzaUJFSDRBRThOQVNBRlFRUkdCRUFnQXlFQkRBRUxJQUFnQTBFQ2RHb2lBeUFBSUFSQkFuUnFLQUlBSUFNb0FnQWdBbmhCZzRhTUdIRnpJZ05CQW5SQi9QbnpaM0VnQTNNZ0EwRUVkRUh3NGNPSGYzRnpJQU5CQm5SQndJR0Robnh4Y3pZQ0FDQUJRUVZxSWdOQkVHc2lCRUg0QUU4TkFTQUZRUVZHQkVBZ0F5RUJEQUVMSUFBZ0EwRUNkR29pQXlBQUlBUkJBblJxS0FJQUlBTW9BZ0FnQW5oQmc0YU1HSEZ6SWdOQkFuUkIvUG56WjNFZ0EzTWdBMEVFZEVIdzRjT0hmM0Z6SUFOQkJuUkJ3SUdEaG54eGN6WUNBQ0FCUVFacUlnTkJFR3NpQkVINEFFOE5BU0FGUVFaR0JFQWdBeUVCREFFTElBQWdBMEVDZEdvaUF5QUFJQVJCQW5ScUtBSUFJQU1vQWdBZ0FuaEJnNGFNR0hGeklnTkJBblJCL1BuelozRWdBM01nQTBFRWRFSHc0Y09IZjNGeklBTkJCblJCd0lHRGhueHhjellDQUNBQlFRZHFJZ0ZCRUdzaUJFSDRBRThOQVNBRlFRZEhEUUlMSUFGQitBQkJ3SXJBQUJCbEFBc2dCRUg0QUVHd2lzQUFFR1VBQ3lBQUlBRkJBblJxSWdFZ0FDQUVRUUowYWlnQ0FDQUJLQUlBSUFKNFFZT0dqQmh4Y3lJQVFRSjBRZno1ODJkeElBQnpJQUJCQkhSQjhPSERoMzl4Y3lBQVFRWjBRY0NCZzRaOGNYTTJBZ0FMc0FZQ0NYOEJmaU1BUVVCcUlnTWtBQ0FEUVNCcUlBRVFiU0FES0FJZ0lRZ2dBeWdDS0NJSklRSURRQ0FFSUFocUlRWUNRQ0FDUVFoUEJFQWdBMEVZYWlBR0lBSVFNeUFES0FJY0lRSWdBeWdDR0NFRURBRUxJQUpGQkVCQkFDRUNRUUFoQkF3QkMwRUFJUVVDUUNBR0xRQUFRU0JHRFFCQkFDRUVJQUpCQVVZTkFVRUJJUVVnQmkwQUFVRWdSZzBBSUFKQkFrWU5BVUVDSVFVZ0JpMEFBa0VnUmcwQUlBSkJBMFlOQVVFRElRVWdCaTBBQTBFZ1JnMEFJQUpCQkVZTkFVRUVJUVVnQmkwQUJFRWdSZzBBSUFKQkJVWU5BVUVGSVFVZ0JpMEFCVUVnUmcwQUlBSkJCa1lOQVVFR0lRVWdCaTBBQmtFZ1J3MEJDMEVCSVFRZ0JTRUNDd0pBSUFSQkFVY05BRUVBSVFRZ0FpQUhhaUlDUVFGcUlnY2dBazhFUUFKQUlBa2dCMGtpQlEwQUlBSWdDR29pQ2kwQUFFRWdSdzBBQWtBQ1FDQUpJQWROQkVBZ0J5QUpSZzBCREFJTElBY2dDR29zQUFCQnYzOU1EUUVMQWtBQ1FDQUpJQWRySWdSQkFFNEVRQ0FFRFFGQkFTRUNEQUlMRUhrQUN5QUVRUUVRbWdFaUFnMEFJQVJCQVJDdkFRQUxJQU1nQnpZQ0tDQUNJQWNnQ0dvaUJTQUVFTEVCSVFsQmZ5RUdBa0FDUUNBS0xBQUFJZ0pCZjBvTkFDQUNRVDl4QW44Z0JVRithaTBBQUNJQ1FSaDBRUmgxSWdoQnYzOUtCRUFnQWtFZmNRd0JDeUFJUVQ5eEFuOGdCVUY5YWkwQUFDSUNRUmgwUVJoMUlnaEJRRTRFUUNBQ1FROXhEQUVMSUFoQlAzRWdCVUY4YWkwQUFFRUhjVUVHZEhJTFFRWjBjZ3RCQm5SeUlnSkJnSURFQUVZTkFTQUNRWUFCU1EwQVFYNGhCaUFDUVlBUVNRMEFRWDFCZkNBQ1FZQ0FCRWtiSVFZTElBTWdCaUFIYWpZQ0tBc2dBMEVBTmdJc0lBTkJNR29nQTBFZ2FoQnRJQU5CQ0dvZ0EwRXdha0VBSUFJZ0EwRXNha0VBRUE0Z0F5a0RDS2RGQkVBZ0F5a0RFQ0VMSUFBZ0NUWUNEQ0FBSUFNb0FpdzJBZ2dnQUVFVWFpQUVOZ0lBSUFCQkVHb2dCRFlDQUNBQUlBczNBd0FnQXlnQ0pBUkFJQU1vQWlBUUVBc2dBVUVFYWlnQ0FBUkFJQUVvQWdBUUVBc2dBMEZBYXlRQUR3c2dBMEV3YWtHY2dNQUFFRndBQzBIUWdzQUFRU3RCeUlQQUFCQjFBQXNnQnlFRUlBVU5BUXNnQ1NBRWF5RUNEQUVMQzBIWWc4QUFRU3RCaklEQUFCQjFBQXY3QmdFR2Z3SkFBa0FDUUNBQ1FRbFBCRUFnQXlBQ0VDVWlBZzBCUVFBUEMwRUFJUUpCZ0lCOFFRaEJDQkNWQVVFVVFRZ1FsUUZxUVJCQkNCQ1ZBV3ByUVhkeFFYMXFJZ0ZCQUVFUVFRZ1FsUUZCQW5ScklnVWdCU0FCU3hzZ0EwME5BVUVRSUFOQkJHcEJFRUVJRUpVQlFYdHFJQU5MRzBFSUVKVUJJUVVnQUJDMUFTSUJJQUVRcXdFaUJoQ3lBU0VFQWtBQ1FBSkFBa0FDUUFKQUFrQWdBUkNoQVVVRVFDQUdJQVZQRFFFZ0JFR1lsY0FBS0FJQVJnMENJQVJCbEpYQUFDZ0NBRVlOQXlBRUVKNEJEUWNnQkJDckFTSUhJQVpxSWdnZ0JVa05CeUFJSUFWcklRWWdCMEdBQWtrTkJDQUVFRHdNQlFzZ0FSQ3JBU0VFSUFWQmdBSkpEUVlnQkNBRlFRUnFUMEVBSUFRZ0JXdEJnWUFJU1JzTkJTQUJLQUlBSWdZZ0JHcEJFR29oQnlBRlFSOXFRWUNBQkJDVkFTRUVRUUFpQlVVTkJpQUZJQVpxSWdFZ0JDQUdheUlBUVhCcUlnSTJBZ1FnQVNBQ0VMSUJRUWMyQWdRZ0FTQUFRWFJxRUxJQlFRQTJBZ1JCbkpYQUFFR2NsY0FBS0FJQUlBUWdCMnRxSWdBMkFnQkJ1SlhBQUVHNGxjQUFLQUlBSWdJZ0JTQUZJQUpMR3pZQ0FFR2dsY0FBUWFDVndBQW9BZ0FpQWlBQUlBSWdBRXNiTmdJQURBa0xJQVlnQldzaUJFRVFRUWdRbFFGSkRRUWdBU0FGRUxJQklRWWdBU0FGRUg4Z0JpQUVFSDhnQmlBRUVCNE1CQXRCa0pYQUFDZ0NBQ0FHYWlJR0lBVk5EUVFnQVNBRkVMSUJJUVFnQVNBRkVIOGdCQ0FHSUFWcklnVkJBWEkyQWdSQmtKWEFBQ0FGTmdJQVFaaVZ3QUFnQkRZQ0FBd0RDMEdNbGNBQUtBSUFJQVpxSWdZZ0JVa05Bd0pBSUFZZ0JXc2lCRUVRUVFnUWxRRkpCRUFnQVNBR0VIOUJBQ0VFUVFBaEJnd0JDeUFCSUFVUXNnRWlCaUFFRUxJQklRY2dBU0FGRUg4Z0JpQUVFSlFCSUFjZ0J5Z0NCRUYrY1RZQ0JBdEJsSlhBQUNBR05nSUFRWXlWd0FBZ0JEWUNBQXdDQ3lBRVFReHFLQUlBSWdrZ0JFRUlhaWdDQUNJRVJ3UkFJQVFnQ1RZQ0RDQUpJQVEyQWdnTUFRdEIvSkhBQUVIOGtjQUFLQUlBUVg0Z0IwRURkbmR4TmdJQUN5QUdRUkJCQ0JDVkFVOEVRQ0FCSUFVUXNnRWhCQ0FCSUFVUWZ5QUVJQVlRZnlBRUlBWVFIZ3dCQ3lBQklBZ1Fmd3NnQVEwREN5QURFQXNpQlVVTkFTQUZJQUFnQXlBQkVLc0JRWGhCZkNBQkVLRUJHMm9pQVNBQklBTkxHeEN4QVNBQUVCQVBDeUFDSUFBZ0F5QUJJQUVnQTBzYkVMRUJHaUFBRUJBTElBSVBDeUFCRUtFQkdpQUJFTFFCQzVnRkFRZC9Ba0FDZndKQUlBQWdBV3NnQWtrRVFDQUJJQUpxSVFVZ0FDQUNhaUVESUFBZ0FrRVBUUTBDR2lBRFFYeHhJUUJCQUNBRFFRTnhJZ1pySVFjZ0JnUkFJQUVnQW1wQmYyb2hCQU5BSUFOQmYyb2lBeUFFTFFBQU9nQUFJQVJCZjJvaEJDQUFJQU5KRFFBTEN5QUFJQUlnQm1zaUJrRjhjU0lDYXlFRFFRQWdBbXNoQWlBRklBZHFJZ1ZCQTNFRVFDQUNRWDlLRFFJZ0JVRURkQ0lFUVJoeElRY2dCVUY4Y1NJSVFYeHFJUUZCQUNBRWEwRVljU0VKSUFnb0FnQWhCQU5BSUFCQmZHb2lBQ0FFSUFsMElBRW9BZ0FpQkNBSGRuSTJBZ0FnQVVGOGFpRUJJQUFnQTBzTkFBc01BZ3NnQWtGL1NnMEJJQUVnQm1wQmZHb2hBUU5BSUFCQmZHb2lBQ0FCS0FJQU5nSUFJQUZCZkdvaEFTQUFJQU5MRFFBTERBRUxBa0FnQWtFUFRRUkFJQUFoQXd3QkN5QUFRUUFnQUd0QkEzRWlCV29oQkNBRkJFQWdBQ0VESUFFaEFBTkFJQU1nQUMwQUFEb0FBQ0FBUVFGcUlRQWdBMEVCYWlJRElBUkpEUUFMQ3lBRUlBSWdCV3NpQWtGOGNTSUdhaUVEQWtBZ0FTQUZhaUlGUVFOeEJFQWdCa0VCU0EwQklBVkJBM1FpQUVFWWNTRUhJQVZCZkhFaUNFRUVhaUVCUVFBZ0FHdEJHSEVoQ1NBSUtBSUFJUUFEUUNBRUlBQWdCM1lnQVNnQ0FDSUFJQWwwY2pZQ0FDQUJRUVJxSVFFZ0JFRUVhaUlFSUFOSkRRQUxEQUVMSUFaQkFVZ05BQ0FGSVFFRFFDQUVJQUVvQWdBMkFnQWdBVUVFYWlFQklBUkJCR29pQkNBRFNRMEFDd3NnQWtFRGNTRUNJQVVnQm1vaEFRc2dBa1VOQWlBQ0lBTnFJUUFEUUNBRElBRXRBQUE2QUFBZ0FVRUJhaUVCSUFOQkFXb2lBeUFBU1EwQUN3d0NDeUFHUVFOeElnQkZEUUVnQWlBRmFpRUZJQU1nQUdzTElRQWdCVUYvYWlFQkEwQWdBMEYvYWlJRElBRXRBQUE2QUFBZ0FVRi9haUVCSUFBZ0Ewa05BQXNMQzl3RUFSMS9JQUFnQUNnQ0dDSUJJQUFvQWdRaUJITWlDeUFBS0FJVUlnSWdBQ2dDRENJSGMzTWlEQ0FBS0FJUUlnVWdCM01pQXlBRUlBQW9BZ0FpQm5NaUNITWlGWElnQVNBRmN5SUtJQU1nQm5NaUUzRnpJQVVnQUNnQ0hDSUZjeUlQSUFGekloQWdCM01pRnlBRElBUWdBQ2dDQ0NJRWN5SU5jeUlXY1NBQklBVnpJZ0VnQmlBSGN5SUdjeUlISUJaekloZ2dBM0VpRG5NaUNYTWlFU0FKSUE4Z0VIRWdBU0FJY3lJWklBb2dBaUFFY3lJSmN5SWFjU0lTSUFjZ0RYTnpjM01pRFhFaUJDQU9JQUVnQjNGekloUWdDQ0FLY3lJT0lBSnpJaHNnQmlBTGN5SWNjU0FNSUJWeElBSWdBM056YzNNaUFuTWdEU0FVSUE0Z0JTQUpjeUlVY1NBR2N5QVNjM01pQlhNaUMzRWdCWE1pQmlBQ0lCRnpJZ2tnQkNBRmMzRWdBbk1pQ0hNaUVpQURjU0lkSUFnZ0RuRWlEbk1nQ0NBRklCRnhJQWx4SUFRZ0NYTnpJZ056SWdVZ0dYRWdBU0FDSUExeElBdHhJQVFnQzNOeklnRWdBM01pQW5FaUVYTWlEWE0yQWdBZ0FDQVNJQmh4SUIxeklnc2dEQ0FCSUFaeklneHhJZ1FnQVNBVGNTSUpJQU1nRUhGekloQWdCaUFjY1hOemN5SVRJQWdnRkhFaUNDQURJQTl4Y3lJUElBSWdCM0VpQXlBQklBcHhJZ0Z6Y3lBTmMzTTJBaGdnQUNBQ0lCSnpJZ0lnRjNFaUJ5QURjeUlLSUFFZ0RDQVZjU0lCY3lBTGN5SU1jeUlESUFRZ0JpQWJjU0lHYzNNMkFod2dBQ0FCSUE0Z0QzTWlBWE1nRTNNZ0NuTTJBaFFnQUNBRklCcHhJZ29nQ0hNZ0EzTTJBaEFnQUNBQ0lCWnhJQWx6SUF4eklnSWdBU0FHSUFweklnRWdFWE56Y3pZQ0RDQUFJQUVnRUhNZ0EzTTJBZ2dnQUNBRUlBZHpJQUp6TmdJRUM5Z0VBZ1IvQVg0akFFSHdBR3NpQXlRQUFrQUNRQ0FBQkVBZ0FDZ0NBQ0lFUVg5R0RRRkJBU0VGSUFBZ0JFRUJhallDQUNBQVFSQnFLQUlBSVFRZ0FDa0RDQ0VISUFOQnpBQnFJQUJCRkdvUWJTQURJQVEyQWtnZ0F5QUhOd05BSUFNZ0FqWUNFQ0FESUFJMkFnd2dBeUFCTmdJSUlBQkJDR29oQVNBRFFUQnFJQU5CUUdzZ0EwRUlhaEJBQWtBZ0F5Z0NNRVVFUUNBRFFUaHFLQUlBSVFZZ0F5Z0NOQ0VDSUFOQlBHb29BZ0FpQkNBQktBSWdSZ1JBSUFJZ0FTZ0NHQ0FFRUxBQlFRQkhJUVVMSUFOQktHb2dCRFlDQUNBRFFTUnFJQVkyQWdBZ0EwRVlhaUFEUWRBQWFpa0RBRGNEQUNBRFFSQnFJQU5CeUFCcUtRTUFOd01BSUFNZ0F5a0RRRGNEQ0NBRElBVTZBQ3dnQXlBQ05nSWdEQUVMSUFOQkVHb2dBMEhJQUdvcEF3QTNBd0FnQTBFWWFpQURRZEFBYWlrREFEY0RBQ0FESUFNcEEwQTNBd2dnQXlnQ05DRUNJQU5CSUdvZ0FVRVlhaEJ0SUFOQkFEb0FMQ0FDUVNSSkRRQWdBaEFBQ3lBQUlBQW9BZ0JCZjJvMkFnQWdBMEhrQUdvZ0EwRW9haWtEQURjQ0FDQURRZHdBYWlBRFFTQnFLUU1BTndJQUlBTkIxQUJxSUFOQkdHb3BBd0EzQWdBZ0EwSE1BR29nQTBFUWFpa0RBRGNDQUNBRElBTXBBd2czQWtSQk1FRUlFSm9CSWdCRkRRSWdBRUVBTmdJQUlBQWdBeWtDUURjQ0JDQUFRUXhxSUFOQnlBQnFLUUlBTndJQUlBQkJGR29nQTBIUUFHb3BBZ0EzQWdBZ0FFRWNhaUFEUWRnQWFpa0NBRGNDQUNBQVFTUnFJQU5CNEFCcUtRSUFOd0lBSUFCQkxHb2dBMEhvQUdvb0FnQTJBZ0FnQTBId0FHb2tBQ0FBRHdzUXFBRUFDeENwQVFBTFFUQkJDQkN2QVFBTGxnVUJEbjhnQUNBQUtBSWNJZ05CRm5kQnYvNzgrUU54SUFOQkhuZEJ3SUdEaG54eGNpQURjeUlFSUFBb0FoQWlBa0VXZDBHLy92ejVBM0VnQWtFZWQwSEFnWU9HZkhGeUlBSnpJZ3NnQUNnQ0ZDSUJjeUlHY3lJRklBTWdBQ2dDR0NJRFFSWjNRYi8rL1BrRGNTQURRUjUzUWNDQmc0WjhjWElnQTNNaUIzTWlDSE1nQlVFTWQwR1Bucno0QUhFZ0JVRVVkMEh3NGNPSGYzRnljellDSENBQUlBUWdBQ2dDQUNJRmN5SU1JQU1nQVNBQlFSWjNRYi8rL1BrRGNTQUJRUjUzUWNDQmc0WjhjWEp6SWdseklnTWdCVUVXZDBHLy92ejVBM0VnQlVFZWQwSEFnWU9HZkhGeUlBVnpJZ1Z6SWdGeklBRkJESGRCajU2OCtBQnhJQUZCRkhkQjhPSERoMzl4Y25NMkFnQWdBQ0FISUFJZ0FDZ0NEQ0lCUVJaM1FiLysvUGtEY1NBQlFSNTNRY0NCZzRaOGNYSWdBWE1pQjNNZ0JITWlDbk1pQWlBRGN5QUNRUXgzUVkrZXZQZ0FjU0FDUVJSM1FmRGh3NGQvY1hKek5nSVlJQUFnQmlBQklBQW9BZ2dpQWtFV2QwRy8vdno1QTNFZ0FrRWVkMEhBZ1lPR2ZIRnlJQUp6SWdaeklBUnpJZzBnQ0NBSmMzTWlBWE1nQVVFTWQwR1Bucno0QUhFZ0FVRVVkMEh3NGNPSGYzRnljellDRkNBQUlBb2dBeUFJY3lJSklBc2dBaUFBS0FJRUlnRkJGbmRCdi83OCtRTnhJQUZCSG5kQndJR0Robnh4Y2lBQmN5SUtjeUlPYzNNaUFuTWdBa0VNZDBHUG5yejRBSEVnQWtFVWQwSHc0Y09IZjNGeWN6WUNFQ0FBSUFFZ0JYTWdCSE1pQWlBRElBZHpjeUlFSUExeklBUkJESGRCajU2OCtBQnhJQVJCRkhkQjhPSERoMzl4Y25NMkFnd2dBQ0FHSUFoeklBeHpJZ1FnRG5NZ0JFRU1kMEdQbnJ6NEFIRWdCRUVVZDBIdzRjT0hmM0Z5Y3pZQ0NDQUFJQWtnQ25NaUFDQUNjeUFBUVF4M1FZK2V2UGdBY1NBQVFSUjNRZkRodzRkL2NYSnpOZ0lFQzRZRkFRNS9JQUFnQUNnQ0hDSURRUkozUVlPR2pCaHhJQU5CR25kQi9QbnpaM0Z5SUFOeklnUWdBQ2dDRUNJQ1FSSjNRWU9HakJoeElBSkJHbmRCL1BuelozRnlJQUp6SWdzZ0FDZ0NGQ0lCY3lJR2N5SUZJQU1nQUNnQ0dDSURRUkozUVlPR2pCaHhJQU5CR25kQi9QbnpaM0Z5SUFOeklnZHpJZ2h6SUFWQkRIZEJqNTY4K0FCeElBVkJGSGRCOE9IRGgzOXhjbk0yQWh3Z0FDQUVJQUFvQWdBaUJYTWlEQ0FESUFFZ0FVRVNkMEdEaG93WWNTQUJRUnAzUWZ6NTgyZHhjbk1pQ1hNaUF5QUZRUkozUVlPR2pCaHhJQVZCR25kQi9QbnpaM0Z5SUFWeklnVnpJZ0Z6SUFGQkRIZEJqNTY4K0FCeElBRkJGSGRCOE9IRGgzOXhjbk0yQWdBZ0FDQUhJQUlnQUNnQ0RDSUJRUkozUVlPR2pCaHhJQUZCR25kQi9QbnpaM0Z5SUFGeklnZHpJQVJ6SWdweklnSWdBM01nQWtFTWQwR1Bucno0QUhFZ0FrRVVkMEh3NGNPSGYzRnljellDR0NBQUlBWWdBU0FBS0FJSUlnSkJFbmRCZzRhTUdIRWdBa0VhZDBIOCtmTm5jWElnQW5NaUJuTWdCSE1pRFNBSUlBbHpjeUlCY3lBQlFReDNRWStldlBnQWNTQUJRUlIzUWZEaHc0ZC9jWEp6TmdJVUlBQWdDaUFESUFoeklna2dDeUFDSUFBb0FnUWlBVUVTZDBHRGhvd1ljU0FCUVJwM1FmejU4MmR4Y2lBQmN5SUtjeUlPYzNNaUFuTWdBa0VNZDBHUG5yejRBSEVnQWtFVWQwSHc0Y09IZjNGeWN6WUNFQ0FBSUFFZ0JYTWdCSE1pQWlBRElBZHpjeUlFSUExeklBUkJESGRCajU2OCtBQnhJQVJCRkhkQjhPSERoMzl4Y25NMkFnd2dBQ0FHSUFoeklBeHpJZ1FnRG5NZ0JFRU1kMEdQbnJ6NEFIRWdCRUVVZDBIdzRjT0hmM0Z5Y3pZQ0NDQUFJQWtnQ25NaUFDQUNjeUFBUVF4M1FZK2V2UGdBY1NBQVFSUjNRZkRodzRkL2NYSnpOZ0lFQzZNRUFSdC9JQUFnQUNnQ0dDSUdJQUFvQWhSeklnTWdBQ2dDQUNJQ2N5SUZJQUFvQWdRaUFYTWlEQ0FGY1NBQklBQW9BaHdpQVhNaUIzTWdCeUFBS0FJUUlnUWdBQ2dDQ0NJS2N5SU5jeUlRSUFBb0FneHpJZ2dnQm5NaUN5QUJJQVJ6SWhGeklnWWdBM01pRWlBSFFYOXpjU0lPY3lBR0lCRnhJZ2tnQXlBSUlBcHpJZ056SWdnZ0JuTWlGeUFOY1hNaUUzTWlEeUFUSUFJZ0EzTWlFeUFNSUFFZ0NuTWlDbk1pR0hFZ0F5QVFjU0lVSUF0emMzTWlGWEVpQ3lBSUlBcHhJQWx6SWdrZ0ZDQUVJQVZ6SWhRZ0FuRWdDbk1nQ0hOemN5SUVjeUFQSUFrZ0FpQUdjeUlKSUFFZ0JYTWlHWEVnQVNBT2MzTnpJZ0Z6Y1NJT0lBdHpJQUZ4SWhZZ0QzTWlEeUFEY1NJYUlBRWdEbk1pQXlBQ2NYTWlEaUFFSUFFZ0MzTWlBU0FFSUJWeklnUnhjeUlDSUFseGN5QUJJQlp6SUFKeElBUnpJZ0VnQW5NaUN5QVNjU0lTY3lJSklBRWdESEZ6SUEwZ0FTQURJQTl6SWd4eklnUWdBaUFEY3lJTmN5SVZjU0FOSUJGeEloRnpJaFp6SWhzZ0VpQUJJQVZ4Y3lJQklCVWdGM0Z6SWdVZ0JDQUljU0FISUF0eElnY2dEbk56Y3lJSWN6WUNCQ0FBSUFjZ0czTTJBZ0FnQUNBV0lBd2dHSEZ6SWdjZ0R5QVFjWE1pRUNBRklBWWdEWEZ6SWdWek5nSWNJQUFnQ0NBQ0lCbHhjeUlHSUFRZ0NuRWdFWE1nQlhOek5nSVVJQUFnRENBVGNTQWFjeUFCY3lBUWN5SUNOZ0lRSUFBZ0J5QURJQlJ4Y3lBR2N6WUNDQ0FBSUFJZ0JYTTJBaGdnQUNBQ0lBbHpOZ0lNQzRFRkFRdC9Jd0JCTUdzaUFpUUFJQUpCSkdwQjdJekFBRFlDQUNBQ1FRTTZBQ2dnQWtLQWdJQ0FnQVEzQXdnZ0FpQUFOZ0lnSUFKQkFEWUNHQ0FDUVFBMkFoQUNRQUpBQWtBZ0FTZ0NDQ0lLUlFSQUlBRkJGR29vQWdBaUJFVU5BU0FCS0FJQUlRTWdBU2dDRUNFQUlBUkJmMnBCLy8vLy93RnhRUUZxSWdjaEJRTkFJQU5CQkdvb0FnQWlCQVJBSUFJb0FpQWdBeWdDQUNBRUlBSW9BaVFvQWd3UkF3QU5CQXNnQUNnQ0FDQUNRUWhxSUFCQkJHb29BZ0FSQUFBTkF5QUFRUWhxSVFBZ0EwRUlhaUVESUFWQmYyb2lCUTBBQ3d3QkN5QUJRUXhxS0FJQUlnQkZEUUFnQUVFRmRDRUxJQUJCZjJwQi8vLy9QM0ZCQVdvaEJ5QUJLQUlBSVFNRFFDQURRUVJxS0FJQUlnQUVRQ0FDS0FJZ0lBTW9BZ0FnQUNBQ0tBSWtLQUlNRVFNQURRTUxJQUlnQlNBS2FpSUVRUnhxTFFBQU9nQW9JQUlnQkVFRWFpa0NBRUlnaVRjRENDQUVRUmhxS0FJQUlRWWdBU2dDRUNFSVFRQWhDVUVBSVFBQ1FBSkFBa0FnQkVFVWFpZ0NBRUVCYXc0Q0FBSUJDeUFHUVFOMElBaHFJZ3dvQWdSQkkwY05BU0FNS0FJQUtBSUFJUVlMUVFFaEFBc2dBaUFHTmdJVUlBSWdBRFlDRUNBRVFSQnFLQUlBSVFBQ1FBSkFBa0FnQkVFTWFpZ0NBRUVCYXc0Q0FBSUJDeUFBUVFOMElBaHFJZ1lvQWdSQkkwY05BU0FHS0FJQUtBSUFJUUFMUVFFaENRc2dBaUFBTmdJY0lBSWdDVFlDR0NBSUlBUW9BZ0JCQTNScUlnQW9BZ0FnQWtFSWFpQUFLQUlFRVFBQURRSWdBMEVJYWlFRElBc2dCVUVnYWlJRlJ3MEFDd3RCQUNFQUlBY2dBU2dDQkVraUEwVU5BU0FDS0FJZ0lBRW9BZ0FnQjBFRGRHcEJBQ0FER3lJQktBSUFJQUVvQWdRZ0FpZ0NKQ2dDREJFREFFVU5BUXRCQVNFQUN5QUNRVEJxSkFBZ0FBdlhCQUVFZnlBQUlBRVFzZ0VoQWdKQUFrQUNRQ0FBRUt3QkRRQWdBQ2dDQUNFREFrQWdBQkNoQVVVRVFDQUJJQU5xSVFFZ0FDQURFTE1CSWdCQmxKWEFBQ2dDQUVjTkFTQUNLQUlFUVFOeFFRTkhEUUpCakpYQUFDQUJOZ0lBSUFBZ0FTQUNFSVlCRHdzZ0FTQURha0VRYWlFQURBSUxJQU5CZ0FKUEJFQWdBQkE4REFFTElBQkJER29vQWdBaUJDQUFRUWhxS0FJQUlnVkhCRUFnQlNBRU5nSU1JQVFnQlRZQ0NBd0JDMEg4a2NBQVFmeVJ3QUFvQWdCQmZpQURRUU4yZDNFMkFnQUxJQUlRbmdFRVFDQUFJQUVnQWhDR0FRd0NDd0pBUVppVndBQW9BZ0FnQWtjRVFDQUNRWlNWd0FBb0FnQkhEUUZCbEpYQUFDQUFOZ0lBUVl5VndBQkJqSlhBQUNnQ0FDQUJhaUlCTmdJQUlBQWdBUkNVQVE4TFFaaVZ3QUFnQURZQ0FFR1FsY0FBUVpDVndBQW9BZ0FnQVdvaUFUWUNBQ0FBSUFGQkFYSTJBZ1FnQUVHVWxjQUFLQUlBUncwQlFZeVZ3QUJCQURZQ0FFR1VsY0FBUVFBMkFnQVBDeUFDRUtzQklnTWdBV29oQVFKQUlBTkJnQUpQQkVBZ0FoQThEQUVMSUFKQkRHb29BZ0FpQkNBQ1FRaHFLQUlBSWdKSEJFQWdBaUFFTmdJTUlBUWdBallDQ0F3QkMwSDhrY0FBUWZ5UndBQW9BZ0JCZmlBRFFRTjJkM0UyQWdBTElBQWdBUkNVQVNBQVFaU1Z3QUFvQWdCSERRRkJqSlhBQUNBQk5nSUFDdzhMSUFGQmdBSlBCRUFnQUNBQkVEc1BDeUFCUVFOMklnSkJBM1JCaEpMQUFHb2hBUUovUWZ5UndBQW9BZ0FpQTBFQklBSjBJZ0p4QkVBZ0FTZ0NDQXdCQzBIOGtjQUFJQUlnQTNJMkFnQWdBUXNoQWlBQklBQTJBZ2dnQWlBQU5nSU1JQUFnQVRZQ0RDQUFJQUkyQWdnTDdnTUNCWDhHZmlNQVFZQUJheUlDSkFBQ1FBSkFBa0FnQUVVTkFDQUFLQUlBSWdOQmYwWU5BU0FBSUFOQkFXbzJBZ0FnQVVVTkFDQUJLQUlBSWdOQmYwWU5BU0FCSUFOQkFXbzJBZ0FnQUNrRENDRUhJQUFvQWhBaEF5QUNRVHhxSUFCQkZHb1FiU0FDUVRocUlnUWdBellDQUNBQ0lBYzNBekFnQVVFUWFpZ0NBQ0VGSUFFcEF3Z2hCeUFDUWRRQWFpSUdJQUZCRkdvUWJTQUNRZEFBYWlJRElBVTJBZ0FnQWtFWWFpQUhOd01BSUFKQkNHb2dCQ2tEQUNJSU53TUFJQUpCRUdvZ0FrRkFheWtEQUNJSk53TUFJQUpCS0dvZ0FrSFlBR29pQkNrREFDSUtOd01BSUFKQklHb2dBeWtEQUNJTE53TUFJQUlnQWlrRE1DSU1Od01BSUFFZ0FTZ0NBRUYvYWpZQ0FDQUFJQUFvQWdCQmYybzJBZ0FnQWtIMEFHb2dDamNDQUNBQ1Fld0FhaUFMTndJQUlBSkI1QUJxSUFjM0FnQWdBa0hjQUdvZ0NUY0NBQ0FHSUFnM0FnQWdBaUFNTndKTVFUaEJDQkNhQVNJQVJRMENJQUJCQURZQ0FDQUFJQUlwQWtnM0FnUWdBRUVNYWlBREtRSUFOd0lBSUFCQkZHb2dCQ2tDQURjQ0FDQUFRUnhxSUFKQjRBQnFLUUlBTndJQUlBQkJKR29nQWtIb0FHb3BBZ0EzQWdBZ0FFRXNhaUFDUWZBQWFpa0NBRGNDQUNBQVFUUnFJQUpCK0FCcUtBSUFOZ0lBSUFKQmdBRnFKQUFnQUE4TEVLZ0JBQXNRcVFFQUMwRTRRUWdRcndFQUMvWURBUTEvSUFBZ0FDZ0NIQ0lCUVJSM1FZK2V2UGdBY1NBQlFSeDNRZkRodzRkL2NYSWdBWE1pQlNBQUtBSVFJZ05CRkhkQmo1NjgrQUJ4SUFOQkhIZEI4T0hEaDM5eGNpQURjeUlHSUFBb0FoUWlBbk1pQjNNaUJDQUJJQUFvQWhnaUFVRVVkMEdQbnJ6NEFIRWdBVUVjZDBIdzRjT0hmM0Z5SUFGeklnaHpJZ2x6SUFSQkVIZHpOZ0ljSUFBZ0JTQUFLQUlBSWdSeklnd2dBU0FDSUFKQkZIZEJqNTY4K0FCeElBSkJISGRCOE9IRGgzOXhjbk1pQ25NaUFTQUVRUlIzUVkrZXZQZ0FjU0FFUVJ4M1FmRGh3NGQvY1hJZ0JITWlCSE1pQW5NZ0FrRVFkM00yQWdBZ0FDQUlJQU1nQUNnQ0RDSUNRUlIzUVkrZXZQZ0FjU0FDUVJ4M1FmRGh3NGQvY1hJZ0FuTWlDSE1nQlhNaUMzTWlBeUFCY3lBRFFSQjNjellDR0NBQUlBY2dBaUFBS0FJSUlnTkJGSGRCajU2OCtBQnhJQU5CSEhkQjhPSERoMzl4Y2lBRGN5SUhjeUFGY3lJTklBa2dDbk56SWdKeklBSkJFSGR6TmdJVUlBQWdDeUFCSUFseklnb2dCaUFESUFBb0FnUWlBa0VVZDBHUG5yejRBSEVnQWtFY2QwSHc0Y09IZjNGeUlBSnpJZ3R6SWdOemN5SUdjeUFHUVJCM2N6WUNFQ0FBSUFJZ0JITWdCWE1pQlNBQklBaHpjeUlCSUExeklBRkJFSGR6TmdJTUlBQWdCeUFKY3lBTWN5SUJJQU56SUFGQkVIZHpOZ0lJSUFBZ0NpQUxjeUlBSUFWeklBQkJFSGR6TmdJRUM4a0RBZ1YvQTM0akFFRVFheUlGSkFBQ1FDQUNRUTVOQkVBZ0FrRURkRUhBaE1BQWFpa0RBQ0lLVUVVRVFBSkFJQUZDZ0lDQWdJQ0FnSUNBZjFGQkFDQUtRbjlSRzBVRVFDQUJJQXAvSVF4QkNrRUJFSm9CSWdaRkRRRWdBRUlLTndJRUlBQWdCallDQUVJQUlBcDlJQW9nQVVJQVV4dENBQ0FNVUJzZ0FYd2lDbEJGQkVBZ0FpQUVJQUlnQXhzaUIyc2hDQ0FEUVFGSElRbEJBQ0VFQTBBZ0NpRUxBa0FDUUFKQUlBUWdDRThFUUNBQ0lBUkhEUUlnQncwQkRBTUxJQXRDQ244aENnd0NDeUFKSUFBb0FnaEZjUVJBREFJTElBVkJMallDRENBQUlBVkJER29RYmd3QkN5QUxRZ3AvSVFvZ0RGQkJBQ0FMUWdsOFFoTlVHMFVFUUNBTElBcENDbjU5SWdzZ0MwSS9oeUlMZkNBTGhhY2lCa0gvQVhFZ0EwRUJSaUFFSUFKUGNuSkZCRUFnQUNnQ0NFVU5BZ3NnQlVFQU5nSU1JQVVnQmtFd2Fqb0FEQ0FBSUFWQkRHb1FiZ3dCQ3lBRlFUQTJBZ3dnQUNBRlFReHFFRzRMSUFSQkFXb2hCQ0FLVUVVTkFBc0xJQUZDQUZrTkJDQUZRUzAyQWd3Z0FDQUZRUXhxRUc0TUJBdEJvSWJBQUVFZlFleUZ3QUFRZFFBTFFRcEJBUkN2QVFBTFFZQ0d3QUJCR1VIc2hjQUFFSFVBQ3lBQ1FROUIzSVhBQUJCbEFBc2dCVUVRYWlRQUM4a0RBZ1YvQm40akFFR0FBV3NpQVNRQUFrQUNRQ0FBQkVBZ0FDZ0NBQ0lDUVg5R0RRRWdBQ0FDUVFGcU5nSUFJQUJCRUdvb0FnQWhBaUFBS1FNSUlRWWdBVUU4YWlBQVFSUnFFRzBnQVVFNGFpSURJQUkyQWdBZ0FTQUdOd013SUFCQklHb3BBd0FoQmlBQVFTaHFLQUlBSVFRZ0FVSFVBR29pQlNBQVFTeHFFRzBnQVVIUUFHb2lBaUFFTmdJQUlBRkJHR29nQmpjREFDQUJRUWhxSUFNcEF3QWlCemNEQUNBQlFSQnFJQUZCUUdzcEF3QWlDRGNEQUNBQlFTaHFJQUZCMkFCcUlnTXBBd0FpQ1RjREFDQUJRU0JxSUFJcEF3QWlDamNEQUNBQklBRXBBekFpQ3pjREFDQUFJQUFvQWdCQmYybzJBZ0FnQVVIMEFHb2dDVGNDQUNBQlFld0FhaUFLTndJQUlBRkI1QUJxSUFZM0FnQWdBVUhjQUdvZ0NEY0NBQ0FGSUFjM0FnQWdBU0FMTndKTVFUaEJDQkNhQVNJQVJRMENJQUJCQURZQ0FDQUFJQUVwQWtnM0FnUWdBRUVNYWlBQ0tRSUFOd0lBSUFCQkZHb2dBeWtDQURjQ0FDQUFRUnhxSUFGQjRBQnFLUUlBTndJQUlBQkJKR29nQVVIb0FHb3BBZ0EzQWdBZ0FFRXNhaUFCUWZBQWFpa0NBRGNDQUNBQVFUUnFJQUZCK0FCcUtBSUFOZ0lBSUFGQmdBRnFKQUFnQUE4TEVLZ0JBQXNRcVFFQUMwRTRRUWdRcndFQUM1NERBZ1YvQkg0akFFSGdBR3NpQVNRQUFrQUNRQ0FBQkVBZ0FDZ0NBQ0lDUVg5R0RRRWdBQ0FDUVFGcU5nSUFJQUJCQ0dvaEFnSitJQUFwQXdnaUJsQkZCRUFnQVVFb2FpQUdJQUlvQWdoQkFDQUJFQ0VnQWlrREFBd0JDeUFCUVFBMkFqQWdBVUlCTndNb1FnQUxJUVlnQUNnQ0VDRURJQUZCeEFCcUlnUWdBa0VNYWhCdElBRkJRR3NpQWlBRE5nSUFJQUZCR0dvZ0FTa0RLQ0lITndNQUlBRkJJR29nQVVFd2FpZ0NBQ0lETmdJQUlBRkJFR29nQVVISUFHb2lCU2tEQUNJSU53TUFJQUZCQ0dvZ0Fpa0RBQ0lKTndNQUlBRWdCamNET0NBQklBWTNBd0FnQUNBQUtBSUFRWDlxTmdJQUlBRkIzQUJxSUFNMkFnQWdBVUhVQUdvZ0J6Y0NBQ0FCUWN3QWFpQUlOd0lBSUFRZ0NUY0NBQ0FCSUFZM0FqeEJNRUVJRUpvQklnQkZEUUlnQUVFQU5nSUFJQUFnQVNrQ09EY0NCQ0FBUVFFNkFDd2dBRUVNYWlBQ0tRSUFOd0lBSUFCQkZHb2dCU2tDQURjQ0FDQUFRUnhxSUFGQjBBQnFLUUlBTndJQUlBQkJKR29nQVVIWUFHb3BBZ0EzQWdBZ0FVSGdBR29rQUNBQUR3c1FxQUVBQ3hDcEFRQUxRVEJCQ0JDdkFRQUxwQU1CRFg4Z0FDQUNLQUFNSWdNZ0FTZ0FEQ0lFUVFGMmMwSFZxdFdxQlhFaUNDQURjeUlESUFJb0FBZ2lCU0FCS0FBSUlnWkJBWFp6UWRXcTFhb0ZjU0lKSUFWeklnVkJBblp6UWJQbXpKa0RjU0lMSUFOeklnTWdBaWdBQkNJSElBRW9BQVFpQ2tFQmRuTkIxYXJWcWdWeElnd2dCM01pQnlBQ0tBQUFJZ0lnQVNnQUFDSUJRUUYyYzBIVnF0V3FCWEVpRFNBQ2N5SUNRUUoyYzBHejVzeVpBM0VpRGlBSGN5SUhRUVIyYzBHUG5yejRBSEVpRHlBRGN6WUNIQ0FBSUFRZ0NFRUJkSE1pQXlBR0lBbEJBWFJ6SWdSQkFuWnpRYlBtekprRGNTSUlJQU56SWdNZ0NpQU1RUUYwY3lJR0lBRWdEVUVCZEhNaUFVRUNkbk5CcytiTW1RTnhJZ2tnQm5NaUJrRUVkbk5CajU2OCtBQnhJZ29nQTNNMkFoZ2dBQ0FMUVFKMElBVnpJZ01nRGtFQ2RDQUNjeUlDUVFSMmMwR1Bucno0QUhFaUJTQURjellDRkNBQUlBOUJCSFFnQjNNMkFnd2dBQ0FJUVFKMElBUnpJZ01nQ1VFQ2RDQUJjeUlCUVFSMmMwR1Bucno0QUhFaUJDQURjellDRUNBQUlBcEJCSFFnQm5NMkFnZ2dBQ0FGUVFSMElBSnpOZ0lFSUFBZ0JFRUVkQ0FCY3pZQ0FBdi9BZ0VEZndKQUFrQUNRQUpBSUFGQkNVOEVRRUVRUVFnUWxRRWdBVXNOQVF3Q0N5QUFFQXNoQXd3Q0MwRVFRUWdRbFFFaEFRdEJnSUI4UVFoQkNCQ1ZBVUVVUVFnUWxRRnFRUkJCQ0JDVkFXcHJRWGR4UVgxcUlnUkJBRUVRUVFnUWxRRkJBblJySWdJZ0FpQUVTeHNnQVdzZ0FFME5BQ0FCUVJBZ0FFRUVha0VRUVFnUWxRRkJlMm9nQUVzYlFRZ1FsUUVpQkdwQkVFRUlFSlVCYWtGOGFoQUxJZ0pGRFFBZ0FoQzFBU0VBQWtBZ0FVRi9haUlESUFKeFJRUkFJQUFoQVF3QkN5QUNJQU5xUVFBZ0FXdHhFTFVCSVFKQkVFRUlFSlVCSVFNZ0FCQ3JBU0FDUVFBZ0FTQUNJQUJySUFOTEcyb2lBU0FBYXlJQ2F5RURJQUFRb1FGRkJFQWdBU0FERUg4Z0FDQUNFSDhnQUNBQ0VCNE1BUXNnQUNnQ0FDRUFJQUVnQXpZQ0JDQUJJQUFnQW1vMkFnQUxJQUVRb1FFTkFTQUJFS3NCSWdKQkVFRUlFSlVCSUFScVRRMEJJQUVnQkJDeUFTRUFJQUVnQkJCL0lBQWdBaUFFYXlJRUVIOGdBQ0FFRUI0TUFRc2dBdzhMSUFFUXRBRWdBUkNoQVJvTG1BTUNBMzhDZmlNQVFVQnFJZ0lrQUFKQUFrQUNRQUpBSUFBRVFDQUFLQUlBSWdOQmYwWU5BU0FBSUFOQkFXbzJBZ0FnQVVRQUFBQUFBQURndzJZaEEwSUFRdi8vLy8vLy8vLy8vd0FDZmlBQm1VUUFBQUFBQUFEZ1EyTUVRQ0FCc0F3QkMwS0FnSUNBZ0lDQWdJQi9DMEtBZ0lDQWdJQ0FnSUIvSUFNYklBRkUvLy8vLy8vLzMwTmtHeUFCSUFGaUd5SUZVQTBDSUFWQ2YxRkJBQ0FBS1FNSUlnWkNnSUNBZ0lDQWdJQ0FmMUViRFFNZ0FDZ0NFQ0VESUFKQkZHb2dBRUVVYWhCdElBSkJFR29pQkNBRE5nSUFJQUFnQUNnQ0FFRi9hallDQUNBQ0lBWWdCWDhpQlRjRENDQUNRVGhxSUFKQkdHb3BBd0EzQWdBZ0FrRXdhaUFFS1FNQU53SUFJQUlnQlRjQ0tFRWdRUWdRbWdFaUFFVU5CQ0FBUVFBMkFnQWdBQ0FDS1FJa053SUVJQUJCREdvZ0FrRXNhaWtDQURjQ0FDQUFRUlJxSUFKQk5Hb3BBZ0EzQWdBZ0FFRWNhaUFDUVR4cUtBSUFOZ0lBSUFKQlFHc2tBQ0FBRHdzUXFBRUFDeENwQVFBTFFlQ0F3QUJCR1VITWdNQUFFSFVBQzBHQWdjQUFRUjlCeklEQUFCQjFBQXRCSUVFSUVLOEJBQXVZQXdJRGZ3SitJd0JCUUdvaUFpUUFBa0FDUUFKQUFrQWdBQVJBSUFBb0FnQWlBMEYvUmcwQklBQWdBMEVCYWpZQ0FDQUJSQUFBQUFBQUFPRERaaUVEUWdCQy8vLy8vLy8vLy8vL0FBSitJQUdaUkFBQUFBQUFBT0JEWXdSQUlBR3dEQUVMUW9DQWdJQ0FnSUNBZ0g4TFFvQ0FnSUNBZ0lDQWdIOGdBeHNnQVVULy8vLy8vLy9mUTJRYklBRWdBV0liSWdWUURRSWdCVUovVVVFQUlBQXBBd2dpQmtLQWdJQ0FnSUNBZ0lCL1VSc05BeUFBS0FJUUlRTWdBa0VVYWlBQVFSUnFFRzBnQWtFUWFpSUVJQU0yQWdBZ0FDQUFLQUlBUVg5cU5nSUFJQUlnQmlBRmdTSUZOd01JSUFKQk9Hb2dBa0VZYWlrREFEY0NBQ0FDUVRCcUlBUXBBd0EzQWdBZ0FpQUZOd0lvUVNCQkNCQ2FBU0lBUlEwRUlBQkJBRFlDQUNBQUlBSXBBaVEzQWdRZ0FFRU1haUFDUVN4cUtRSUFOd0lBSUFCQkZHb2dBa0UwYWlrQ0FEY0NBQ0FBUVJ4cUlBSkJQR29vQWdBMkFnQWdBa0ZBYXlRQUlBQVBDeENvQVFBTEVLa0JBQXRCd0lIQUFFRTVRYkNCd0FBUWRRQUxRWUNDd0FCQk1FR3dnY0FBRUhVQUMwRWdRUWdRcndFQUMrNENBZ04vQW40akFFRkFhaUlDSkFBQ1FBSkFBa0FDUUFKQUlBQkZEUUFnQUNnQ0FDSURRWDlHRFFFZ0FDQURRUUZxTmdJQUlBRkZEUUFnQVNnQ0FDSURRWDlHRFFFZ0FTQURRUUZxTmdJQUlBRXBBd2dpQlZBTkFpQUZRbjlSUVFBZ0FFRUlhaUlES1FNQUlnWkNnSUNBZ0lDQWdJQ0FmMUViRFFNZ0FDZ0NFQ0VFSUFKQkZHb2dBMEVNYWhCdElBRWdBU2dDQUVGL2FqWUNBQ0FDUVJCcUlnRWdCRFlDQUNBQUlBQW9BZ0JCZjJvMkFnQWdBaUFHSUFWL0lnVTNBd2dnQWtFNGFpQUNRUmhxS1FNQU53SUFJQUpCTUdvZ0FTa0RBRGNDQUNBQ0lBVTNBaWhCSUVFSUVKb0JJZ0JGRFFRZ0FFRUFOZ0lBSUFBZ0Fpa0NKRGNDQkNBQVFReHFJQUpCTEdvcEFnQTNBZ0FnQUVFVWFpQUNRVFJxS1FJQU53SUFJQUJCSEdvZ0FrRThhaWdDQURZQ0FDQUNRVUJySkFBZ0FBOExFS2dCQUFzUXFRRUFDMEhnZ01BQVFSbEJvSUhBQUJCMUFBdEJnSUhBQUVFZlFhQ0J3QUFRZFFBTFFTQkJDQkN2QVFBTDdnSUNBMzhDZmlNQVFVQnFJZ0lrQUFKQUFrQUNRQUpBQWtBZ0FFVU5BQ0FBS0FJQUlnTkJmMFlOQVNBQUlBTkJBV28yQWdBZ0FVVU5BQ0FCS0FJQUlnTkJmMFlOQVNBQklBTkJBV28yQWdBZ0FTa0RDQ0lGVUEwQ0lBVkNmMUZCQUNBQVFRaHFJZ01wQXdBaUJrS0FnSUNBZ0lDQWdJQi9VUnNOQXlBQUtBSVFJUVFnQWtFVWFpQURRUXhxRUcwZ0FTQUJLQUlBUVg5cU5nSUFJQUpCRUdvaUFTQUVOZ0lBSUFBZ0FDZ0NBRUYvYWpZQ0FDQUNJQVlnQllFaUJUY0RDQ0FDUVRocUlBSkJHR29wQXdBM0FnQWdBa0V3YWlBQktRTUFOd0lBSUFJZ0JUY0NLRUVnUVFnUW1nRWlBRVVOQkNBQVFRQTJBZ0FnQUNBQ0tRSWtOd0lFSUFCQkRHb2dBa0VzYWlrQ0FEY0NBQ0FBUVJScUlBSkJOR29wQWdBM0FnQWdBRUVjYWlBQ1FUeHFLQUlBTmdJQUlBSkJRR3NrQUNBQUR3c1FxQUVBQ3hDcEFRQUxRY0NCd0FCQk9VR3dnc0FBRUhVQUMwR0Fnc0FBUVRCQnNJTEFBQkIxQUF0QklFRUlFSzhCQUF2eEFnRUJmeU1BUVRCcklnSWtBQ0FDSUFBMkFoUUNRRUVJUVFRUW1nRWlBQVJBSUFBZ0FUWUNCQ0FBUVFFMkFnQWdBRUdVaDhBQVFRa1FDU0VCSUFKQklHcEJsSWZBQURZQ0FDQUNJQUEyQWh3Z0FpQUJOZ0lZSUFKQklUWUNLQ0FDSUFKQkZHb2dBa0VvYWhCeUlBSW9BZ1FoQUFKQUlBSW9BZ0JGQkVBZ0FpQUFOZ0lzSUFKQkxHb29BZ0FRQlVVTkFTQUNJQUlvQWl3MkFnZ2dBa0VJYWlnQ0FDQUNRUmhxS0FJQUVBWWlBRUVrVHdSQUlBQVFBQXNnQWlnQ0NDSUFRU1JKRFFNZ0FCQUFEQU1MSUFCQkpFa05BaUFBRUFBTUFnc2dBaWdDTENJQVFTUkpEUUVnQUJBQURBRUxRUWhCQkJDdkFRQUxJQUpCRUdvZ0FrRWdhaWdDQURZQ0FDQUNJQUlwQXhnM0F3Z2dBaWdDS0NJQVFTUlBCRUFnQUJBQUN5QUNLQUlVSWdCQkpFOEVRQ0FBRUFBTFFSQkJCQkNhQVNJQUJFQWdBRUVBTmdJQUlBQWdBaWtEQ0RjQ0JDQUFRUXhxSUFKQkVHb29BZ0EyQWdBZ0FrRXdhaVFBSUFBUEMwRVFRUVFRcndFQUM5c0NBZ0ovQkg0akFFSGdBR3NpQWlRQUlBSWdBVFlDQ0NBQ0lBRTJBZ1FnQWlBQU5nSUFJQUpCT0dvZ0FoQVZBa0FnQWlrRE9DSUVVRVVFUUNBQ1FTaHFJQVFnQWlnQ1FFRUFJQUlRSVF3QkN5QUNRUUEyQWpBZ0FrSUJOd01vQ3lBQ1FSaHFJQUlwQXlnaUJEY0RBQ0FDUVJCcUlBSkJ5QUJxSWdFcEF3QWlCVGNEQUNBQ1FRaHFJQUpCUUdzaUF5a0RBQ0lHTndNQUlBSkJJR29nQWtFd2FpZ0NBQ0lBTmdJQUlBSWdBaWtET0NJSE53TUFJQUpCM0FCcUlBQTJBZ0FnQWtIVUFHb2dCRGNDQUNBQ1Fjd0FhaUFGTndJQUlBSkJ4QUJxSUFZM0FnQWdBaUFITndJOFFUQkJDQkNhQVNJQVJRUkFRVEJCQ0JDdkFRQUxJQUJCQURZQ0FDQUFJQUlwQWpnM0FnUWdBRUVCT2dBc0lBQkJER29nQXlrQ0FEY0NBQ0FBUVJScUlBRXBBZ0EzQWdBZ0FFRWNhaUFDUWRBQWFpa0NBRGNDQUNBQVFTUnFJQUpCMkFCcUtRSUFOd0lBSUFKQjRBQnFKQUFnQUF2WkFnRUVmeU1BUVRCcklnUWtBQUpBQWtBZ0FRUkFJQUVvQWdBaUJVRi9SZzBCSUFFZ0JVRUJhallDQUNBRUlBRXBBd2dnQVVFUWFpZ0NBQ0lGUVFFZ0F5QUZJQUliRUNFZ0JFRW9haUFFUVFocUtBSUFJZ0kyQWdBZ0JDQUVLUU1BTndNZ0lBUW9BaVFnQWtZRVFDQUVRU0JxSUFKQkFSQklJQVFvQWlnaEFnc2dCQ2dDSUNBQ2FrRWdPZ0FBSUFSQkdHb2dBa0VCYWlJQ05nSUFJQVFnQkNrRElEY0RFQ0FCS0FJVUlRY2dCQ2dDRkNJRklBSnJJQUVvQWh3aUJra0VRQ0FFUVJCcUlBSWdCaEJJSUFRb0FoUWhCU0FFS0FJWUlRSUxJQVFvQWhBaUF5QUNhaUFISUFZUXNRRWFJQUVnQVNnQ0FFRi9hallDQUFKQUlBVWdBaUFHYWlJQlRRUkFJQU1oQWd3QkN5QUJSUVJBUVFFaEFpQURFQkFNQVFzZ0F5QUZRUUVnQVJDV0FTSUNSUTBEQ3lBQUlBRTJBZ1FnQUNBQ05nSUFJQVJCTUdva0FBOExFS2dCQUFzUXFRRUFDeUFCUVFFUXJ3RUFDKzhDQVFOL0l3QkIwQXRySWdja0FBSkFBa0FDUUFKQUFrQUNRQUpBSUFaQkFFZ05BQUpBSUFaRkJFQkJBU0VJREFFTElBWkJBUkNhQVNJSVJRMEVDeUFJSUFVZ0JoQ3hBU0VJSUFSQkVFY2dBa0VnUjNJTkJDQUhRZUFIYWtFRWNpSUNJQUVRRENBSFFZQUVhaUFDUWVBREVMRUJHaUFIUWVBSGFpQUhRWUFFYWtIZ0F4Q3hBUm9nQjBIQUMyb2lBaUFES1FBQU53QUFJQUpCQ0dvZ0EwRUlhaWtBQURjQUFDQUhRUkJxSUFkQjRBZHFRZkFERUxFQkdpQUhRZUFIYWlBSFFSQnFRZkFERUxFQkdpQUhRUWhxSUFkQjRBZHFJQWdnQmhBS0lBY29BZ2dpQ1VVTkJTQUhLQUlNSWdKQkFFZ05BQ0FDRFFGQkFTRUVEQUlMRUhrQUN5QUNRUUVRbWdFaUJFVU5CQXNnQkNBSklBSVFzUUVoQkNBR0JFQWdDQkFRSUFVUUVBc2dBeEFRSUFFUUVDQUFJQUkyQWdRZ0FDQUVOZ0lBSUFkQjBBdHFKQUFQQ3lBR1FRRVFyd0VBQzBIeWhzQUFRUThRcWdFQUMwR0JoOEFBUVJJUXFnRUFDeUFDUVFFUXJ3RUFDOUlDQVFaL0l3QkJNR3NpQWlRQUFrQUNRQ0FCQkVBZ0FTZ0NBQ0lEUVg5R0RRRWdBU0FEUVFGcU5nSUFJQUlnQVNrRENDQUJRUkJxS0FJQVFRQWdBaEFoSUFKQktHb2dBa0VJYWlnQ0FDSUROZ0lBSUFJZ0Fpa0RBRGNESUNBQ0tBSWtJQU5HQkVBZ0FrRWdhaUFEUVFFUVNDQUNLQUlvSVFNTElBSW9BaUFnQTJwQklEb0FBQ0FDUVJocUlBTkJBV29pQXpZQ0FDQUNJQUlwQXlBM0F4QWdBU2dDRkNFSElBSW9BaFFpQkNBRGF5QUJLQUljSWdWSkJFQWdBa0VRYWlBRElBVVFTQ0FDS0FJVUlRUWdBaWdDR0NFREN5QUNLQUlRSWdZZ0Eyb2dCeUFGRUxFQkdpQUJJQUVvQWdCQmYybzJBZ0FDUUNBRUlBTWdCV29pQVUwRVFDQUdJUU1NQVFzZ0FVVUVRRUVCSVFNZ0JoQVFEQUVMSUFZZ0JFRUJJQUVRbGdFaUEwVU5Bd3NnQUNBQk5nSUVJQUFnQXpZQ0FDQUNRVEJxSkFBUEN4Q29BUUFMRUtrQkFBc2dBVUVCRUs4QkFBdlNBZ0VEZnlNQVFSQnJJZ0lrQUFKQUFuOENRQ0FCUVlBQlR3UkFJQUpCQURZQ0RDQUJRWUFRVHcwQklBSWdBVUUvY1VHQUFYSTZBQTBnQWlBQlFRWjJRY0FCY2pvQURFRUNEQUlMSUFBb0FnZ2lBeUFBUVFScUtBSUFSZ1JBSUFBZ0F4QkxJQUFvQWdnaEF3c2dBQ0FEUVFGcU5nSUlJQUFvQWdBZ0Eyb2dBVG9BQUF3Q0N5QUJRWUNBQkU4RVFDQUNJQUZCUDNGQmdBRnlPZ0FQSUFJZ0FVRVNka0h3QVhJNkFBd2dBaUFCUVFaMlFUOXhRWUFCY2pvQURpQUNJQUZCREhaQlAzRkJnQUZ5T2dBTlFRUU1BUXNnQWlBQlFUOXhRWUFCY2pvQURpQUNJQUZCREhaQjRBRnlPZ0FNSUFJZ0FVRUdka0UvY1VHQUFYSTZBQTFCQXdzaEFTQUFRUVJxS0FJQUlBQkJDR29pQkNnQ0FDSURheUFCU1FSQUlBQWdBeUFCRUVvZ0JDZ0NBQ0VEQ3lBQUtBSUFJQU5xSUFKQkRHb2dBUkN4QVJvZ0JDQUJJQU5xTmdJQUN5QUNRUkJxSkFBTHZBSUNCSDhDZmlNQVFVQnFJZ0lrQUFKQUFrQUNRQ0FBUlEwQUlBQW9BZ0FpQTBGL1JnMEJJQUFnQTBFQmFqWUNBQ0FCUlEwQUlBRW9BZ0FpQTBGL1JnMEJJQUVnQTBFQmFqWUNBQ0FCUVFocUlBQkJDR29nQUNrRENDSUdJQUVwQXdnaUIxVWlBeHNpQkNnQ0NDRUZJQUpCRkdvZ0JFRU1haEJ0SUFFZ0FTZ0NBRUYvYWpZQ0FDQUNRUkJxSWdFZ0JUWUNBQ0FBSUFBb0FnQkJmMm8yQWdBZ0FpQUhJQVlnQXhzaUJqY0RDQ0FDUVRocUlBSkJHR29wQXdBM0FnQWdBa0V3YWlBQktRTUFOd0lBSUFJZ0JqY0NLRUVnUVFnUW1nRWlBRVVOQWlBQVFRQTJBZ0FnQUNBQ0tRSWtOd0lFSUFCQkRHb2dBa0VzYWlrQ0FEY0NBQ0FBUVJScUlBSkJOR29wQWdBM0FnQWdBRUVjYWlBQ1FUeHFLQUlBTmdJQUlBSkJRR3NrQUNBQUR3c1FxQUVBQ3hDcEFRQUxRU0JCQ0JDdkFRQUx2QUlDQkg4Q2ZpTUFRVUJxSWdJa0FBSkFBa0FDUUNBQVJRMEFJQUFvQWdBaUEwRi9SZzBCSUFBZ0EwRUJhallDQUNBQlJRMEFJQUVvQWdBaUEwRi9SZzBCSUFFZ0EwRUJhallDQUNBQlFRaHFJQUJCQ0dvZ0FDa0RDQ0lHSUFFcEF3Z2lCMU1pQXhzaUJDZ0NDQ0VGSUFKQkZHb2dCRUVNYWhCdElBRWdBU2dDQUVGL2FqWUNBQ0FDUVJCcUlnRWdCVFlDQUNBQUlBQW9BZ0JCZjJvMkFnQWdBaUFISUFZZ0F4c2lCamNEQ0NBQ1FUaHFJQUpCR0dvcEF3QTNBZ0FnQWtFd2FpQUJLUU1BTndJQUlBSWdCamNDS0VFZ1FRZ1FtZ0VpQUVVTkFpQUFRUUEyQWdBZ0FDQUNLUUlrTndJRUlBQkJER29nQWtFc2Fpa0NBRGNDQUNBQVFSUnFJQUpCTkdvcEFnQTNBZ0FnQUVFY2FpQUNRVHhxS0FJQU5nSUFJQUpCUUdza0FDQUFEd3NRcUFFQUN4Q3BBUUFMUVNCQkNCQ3ZBUUFMdGdJQkIzOENRQ0FDUVE5TkJFQWdBQ0VEREFFTElBQkJBQ0FBYTBFRGNTSUVhaUVGSUFRRVFDQUFJUU1nQVNFR0EwQWdBeUFHTFFBQU9nQUFJQVpCQVdvaEJpQURRUUZxSWdNZ0JVa05BQXNMSUFVZ0FpQUVheUlJUVh4eElnZHFJUU1DUUNBQklBUnFJZ1JCQTNFRVFDQUhRUUZJRFFFZ0JFRURkQ0lDUVJoeElRa2dCRUY4Y1NJR1FRUnFJUUZCQUNBQ2EwRVljU0VDSUFZb0FnQWhCZ05BSUFVZ0JpQUpkaUFCS0FJQUlnWWdBblJ5TmdJQUlBRkJCR29oQVNBRlFRUnFJZ1VnQTBrTkFBc01BUXNnQjBFQlNBMEFJQVFoQVFOQUlBVWdBU2dDQURZQ0FDQUJRUVJxSVFFZ0JVRUVhaUlGSUFOSkRRQUxDeUFJUVFOeElRSWdCQ0FIYWlFQkN5QUNCRUFnQWlBRGFpRUNBMEFnQXlBQkxRQUFPZ0FBSUFGQkFXb2hBU0FEUVFGcUlnTWdBa2tOQUFzTElBQUxyd0lCQlg4Q1FBSkFBa0FDUUNBQlFRTnFRWHh4SUFGcklnTkZEUUFnQWlBRElBTWdBa3NiSWdORkRRQkJBU0VGQTBBZ0FTQUVhaTBBQUVFZ1JnMEVJQU1nQkVFQmFpSUVSdzBBQ3lBRElBSkJlR29pQlVzTkFnd0JDeUFDUVhocUlRVkJBQ0VEQzBHZ3dJQ0JBaUVFQTBBZ0FTQURhaUlHS0FJQVFhREFnSUVDY3lJSFFYOXpJQWRCLy8zN2QycHhJQVpCQkdvb0FnQkJvTUNBZ1FKeklnWkJmM01nQmtILy9mdDNhbkZ5UVlDQmdvUjRjVVVFUUNBRFFRaHFJZ01nQlUwTkFRc0xJQU1nQWswTkFDQURJQUlRWmdBTEFrQWdBaUFEUmcwQUlBTWdBbXNoQWlBQklBTnFJUUZCQUNFRUEwQWdBU0FFYWkwQUFFRWdSd1JBSUFJZ0JFRUJhaUlFYWcwQkRBSUxDeUFESUFScUlRUkJBU0VGREFFTFFRQWhCUXNnQUNBRU5nSUVJQUFnQlRZQ0FBdmFBZ0lEZndGK0l3QkJRR29pQWlRQUFrQUNRQ0FBQkVBZ0FDZ0NBQ0lEUVg5R0RRRWdBQ0FEUVFGcU5nSUFJQUJCRUdvb0FnQWhBeUFBS1FNSUlRVWdBa0VVYWlBQVFSUnFFRzBnQWtFUWFpSUVJQU0yQWdBZ0FDQUFLQUlBUVg5cU5nSUFJQUZFQUFBQUFBQUE0TU5tSVFBZ0FpQUZRZ0JDLy8vLy8vLy8vLy8vQUFKK0lBR1pSQUFBQUFBQUFPQkRZd1JBSUFHd0RBRUxRb0NBZ0lDQWdJQ0FnSDhMUW9DQWdJQ0FnSUNBZ0g4Z0FCc2dBVVQvLy8vLy8vL2ZRMlFiSUFFZ0FXSWJmQ0lGTndNSUlBSkJPR29nQWtFWWFpa0RBRGNDQUNBQ1FUQnFJQVFwQXdBM0FnQWdBaUFGTndJb1FTQkJDQkNhQVNJQVJRMENJQUJCQURZQ0FDQUFJQUlwQWlRM0FnUWdBRUVNYWlBQ1FTeHFLUUlBTndJQUlBQkJGR29nQWtFMGFpa0NBRGNDQUNBQVFSeHFJQUpCUEdvb0FnQTJBZ0FnQWtGQWF5UUFJQUFQQ3hDb0FRQUxFS2tCQUF0QklFRUlFSzhCQUF2YUFnSURmd0YrSXdCQlFHb2lBaVFBQWtBQ1FDQUFCRUFnQUNnQ0FDSURRWDlHRFFFZ0FDQURRUUZxTmdJQUlBQkJFR29vQWdBaEF5QUFLUU1JSVFVZ0FrRVVhaUFBUVJScUVHMGdBa0VRYWlJRUlBTTJBZ0FnQUNBQUtBSUFRWDlxTmdJQUlBRkVBQUFBQUFBQTRNTm1JUUFnQWlBRlFnQkMvLy8vLy8vLy8vLy9BQUorSUFHWlJBQUFBQUFBQU9CRFl3UkFJQUd3REFFTFFvQ0FnSUNBZ0lDQWdIOExRb0NBZ0lDQWdJQ0FnSDhnQUJzZ0FVVC8vLy8vLy8vZlEyUWJJQUVnQVdJYmZTSUZOd01JSUFKQk9Hb2dBa0VZYWlrREFEY0NBQ0FDUVRCcUlBUXBBd0EzQWdBZ0FpQUZOd0lvUVNCQkNCQ2FBU0lBUlEwQ0lBQkJBRFlDQUNBQUlBSXBBaVEzQWdRZ0FFRU1haUFDUVN4cUtRSUFOd0lBSUFCQkZHb2dBa0UwYWlrQ0FEY0NBQ0FBUVJ4cUlBSkJQR29vQWdBMkFnQWdBa0ZBYXlRQUlBQVBDeENvQVFBTEVLa0JBQXRCSUVFSUVLOEJBQXZhQWdJRGZ3RitJd0JCUUdvaUFpUUFBa0FDUUNBQUJFQWdBQ2dDQUNJRFFYOUdEUUVnQUNBRFFRRnFOZ0lBSUFCQkVHb29BZ0FoQXlBQUtRTUlJUVVnQWtFVWFpQUFRUlJxRUcwZ0FrRVFhaUlFSUFNMkFnQWdBQ0FBS0FJQVFYOXFOZ0lBSUFGRUFBQUFBQUFBNE1ObUlRQWdBaUFGUWdCQy8vLy8vLy8vLy8vL0FBSitJQUdaUkFBQUFBQUFBT0JEWXdSQUlBR3dEQUVMUW9DQWdJQ0FnSUNBZ0g4TFFvQ0FnSUNBZ0lDQWdIOGdBQnNnQVVULy8vLy8vLy9mUTJRYklBRWdBV0liZmlJRk53TUlJQUpCT0dvZ0FrRVlhaWtEQURjQ0FDQUNRVEJxSUFRcEF3QTNBZ0FnQWlBRk53SW9RU0JCQ0JDYUFTSUFSUTBDSUFCQkFEWUNBQ0FBSUFJcEFpUTNBZ1FnQUVFTWFpQUNRU3hxS1FJQU53SUFJQUJCRkdvZ0FrRTBhaWtDQURjQ0FDQUFRUnhxSUFKQlBHb29BZ0EyQWdBZ0FrRkFheVFBSUFBUEN4Q29BUUFMRUtrQkFBdEJJRUVJRUs4QkFBdTNBZ0lGZndGK0l3QkJNR3NpQkNRQVFTY2hBZ0pBSUFCQ2tNNEFWQVJBSUFBaEJ3d0JDd05BSUFSQkNXb2dBbW9pQTBGOGFpQUFJQUJDa000QWdDSUhRcERPQUg1OXB5SUZRZi8vQTNGQjVBQnVJZ1pCQVhSQnRJN0FBR292QUFBN0FBQWdBMEYrYWlBRklBWkI1QUJzYTBILy93TnhRUUYwUWJTT3dBQnFMd0FBT3dBQUlBSkJmR29oQWlBQVF2L0IxeTlXSUFjaEFBMEFDd3NnQjZjaUEwSGpBRXNFUUNBQ1FYNXFJZ0lnQkVFSmFtb2dCNmNpQXlBRFFmLy9BM0ZCNUFCdUlnTkI1QUJzYTBILy93TnhRUUYwUWJTT3dBQnFMd0FBT3dBQUN3SkFJQU5CQ2s4RVFDQUNRWDVxSWdJZ0JFRUphbW9nQTBFQmRFRzBqc0FBYWk4QUFEc0FBQXdCQ3lBQ1FYOXFJZ0lnQkVFSmFtb2dBMEV3YWpvQUFBc2dBU0FFUVFscUlBSnFRU2NnQW1zUUV5QUVRVEJxSkFBTHJBSUNBbjhDZmlNQVFVQnFJZ0lrQUFKQUFrQUNRQ0FBUlEwQUlBQW9BZ0FpQTBGL1JnMEJJQUFnQTBFQmFqWUNBQ0FCUlEwQUlBRW9BZ0FpQTBGL1JnMEJJQUVnQTBFQmFqWUNBQ0FCS1FNSUlRUWdBQ2tEQ0NFRklBQW9BaEFoQXlBQ1FSUnFJQUJCRkdvUWJTQUJJQUVvQWdCQmYybzJBZ0FnQWtFUWFpSUJJQU0yQWdBZ0FDQUFLQUlBUVg5cU5nSUFJQUlnQkNBRmZDSUVOd01JSUFKQk9Hb2dBa0VZYWlrREFEY0NBQ0FDUVRCcUlBRXBBd0EzQWdBZ0FpQUVOd0lvUVNCQkNCQ2FBU0lBUlEwQ0lBQkJBRFlDQUNBQUlBSXBBaVEzQWdRZ0FFRU1haUFDUVN4cUtRSUFOd0lBSUFCQkZHb2dBa0UwYWlrQ0FEY0NBQ0FBUVJ4cUlBSkJQR29vQWdBMkFnQWdBa0ZBYXlRQUlBQVBDeENvQVFBTEVLa0JBQXRCSUVFSUVLOEJBQXVzQWdJQ2Z3SitJd0JCUUdvaUFpUUFBa0FDUUFKQUlBQkZEUUFnQUNnQ0FDSURRWDlHRFFFZ0FDQURRUUZxTmdJQUlBRkZEUUFnQVNnQ0FDSURRWDlHRFFFZ0FTQURRUUZxTmdJQUlBRXBBd2doQkNBQUtRTUlJUVVnQUNnQ0VDRURJQUpCRkdvZ0FFRVVhaEJ0SUFFZ0FTZ0NBRUYvYWpZQ0FDQUNRUkJxSWdFZ0F6WUNBQ0FBSUFBb0FnQkJmMm8yQWdBZ0FpQUZJQVI5SWdRM0F3Z2dBa0U0YWlBQ1FSaHFLUU1BTndJQUlBSkJNR29nQVNrREFEY0NBQ0FDSUFRM0FpaEJJRUVJRUpvQklnQkZEUUlnQUVFQU5nSUFJQUFnQWlrQ0pEY0NCQ0FBUVF4cUlBSkJMR29wQWdBM0FnQWdBRUVVYWlBQ1FUUnFLUUlBTndJQUlBQkJIR29nQWtFOGFpZ0NBRFlDQUNBQ1FVQnJKQUFnQUE4TEVLZ0JBQXNRcVFFQUMwRWdRUWdRcndFQUM2d0NBZ0ovQW40akFFRkFhaUlDSkFBQ1FBSkFBa0FnQUVVTkFDQUFLQUlBSWdOQmYwWU5BU0FBSUFOQkFXbzJBZ0FnQVVVTkFDQUJLQUlBSWdOQmYwWU5BU0FCSUFOQkFXbzJBZ0FnQVNrRENDRUVJQUFwQXdnaEJTQUFLQUlRSVFNZ0FrRVVhaUFBUVJScUVHMGdBU0FCS0FJQVFYOXFOZ0lBSUFKQkVHb2lBU0FETmdJQUlBQWdBQ2dDQUVGL2FqWUNBQ0FDSUFRZ0JYNGlCRGNEQ0NBQ1FUaHFJQUpCR0dvcEF3QTNBZ0FnQWtFd2FpQUJLUU1BTndJQUlBSWdCRGNDS0VFZ1FRZ1FtZ0VpQUVVTkFpQUFRUUEyQWdBZ0FDQUNLUUlrTndJRUlBQkJER29nQWtFc2Fpa0NBRGNDQUNBQVFSUnFJQUpCTkdvcEFnQTNBZ0FnQUVFY2FpQUNRVHhxS0FJQU5nSUFJQUpCUUdza0FDQUFEd3NRcUFFQUN4Q3BBUUFMUVNCQkNCQ3ZBUUFMcHdJQkJYOGdBRUlBTndJUUlBQUNmMEVBSUFGQmdBSkpEUUFhUVI4Z0FVSC8vLzhIU3cwQUdpQUJRUVlnQVVFSWRtY2lBbXQyUVFGeElBSkJBWFJyUVQ1cUN5SUNOZ0ljSUFKQkFuUkJqSlRBQUdvaEF5QUFJUVFDUUFKQUFrQUNRRUdBa3NBQUtBSUFJZ1ZCQVNBQ2RDSUdjUVJBSUFNb0FnQWhBeUFDRUpNQklRSWdBeENyQVNBQlJ3MEJJQU1oQWd3Q0MwR0Frc0FBSUFVZ0JuSTJBZ0FnQXlBQU5nSUFEQU1MSUFFZ0FuUWhCUU5BSUFNZ0JVRWRka0VFY1dwQkVHb2lCaWdDQUNJQ1JRMENJQVZCQVhRaEJTQUNJZ01RcXdFZ0FVY05BQXNMSUFJb0FnZ2lBU0FFTmdJTUlBSWdCRFlDQ0NBRUlBSTJBZ3dnQkNBQk5nSUlJQUJCQURZQ0dBOExJQVlnQURZQ0FBc2dBQ0FETmdJWUlBUWdCRFlDQ0NBRUlBUTJBZ3dMdGdJQkJYOGdBQ2dDR0NFRUFrQUNRQ0FBSUFBb0FneEdCRUFnQUVFVVFSQWdBRUVVYWlJQktBSUFJZ01iYWlnQ0FDSUNEUUZCQUNFQkRBSUxJQUFvQWdnaUFpQUFLQUlNSWdFMkFnd2dBU0FDTmdJSURBRUxJQUVnQUVFUWFpQURHeUVEQTBBZ0F5RUZJQUlpQVVFVWFpSURLQUlBSWdKRkJFQWdBVUVRYWlFRElBRW9BaEFoQWdzZ0FnMEFDeUFGUVFBMkFnQUxBa0FnQkVVTkFBSkFJQUFnQUNnQ0hFRUNkRUdNbE1BQWFpSUNLQUlBUndSQUlBUkJFRUVVSUFRb0FoQWdBRVliYWlBQk5nSUFJQUVOQVF3Q0N5QUNJQUUyQWdBZ0FRMEFRWUNTd0FCQmdKTEFBQ2dDQUVGK0lBQW9BaHgzY1RZQ0FBOExJQUVnQkRZQ0dDQUFLQUlRSWdJRVFDQUJJQUkyQWhBZ0FpQUJOZ0lZQ3lBQVFSUnFLQUlBSWdCRkRRQWdBVUVVYWlBQU5nSUFJQUFnQVRZQ0dBc0xid0VNZjBHc2xjQUFLQUlBSWdKRkJFQkJ2SlhBQUVIL0h6WUNBRUVBRHd0QnBKWEFBQ0VHQTBBZ0FpSUJLQUlJSVFJZ0FTZ0NCQ0VESUFFb0FnQWhCQ0FCUVF4cUtBSUFHaUFCSVFZZ0JVRUJhaUVGSUFJTkFBdEJ2SlhBQUNBRlFmOGZJQVZCL3g5TEd6WUNBQ0FJQy9zQkFnTi9BWDRqQUVGQWFpSUJKQUFDUUFKQUlBQUVRQ0FBS0FJQUlnSkJmMFlOQVNBQUlBSkJBV28yQWdBZ0FFRWdhaWtEQUNFRUlBQkJLR29vQWdBaEFpQUJRUlJxSUFCQkxHb1FiU0FCUVJCcUlnTWdBallDQUNBQUlBQW9BZ0JCZjJvMkFnQWdBU0FFTndNSUlBRkJPR29nQVVFWWFpa0RBRGNDQUNBQlFUQnFJQU1wQXdBM0FnQWdBU0FFTndJb1FTQkJDQkNhQVNJQVJRMENJQUJCQURZQ0FDQUFJQUVwQWlRM0FnUWdBRUVNYWlBQlFTeHFLUUlBTndJQUlBQkJGR29nQVVFMGFpa0NBRGNDQUNBQVFSeHFJQUZCUEdvb0FnQTJBZ0FnQVVGQWF5UUFJQUFQQ3hDb0FRQUxFS2tCQUF0QklFRUlFSzhCQUF2NEFRSURmd0YrSXdCQlFHb2lBU1FBQWtBQ1FDQUFCRUFnQUNnQ0FDSUNRWDlHRFFFZ0FDQUNRUUZxTmdJQUlBQkJFR29vQWdBaEFpQUFLUU1JSVFRZ0FVRVVhaUFBUVJScUVHMGdBVUVRYWlJRElBSTJBZ0FnQUNBQUtBSUFRWDlxTmdJQUlBRWdCRGNEQ0NBQlFUaHFJQUZCR0dvcEF3QTNBZ0FnQVVFd2FpQURLUU1BTndJQUlBRWdCRGNDS0VFZ1FRZ1FtZ0VpQUVVTkFpQUFRUUEyQWdBZ0FDQUJLUUlrTndJRUlBQkJER29nQVVFc2Fpa0NBRGNDQUNBQVFSUnFJQUZCTkdvcEFnQTNBZ0FnQUVFY2FpQUJRVHhxS0FJQU5nSUFJQUZCUUdza0FDQUFEd3NRcUFFQUN4Q3BBUUFMUVNCQkNCQ3ZBUUFMaEFJQ0JIOEJmaU1BUVVCcUlnTWtBQ0FEUVFBMkFod0NRQ0FDUVFocUtBSUFJZ1JCQUU0RVFFRUJJUVVnQkFSQUlBUkJBUkNhQVNJRlJRMENDeUFEUVFBMkFpZ2dBeUFFTmdJa0lBTWdCVFlDSUNBRFFUQnFJQUlRYlNBRFFRaHFJQU5CTUdwQkFTQUJLQUlJSUFOQkhHb2dBMEVnYWhBT0FrQWdBeWtEQ0tkRkJFQWdBeWtERUNFSElBQWdBeWtESURjQ0JDQUJJQWMzQXdBZ0FFRU1haUFEUVNocUtBSUFOZ0lBREFFTElBQkJ2SURBQUVFREVBTTJBZ1FnQXlnQ0pFVUVRRUVCSVFZTUFRdEJBU0VHSUFNb0FpQVFFQXNnQUNBR05nSUFJQUpCQkdvb0FnQUVRQ0FDS0FJQUVCQUxJQU5CUUdza0FBOExFSGtBQ3lBRVFRRVFyd0VBQzRZQ0FnUi9BWDRqQUVFd2F5SUNKQUFnQVVFRWFpRUVJQUVvQWdSRkJFQWdBU2dDQUNFRElBSkJFR29pQlVFQU5nSUFJQUpDQVRjRENDQUNJQUpCQ0dvMkFoUWdBa0VvYWlBRFFSQnFLUUlBTndNQUlBSkJJR29nQTBFSWFpa0NBRGNEQUNBQ0lBTXBBZ0EzQXhnZ0FrRVVhaUFDUVJocUVCMGFJQVJCQ0dvZ0JTZ0NBRFlDQUNBRUlBSXBBd2czQWdBTElBSkJJR29pQXlBRVFRaHFLQUlBTmdJQUlBRkJER3BCQURZQ0FDQUVLUUlBSVFZZ0FVSUJOd0lFSUFJZ0JqY0RHRUVNUVFRUW1nRWlBVVVFUUVFTVFRUVFyd0VBQ3lBQklBSXBBeGczQWdBZ0FVRUlhaUFES0FJQU5nSUFJQUJCcEl6QUFEWUNCQ0FBSUFFMkFnQWdBa0V3YWlRQUM1a0NBZ04vQVg0akFFRWdheUlGSkFBZ0FFUUFBQUFBQUFEZ3cyWWhCQUpBUWdCQy8vLy8vLy8vLy8vL0FBSitJQUNaUkFBQUFBQUFBT0JEWXdSQUlBQ3dEQUVMUW9DQWdJQ0FnSUNBZ0g4TFFvQ0FnSUNBZ0lDQWdIOGdCQnNnQUVULy8vLy8vLy9mUTJRYklBQWdBR0liSWdkUVJRUkFJQVZCRUdvZ0J5QUJRUUFnQkJBaERBRUxJQVZCQURZQ0dDQUZRZ0UzQXhBTElBVkJDR29pQmlBRlFSaHFLQUlBTmdJQUlBVWdCU2tERURjREFFRXdRUWdRbWdFaUJFVUVRRUV3UVFnUXJ3RUFDeUFFSUFNMkFod2dCQ0FETmdJWUlBUWdBallDRkNBRUlBRTJBaEFnQkNBSE53TUlJQVJCQURZQ0FDQUVJQVVwQXdBM0F5QWdCRUVCT2dBc0lBUkJLR29nQmlnQ0FEWUNBQ0FGUVNCcUpBQWdCQXZTQVFJRGZ3RitJd0JCSUdzaUFpUUFBa0FDUUNBQVJRMEFJQUFvQWdBTkFTQUFRWDgyQWdBZ0FVVU5BQ0FCS0FJQUlnTkJmMFlOQVNBQklBTkJBV28yQWdBZ0FVRVFhaWdDQUNFRElBRXBBd2doQlNBQ1FSUnFJQUZCRkdvUWJTQUNJQU0yQWhBZ0FpQUZOd01JSUFCQkNHb2lBMEVRYWlJRUtBSUFCRUFnQXlnQ0RCQVFDeUFESUFJcEF3ZzNBd0FnQkNBQ1FSaHFLUU1BTndNQUlBTkJDR29nQWtFUWFpa0RBRGNEQUNBQklBRW9BZ0JCZjJvMkFnQWdBRUVBTmdJQUlBSkJJR29rQUE4TEVLZ0JBQXNRcVFFQUM5VUJBZ04vQVg0akFFRWdheUlDSkFBQ1FBSkFJQUJGRFFBZ0FDZ0NBQTBCSUFCQmZ6WUNBQ0FCUlEwQUlBRW9BZ0FpQTBGL1JnMEJJQUVnQTBFQmFqWUNBQ0FCUVJCcUtBSUFJUU1nQVNrRENDRUZJQUpCRkdvZ0FVRVVhaEJ0SUFJZ0F6WUNFQ0FDSUFVM0F3Z2dBRUVJYWlJRFFTaHFJZ1FvQWdBRVFDQURRU1JxS0FJQUVCQUxJQU1nQWlrRENEY0RHQ0FFSUFKQkdHb3BBd0EzQXdBZ0EwRWdhaUFDUVJCcUtRTUFOd01BSUFFZ0FTZ0NBRUYvYWpZQ0FDQUFRUUEyQWdBZ0FrRWdhaVFBRHdzUXFBRUFDeENwQVFBTGp3SUJBMzhqQUVFZ2F5SUZKQUJCQVNFR1FmaVJ3QUJCK0pIQUFDZ0NBQ0lIUVFGcU5nSUFBa0JCd0pYQUFDMEFBQVJBUWNpVndBQW9BZ0JCQVdvaEJnd0JDMEhBbGNBQVFRRTZBQUFMUWNpVndBQWdCallDQUFKQUFrQWdCMEVBU0NBR1FRSkxjZzBBSUFVZ0JEb0FHQ0FGSUFNMkFoUWdCU0FDTmdJUVFleVJ3QUFvQWdBaUFrRi9UQTBBUWV5UndBQWdBa0VCYWlJQ05nSUFRZXlSd0FCQjlKSEFBQ2dDQUNJREJIOUI4SkhBQUNnQ0FDQUZJQUFnQVNnQ0VCRUJBQ0FGSUFVcEF3QTNBd2dnQlVFSWFpQURLQUlVRVFFQVFleVJ3QUFvQWdBRklBSUxRWDlxTmdJQUlBWkJBVXNOQUNBRURRRUxBQXNqQUVFUWF5SUNKQUFnQWlBQk5nSU1JQUlnQURZQ0NBQUx0d0VCQVg4akFFRkFhaUlDSkFBZ0FpQUJOZ0lvSUFJZ0FUWUNKQ0FDSUFBMkFpQWdBa0VJYWlBQ1FTQnFFQlVnQWtFMGFpQUNRUmhxS1FNQU53SUFJQUpCTEdvZ0FrRVFhaWtEQURjQ0FDQUNJQUlwQXdnM0FpUkJJRUVJRUpvQklnQkZCRUJCSUVFSUVLOEJBQXNnQUVFQU5nSUFJQUFnQWlrQ0lEY0NCQ0FBUVF4cUlBSkJLR29wQWdBM0FnQWdBRUVVYWlBQ1FUQnFLUUlBTndJQUlBQkJIR29nQWtFNGFpZ0NBRFlDQUNBQ1FVQnJKQUFnQUF2SkFRSUJmd0YrSXdCQklHc2lCQ1FBQWtBQ1FBSkFJQUVFUUNBQktBSUFEUUVnQVVGL05nSUFJQVFnQXpZQ0dDQUVJQU0yQWhRZ0JDQUNOZ0lRSUFRZ0FVRUlhaUFFUVJCcUVFQWdBVUVBTmdJQUlBUW9BZ1FoQVNBRUtBSUFEUUlDUUNBRVFRaHFLUU1BSWdXbklnTWdCVUlnaUtjaUFrME5BQ0FDUlFSQUlBRVFFRUVCSVFFTUFRc2dBU0FEUVFFZ0FoQ1dBU0lCUlEwRUN5QUFJQUkyQWdRZ0FDQUJOZ0lBSUFSQklHb2tBQThMRUtnQkFBc1FxUUVBQ3lBQkVBZ0FDeUFDUVFFUXJ3RUFDN2tCQVFKL0l3QkJJR3NpQXlRQUFrQWdBU0FDYWlJQ0lBRkpEUUFnQUVFRWFpZ0NBQ0lCUVFGMElnUWdBaUFFSUFKTEd5SUNRUWdnQWtFSVN4c2hBZ0pBSUFFRVFDQURRUmhxUVFFMkFnQWdBeUFCTmdJVUlBTWdBQ2dDQURZQ0VBd0JDeUFEUVFBMkFoQUxJQU1nQWlBRFFSQnFFRmNnQXlnQ0FBUkFJQU5CQ0dvb0FnQWlBRVVOQVNBREtBSUVJQUFRcndFQUN5QURLQUlFSVFFZ0FFRUVhaUFDTmdJQUlBQWdBVFlDQUNBRFFTQnFKQUFQQ3hCNUFBdTVBUUVEZnlNQVFTQnJJZ0lrQUFKQUlBRkJBV29pQXlBQlNRMEFJQUJCQkdvb0FnQWlBVUVCZENJRUlBTWdCQ0FEU3hzaUEwRUlJQU5CQ0VzYklRTUNRQ0FCQkVBZ0FrRVlha0VCTmdJQUlBSWdBVFlDRkNBQ0lBQW9BZ0EyQWhBTUFRc2dBa0VBTmdJUUN5QUNJQU1nQWtFUWFoQlhJQUlvQWdBRVFDQUNRUWhxS0FJQUlnQkZEUUVnQWlnQ0JDQUFFSzhCQUFzZ0FpZ0NCQ0VCSUFCQkJHb2dBellDQUNBQUlBRTJBZ0FnQWtFZ2FpUUFEd3NRZVFBTHVRRUJBbjhqQUVFZ2F5SURKQUFDUUNBQklBSnFJZ0lnQVVrTkFDQUFRUVJxS0FJQUlnRkJBWFFpQkNBQ0lBUWdBa3NiSWdKQkNDQUNRUWhMR3lFQ0FrQWdBUVJBSUFOQkdHcEJBVFlDQUNBRElBRTJBaFFnQXlBQUtBSUFOZ0lRREFFTElBTkJBRFlDRUFzZ0F5QUNJQU5CRUdvUVZTQURLQUlBQkVBZ0EwRUlhaWdDQUNJQVJRMEJJQU1vQWdRZ0FCQ3ZBUUFMSUFNb0FnUWhBU0FBUVFScUlBSTJBZ0FnQUNBQk5nSUFJQU5CSUdva0FBOExFSGtBQzdrQkFRTi9Jd0JCSUdzaUFpUUFBa0FnQVVFQmFpSURJQUZKRFFBZ0FFRUVhaWdDQUNJQlFRRjBJZ1FnQXlBRUlBTkxHeUlEUVFnZ0EwRUlTeHNoQXdKQUlBRUVRQ0FDUVJocVFRRTJBZ0FnQWlBQk5nSVVJQUlnQUNnQ0FEWUNFQXdCQ3lBQ1FRQTJBaEFMSUFJZ0F5QUNRUkJxRUZVZ0FpZ0NBQVJBSUFKQkNHb29BZ0FpQUVVTkFTQUNLQUlFSUFBUXJ3RUFDeUFDS0FJRUlRRWdBRUVFYWlBRE5nSUFJQUFnQVRZQ0FDQUNRU0JxSkFBUEN4QjVBQXU0QVFFRGZ5TUFRUkJySWdNa0FBSkFBa0FnQVFSQUlBRW9BZ0FpQWtGL1JnMEJJQUVnQWtFQmFqWUNBQ0FESUFFcEF3Z2dBVUVRYWlnQ0FFRUFJQUVRSVNBQklBRW9BZ0JCZjJvMkFnQWdBeWdDQUNFQkFrQWdBeWdDQkNJQ0lBTW9BZ2dpQkUwRVFDQUJJUUlNQVFzZ0JFVUVRRUVCSVFJZ0FSQVFEQUVMSUFFZ0FrRUJJQVFRbGdFaUFrVU5Bd3NnQUNBRU5nSUVJQUFnQWpZQ0FDQURRUkJxSkFBUEN4Q29BUUFMRUtrQkFBc2dCRUVCRUs4QkFBdUxBUUVFZnlBQVFRQWdBR3RCQTNFaUEyb2hBU0FEQkVBZ0FDRUNBMEFnQWtFQU9nQUFJQUpCQVdvaUFpQUJTUTBBQ3dzZ0FVSGdBeUFEYXlJRFFYeHhJZ1JxSVFJZ0JFRUJUZ1JBQTBBZ0FVRUFOZ0lBSUFGQkJHb2lBU0FDU1EwQUN3c2dBMEVEY1NJQkJFQWdBU0FDYWlFQkEwQWdBa0VBT2dBQUlBSkJBV29pQWlBQlNRMEFDd3NnQUF1dEFRRUJmeU1BUVRCcklnTWtBQUpBQWtBZ0FBUkFJQUFvQWdBTkFTQUFRWDgyQWdBZ0F5QUNOZ0lZSUFNZ0FqWUNGQ0FESUFFMkFoQWdBMEVBTmdJY0lBTkJJR29nQTBFUWFoQnRJQU1nQTBFZ2FrRUJJQUJCRUdvb0FnQWdBMEVjYWtFQUVBNGdBeWtEQUtjTkFpQUFJQU1wQXdnM0F3Z2dBeWdDRkFSQUlBTW9BaEFRRUFzZ0FFRUFOZ0lBSUFOQk1Hb2tBQThMRUtnQkFBc1FxUUVBQ3lBRFFTQnFRYXlBd0FBUVhBQUxyQUVCQTM4akFFRVFheUlESkFBQ1FBSkFJQUVFUUNBQktBSUFJZ0pCZjBZTkFTQUJJQUpCQVdvMkFnQWdBeUFCUVJScUVHMGdBU0FCS0FJQVFYOXFOZ0lBSUFNb0FnQWhBUUpBSUFNb0FnUWlBaUFES0FJSUlnUk5CRUFnQVNFQ0RBRUxJQVJGQkVCQkFTRUNJQUVRRUF3QkN5QUJJQUpCQVNBRUVKWUJJZ0pGRFFNTElBQWdCRFlDQkNBQUlBSTJBZ0FnQTBFUWFpUUFEd3NRcUFFQUN4Q3BBUUFMSUFSQkFSQ3ZBUUFMckFFQkEzOGpBRUVRYXlJREpBQUNRQUpBSUFFRVFDQUJLQUlBSWdKQmYwWU5BU0FCSUFKQkFXbzJBZ0FnQXlBQlFTQnFFRzBnQVNBQktBSUFRWDlxTmdJQUlBTW9BZ0FoQVFKQUlBTW9BZ1FpQWlBREtBSUlJZ1JOQkVBZ0FTRUNEQUVMSUFSRkJFQkJBU0VDSUFFUUVBd0JDeUFCSUFKQkFTQUVFSllCSWdKRkRRTUxJQUFnQkRZQ0JDQUFJQUkyQWdBZ0EwRVFhaVFBRHdzUXFBRUFDeENwQVFBTElBUkJBUkN2QVFBTHFBRUNBWDhCZmlNQVFTQnJJZ0lrQUNBQUtRSUFJUU1nQUVFQU5nSUFJQU9uQkVBZ0FpQURRaUNJUGdJVUlBSWdBVFlDR0NBQ1FTRTJBaHdnQWtFSWFpQUNRUlJxSUFKQkhHb2dBa0VZYWhCd0lBSW9BZ3dpQUVFa1R3UkFJQUFRQUFzZ0FpZ0NIQ0lBUVNSUEJFQWdBQkFBQ3lBQ0tBSVlJZ0JCSkU4RVFDQUFFQUFMSUFJb0FoUWlBRUVrVHdSQUlBQVFBQXNnQWtFZ2FpUUFEd3RCcUlmQUFFRWNFS29CQUF1bkFRRURmeU1BUVRCcklnSWtBQ0FCUVFScUlRTWdBU2dDQkVVRVFDQUJLQUlBSVFFZ0FrRVFhaUlFUVFBMkFnQWdBa0lCTndNSUlBSWdBa0VJYWpZQ0ZDQUNRU2hxSUFGQkVHb3BBZ0EzQXdBZ0FrRWdhaUFCUVFocUtRSUFOd01BSUFJZ0FTa0NBRGNER0NBQ1FSUnFJQUpCR0dvUUhSb2dBMEVJYWlBRUtBSUFOZ0lBSUFNZ0Fpa0RDRGNDQUFzZ0FFR2tqTUFBTmdJRUlBQWdBellDQUNBQ1FUQnFKQUFMbWdFQkFYOGpBRUVnYXlJREpBQUNRQ0FBQkVBZ0FDZ0NBQTBCSUFCQmZ6WUNBQ0FESUFJMkFnZ2dBeUFDTmdJRUlBTWdBVFlDQUNBQVFSUnFJUUVnQTBFUWFpQURFRzBnQUVFWWFpZ0NBQVJBSUFFb0FnQVFFQXNnQVNBREtRTVFOd0lBSUFGQkNHb2dBMEVZYWlnQ0FEWUNBQ0FES0FJRUJFQWdBeWdDQUJBUUN5QUFRUUEyQWdBZ0EwRWdhaVFBRHdzUXFBRUFDeENwQVFBTG93RUJBWDhqQUVFUWF5SUdKQUFDUUNBQkJFQWdCaUFCSUFNZ0JDQUZJQUlvQWhBUkNRQWdCaWdDQUNFQkFrQWdCaWdDQkNJQ0lBWW9BZ2dpQTAwRVFDQUJJUUlNQVFzZ0FrRUNkQ0VFSUFOQkFuUWlCVVVFUUVFRUlRSWdCRVVOQVNBQkVCQU1BUXNnQVNBRVFRUWdCUkNXQVNJQ1JRMENDeUFBSUFNMkFnUWdBQ0FDTmdJQUlBWkJFR29rQUE4TFFmU0h3QUJCTUJDcUFRQUxJQVZCQkJDdkFRQUxtUUVCQW44Q1FBSkFBa0FDUUFKL0FrQUNRQUovUVFFaUF5QUJRUUJJRFFBYUlBSW9BZ0FpQkVVTkFTQUNLQUlFSWdJTkJDQUJEUUpCQVF3REN5RURRUUFoQVF3R0N5QUJEUUJCQVF3QkN5QUJRUUVRbWdFTElnSkZEUUVNQWdzZ0JDQUNRUUVnQVJDV0FTSUNEUUVMSUFBZ0FUWUNCRUVCSVFFTUFRc2dBQ0FDTmdJRVFRQWhBd3NnQUNBRE5nSUFJQUJCQ0dvZ0FUWUNBQXVhQVFFQmZ5TUFRU0JySWdJa0FDQUFLQUlBQkVBZ0FpQUFLQUlFTmdJVUlBSWdBVFlDR0NBQ1FTRTJBaHdnQWtFSWFpQUNRUlJxSUFKQkhHb2dBa0VZYWhCd0lBSW9BZ3dpQUVFa1R3UkFJQUFRQUFzZ0FpZ0NIQ0lBUVNSUEJFQWdBQkFBQ3lBQ0tBSVlJZ0JCSkU4RVFDQUFFQUFMSUFJb0FoUWlBRUVrVHdSQUlBQVFBQXNnQWtFZ2FpUUFEd3RCcUlmQUFFRWNFS29CQUF1WUFRRUNmd0pBQWtBQ1FBSkFBa0FDUUFKQUFuOUJBU0lESUFGQkFFZ05BQm9nQWlnQ0FDSUVSUTBDSUFJb0FnUWlBZzBCSUFFTkF3d0ZDeUVEUVFBaEFRd0dDeUFFSUFKQkFTQUJFSllCSWdKRkRRSU1CQXNnQVVVTkFnc2dBVUVCRUpvQklnSU5BZ3NnQUNBQk5nSUVRUUVoQVF3Q0MwRUJJUUlMSUFBZ0FqWUNCRUVBSVFNTElBQWdBellDQUNBQVFRaHFJQUUyQWdBTGhBRUJCSDhDUUNBQ1JRMEFJQUVnQWtGL2FpSUVhaTBBQUNJRlJTQUZJQUpMY2cwQUlBUWdBaUFGYXlJR1R3UkFRUUFnQldzaEF5QUJJQUpxSVFJRFFDQURRWDlHQkVBZ0FTRUREQU1MSUFJZ0Eyb2dBMEVCYWlFRExRQUFJQVZHRFFBTFFRQWhBd3dCQ3lBR0lBUkIrSWpBQUJCb0FBc2dBQ0FHTmdJRUlBQWdBellDQUF1Z0FRRURmd0pBSUFBRVFDQUFLQUlBSWdGQmYwWU5BVUVCSVFNZ0FDQUJRUUZxTmdJQUlBQkJGR29vQWdBaEFnSkFBa0FDUUFKQUlBQkJIR29vQWdCQmZXb09Bd0VEQUFNTElBSkJ2NERBQUVFRkVMQUJEUUVnQUNBQk5nSUFRUUFQQ3lBQ1FjU0F3QUJCQXhDd0FRMEJJQUFnQVRZQ0FFRUFEd3NnQWtISGdNQUFRUVVRc0FGQkFFY2hBd3NnQUNBQk5nSUFJQU1QQ3hDb0FRQUxFS2tCQUF1ZUFRRUNmeU1BUVJCcklnTWtBQ0FBUVJScUtBSUFJUVFDUUFKL0FrQUNRQ0FBUVFScUtBSUFEZ0lBQVFNTElBUU5Ba0VBSVFCQnZJdkFBQXdCQ3lBRURRRWdBQ2dDQUNJRUtBSUVJUUFnQkNnQ0FBc2hCQ0FESUFBMkFnUWdBeUFFTmdJQUlBTkIySXpBQUNBQktBSUlJQUlnQVMwQUVCQkZBQXNnQTBFQU5nSUVJQU1nQURZQ0FDQURRY1NNd0FBZ0FTZ0NDQ0FDSUFFdEFCQVFSUUFMb2dFQkFYOUJJRUVJRUpvQklnUUVRQ0FFSUFNMkFod2dCQ0FETmdJWUlBUWdBallDRkNBRUlBRTJBaEFnQkVFQU5nSUFJQUJFQUFBQUFBQUE0TU5tSVFFZ0JFSUFRdi8vLy8vLy8vLy8vd0FDZmlBQW1VUUFBQUFBQUFEZ1EyTUVRQ0FBc0F3QkMwS0FnSUNBZ0lDQWdJQi9DMEtBZ0lDQWdJQ0FnSUIvSUFFYklBQkUvLy8vLy8vLzMwTmtHeUFBSUFCaUd6Y0RDQ0FFRHd0QklFRUlFSzhCQUF1REFRRUJmeU1BUVVCcUlnSWtBQ0FDUVNzMkFnd2dBa0dEaE1BQU5nSUlJQUpCc0lUQUFEWUNGQ0FDSUFBMkFoQWdBa0VzYWtFQ05nSUFJQUpCUEdwQkpEWUNBQ0FDUWdJM0Fod2dBa0dranNBQU5nSVlJQUpCSlRZQ05DQUNJQUpCTUdvMkFpZ2dBaUFDUVJCcU5nSTRJQUlnQWtFSWFqWUNNQ0FDUVJocUlBRVFlZ0FMYWdJQmZ3SitBa0FDUUNBQVJRMEFJQUFvQWdBaUFrRi9SZzBCSUFBZ0FrRUJhallDQUNBQlJRMEFJQUVvQWdBaUFrRi9SZzBCSUFFZ0FrRUJhallDQUNBQUtRTUlJQUVnQWpZQ0FDQUJLUU1JSUFBZ0FDZ0NBRUYvYWpZQ0FGRVBDeENvQVFBTEVLa0JBQXRxQWdGL0FuNENRQUpBSUFCRkRRQWdBQ2dDQUNJQ1FYOUdEUUVnQUNBQ1FRRnFOZ0lBSUFGRkRRQWdBU2dDQUNJQ1FYOUdEUUVnQVNBQ1FRRnFOZ0lBSUFBcEF3Z2dBU0FDTmdJQUlBRXBBd2dnQUNBQUtBSUFRWDlxTmdJQVVnOExFS2dCQUFzUXFRRUFDMm9DQVg4Q2ZnSkFBa0FnQUVVTkFDQUFLQUlBSWdKQmYwWU5BU0FBSUFKQkFXbzJBZ0FnQVVVTkFDQUJLQUlBSWdKQmYwWU5BU0FCSUFKQkFXbzJBZ0FnQUNrRENDQUJJQUkyQWdBZ0FTa0RDQ0FBSUFBb0FnQkJmMm8yQWdCVER3c1FxQUVBQ3hDcEFRQUxhZ0lCZndKK0FrQUNRQ0FBUlEwQUlBQW9BZ0FpQWtGL1JnMEJJQUFnQWtFQmFqWUNBQ0FCUlEwQUlBRW9BZ0FpQWtGL1JnMEJJQUVnQWtFQmFqWUNBQ0FBS1FNSUlBRWdBallDQUNBQktRTUlJQUFnQUNnQ0FFRi9hallDQUZjUEN4Q29BUUFMRUtrQkFBdHFBZ0YvQW40Q1FBSkFJQUJGRFFBZ0FDZ0NBQ0lDUVg5R0RRRWdBQ0FDUVFGcU5nSUFJQUZGRFFBZ0FTZ0NBQ0lDUVg5R0RRRWdBU0FDUVFGcU5nSUFJQUFwQXdnZ0FTQUNOZ0lBSUFFcEF3Z2dBQ0FBS0FJQVFYOXFOZ0lBVlE4TEVLZ0JBQXNRcVFFQUMyb0NBWDhDZmdKQUFrQWdBRVVOQUNBQUtBSUFJZ0pCZjBZTkFTQUFJQUpCQVdvMkFnQWdBVVVOQUNBQktBSUFJZ0pCZjBZTkFTQUJJQUpCQVdvMkFnQWdBQ2tEQ0NBQklBSTJBZ0FnQVNrRENDQUFJQUFvQWdCQmYybzJBZ0JaRHdzUXFBRUFDeENwQVFBTGZBRURmeUFBSUFBUXRBRWlBRUVJRUpVQklBQnJJZ0lRc2dFaEFFR1FsY0FBSUFFZ0Ftc2lBVFlDQUVHWWxjQUFJQUEyQWdBZ0FDQUJRUUZ5TmdJRVFRaEJDQkNWQVNFQ1FSUkJDQkNWQVNFRFFSQkJDQkNWQVNFRUlBQWdBUkN5QVNBRUlBTWdBa0VJYTJwcU5nSUVRYlNWd0FCQmdJQ0FBVFlDQUF1SEFRRUJmd0pBSUFBRVFDQUFLQUlBRFFFZ0FFRUFOZ0lBSUFGRUFBQUFBQUFBNE1ObUlRSWdBRUlBUXYvLy8vLy8vLy8vL3dBQ2ZpQUJtVVFBQUFBQUFBRGdRMk1FUUNBQnNBd0JDMEtBZ0lDQWdJQ0FnSUIvQzBLQWdJQ0FnSUNBZ0lCL0lBSWJJQUZFLy8vLy8vLy8zME5rR3lBQklBRmlHemNEQ0E4TEVLZ0JBQXNRcVFFQUMyd0JBWDhqQUVFd2F5SURKQUFnQXlBQk5nSUVJQU1nQURZQ0FDQURRUnhxUVFJMkFnQWdBMEVzYWtFaU5nSUFJQU5DQWpjQ0RDQURRWkNPd0FBMkFnZ2dBMEVpTmdJa0lBTWdBMEVnYWpZQ0dDQURJQU0yQWlnZ0F5QURRUVJxTmdJZ0lBTkJDR29nQWhCNkFBdHZBUUYvSXdCQk1Hc2lBaVFBSUFJZ0FUWUNCQ0FDSUFBMkFnQWdBa0VjYWtFQ05nSUFJQUpCTEdwQklqWUNBQ0FDUWdJM0Fnd2dBa0hna01BQU5nSUlJQUpCSWpZQ0pDQUNJQUpCSUdvMkFoZ2dBaUFDUVFScU5nSW9JQUlnQWpZQ0lDQUNRUWhxUVp5UXdBQVFlZ0FMY0FFQmZ5TUFRVEJySWdFa0FDQUJRZmdBTmdJRUlBRWdBRFlDQUNBQlFSeHFRUUkyQWdBZ0FVRXNha0VpTmdJQUlBRkNBamNDRENBQlFZQ1J3QUEyQWdnZ0FVRWlOZ0lrSUFFZ0FVRWdhallDR0NBQklBRkJCR28yQWlnZ0FTQUJOZ0lnSUFGQkNHcEI0SW5BQUJCNkFBdHNBUUYvSXdCQk1Hc2lBeVFBSUFNZ0FUWUNCQ0FESUFBMkFnQWdBMEVjYWtFQ05nSUFJQU5CTEdwQklqWUNBQ0FEUWdJM0Fnd2dBMEcwa2NBQU5nSUlJQU5CSWpZQ0pDQURJQU5CSUdvMkFoZ2dBeUFEUVFScU5nSW9JQU1nQXpZQ0lDQURRUWhxSUFJUWVnQUxVUUVFZndKQUlBQUVRQ0FBS0FJQURRRWdBRUVBTmdJQUlBQW9BaFFoQVNBQUtBSVlJQUFvQWlBaEF5QUFLQUlrSVFRZ0FCQVFCRUFnQVJBUUN5QUVCRUFnQXhBUUN3OExFS2dCQUFzUXFRRUFDMUVCQkg4Q1FDQUFCRUFnQUNnQ0FBMEJJQUJCQURZQ0FDQUFLQUlVSVFFZ0FDZ0NHQ0FBS0FJc0lRTWdBQ2dDTUNFRUlBQVFFQVJBSUFFUUVBc2dCQVJBSUFNUUVBc1BDeENvQVFBTEVLa0JBQXRpQVFOL0FrQWdBQVJBSUFBb0FnQU5BU0FBUVFBMkFnQWdBQ2dDQ0NFQ0lBQW9BZ3doQVNBQUtBSUVJUU1nQUJBUUFrQWdBeEFCUlEwQUlBSWdBU2dDQUJFRUFDQUJLQUlFUlEwQUlBRW9BZ2dhSUFJUUVBc1BDeENvQVFBTEVLa0JBQXRVQVFGL0l3QkJJR3NpQWlRQUlBSWdBQ2dDQURZQ0JDQUNRUmhxSUFGQkVHb3BBZ0EzQXdBZ0FrRVFhaUFCUVFocUtRSUFOd01BSUFJZ0FTa0NBRGNEQ0NBQ1FRUnFJQUpCQ0dvUUhTQUNRU0JxSkFBTFpnRUNmd0pBQWtBQ1FDQUJRUWhxS0FJQUlnSkJBRTRFUUNBQktBSUFJUU1nQWcwQlFRRWhBUXdDQ3hCNUFBc2dBa0VCRUpvQklnRkZEUUVMSUFFZ0F5QUNFTEVCSVFFZ0FDQUNOZ0lJSUFBZ0FqWUNCQ0FBSUFFMkFnQVBDeUFDUVFFUXJ3RUFDMHNCQW44Z0FFRUVhaWdDQUNBQVFRaHFJZ01vQWdBaUFtdEJBVWtFUUNBQUlBSkJBUkJLQ3lBQUtBSUFJZ0JCQVdvZ0FDQUNFQmNnQUNBQlFRRVFzUUVhSUFNZ0FrRUJhallDQUF0UEFRSi9JQUFvQWdBaUEwRUVhaWdDQUNBRFFRaHFJZ1FvQWdBaUFHc2dBa2tFUUNBRElBQWdBaEJLSUFRb0FnQWhBQXNnQXlnQ0FDQUFhaUFCSUFJUXNRRWFJQVFnQUNBQ2FqWUNBRUVBQzFFQkFYOGpBRUVRYXlJRUpBQWdBU2dDQUNBQ0tBSUFJQU1vQWdBUUJDRUJJQVJCQ0dvUWdnRWdCQ2dDRENFQ0lBQWdCQ2dDQ0NJRFFRQkhOZ0lBSUFBZ0FpQUJJQU1iTmdJRUlBUkJFR29rQUF0REFRTi9Ba0FnQWtVTkFBTkFJQUF0QUFBaUJDQUJMUUFBSWdWR0JFQWdBRUVCYWlFQUlBRkJBV29oQVNBQ1FYOXFJZ0lOQVF3Q0N3c2dCQ0FGYXlFREN5QURDMHdCQW44akFFRVFheUlESkFBZ0FTZ0NBQ0FDS0FJQUVBSWhBU0FEUVFocUVJSUJJQU1vQWd3aEFpQUFJQU1vQWdnaUJFRUFSellDQUNBQUlBSWdBU0FFR3pZQ0JDQURRUkJxSkFBTFN3QUNRQUovSUFGQmdJREVBRWNFUUVFQklBQW9BaGdnQVNBQVFSeHFLQUlBS0FJUUVRQUFEUUVhQ3lBQ0RRRkJBQXNQQ3lBQUtBSVlJQUpCQUNBQVFSeHFLQUlBS0FJTUVRTUFDem9CQW44Q1FDQUFCRUFnQUNnQ0FBMEJJQUJCQURZQ0FDQUFLQUlVSVFFZ0FDZ0NHQ0FBRUJBRVFDQUJFQkFMRHdzUXFBRUFDeENwQVFBTFJ3RUJmeU1BUVNCcklnTWtBQ0FEUVJScVFRQTJBZ0FnQTBITWpjQUFOZ0lRSUFOQ0FUY0NCQ0FESUFFMkFod2dBeUFBTmdJWUlBTWdBMEVZYWpZQ0FDQURJQUlRZWdBTFJnRUNmeUFCS0FJRUlRSWdBU2dDQUNFRFFRaEJCQkNhQVNJQlJRUkFRUWhCQkJDdkFRQUxJQUVnQWpZQ0JDQUJJQU0yQWdBZ0FFRzBqTUFBTmdJRUlBQWdBVFlDQUFzNUFRRi9JQUZCRUhaQUFDRUNJQUJCQURZQ0NDQUFRUUFnQVVHQWdIeHhJQUpCZjBZaUFSczJBZ1FnQUVFQUlBSkJFSFFnQVJzMkFnQUxhQUVEZnlNQVFSQnJJZ0VrQUNBQUtBSU1JZ0pGQkVCQnZJdkFBRUVyUVlTTXdBQVFkUUFMSUFBb0FnZ2lBMFVFUUVHOGk4QUFRU3RCbEl6QUFCQjFBQXNnQVNBQ05nSUlJQUVnQURZQ0JDQUJJQU0yQWdBZ0FTZ0NBQ0FCS0FJRUlBRW9BZ2dRV2dBTFB3RUJmeU1BUVNCcklnQWtBQ0FBUVJ4cVFRQTJBZ0FnQUVHZ2pjQUFOZ0lZSUFCQ0FUY0NEQ0FBUWJTTndBQTJBZ2dnQUVFSWFrRzhqY0FBRUhvQUN6NEJBWDhqQUVFZ2F5SUNKQUFnQWtFQk9nQVlJQUlnQVRZQ0ZDQUNJQUEyQWhBZ0FrSE1qY0FBTmdJTUlBSkJ6STNBQURZQ0NDQUNRUWhxRUhnQUN5c0FBa0FnQUVGOFN3MEFJQUJGQkVCQkJBOExJQUFnQUVGOVNVRUNkQkNhQVNJQVJRMEFJQUFQQ3dBTEt3QUNRQ0FBQkVBZ0FDZ0NBQTBCSUFCQkFEWUNBQ0FBUVJCcUlBRTJBZ0FQQ3hDb0FRQUxFS2tCQUFzb0FBSkFJQUFFUUNBQUtBSUFRWDlHRFFFZ0FFRXNhaTBBQUVFQVJ3OExFS2dCQUFzUXFRRUFDeVVBQWtBZ0FBUkFJQUFvQWdCQmYwWU5BU0FBUVJCcUtBSUFEd3NRcUFFQUN4Q3BBUUFMSndBZ0FDQUFLQUlFUVFGeElBRnlRUUp5TmdJRUlBQWdBV29pQUNBQUtBSUVRUUZ5TmdJRUN5TUFBa0FnQUFSQUlBQW9BZ0JCZjBZTkFTQUFLUU1JdVE4TEVLZ0JBQXNRcVFFQUN5WUFBa0FnQUVVTkFDQUFJQUVvQWdBUkJBQWdBU2dDQkVVTkFDQUJLQUlJR2lBQUVCQUxDem9CQW45QjRKSEFBQzBBQUNFQlFlQ1J3QUJCQURvQUFFSGtrY0FBS0FJQUlRSkI1SkhBQUVFQU5nSUFJQUFnQWpZQ0JDQUFJQUUyQWdBTEhnQUNRQ0FBUVFScUtBSUFSUTBBSUFBb0FnQWlBRVVOQUNBQUVCQUxDeUFCQVg4Q1FDQUFLQUlFSWdGRkRRQWdBRUVJYWlnQ0FFVU5BQ0FCRUJBTEN4OEFBa0FnQVVGOFRRUkFJQUFnQVVFRUlBSVFsZ0VpQUEwQkN3QUxJQUFMSXdBZ0FpQUNLQUlFUVg1eE5nSUVJQUFnQVVFQmNqWUNCQ0FBSUFGcUlBRTJBZ0FMSlFBZ0FFVUVRRUgwaDhBQVFUQVFxZ0VBQ3lBQUlBSWdBeUFFSUFVZ0FTZ0NFQkVOQUFzakFDQUFSUVJBUWZTSHdBQkJNQkNxQVFBTElBQWdBaUFESUFRZ0FTZ0NFQkVUQUFzakFDQUFSUVJBUWZTSHdBQkJNQkNxQVFBTElBQWdBaUFESUFRZ0FTZ0NFQkVLQUFzakFDQUFSUVJBUWZTSHdBQkJNQkNxQVFBTElBQWdBaUFESUFRZ0FTZ0NFQkVHQUFzakFDQUFSUVJBUWZTSHdBQkJNQkNxQVFBTElBQWdBaUFESUFRZ0FTZ0NFQkVWQUFzZUFDQUFJQUZCQTNJMkFnUWdBQ0FCYWlJQUlBQW9BZ1JCQVhJMkFnUUxIUUFDUUNBQUtBSUFSUTBBSUFBb0FnUWlBRUVrU1EwQUlBQVFBQXNMSVFBZ0FFVUVRRUgwaDhBQVFUQVFxZ0VBQ3lBQUlBSWdBeUFCS0FJUUVRVUFDeDhBSUFCRkJFQkJ3b2JBQUVFd0VLb0JBQXNnQUNBQ0lBRW9BaEFSQVFBTEh3QWdBRVVFUUVIRWg4QUFRVEFRcWdFQUN5QUFJQUlnQVNnQ0VCRUJBQXNmQUNBQVJRUkFRZlNId0FCQk1CQ3FBUUFMSUFBZ0FpQUJLQUlRRVFBQUN4a0JBWDhnQUNnQ0VDSUJCSDhnQVFVZ0FFRVVhaWdDQUFzTEVnQkJBRUVaSUFCQkFYWnJJQUJCSDBZYkN4WUFJQUFnQVVFQmNqWUNCQ0FBSUFGcUlBRTJBZ0FMRUFBZ0FDQUJha0YvYWtFQUlBRnJjUXNNQUNBQUlBRWdBaUFERUJZTEN3QWdBUVJBSUFBUUVBc0xEd0FnQUVFQmRDSUFRUUFnQUd0eUN4UUFJQUFvQWdBZ0FTQUFLQUlFS0FJTUVRQUFDd2dBSUFBZ0FSQWxDeFlBUWVTUndBQWdBRFlDQUVIZ2tjQUFRUUU2QUFBTEV3QWdBRUcwak1BQU5nSUVJQUFnQVRZQ0FBc05BQ0FBS0FJQUlBRVFMMEVBQ3cwQUlBQXRBQVJCQW5GQkFYWUxFQUFnQVNBQUtBSUFJQUFvQWdRUUVRc0tBRUVBSUFCcklBQnhDd3NBSUFBdEFBUkJBM0ZGQ3d3QUlBQWdBVUVEY2pZQ0JBc05BQ0FBS0FJQUlBQW9BZ1JxQ3c0QUlBQW9BZ0FhQTBBTUFBc0FDd3NBSUFBMUFnQWdBUkEzQ3dzQUlBQWpBR29rQUNNQUN4d0FJQUVvQWhoQnY0YkFBRUVESUFGQkhHb29BZ0FvQWd3UkF3QUxEUUJCMElyQUFFRWJFS29CQUFzT0FFSHJpc0FBUWM4QUVLb0JBQXNKQUNBQUlBRVFCd0FMQ2dBZ0FDZ0NCRUY0Y1FzS0FDQUFLQUlFUVFGeEN3b0FJQUFvQWd4QkFYRUxDZ0FnQUNnQ0RFRUJkZ3NaQUNBQUlBRkI2SkhBQUNnQ0FDSUFRUlVnQUJzUkFRQUFDd29BSUFBZ0FTQUNFSEVMQ2dBZ0FDQUJJQUlRTWdzSEFDQUFJQUZxQ3djQUlBQWdBV3NMQndBZ0FFRUlhZ3NIQUNBQVFYaHFDd3dBUXZiaStMSHk0YS9uQlFzTkFFTFJycGpFbVlPeTk0Ui9Dd3dBUW9HNHFwUDE4K1hzRkFzREFBRUxBd0FCQ3d2TEVRRUFRWUNBd0FBTHdSRnpjbU12WVhOelpYUXVjbk1BQUJBQURBQUFBQlFBQUFBdUFBQUFBQUFRQUF3QUFBQVpBQUFBVXdBQUFBQUFFQUFNQUFBQU9RQUFBR1FBQUFCT1lVNUhUMHhQVTBkQ1IwZEZVMVJUQUFBUUFBd0FBQUNUQUFBQUZBQUFBQUFBQUFCaGRIUmxiWEIwSUhSdklHUnBkbWxrWlNCaWVTQjZaWEp2QUFBQUFBQUFBR0YwZEdWdGNIUWdkRzhnWkdsMmFXUmxJSGRwZEdnZ2IzWmxjbVpzYjNjQUFBQVFBQXdBQUFDWEFBQUFGQUFBQUFBQUVBQU1BQUFBbXdBQUFCUUFBQUJoZEhSbGJYQjBJSFJ2SUdOaGJHTjFiR0YwWlNCMGFHVWdjbVZ0WVdsdVpHVnlJSGRwZEdnZ1lTQmthWFpwYzI5eUlHOW1JSHBsY204QUFBQUFBQUFBWVhSMFpXMXdkQ0IwYnlCallXeGpkV3hoZEdVZ2RHaGxJSEpsYldGcGJtUmxjaUIzYVhSb0lHOTJaWEptYkc5M0FBQVFBQXdBQUFDZkFBQUFGQUFBQUFBQUVBQU1BQUFBcXdBQUFCd0FBQUJoYzNObGNuUnBiMjRnWm1GcGJHVmtPaUJ6Wld4bUxtbHpYMk5vWVhKZlltOTFibVJoY25rb1lYUXBMM0oxYzNSakx6YzNNemRsTUdJMVl6UXhNRE15TVRaa05tWmtPR05tT1RReFlqZGhZamxpWkdKaFlXTmxOMk12YkdsaWNtRnllUzloYkd4dll5OXpjbU12YzNSeWFXNW5Mbkp6QUFCN0FSQUFTd0FBQUVJR0FBQUpBQUFBWTJGc2JHVmtJR0JQY0hScGIyNDZPblZ1ZDNKaGNDZ3BZQ0J2YmlCaElHQk9iMjVsWUNCMllXeDFaV05oYkd4bFpDQmdVbVZ6ZFd4ME9qcDFibmR5WVhBb0tXQWdiMjRnWVc0Z1lFVnljbUFnZG1Gc2RXVUFBQUVBQUFBQUFBQUFBUUFBQUFJQUFBQUJBQUFBQUFBQUFBb0FBQUFBQUFBQVpBQUFBQUFBQUFEb0F3QUFBQUFBQUJBbkFBQUFBQUFBb0lZQkFBQUFBQUJBUWc4QUFBQUFBSUNXbUFBQUFBQUFBT0gxQlFBQUFBQUF5cG83QUFBQUFBRGtDMVFDQUFBQUFPaDJTQmNBQUFBQUVLWFU2QUFBQUFDZ2NrNFlDUUFBQUVCNkVQTmFBQUJ6Y21NdlptbDRaV1JmZFhScGJITXVjbk1BQUxnQ0VBQVNBQUFBY1FBQUFCQUFBQUM0QWhBQUVnQUFBSHdBQUFBVUFBQUF1QUlRQUJJQUFBQjlBQUFBRXdBQUFBQUFBQUJoZEhSbGJYQjBJSFJ2SUdScGRtbGtaU0JpZVNCNlpYSnZBQUFBQUFBQUFHRjBkR1Z0Y0hRZ2RHOGdaR2wyYVdSbElIZHBkR2dnYjNabGNtWnNiM2RPWVU1amJHOXpkWEpsSUdsdWRtOXJaV1FnY21WamRYSnphWFpsYkhrZ2IzSWdaR1Z6ZEhKdmVXVmtJR0ZzY21WaFpIbFhjbTl1WnlCclpYa2diM0lnYVhaRFlXNXViM1FnWkdWamNubHdkQ0JrZEdFQUF3QUFBQWdBQUFBRUFBQUFCQUFBQUFVQUFBQkdiazl1WTJVZ1kyRnNiR1ZrSUcxdmNtVWdkR2hoYmlCdmJtTmxZMnh2YzNWeVpTQnBiblp2YTJWa0lISmxZM1Z5YzJsMlpXeDVJRzl5SUdSbGMzUnliM2xsWkNCaGJISmxZV1I1WTJ4dmMzVnlaU0JwYm5admEyVmtJSEpsWTNWeWMybDJaV3g1SUc5eUlHUmxjM1J5YjNsbFpDQmhiSEpsWVdSNUwzSnZiM1F2TG1OaGNtZHZMM0psWjJsemRISjVMM055WXk5bmFYUm9kV0l1WTI5dExURmxZMk0yTWprNVpHSTVaV000TWpNdllteHZZMnN0Y0dGa1pHbHVaeTB3TGpJdU1TOXpjbU12YkdsaUxuSnpKQVFRQUZRQUFBQ3dBQUFBRXdBQUFDOXliMjkwTHk1allYSm5ieTl5WldkcGMzUnllUzl6Y21NdloybDBhSFZpTG1OdmJTMHhaV05qTmpJNU9XUmlPV1ZqT0RJekwyRmxjeTB3TGpjdU5TOXpjbU12YzI5bWRDOW1hWGh6YkdsalpUTXlMbkp6QUFDSUJCQUFWZ0FBQU9jQUFBQWpBQUFBaUFRUUFGWUFBQURUQVFBQUd3QUFBSWdFRUFCV0FBQUEwd0VBQUNjQUFBQ0lCQkFBVmdBQUFPUUJBQUFrQUFBQWlBUVFBRllBQUFENUFRQUFLQUFBQUlnRUVBQldBQUFBa1FRQUFCSUFBQUNJQkJBQVZnQUFBSkVFQUFBOUFBQUFiblZzYkNCd2IybHVkR1Z5SUhCaGMzTmxaQ0IwYnlCeWRYTjBjbVZqZFhKemFYWmxJSFZ6WlNCdlppQmhiaUJ2WW1wbFkzUWdaR1YwWldOMFpXUWdkMmhwWTJnZ2QyOTFiR1FnYkdWaFpDQjBieUIxYm5OaFptVWdZV3hwWVhOcGJtY2dhVzRnY25WemRBQUFZMkZzYkdWa0lHQlBjSFJwYjI0Nk9uVnVkM0poY0NncFlDQnZiaUJoSUdCT2IyNWxZQ0IyWVd4MVpXeHBZbkpoY25rdmMzUmtMM055WXk5d1lXNXBZMnRwYm1jdWNuTUE1d1VRQUJ3QUFBQkdBZ0FBSHdBQUFPY0ZFQUFjQUFBQVJ3SUFBQjRBQUFBV0FBQUFEQUFBQUFRQUFBQVhBQUFBR0FBQUFBZ0FBQUFFQUFBQUdRQUFBQm9BQUFBUUFBQUFCQUFBQUJzQUFBQWNBQUFBR0FBQUFBZ0FBQUFFQUFBQUhRQUFBQjRBQUFBWUFBQUFCQUFBQUFRQUFBQWZBQUFBSUFBQUFDRUFBQUJzYVdKeVlYSjVMMkZzYkc5akwzTnlZeTl5WVhkZmRtVmpMbkp6WTJGd1lXTnBkSGtnYjNabGNtWnNiM2NBQUFDZ0JoQUFFUUFBQUlRR0VBQWNBQUFBQmdJQUFBVUFBQUFtQUFBQUFBQUFBQUVBQUFBbkFBQUFhVzVrWlhnZ2IzVjBJRzltSUdKdmRXNWtjem9nZEdobElHeGxiaUJwY3lBZ1luVjBJSFJvWlNCcGJtUmxlQ0JwY3lBQUFOd0dFQUFnQUFBQS9BWVFBQklBQUFBNklBQUF6QVlRQUFBQUFBQWdCeEFBQWdBQUFEQXdNREV3TWpBek1EUXdOVEEyTURjd09EQTVNVEF4TVRFeU1UTXhOREUxTVRZeE56RTRNVGt5TURJeE1qSXlNekkwTWpVeU5qSTNNamd5T1RNd016RXpNak16TXpRek5UTTJNemN6T0RNNU5EQTBNVFF5TkRNME5EUTFORFkwTnpRNE5EazFNRFV4TlRJMU16VTBOVFUxTmpVM05UZzFPVFl3TmpFMk1qWXpOalEyTlRZMk5qYzJPRFk1TnpBM01UY3lOek0zTkRjMU56WTNOemM0TnprNE1EZ3hPREk0TXpnME9EVTROamczT0RnNE9Ua3dPVEU1TWprek9UUTVOVGsyT1RjNU9EazViR2xpY21GeWVTOWpiM0psTDNOeVl5OXpiR2xqWlM5dFpXMWphSEl1Y25QOEJ4QUFJQUFBQUZzQUFBQUZBQUFBY21GdVoyVWdjM1JoY25RZ2FXNWtaWGdnSUc5MWRDQnZaaUJ5WVc1blpTQm1iM0lnYzJ4cFkyVWdiMllnYkdWdVozUm9JQ3dJRUFBU0FBQUFQZ2dRQUNJQUFBQnlZVzVuWlNCbGJtUWdhVzVrWlhnZ2NBZ1FBQkFBQUFBK0NCQUFJZ0FBQUhOc2FXTmxJR2x1WkdWNElITjBZWEowY3lCaGRDQWdZblYwSUdWdVpITWdZWFFnQUpBSUVBQVdBQUFBcGdnUUFBMEFld2x3Y205a2RXTmxjbk1DQ0d4aGJtZDFZV2RsQVFSU2RYTjBBQXh3Y205alpYTnpaV1F0WW5rREJYSjFjM1JqSFRFdU5qQXVNQ0FvTnpjek4yVXdZalZqSURJd01qSXRNRFF0TURRcEJuZGhiSEoxY3dZd0xqRTVMakFNZDJGemJTMWlhVzVrWjJWdUVqQXVNaTQzTmlBb1lUZzRNV0U0TTJNMUtRPT0nO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsbC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQ4LWFycmF5LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmNvcHktd2l0aGluLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGwuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsdGVyLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mb3ItZWFjaC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlcy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZi5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5qb2luLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2YuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubWFwLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHQuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmV2ZXJzZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zZXQuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2UuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29tZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb3J0LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLWxvY2FsZS1zdHJpbmcuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbnQzMi1hcnJheS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24uanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2UuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy93ZWIudXJsLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL3dlYi51cmwtc2VhcmNoLXBhcmFtcy5qc1wiKTtcblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgd2FzbV9iaW5kZ2VuO1xuXG4oZnVuY3Rpb24gKCkge1xuICB2YXIgX19leHBvcnRzID0ge307XG4gIHZhciB3YXNtO1xuICB2YXIgaGVhcCA9IG5ldyBBcnJheSgzMikuZmlsbCh1bmRlZmluZWQpO1xuICBoZWFwLnB1c2godW5kZWZpbmVkLCBudWxsLCB0cnVlLCBmYWxzZSk7XG5cbiAgZnVuY3Rpb24gZ2V0T2JqZWN0KGlkeCkge1xuICAgIHJldHVybiBoZWFwW2lkeF07XG4gIH1cblxuICB2YXIgaGVhcF9uZXh0ID0gaGVhcC5sZW5ndGg7XG5cbiAgZnVuY3Rpb24gZHJvcE9iamVjdChpZHgpIHtcbiAgICBpZiAoaWR4IDwgMzYpIHJldHVybjtcbiAgICBoZWFwW2lkeF0gPSBoZWFwX25leHQ7XG4gICAgaGVhcF9uZXh0ID0gaWR4O1xuICB9XG5cbiAgZnVuY3Rpb24gdGFrZU9iamVjdChpZHgpIHtcbiAgICB2YXIgcmV0ID0gZ2V0T2JqZWN0KGlkeCk7XG4gICAgZHJvcE9iamVjdChpZHgpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICB2YXIgY2FjaGVkVGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jywge1xuICAgIGlnbm9yZUJPTTogdHJ1ZSxcbiAgICBmYXRhbDogdHJ1ZVxuICB9KTtcbiAgY2FjaGVkVGV4dERlY29kZXIuZGVjb2RlKCk7XG4gIHZhciBjYWNoZWdldFVpbnQ4TWVtb3J5MCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gZ2V0VWludDhNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWdldFVpbnQ4TWVtb3J5MCA9PT0gbnVsbCB8fCBjYWNoZWdldFVpbnQ4TWVtb3J5MC5idWZmZXIgIT09IHdhc20ubWVtb3J5LmJ1ZmZlcikge1xuICAgICAgY2FjaGVnZXRVaW50OE1lbW9yeTAgPSBuZXcgVWludDhBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoZWdldFVpbnQ4TWVtb3J5MDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFN0cmluZ0Zyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHJldHVybiBjYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoZ2V0VWludDhNZW1vcnkwKCkuc3ViYXJyYXkocHRyLCBwdHIgKyBsZW4pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VNdXRDbG9zdXJlKGFyZzAsIGFyZzEsIGR0b3IsIGYpIHtcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBhOiBhcmcwLFxuICAgICAgYjogYXJnMSxcbiAgICAgIGNudDogMSxcbiAgICAgIGR0b3I6IGR0b3JcbiAgICB9O1xuXG4gICAgdmFyIHJlYWwgPSBmdW5jdGlvbiByZWFsKCkge1xuICAgICAgLy8gRmlyc3QgdXAgd2l0aCBhIGNsb3N1cmUgd2UgaW5jcmVtZW50IHRoZSBpbnRlcm5hbCByZWZlcmVuY2VcbiAgICAgIC8vIGNvdW50LiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgUnVzdCBjbG9zdXJlIGVudmlyb25tZW50IHdvbid0XG4gICAgICAvLyBiZSBkZWFsbG9jYXRlZCB3aGlsZSB3ZSdyZSBpbnZva2luZyBpdC5cbiAgICAgIHN0YXRlLmNudCsrO1xuICAgICAgdmFyIGEgPSBzdGF0ZS5hO1xuICAgICAgc3RhdGUuYSA9IDA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZi5hcHBseSh2b2lkIDAsIFthLCBzdGF0ZS5iXS5jb25jYXQoYXJncykpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKC0tc3RhdGUuY250ID09PSAwKSB7XG4gICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8wLmdldChzdGF0ZS5kdG9yKShhLCBzdGF0ZS5iKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5hID0gYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZWFsLm9yaWdpbmFsID0gc3RhdGU7XG4gICAgcmV0dXJuIHJlYWw7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRIZWFwT2JqZWN0KG9iaikge1xuICAgIGlmIChoZWFwX25leHQgPT09IGhlYXAubGVuZ3RoKSBoZWFwLnB1c2goaGVhcC5sZW5ndGggKyAxKTtcbiAgICB2YXIgaWR4ID0gaGVhcF9uZXh0O1xuICAgIGhlYXBfbmV4dCA9IGhlYXBbaWR4XTtcbiAgICBoZWFwW2lkeF0gPSBvYmo7XG4gICAgcmV0dXJuIGlkeDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9fd2JnX2FkYXB0ZXJfMTAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIHdhc20uX2R5bl9jb3JlX19vcHNfX2Z1bmN0aW9uX19Gbk11dF9fQV9fX19PdXRwdXRfX19SX2FzX3dhc21fYmluZGdlbl9fY2xvc3VyZV9fV2FzbUNsb3N1cmVfX19kZXNjcmliZV9faW52b2tlX19oY2UyZWQzODdhYTFjMmI2OShhcmcwLCBhcmcxLCBhZGRIZWFwT2JqZWN0KGFyZzIpKTtcbiAgfVxuXG4gIHZhciBXQVNNX1ZFQ1RPUl9MRU4gPSAwO1xuICB2YXIgY2FjaGVkVGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoJ3V0Zi04Jyk7XG4gIHZhciBlbmNvZGVTdHJpbmcgPSB0eXBlb2YgY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlSW50byA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uIChhcmcsIHZpZXcpIHtcbiAgICByZXR1cm4gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlSW50byhhcmcsIHZpZXcpO1xuICB9IDogZnVuY3Rpb24gKGFyZywgdmlldykge1xuICAgIHZhciBidWYgPSBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGUoYXJnKTtcbiAgICB2aWV3LnNldChidWYpO1xuICAgIHJldHVybiB7XG4gICAgICByZWFkOiBhcmcubGVuZ3RoLFxuICAgICAgd3JpdHRlbjogYnVmLmxlbmd0aFxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFzc1N0cmluZ1RvV2FzbTAoYXJnLCBtYWxsb2MsIHJlYWxsb2MpIHtcbiAgICBpZiAocmVhbGxvYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgYnVmID0gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlKGFyZyk7XG5cbiAgICAgIHZhciBfcHRyID0gbWFsbG9jKGJ1Zi5sZW5ndGgpO1xuXG4gICAgICBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShfcHRyLCBfcHRyICsgYnVmLmxlbmd0aCkuc2V0KGJ1Zik7XG4gICAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBidWYubGVuZ3RoO1xuICAgICAgcmV0dXJuIF9wdHI7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IGFyZy5sZW5ndGg7XG4gICAgdmFyIHB0ciA9IG1hbGxvYyhsZW4pO1xuICAgIHZhciBtZW0gPSBnZXRVaW50OE1lbW9yeTAoKTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgIGZvciAoOyBvZmZzZXQgPCBsZW47IG9mZnNldCsrKSB7XG4gICAgICB2YXIgY29kZSA9IGFyZy5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgICBpZiAoY29kZSA+IDB4N0YpIGJyZWFrO1xuICAgICAgbWVtW3B0ciArIG9mZnNldF0gPSBjb2RlO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXQgIT09IGxlbikge1xuICAgICAgaWYgKG9mZnNldCAhPT0gMCkge1xuICAgICAgICBhcmcgPSBhcmcuc2xpY2Uob2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgcHRyID0gcmVhbGxvYyhwdHIsIGxlbiwgbGVuID0gb2Zmc2V0ICsgYXJnLmxlbmd0aCAqIDMpO1xuICAgICAgdmFyIHZpZXcgPSBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIgKyBvZmZzZXQsIHB0ciArIGxlbik7XG4gICAgICB2YXIgcmV0ID0gZW5jb2RlU3RyaW5nKGFyZywgdmlldyk7XG4gICAgICBvZmZzZXQgKz0gcmV0LndyaXR0ZW47XG4gICAgfVxuXG4gICAgV0FTTV9WRUNUT1JfTEVOID0gb2Zmc2V0O1xuICAgIHJldHVybiBwdHI7XG4gIH1cblxuICB2YXIgY2FjaGVnZXRJbnQzMk1lbW9yeTAgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGdldEludDMyTWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVnZXRJbnQzMk1lbW9yeTAgPT09IG51bGwgfHwgY2FjaGVnZXRJbnQzMk1lbW9yeTAuYnVmZmVyICE9PSB3YXNtLm1lbW9yeS5idWZmZXIpIHtcbiAgICAgIGNhY2hlZ2V0SW50MzJNZW1vcnkwID0gbmV3IEludDMyQXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGVnZXRJbnQzMk1lbW9yeTA7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xpa2VOb25lKHgpIHtcbiAgICByZXR1cm4geCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBfYXNzZXJ0Q2xhc3MoaW5zdGFuY2UsIGtsYXNzKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBrbGFzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIGluc3RhbmNlIG9mIFwiLmNvbmNhdChrbGFzcy5uYW1lKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlLnB0cjtcbiAgfVxuICAvKipcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXRfZGdwXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgKiBAcmV0dXJucyB7U3RyZWFtaW5nSGFuZGxlfVxuICAqL1xuXG5cbiAgX19leHBvcnRzLnN0cmVhbV9ibG9ja19udW1iZXIgPSBmdW5jdGlvbiAoZ2V0X2RncCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcmV0ID0gd2FzbS5zdHJlYW1fYmxvY2tfbnVtYmVyKGFkZEhlYXBPYmplY3QoZ2V0X2RncCksIGFkZEhlYXBPYmplY3QoY2FsbGJhY2spKTtcbiAgICByZXR1cm4gU3RyZWFtaW5nSGFuZGxlLl9fd3JhcChyZXQpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhc3NBcnJheThUb1dhc20wKGFyZywgbWFsbG9jKSB7XG4gICAgdmFyIHB0ciA9IG1hbGxvYyhhcmcubGVuZ3RoICogMSk7XG4gICAgZ2V0VWludDhNZW1vcnkwKCkuc2V0KGFyZywgcHRyIC8gMSk7XG4gICAgV0FTTV9WRUNUT1JfTEVOID0gYXJnLmxlbmd0aDtcbiAgICByZXR1cm4gcHRyO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QXJyYXlVOEZyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHJldHVybiBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIgLyAxLCBwdHIgLyAxICsgbGVuKTtcbiAgfVxuICAvKipcbiAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGtleVxuICAqIEBwYXJhbSB7VWludDhBcnJheX0gaXZcbiAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgKi9cblxuXG4gIF9fZXhwb3J0cy5hZXMyNTZfZGVjcnlwdCA9IGZ1bmN0aW9uIChrZXksIGl2LCBkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcblxuICAgICAgdmFyIHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChrZXksIHdhc20uX193YmluZGdlbl9tYWxsb2MpO1xuICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICB2YXIgcHRyMSA9IHBhc3NBcnJheThUb1dhc20wKGl2LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jKTtcbiAgICAgIHZhciBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgdmFyIHB0cjIgPSBwYXNzQXJyYXk4VG9XYXNtMChkYXRhLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jKTtcbiAgICAgIHZhciBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgd2FzbS5hZXMyNTZfZGVjcnlwdChyZXRwdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIHB0cjIsIGxlbjIpO1xuICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgdmFyIHYzID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG5cbiAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHIwLCByMSAqIDEpO1xuXG4gICAgICByZXR1cm4gdjM7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGYsIGFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4bl9zdG9yZShhZGRIZWFwT2JqZWN0KGUpKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICovXG5cblxuICB2YXIgU3RyZWFtaW5nSGFuZGxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJlYW1pbmdIYW5kbGUoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyZWFtaW5nSGFuZGxlKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU3RyZWFtaW5nSGFuZGxlLCBbe1xuICAgICAga2V5OiBcIl9fZGVzdHJveV9pbnRvX3Jhd1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgdmFyIHB0ciA9IHRoaXMucHRyO1xuICAgICAgICB0aGlzLnB0ciA9IDA7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZyZWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcmVlKCkge1xuICAgICAgICB2YXIgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcblxuICAgICAgICB3YXNtLl9fd2JnX3N0cmVhbWluZ2hhbmRsZV9mcmVlKHB0cik7XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwiX193cmFwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX193cmFwKHB0cikge1xuICAgICAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShTdHJlYW1pbmdIYW5kbGUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLnB0ciA9IHB0cjtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU3RyZWFtaW5nSGFuZGxlO1xuICB9KCk7XG5cbiAgX19leHBvcnRzLlN0cmVhbWluZ0hhbmRsZSA9IFN0cmVhbWluZ0hhbmRsZTtcbiAgLyoqXG4gICovXG5cbiAgdmFyIF9Bc3NldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX0Fzc2V0KCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9Bc3NldCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKF9Bc3NldCwgW3tcbiAgICAgIGtleTogXCJfX2Rlc3Ryb3lfaW50b19yYXdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIHZhciBwdHIgPSB0aGlzLnB0cjtcbiAgICAgICAgdGhpcy5wdHIgPSAwO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmcmVlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZnJlZSgpIHtcbiAgICAgICAgdmFyIHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG5cbiAgICAgICAgd2FzbS5fX3diZ19fYXNzZXRfZnJlZShwdHIpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAgKiBAcmV0dXJucyB7X0Fzc2V0fVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgdmFsdWU6XG4gICAgICAvKipcbiAgICAgICogQHJldHVybnMge19Bc3NldH1cbiAgICAgICovXG4gICAgICBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgdmFyIHJldCA9IHdhc20uX2Fzc2V0X2Nsb25lKHRoaXMucHRyKTtcblxuICAgICAgICByZXR1cm4gX0Fzc2V0Ll9fd3JhcChyZXQpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImFtb3VudFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciByZXQgPSB3YXNtLl9hc3NldF9hbW91bnQodGhpcy5wdHIpO1xuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICAqL1xuICAgICAgLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgd2FzbS5fYXNzZXRfc2V0X2Ftb3VudCh0aGlzLnB0ciwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImFtb3VudEZsb2F0XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG5cbiAgICAgICAgICB3YXNtLl9hc3NldF9hbW91bnRfZmxvYXQocmV0cHRyLCB0aGlzLnB0cik7XG5cbiAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuXG4gICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocjAsIHIxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbW91bnRfc3RyXG4gICAgICAqL1xuICAgICAgLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYW1vdW50X3N0cikge1xuICAgICAgICB2YXIgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFtb3VudF9zdHIsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG5cbiAgICAgICAgd2FzbS5fYXNzZXRfc2V0X2Ftb3VudF9mbG9hdCh0aGlzLnB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFtb3VudF9zdHJcbiAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidXBkYXRlQW1vdW50RmxvYXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVBbW91bnRGbG9hdChhbW91bnRfc3RyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuXG4gICAgICAgICAgdmFyIHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhbW91bnRfc3RyLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG5cbiAgICAgICAgICB3YXNtLl9hc3NldF91cGRhdGVBbW91bnRGbG9hdChyZXRwdHIsIHRoaXMucHRyLCBwdHIwLCBsZW4wKTtcblxuICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG5cbiAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyMCwgcjEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJlY2lzaW9uXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIHJldCA9IHdhc20uX2Fzc2V0X3ByZWNpc2lvbih0aGlzLnB0cik7XG5cbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgICovXG4gICAgICAsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB3YXNtLl9hc3NldF9zZXRfcHJlY2lzaW9uKHRoaXMucHRyLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3ltYm9sXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG5cbiAgICAgICAgICB3YXNtLl9hc3NldF9zeW1ib2wocmV0cHRyLCB0aGlzLnB0cik7XG5cbiAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuXG4gICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocjAsIHIxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAgKi9cbiAgICAgICxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHZhciBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAodmFsdWUsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG5cbiAgICAgICAgd2FzbS5fYXNzZXRfc2V0X3N5bWJvbCh0aGlzLnB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImlzVUlBXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIHJldCA9IHdhc20uX2Fzc2V0X2lzX3VpYSh0aGlzLnB0cik7XG5cbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gZGVjX3BsYWNlc1xuICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKGRlY19wbGFjZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG5cbiAgICAgICAgICB3YXNtLl9hc3NldF90b1N0cmluZyhyZXRwdHIsIHRoaXMucHRyLCAhaXNMaWtlTm9uZShkZWNfcGxhY2VzKSwgaXNMaWtlTm9uZShkZWNfcGxhY2VzKSA/IDAgOiBkZWNfcGxhY2VzKTtcblxuICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG5cbiAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyMCwgcjEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZmxvYXRTdHJpbmdcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcblxuICAgICAgICAgIHdhc20uX2Fzc2V0X2Zsb2F0X3N0cmluZyhyZXRwdHIsIHRoaXMucHRyKTtcblxuICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG5cbiAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyMCwgcjEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICAgICAgKiBAcmV0dXJucyB7X0Fzc2V0fVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcGx1c19udW1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGx1c19udW0obnVtKSB7XG4gICAgICAgIHZhciByZXQgPSB3YXNtLl9hc3NldF9fcGx1c19udW0odGhpcy5wdHIsIG51bSk7XG5cbiAgICAgICAgcmV0dXJuIF9Bc3NldC5fX3dyYXAocmV0KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge19Bc3NldH0gYVxuICAgICAgKiBAcmV0dXJucyB7X0Fzc2V0fVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcGx1c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wbHVzKGEpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGEsIF9Bc3NldCk7XG5cbiAgICAgICAgdmFyIHJldCA9IHdhc20uX2Fzc2V0X19wbHVzKHRoaXMucHRyLCBhLnB0cik7XG5cbiAgICAgICAgcmV0dXJuIF9Bc3NldC5fX3dyYXAocmV0KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtXG4gICAgICAqIEByZXR1cm5zIHtfQXNzZXR9XG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9taW51c19udW1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWludXNfbnVtKG51bSkge1xuICAgICAgICB2YXIgcmV0ID0gd2FzbS5fYXNzZXRfX21pbnVzX251bSh0aGlzLnB0ciwgbnVtKTtcblxuICAgICAgICByZXR1cm4gX0Fzc2V0Ll9fd3JhcChyZXQpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7X0Fzc2V0fSBhXG4gICAgICAqIEByZXR1cm5zIHtfQXNzZXR9XG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9taW51c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9taW51cyhhKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhLCBfQXNzZXQpO1xuXG4gICAgICAgIHZhciByZXQgPSB3YXNtLl9hc3NldF9fbWludXModGhpcy5wdHIsIGEucHRyKTtcblxuICAgICAgICByZXR1cm4gX0Fzc2V0Ll9fd3JhcChyZXQpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1cbiAgICAgICogQHJldHVybnMge19Bc3NldH1cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX211bF9udW1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbXVsX251bShudW0pIHtcbiAgICAgICAgdmFyIHJldCA9IHdhc20uX2Fzc2V0X19tdWxfbnVtKHRoaXMucHRyLCBudW0pO1xuXG4gICAgICAgIHJldHVybiBfQXNzZXQuX193cmFwKHJldCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICogQHBhcmFtIHtfQXNzZXR9IGFcbiAgICAgICogQHJldHVybnMge19Bc3NldH1cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX211bFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tdWwoYSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYSwgX0Fzc2V0KTtcblxuICAgICAgICB2YXIgcmV0ID0gd2FzbS5fYXNzZXRfX211bCh0aGlzLnB0ciwgYS5wdHIpO1xuXG4gICAgICAgIHJldHVybiBfQXNzZXQuX193cmFwKHJldCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICAgICAgKiBAcmV0dXJucyB7X0Fzc2V0fVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZGl2X251bVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kaXZfbnVtKG51bSkge1xuICAgICAgICB2YXIgcmV0ID0gd2FzbS5fYXNzZXRfX2Rpdl9udW0odGhpcy5wdHIsIG51bSk7XG5cbiAgICAgICAgcmV0dXJuIF9Bc3NldC5fX3dyYXAocmV0KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge19Bc3NldH0gYVxuICAgICAgKiBAcmV0dXJucyB7X0Fzc2V0fVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZGl2XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RpdihhKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhLCBfQXNzZXQpO1xuXG4gICAgICAgIHZhciByZXQgPSB3YXNtLl9hc3NldF9fZGl2KHRoaXMucHRyLCBhLnB0cik7XG5cbiAgICAgICAgcmV0dXJuIF9Bc3NldC5fX3dyYXAocmV0KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtXG4gICAgICAqIEByZXR1cm5zIHtfQXNzZXR9XG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9tb2RfbnVtXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21vZF9udW0obnVtKSB7XG4gICAgICAgIHZhciByZXQgPSB3YXNtLl9hc3NldF9fbW9kX251bSh0aGlzLnB0ciwgbnVtKTtcblxuICAgICAgICByZXR1cm4gX0Fzc2V0Ll9fd3JhcChyZXQpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7X0Fzc2V0fSBhXG4gICAgICAqIEByZXR1cm5zIHtfQXNzZXR9XG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9tb2RcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbW9kKGEpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGEsIF9Bc3NldCk7XG5cbiAgICAgICAgdmFyIHJldCA9IHdhc20uX2Fzc2V0X19tb2QodGhpcy5wdHIsIGEucHRyKTtcblxuICAgICAgICByZXR1cm4gX0Fzc2V0Ll9fd3JhcChyZXQpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7X1ByaWNlfSBwXG4gICAgICAqIEBwYXJhbSB7X0Fzc2V0fSByZW1haW5cbiAgICAgICogQHJldHVybnMge19Bc3NldH1cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX211bF9wcmljZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tdWxfcHJpY2UocCwgcmVtYWluKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhwLCBfUHJpY2UpO1xuXG4gICAgICAgIF9hc3NlcnRDbGFzcyhyZW1haW4sIF9Bc3NldCk7XG5cbiAgICAgICAgdmFyIHJldCA9IHdhc20uX2Fzc2V0X19tdWxfcHJpY2UodGhpcy5wdHIsIHAucHRyLCByZW1haW4ucHRyKTtcblxuICAgICAgICByZXR1cm4gX0Fzc2V0Ll9fd3JhcChyZXQpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7X0Fzc2V0fSBhXG4gICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlcVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVxKGEpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGEsIF9Bc3NldCk7XG5cbiAgICAgICAgdmFyIHJldCA9IHdhc20uX2Fzc2V0X2VxKHRoaXMucHRyLCBhLnB0cik7XG5cbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge19Bc3NldH0gYVxuICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBuZShhKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhLCBfQXNzZXQpO1xuXG4gICAgICAgIHZhciByZXQgPSB3YXNtLl9hc3NldF9uZSh0aGlzLnB0ciwgYS5wdHIpO1xuXG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICogQHBhcmFtIHtfQXNzZXR9IGFcbiAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImx0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbHQoYSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYSwgX0Fzc2V0KTtcblxuICAgICAgICB2YXIgcmV0ID0gd2FzbS5fYXNzZXRfbHQodGhpcy5wdHIsIGEucHRyKTtcblxuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7X0Fzc2V0fSBhXG4gICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJsdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsdGUoYSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYSwgX0Fzc2V0KTtcblxuICAgICAgICB2YXIgcmV0ID0gd2FzbS5fYXNzZXRfbHRlKHRoaXMucHRyLCBhLnB0cik7XG5cbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge19Bc3NldH0gYVxuICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ3RcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBndChhKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhLCBfQXNzZXQpO1xuXG4gICAgICAgIHZhciByZXQgPSB3YXNtLl9hc3NldF9ndCh0aGlzLnB0ciwgYS5wdHIpO1xuXG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICogQHBhcmFtIHtfQXNzZXR9IGFcbiAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImd0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGd0ZShhKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhLCBfQXNzZXQpO1xuXG4gICAgICAgIHZhciByZXQgPSB3YXNtLl9hc3NldF9ndGUodGhpcy5wdHIsIGEucHRyKTtcblxuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7X0Fzc2V0fSBhXG4gICAgICAqIEByZXR1cm5zIHtfQXNzZXR9XG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm1pblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1pbihhKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhLCBfQXNzZXQpO1xuXG4gICAgICAgIHZhciByZXQgPSB3YXNtLl9hc3NldF9taW4odGhpcy5wdHIsIGEucHRyKTtcblxuICAgICAgICByZXR1cm4gX0Fzc2V0Ll9fd3JhcChyZXQpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7X0Fzc2V0fSBhXG4gICAgICAqIEByZXR1cm5zIHtfQXNzZXR9XG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm1heFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1heChhKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhLCBfQXNzZXQpO1xuXG4gICAgICAgIHZhciByZXQgPSB3YXNtLl9hc3NldF9tYXgodGhpcy5wdHIsIGEucHRyKTtcblxuICAgICAgICByZXR1cm4gX0Fzc2V0Ll9fd3JhcChyZXQpO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcIl9fd3JhcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9fd3JhcChwdHIpIHtcbiAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoX0Fzc2V0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5wdHIgPSBwdHI7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZyb21TdHJpbmdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHZhciBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAodmFsdWUsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG5cbiAgICAgICAgdmFyIHJldCA9IHdhc20uX2Fzc2V0X2Zyb21TdHJpbmcocHRyMCwgbGVuMCk7XG5cbiAgICAgICAgcmV0dXJuIF9Bc3NldC5fX3dyYXAocmV0KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50XG4gICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVjaXNpb25cbiAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbFxuICAgICAgKiBAcmV0dXJucyB7X0Fzc2V0fVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJuZXdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbmV3KGFtb3VudCwgcHJlY2lzaW9uLCBzeW1ib2wpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChzeW1ib2wsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG5cbiAgICAgICAgdmFyIHJldCA9IHdhc20uX2Fzc2V0X25ldyhhbW91bnQsIHByZWNpc2lvbiwgcHRyMCwgbGVuMCk7XG5cbiAgICAgICAgcmV0dXJuIF9Bc3NldC5fX3dyYXAocmV0KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gX0Fzc2V0O1xuICB9KCk7XG5cbiAgX19leHBvcnRzLl9Bc3NldCA9IF9Bc3NldDtcbiAgLyoqXG4gICovXG5cbiAgdmFyIF9Bc3NldEVkaXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX0Fzc2V0RWRpdG9yKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9Bc3NldEVkaXRvcik7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKF9Bc3NldEVkaXRvciwgW3tcbiAgICAgIGtleTogXCJfX2Rlc3Ryb3lfaW50b19yYXdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIHZhciBwdHIgPSB0aGlzLnB0cjtcbiAgICAgICAgdGhpcy5wdHIgPSAwO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmcmVlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZnJlZSgpIHtcbiAgICAgICAgdmFyIHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG5cbiAgICAgICAgd2FzbS5fX3diZ19fYXNzZXRlZGl0b3JfZnJlZShwdHIpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7X0Fzc2V0fSBhc3NldFxuICAgICAgKiBAcmV0dXJucyB7X0Fzc2V0RWRpdG9yfVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ3aXRoQ2hhbmdlXCIsXG4gICAgICB2YWx1ZTpcbiAgICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICAqIEByZXR1cm5zIHtfQXNzZXRFZGl0b3J9XG4gICAgICAqL1xuICAgICAgZnVuY3Rpb24gd2l0aENoYW5nZShzdHIpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChzdHIsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG5cbiAgICAgICAgdmFyIHJldCA9IHdhc20uX2Fzc2V0ZWRpdG9yX3dpdGhDaGFuZ2UodGhpcy5wdHIsIHB0cjAsIGxlbjApO1xuXG4gICAgICAgIHJldHVybiBfQXNzZXRFZGl0b3IuX193cmFwKHJldCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICogQHJldHVybnMge19Bc3NldH1cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYXNzZXRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgcmV0ID0gd2FzbS5fYXNzZXRlZGl0b3JfYXNzZXQodGhpcy5wdHIpO1xuXG4gICAgICAgIHJldHVybiBfQXNzZXQuX193cmFwKHJldCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYW1vdW50U3RyXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG5cbiAgICAgICAgICB3YXNtLl9hc3NldGVkaXRvcl9hbW91bnRfc3RyKHJldHB0ciwgdGhpcy5wdHIpO1xuXG4gICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcblxuICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHIwLCByMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFzQ2hhbmdlXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIHJldCA9IHdhc20uX2Fzc2V0ZWRpdG9yX2hhc19jaGFuZ2UodGhpcy5wdHIpO1xuXG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwiX193cmFwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX193cmFwKHB0cikge1xuICAgICAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShfQXNzZXRFZGl0b3IucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLnB0ciA9IHB0cjtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZnJvbUFzc2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUFzc2V0KGFzc2V0KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhc3NldCwgX0Fzc2V0KTtcblxuICAgICAgICB2YXIgcmV0ID0gd2FzbS5fYXNzZXRlZGl0b3JfZnJvbUFzc2V0KGFzc2V0LnB0cik7XG5cbiAgICAgICAgcmV0dXJuIF9Bc3NldEVkaXRvci5fX3dyYXAocmV0KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgICogQHJldHVybnMge19Bc3NldEVkaXRvcn1cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZnJvbVN0cmluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMCh2YWx1ZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcblxuICAgICAgICB2YXIgcmV0ID0gd2FzbS5fYXNzZXRlZGl0b3JfZnJvbVN0cmluZyhwdHIwLCBsZW4wKTtcblxuICAgICAgICByZXR1cm4gX0Fzc2V0RWRpdG9yLl9fd3JhcChyZXQpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnRcbiAgICAgICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvblxuICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sXG4gICAgICAqIEByZXR1cm5zIHtfQXNzZXRFZGl0b3J9XG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm5ld1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9uZXcoYW1vdW50LCBwcmVjaXNpb24sIHN5bWJvbCkge1xuICAgICAgICB2YXIgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHN5bWJvbCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcblxuICAgICAgICB2YXIgcmV0ID0gd2FzbS5fYXNzZXRlZGl0b3JfbmV3KGFtb3VudCwgcHJlY2lzaW9uLCBwdHIwLCBsZW4wKTtcblxuICAgICAgICByZXR1cm4gX0Fzc2V0RWRpdG9yLl9fd3JhcChyZXQpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBfQXNzZXRFZGl0b3I7XG4gIH0oKTtcblxuICBfX2V4cG9ydHMuX0Fzc2V0RWRpdG9yID0gX0Fzc2V0RWRpdG9yO1xuICAvKipcbiAgKi9cblxuICB2YXIgX1ByaWNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfUHJpY2UoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX1ByaWNlKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoX1ByaWNlLCBbe1xuICAgICAga2V5OiBcIl9fZGVzdHJveV9pbnRvX3Jhd1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgdmFyIHB0ciA9IHRoaXMucHRyO1xuICAgICAgICB0aGlzLnB0ciA9IDA7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZyZWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcmVlKCkge1xuICAgICAgICB2YXIgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcblxuICAgICAgICB3YXNtLl9fd2JnX19wcmljZV9mcmVlKHB0cik7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICogQHBhcmFtIHtfQXNzZXR9IGJhc2VcbiAgICAgICogQHBhcmFtIHtfQXNzZXR9IHF1b3RlXG4gICAgICAqIEByZXR1cm5zIHtfUHJpY2V9XG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICB2YWx1ZTpcbiAgICAgIC8qKlxuICAgICAgKiBAcmV0dXJucyB7X1ByaWNlfVxuICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICB2YXIgcmV0ID0gd2FzbS5fcHJpY2VfY2xvbmUodGhpcy5wdHIpO1xuXG4gICAgICAgIHJldHVybiBfUHJpY2UuX193cmFwKHJldCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICogQHJldHVybnMge19Bc3NldH1cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYmFzZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciByZXQgPSB3YXNtLl9wcmljZV9iYXNlKHRoaXMucHRyKTtcblxuICAgICAgICByZXR1cm4gX0Fzc2V0Ll9fd3JhcChyZXQpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7X0Fzc2V0fSB2YWx1ZVxuICAgICAgKi9cbiAgICAgICxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh2YWx1ZSwgX0Fzc2V0KTtcblxuICAgICAgICB3YXNtLl9wcmljZV9zZXRfYmFzZSh0aGlzLnB0ciwgdmFsdWUucHRyKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgKiBAcmV0dXJucyB7X0Fzc2V0fVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJxdW90ZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciByZXQgPSB3YXNtLl9wcmljZV9xdW90ZSh0aGlzLnB0cik7XG5cbiAgICAgICAgcmV0dXJuIF9Bc3NldC5fX3dyYXAocmV0KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge19Bc3NldH0gdmFsdWVcbiAgICAgICovXG4gICAgICAsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3ModmFsdWUsIF9Bc3NldCk7XG5cbiAgICAgICAgd2FzbS5fcHJpY2Vfc2V0X3F1b3RlKHRoaXMucHRyLCB2YWx1ZS5wdHIpO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcIl9fd3JhcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9fd3JhcChwdHIpIHtcbiAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoX1ByaWNlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5wdHIgPSBwdHI7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm5ld1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9uZXcoYmFzZSwgcXVvdGUpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGJhc2UsIF9Bc3NldCk7XG5cbiAgICAgICAgX2Fzc2VydENsYXNzKHF1b3RlLCBfQXNzZXQpO1xuXG4gICAgICAgIHZhciByZXQgPSB3YXNtLl9wcmljZV9uZXcoYmFzZS5wdHIsIHF1b3RlLnB0cik7XG5cbiAgICAgICAgcmV0dXJuIF9QcmljZS5fX3dyYXAocmV0KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gX1ByaWNlO1xuICB9KCk7XG5cbiAgX19leHBvcnRzLl9QcmljZSA9IF9QcmljZTtcblxuICBmdW5jdGlvbiBsb2FkKF94LCBfeDIpIHtcbiAgICByZXR1cm4gX2xvYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9sb2FkKCkge1xuICAgIF9sb2FkID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKG1vZHVsZSwgaW1wb3J0cykge1xuICAgICAgdmFyIGJ5dGVzLCBpbnN0YW5jZTtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIFJlc3BvbnNlID09PSAnZnVuY3Rpb24nICYmIG1vZHVsZSBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghKHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgIHJldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhtb2R1bGUsIGltcG9ydHMpO1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDg7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgyKTtcblxuICAgICAgICAgICAgICBpZiAoIShtb2R1bGUuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpICE9ICdhcHBsaWNhdGlvbi93YXNtJykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmdgIGZhaWxlZCBiZWNhdXNlIHlvdXIgc2VydmVyIGRvZXMgbm90IHNlcnZlIHdhc20gd2l0aCBgYXBwbGljYXRpb24vd2FzbWAgTUlNRSB0eXBlLiBGYWxsaW5nIGJhY2sgdG8gYFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlYCB3aGljaCBpcyBzbG93ZXIuIE9yaWdpbmFsIGVycm9yOlxcblwiLCBfY29udGV4dC50MCk7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgIHRocm93IF9jb250ZXh0LnQwO1xuXG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgIHJldHVybiBtb2R1bGUuYXJyYXlCdWZmZXIoKTtcblxuICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgYnl0ZXMgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgIHJldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShieXRlcywgaW1wb3J0cyk7XG5cbiAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNTtcbiAgICAgICAgICAgICAgcmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKG1vZHVsZSwgaW1wb3J0cyk7XG5cbiAgICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICAgIGluc3RhbmNlID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lkluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBtb2R1bGU6IG1vZHVsZVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBpbnN0YW5jZSk7XG5cbiAgICAgICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzIsIDhdXSk7XG4gICAgfSkpO1xuICAgIHJldHVybiBfbG9hZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdChfeDMpIHtcbiAgICByZXR1cm4gX2luaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbml0KCkge1xuICAgIF9pbml0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMihpbnB1dCkge1xuICAgICAgdmFyIHNyYywgaW1wb3J0cywgX3lpZWxkJGxvYWQsIGluc3RhbmNlLCBtb2R1bGU7XG5cbiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgIHNyYyA9IGxvY2F0aW9uLmhyZWY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHNyYyA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlucHV0ID0gc3JjLnJlcGxhY2UoL1xcLmpzJC8sICdfYmcud2FzbScpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaW1wb3J0cyA9IHt9O1xuICAgICAgICAgICAgICBpbXBvcnRzLndiZyA9IHt9O1xuXG4gICAgICAgICAgICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fb2JqZWN0X2Ryb3BfcmVmID0gZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgICAgICAgICB0YWtlT2JqZWN0KGFyZzApO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2JfZHJvcCA9IGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IHRha2VPYmplY3QoYXJnMCkub3JpZ2luYWw7XG5cbiAgICAgICAgICAgICAgICBpZiAob2JqLmNudC0tID09IDEpIHtcbiAgICAgICAgICAgICAgICAgIG9iai5hID0gMDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGltcG9ydHMud2JnLl9fd2JnX2NhbGxfZTkxZjcxZGRmMWY0NWNmZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBnZXRPYmplY3QoYXJnMCkuY2FsbChnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgICAgICAgICB9LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGltcG9ydHMud2JnLl9fd2JnX25ld184MDgxMWRjYjY2ZDFiNTNmID0gZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IEVycm9yKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpbXBvcnRzLndiZy5fX3diZ19jYWxsX2UzYzcyMzU1ZDA5MWQ1ZDQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNhbGwoZ2V0T2JqZWN0KGFyZzEpLCBnZXRPYmplY3QoYXJnMikpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgICAgICAgICB9LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGltcG9ydHMud2JnLl9fd2JnX2luc3RhbmNlb2ZfUHJvbWlzZV8wZmI1ZDdlMjZjYTgzNjI2ID0gZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gZ2V0T2JqZWN0KGFyZzApIGluc3RhbmNlb2YgUHJvbWlzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGltcG9ydHMud2JnLl9fd2JnX3RoZW5fNmQ1MDcyZmVjM2ZkYjIzNyA9IGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGdldE9iamVjdChhcmcwKS50aGVuKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX3Rocm93ID0gZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX3JldGhyb3cgPSBmdW5jdGlvbiAoYXJnMCkge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QoYXJnMCk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jbG9zdXJlX3dyYXBwZXIxMTMgPSBmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCA3LCBfX3diZ19hZGFwdGVyXzEwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBSZXF1ZXN0ID09PSAnZnVuY3Rpb24nICYmIGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCB8fCB0eXBlb2YgVVJMID09PSAnZnVuY3Rpb24nICYmIGlucHV0IGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBmZXRjaChpbnB1dCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBsb2FkO1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE3O1xuICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG5cbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi50MSA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICBfY29udGV4dDIudDIgPSBpbXBvcnRzO1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIxO1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIF9jb250ZXh0Mi50MCkoX2NvbnRleHQyLnQxLCBfY29udGV4dDIudDIpO1xuXG4gICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICBfeWllbGQkbG9hZCA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICBpbnN0YW5jZSA9IF95aWVsZCRsb2FkLmluc3RhbmNlO1xuICAgICAgICAgICAgICBtb2R1bGUgPSBfeWllbGQkbG9hZC5tb2R1bGU7XG4gICAgICAgICAgICAgIHdhc20gPSBpbnN0YW5jZS5leHBvcnRzO1xuICAgICAgICAgICAgICBpbml0Ll9fd2JpbmRnZW5fd2FzbV9tb2R1bGUgPSBtb2R1bGU7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHdhc20pO1xuXG4gICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIF9pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICB3YXNtX2JpbmRnZW4gPSBPYmplY3QuYXNzaWduKGluaXQsIF9fZXhwb3J0cyk7XG59KSgpO1xuXG52YXIgX2RlZmF1bHQgPSB3YXNtX2JpbmRnZW47XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20uanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qc1wiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYWVzX2RlY3J5cHQgPSBleHBvcnRzLl9QcmljZSA9IGV4cG9ydHMuX0Fzc2V0RWRpdG9yID0gZXhwb3J0cy5fQXNzZXQgPSBleHBvcnRzLlByaWNlID0gZXhwb3J0cy5OYXRpdmVMaWJDb250ZXh0ID0gZXhwb3J0cy5Bc3NldEVkaXRvciA9IGV4cG9ydHMuQXNzZXQgPSB2b2lkIDA7XG5leHBvcnRzLmFzc2VydE5hdGl2ZUxpYiA9IGFzc2VydE5hdGl2ZUxpYjtcbmV4cG9ydHMuaW1wb3J0TmF0aXZlTGliID0gaW1wb3J0TmF0aXZlTGliO1xuZXhwb3J0cy5pbXBvcnROYXRpdmVMaWJDdHggPSBpbXBvcnROYXRpdmVMaWJDdHg7XG5leHBvcnRzLmlzTmF0aXZlTGliTG9hZGVkID0gaXNOYXRpdmVMaWJMb2FkZWQ7XG5leHBvcnRzLnVubG9hZE5hdGl2ZUxpYiA9IHVubG9hZE5hdGl2ZUxpYjtcblxucmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQ4LWFycmF5LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmNvcHktd2l0aGluLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGwuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsdGVyLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mb3ItZWFjaC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlcy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZi5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5qb2luLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2YuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubWFwLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHQuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmV2ZXJzZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zZXQuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2UuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29tZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb3J0LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLWxvY2FsZS1zdHJpbmcuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubWF0Y2guanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZnJvbS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvd2ViLnVybC50by1qc29uLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanNcIik7XG5cbnZhciBfY29kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29kZVwiKSk7XG5cbnZhciBfZ29sb3NfbGliID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9nb2xvc19saWJcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBfQXNzZXQgPSBfZ29sb3NfbGliLmRlZmF1bHQuX0Fzc2V0LFxuICAgIF9Bc3NldEVkaXRvciA9IF9nb2xvc19saWIuZGVmYXVsdC5fQXNzZXRFZGl0b3IsXG4gICAgX1ByaWNlID0gX2dvbG9zX2xpYi5kZWZhdWx0Ll9QcmljZSxcbiAgICBhZXMyNTZfZGVjcnlwdCA9IF9nb2xvc19saWIuZGVmYXVsdC5hZXMyNTZfZGVjcnlwdDtcbmV4cG9ydHMuX1ByaWNlID0gX1ByaWNlO1xuZXhwb3J0cy5fQXNzZXRFZGl0b3IgPSBfQXNzZXRFZGl0b3I7XG5leHBvcnRzLl9Bc3NldCA9IF9Bc3NldDtcblxudmFyIE5hdGl2ZUxpYkNvbnRleHQgPSBmdW5jdGlvbiBOYXRpdmVMaWJDb250ZXh0KCkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmF0aXZlTGliQ29udGV4dCk7XG59O1xuXG5leHBvcnRzLk5hdGl2ZUxpYkNvbnRleHQgPSBOYXRpdmVMaWJDb250ZXh0O1xuXG52YXIgZnJvbUhleFN0cmluZyA9IGZ1bmN0aW9uIGZyb21IZXhTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShzdHIubWF0Y2goLy57MSwyfS9nKS5tYXAoZnVuY3Rpb24gKGJ5dGUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoYnl0ZSwgMTYpO1xuICB9KSk7XG59O1xuXG52YXIgZnJvbUJhc2U2NFN0cmluZyA9IGZ1bmN0aW9uIGZyb21CYXNlNjRTdHJpbmcoc3RyKSB7XG4gIGlmICh0eXBlb2YgYXRvYiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGF0b2Ioc3RyKSwgZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgJ2Jhc2U2NCcpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBpbXBvcnROYXRpdmVMaWJDdHgoKSB7XG4gIHJldHVybiBfaW1wb3J0TmF0aXZlTGliQ3R4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pbXBvcnROYXRpdmVMaWJDdHgoKSB7XG4gIF9pbXBvcnROYXRpdmVMaWJDdHggPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgdmFyIHdoYXQ7XG4gICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCEoIV9jb2RlLmRlZmF1bHQgfHwgIV9nb2xvc19saWIuZGVmYXVsdCB8fCAhX0Fzc2V0KSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoYXQgPSAhX2NvZGUuZGVmYXVsdCA/ICd3YXNtIGNvZGUnIDogJ2luaXQoKSc7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOYXRpdmUgZ29sb3MtbGliIGNvcmUgaXMgbm90IGluY2x1ZGVkIGludG8gdGhpcyBnb2xvcy1saWItanMgbGlicmFyeS4gVGhlcmUgaXMgbm8gXCIuY29uY2F0KHdoYXQsIFwiLlwiKSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2dvbG9zX2xpYi5kZWZhdWx0KShmcm9tQmFzZTY0U3RyaW5nKF9jb2RlLmRlZmF1bHQpKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV3IE5hdGl2ZUxpYkNvbnRleHQoKSk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfaW1wb3J0TmF0aXZlTGliQ3R4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBnbG9iYWxOYXRpdmVDdHggPSBudWxsO1xuXG5mdW5jdGlvbiBpbXBvcnROYXRpdmVMaWIoKSB7XG4gIHJldHVybiBfaW1wb3J0TmF0aXZlTGliLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pbXBvcnROYXRpdmVMaWIoKSB7XG4gIF9pbXBvcnROYXRpdmVMaWIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIWdsb2JhbE5hdGl2ZUN0eCkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBnbG9iYWxOYXRpdmVDdHgpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIGltcG9ydE5hdGl2ZUxpYkN0eCgpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgZ2xvYmFsTmF0aXZlQ3R4ID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBnbG9iYWxOYXRpdmVDdHgpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG4gIHJldHVybiBfaW1wb3J0TmF0aXZlTGliLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHVubG9hZE5hdGl2ZUxpYigpIHtcbiAgZ2xvYmFsTmF0aXZlQ3R4ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOYXRpdmVMaWJMb2FkZWQoKSB7XG4gIHJldHVybiAhIWdsb2JhbE5hdGl2ZUN0eDtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TmF0aXZlTGliKGZvcldoYXQpIHtcbiAgdmFyIHZlcnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcwLjkuMCc7XG5cbiAgaWYgKCFpc05hdGl2ZUxpYkxvYWRlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhcnRpbmcgZnJvbSBcIi5jb25jYXQodmVyc2lvbiwgXCIsIGdvbG9zLWxpYi1qcyByZXF1aXJlcyBcXFwiYXdhaXQgZ29sb3MuaW1wb3J0TmF0aXZlTGliKClcXFwiIGJlZm9yZSBjYWxsaW5nIFwiKS5jb25jYXQoZm9yV2hhdCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdyYXBOYXRpdmUob3JpZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgaGFzQ29udGV4dCA9IGFyZ3NbMF0gaW5zdGFuY2VvZiBOYXRpdmVMaWJDb250ZXh0O1xuXG4gICAgaWYgKCFoYXNDb250ZXh0ICYmICFpc05hdGl2ZUxpYkxvYWRlZCgpKSB7XG4gICAgICByZXR1cm4gaW1wb3J0TmF0aXZlTGliKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvcmlnLmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBhcmdzID0gYXJncy5zbGljZSgxLCBhcmdzLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yaWcuYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJncykpO1xuICB9O1xufVxuXG52YXIgQXNzZXQgPSB3cmFwTmF0aXZlKGZ1bmN0aW9uIChhbW91bnQsIHByZWNpc2lvbiwgc3ltYm9sKSB7XG4gIHZhciBhID0gbnVsbDtcblxuICBpZiAocHJlY2lzaW9uICE9PSB1bmRlZmluZWQgJiYgc3ltYm9sKSB7XG4gICAgYSA9IF9Bc3NldC5uZXcoYW1vdW50LCBwcmVjaXNpb24sIHN5bWJvbCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0ciA9IGFtb3VudDtcbiAgICBhID0gX0Fzc2V0LmZyb21TdHJpbmcoc3RyKTtcbiAgfVxuXG4gIHZhciB3cmFwQmluT3AgPSBmdW5jdGlvbiB3cmFwQmluT3Aob3ApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFzc2V0Mikge1xuICAgICAgaWYgKCEoYXNzZXQyIGluc3RhbmNlb2YgX0Fzc2V0KSkgcmV0dXJuIHRoaXNbXCJfXCIuY29uY2F0KG9wLCBcIl9udW1cIildKGFzc2V0Mik7XG4gICAgICByZXR1cm4gdGhpc1tcIl9cIi5jb25jYXQob3ApXShhc3NldDIpO1xuICAgIH07XG4gIH07XG5cbiAgX0Fzc2V0LnByb3RvdHlwZS5wbHVzID0gd3JhcEJpbk9wKCdwbHVzJyk7XG4gIF9Bc3NldC5wcm90b3R5cGUubWludXMgPSB3cmFwQmluT3AoJ21pbnVzJyk7XG5cbiAgX0Fzc2V0LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiAocHJpY2UsIHJlbWFpbmRlckFzc2V0KSB7XG4gICAgaWYgKHByaWNlIGluc3RhbmNlb2YgX1ByaWNlKSB7XG4gICAgICBpZiAoIXJlbWFpbmRlckFzc2V0KSB7XG4gICAgICAgIHJlbWFpbmRlckFzc2V0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fbXVsX3ByaWNlKHByaWNlLCByZW1haW5kZXJBc3NldCk7XG4gICAgfVxuXG4gICAgdmFyIGFzc2V0MiA9IHByaWNlO1xuICAgIGlmICghKGFzc2V0MiBpbnN0YW5jZW9mIF9Bc3NldCkpIHJldHVybiB0aGlzLl9tdWxfbnVtKGFzc2V0Mik7XG4gICAgcmV0dXJuIHRoaXMuX211bChhc3NldDIpO1xuICB9O1xuXG4gIF9Bc3NldC5wcm90b3R5cGUuZGl2ID0gd3JhcEJpbk9wKCdkaXYnKTtcbiAgX0Fzc2V0LnByb3RvdHlwZS5tb2QgPSB3cmFwQmluT3AoJ21vZCcpO1xuXG4gIF9Bc3NldC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgcmV0dXJuIGE7XG59KTtcbmV4cG9ydHMuQXNzZXQgPSBBc3NldDtcbnZhciBBc3NldEVkaXRvciA9IHdyYXBOYXRpdmUoZnVuY3Rpb24gKGFtb3VudCwgcHJlY2lzaW9uLCBzeW1ib2wpIHtcbiAgdmFyIGFlID0gbnVsbDtcblxuICBpZiAoYW1vdW50IGluc3RhbmNlb2YgX0Fzc2V0KSB7XG4gICAgYWUgPSBfQXNzZXRFZGl0b3IuZnJvbUFzc2V0KGFtb3VudCk7XG4gIH0gZWxzZSBpZiAocHJlY2lzaW9uICE9PSB1bmRlZmluZWQgJiYgc3ltYm9sKSB7XG4gICAgYWUgPSBfQXNzZXRFZGl0b3IubmV3KGFtb3VudCwgcHJlY2lzaW9uLCBzeW1ib2wpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdHIgPSBhbW91bnQ7XG4gICAgYWUgPSBfQXNzZXRFZGl0b3IuZnJvbVN0cmluZyhzdHIpO1xuICB9XG5cbiAgX0Fzc2V0RWRpdG9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNzZXQudG9TdHJpbmcoKTtcbiAgfTtcblxuICBfQXNzZXRFZGl0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBhc3NldDogdGhpcy5hc3NldCxcbiAgICAgIGFtb3VudF9zdHI6IHRoaXMuYW1vdW50U3RyXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIGFlO1xufSk7XG5leHBvcnRzLkFzc2V0RWRpdG9yID0gQXNzZXRFZGl0b3I7XG52YXIgUHJpY2UgPSB3cmFwTmF0aXZlKGZ1bmN0aW9uIChiYXNlLCBxdW90ZSkge1xuICB2YXIgcHIgPSBudWxsO1xuXG4gIGlmICghcXVvdGUpIHtcbiAgICBwciA9IF9QcmljZS5uZXcoQXNzZXQoYmFzZS5iYXNlKSwgQXNzZXQoYmFzZS5xdW90ZSkpO1xuICB9IGVsc2Uge1xuICAgIHByID0gX1ByaWNlLm5ldyhiYXNlLCBxdW90ZSk7XG4gIH1cblxuICBfUHJpY2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmFzZTogdGhpcy5iYXNlLnRvSlNPTigpLFxuICAgICAgcXVvdGU6IHRoaXMucXVvdGUudG9KU09OKClcbiAgICB9O1xuICB9O1xuXG4gIF9QcmljZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9KU09OKCkudG9TdHJpbmcoKTtcbiAgfTtcblxuICByZXR1cm4gcHI7XG59KTtcbmV4cG9ydHMuUHJpY2UgPSBQcmljZTtcbnZhciBhZXNfZGVjcnlwdCA9IHdyYXBOYXRpdmUoZnVuY3Rpb24gKGtleSwgaXYsIGRhdGEpIHtcbiAgcmV0dXJuIGFlczI1Nl9kZWNyeXB0KGtleSwgaXYsIGRhdGEpO1xufSk7XG5leHBvcnRzLmFlc19kZWNyeXB0ID0gYWVzX2RlY3J5cHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXQuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIudG8tZml4ZWQuanNcIik7XG5cbnZhciBfZ2V0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2dldFwiKSk7XG5cbnZhciBfZWNjID0gcmVxdWlyZShcIi4vYXV0aC9lY2NcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RlZW1BUEkpIHtcbiAgZnVuY3Rpb24gbnVtYmVyV2l0aENvbW1hcyh4KSB7XG4gICAgcmV0dXJuIHgucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgXCIsXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdmVzdGluZ0dvbG9zKGFjY291bnQsIGdwcm9wcykge1xuICAgIHZhciB2ZXN0cyA9IHBhcnNlRmxvYXQoYWNjb3VudC52ZXN0aW5nX3NoYXJlcy5zcGxpdChcIiBcIilbMF0pO1xuICAgIHZhciB0b3RhbF92ZXN0cyA9IHBhcnNlRmxvYXQoZ3Byb3BzLnRvdGFsX3Zlc3Rpbmdfc2hhcmVzLnNwbGl0KFwiIFwiKVswXSk7XG4gICAgdmFyIHRvdGFsX3Zlc3Rfc3RlZW0gPSBwYXJzZUZsb2F0KGdwcm9wcy50b3RhbF92ZXN0aW5nX2Z1bmRfc3RlZW0uc3BsaXQoXCIgXCIpWzBdKTtcbiAgICB2YXIgdmVzdGluZ19zdGVlbWYgPSB0b3RhbF92ZXN0X3N0ZWVtICogKHZlc3RzIC8gdG90YWxfdmVzdHMpO1xuICAgIHJldHVybiB2ZXN0aW5nX3N0ZWVtZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NPcmRlcnMob3Blbl9vcmRlcnMsIGFzc2V0UHJlY2lzaW9uKSB7XG4gICAgdmFyIHNiZE9yZGVycyA9ICFvcGVuX29yZGVycyA/IDAgOiBvcGVuX29yZGVycy5yZWR1Y2UoZnVuY3Rpb24gKG8sIG9yZGVyKSB7XG4gICAgICBpZiAob3JkZXIuc2VsbF9wcmljZS5iYXNlLmluZGV4T2YoXCJHQkdcIikgIT09IC0xKSB7XG4gICAgICAgIG8gKz0gb3JkZXIuZm9yX3NhbGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvO1xuICAgIH0sIDApIC8gYXNzZXRQcmVjaXNpb247XG4gICAgdmFyIHN0ZWVtT3JkZXJzID0gIW9wZW5fb3JkZXJzID8gMCA6IG9wZW5fb3JkZXJzLnJlZHVjZShmdW5jdGlvbiAobywgb3JkZXIpIHtcbiAgICAgIGlmIChvcmRlci5zZWxsX3ByaWNlLmJhc2UuaW5kZXhPZihcIkdPTE9TXCIpICE9PSAtMSkge1xuICAgICAgICBvICs9IG9yZGVyLmZvcl9zYWxlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbztcbiAgICB9LCAwKSAvIGFzc2V0UHJlY2lzaW9uO1xuICAgIHJldHVybiB7XG4gICAgICBzdGVlbU9yZGVyczogc3RlZW1PcmRlcnMsXG4gICAgICBzYmRPcmRlcnM6IHNiZE9yZGVyc1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjdWxhdGVTYXZpbmcoc2F2aW5nc193aXRoZHJhd3MpIHtcbiAgICB2YXIgc2F2aW5nc19wZW5kaW5nID0gMDtcbiAgICB2YXIgc2F2aW5nc19zYmRfcGVuZGluZyA9IDA7XG4gICAgc2F2aW5nc193aXRoZHJhd3MuZm9yRWFjaChmdW5jdGlvbiAod2l0aGRyYXcpIHtcbiAgICAgIHZhciBfd2l0aGRyYXckYW1vdW50JHNwbGkgPSB3aXRoZHJhdy5hbW91bnQuc3BsaXQoXCIgXCIpLFxuICAgICAgICAgIF93aXRoZHJhdyRhbW91bnQkc3BsaTIgPSBfc2xpY2VkVG9BcnJheShfd2l0aGRyYXckYW1vdW50JHNwbGksIDIpLFxuICAgICAgICAgIGFtb3VudCA9IF93aXRoZHJhdyRhbW91bnQkc3BsaTJbMF0sXG4gICAgICAgICAgYXNzZXQgPSBfd2l0aGRyYXckYW1vdW50JHNwbGkyWzFdO1xuXG4gICAgICBpZiAoYXNzZXQgPT09IFwiR09MT1NcIikgc2F2aW5nc19wZW5kaW5nICs9IHBhcnNlRmxvYXQoYW1vdW50KTtlbHNlIHtcbiAgICAgICAgaWYgKGFzc2V0ID09PSBcIkdCR1wiKSBzYXZpbmdzX3NiZF9wZW5kaW5nICs9IHBhcnNlRmxvYXQoYW1vdW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgc2F2aW5nc19wZW5kaW5nOiBzYXZpbmdzX3BlbmRpbmcsXG4gICAgICBzYXZpbmdzX3NiZF9wZW5kaW5nOiBzYXZpbmdzX3NiZF9wZW5kaW5nXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVzdGltYXRlQWNjb3VudFZhbHVlKGFjY291bnQpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgIGdwcm9wcyA9IF9yZWYuZ3Byb3BzLFxuICAgICAgICBmZWVkX3ByaWNlID0gX3JlZi5mZWVkX3ByaWNlLFxuICAgICAgICBvcGVuX29yZGVycyA9IF9yZWYub3Blbl9vcmRlcnMsXG4gICAgICAgIHNhdmluZ3Nfd2l0aGRyYXdzID0gX3JlZi5zYXZpbmdzX3dpdGhkcmF3cyxcbiAgICAgICAgdmVzdGluZ19zdGVlbSA9IF9yZWYudmVzdGluZ19zdGVlbTtcblxuICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgIHZhciB1c2VybmFtZSA9IGFjY291bnQubmFtZTtcbiAgICB2YXIgYXNzZXRQcmVjaXNpb24gPSAxMDAwO1xuICAgIHZhciBvcmRlcnMsIHNhdmluZ3M7XG5cbiAgICBpZiAoIXZlc3Rpbmdfc3RlZW0gfHwgIWZlZWRfcHJpY2UpIHtcbiAgICAgIGlmICghZ3Byb3BzIHx8ICFmZWVkX3ByaWNlKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2goc3RlZW1BUEkuZ2V0U3RhdGVBc3luYyhcIi9Ae3VzZXJuYW1lfVwiKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgZ3Byb3BzID0gZGF0YS5wcm9wcztcbiAgICAgICAgICBmZWVkX3ByaWNlID0gZGF0YS5mZWVkX3ByaWNlO1xuICAgICAgICAgIHZlc3Rpbmdfc3RlZW0gPSB2ZXN0aW5nR29sb3MoYWNjb3VudCwgZ3Byb3BzKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVzdGluZ19zdGVlbSA9IHZlc3RpbmdHb2xvcyhhY2NvdW50LCBncHJvcHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghb3Blbl9vcmRlcnMpIHtcbiAgICAgIHByb21pc2VzLnB1c2goc3RlZW1BUEkuZ2V0T3Blbk9yZGVyc0FzeW5jKHVzZXJuYW1lKS50aGVuKGZ1bmN0aW9uIChvcGVuX29yZGVycykge1xuICAgICAgICBvcmRlcnMgPSBwcm9jZXNzT3JkZXJzKG9wZW5fb3JkZXJzLCBhc3NldFByZWNpc2lvbik7XG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9yZGVycyA9IHByb2Nlc3NPcmRlcnMob3Blbl9vcmRlcnMsIGFzc2V0UHJlY2lzaW9uKTtcbiAgICB9XG5cbiAgICBpZiAoIXNhdmluZ3Nfd2l0aGRyYXdzKSB7XG4gICAgICBwcm9taXNlcy5wdXNoKHN0ZWVtQVBJLmdldFNhdmluZ3NXaXRoZHJhd0Zyb21Bc3luYyh1c2VybmFtZSkudGhlbihmdW5jdGlvbiAoc2F2aW5nc193aXRoZHJhd3MpIHtcbiAgICAgICAgc2F2aW5ncyA9IGNhbGN1bGF0ZVNhdmluZyhzYXZpbmdzX3dpdGhkcmF3cyk7XG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNhdmluZ3MgPSBjYWxjdWxhdGVTYXZpbmcoc2F2aW5nc193aXRoZHJhd3MpO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJpY2VfcGVyX3N0ZWVtID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIF9mZWVkX3ByaWNlID0gZmVlZF9wcmljZSxcbiAgICAgICAgICBiYXNlID0gX2ZlZWRfcHJpY2UuYmFzZSxcbiAgICAgICAgICBxdW90ZSA9IF9mZWVkX3ByaWNlLnF1b3RlO1xuICAgICAgaWYgKC8gR0JHJC8udGVzdChiYXNlKSAmJiAvIEdPTE9TJC8udGVzdChxdW90ZSkpIHByaWNlX3Blcl9zdGVlbSA9IHBhcnNlRmxvYXQoYmFzZS5zcGxpdChcIiBcIilbMF0pO1xuICAgICAgdmFyIHNhdmluZ3NfYmFsYW5jZSA9IGFjY291bnQuc2F2aW5nc19iYWxhbmNlO1xuICAgICAgdmFyIHNhdmluZ3Nfc2JkX2JhbGFuY2UgPSBhY2NvdW50LnNhdmluZ3Nfc2JkX2JhbGFuY2U7XG4gICAgICB2YXIgYmFsYW5jZV9zdGVlbSA9IHBhcnNlRmxvYXQoYWNjb3VudC5iYWxhbmNlLnNwbGl0KFwiIFwiKVswXSk7XG4gICAgICB2YXIgc2F2aW5nX2JhbGFuY2Vfc3RlZW0gPSBwYXJzZUZsb2F0KHNhdmluZ3NfYmFsYW5jZS5zcGxpdChcIiBcIilbMF0pO1xuICAgICAgdmFyIHNiZF9iYWxhbmNlID0gcGFyc2VGbG9hdChhY2NvdW50LnNiZF9iYWxhbmNlKTtcbiAgICAgIHZhciBzYmRfYmFsYW5jZV9zYXZpbmdzID0gcGFyc2VGbG9hdChzYXZpbmdzX3NiZF9iYWxhbmNlLnNwbGl0KFwiIFwiKVswXSk7XG4gICAgICB2YXIgY29udmVyc2lvblZhbHVlID0gMDtcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgKGFjY291bnQub3RoZXJfaGlzdG9yeSB8fCBbXSkucmVkdWNlKGZ1bmN0aW9uIChvdXQsIGl0ZW0pIHtcbiAgICAgICAgaWYgKCgwLCBfZ2V0LmRlZmF1bHQpKGl0ZW0sIFsxLCBcIm9wXCIsIDBdLCBcIlwiKSAhPT0gXCJjb252ZXJ0XCIpIHJldHVybiBvdXQ7XG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgoMCwgX2dldC5kZWZhdWx0KShpdGVtLCBbMSwgXCJ0aW1lc3RhbXBcIl0pKS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciBmaW5pc2hUaW1lID0gdGltZXN0YW1wICsgODY0MDAwMDAgKiAzLjU7IC8vIGFkZCAzLjVkYXkgY29udmVyc2lvbiBkZWxheVxuXG4gICAgICAgIGlmIChmaW5pc2hUaW1lIDwgY3VycmVudFRpbWUpIHJldHVybiBvdXQ7XG4gICAgICAgIHZhciBhbW91bnQgPSBwYXJzZUZsb2F0KCgwLCBfZ2V0LmRlZmF1bHQpKGl0ZW0sIFsxLCBcIm9wXCIsIDEsIFwiYW1vdW50XCJdKS5yZXBsYWNlKFwiIEdCR1wiLCBcIlwiKSk7XG4gICAgICAgIGNvbnZlcnNpb25WYWx1ZSArPSBhbW91bnQ7XG4gICAgICB9LCBbXSk7XG4gICAgICB2YXIgdG90YWxfc2JkID0gc2JkX2JhbGFuY2UgKyBzYmRfYmFsYW5jZV9zYXZpbmdzICsgc2F2aW5ncy5zYXZpbmdzX3NiZF9wZW5kaW5nICsgb3JkZXJzLnNiZE9yZGVycyArIGNvbnZlcnNpb25WYWx1ZTtcbiAgICAgIHZhciB0b3RhbF9zdGVlbSA9IHZlc3Rpbmdfc3RlZW0gKyBiYWxhbmNlX3N0ZWVtICsgc2F2aW5nX2JhbGFuY2Vfc3RlZW0gKyBzYXZpbmdzLnNhdmluZ3NfcGVuZGluZyArIG9yZGVycy5zdGVlbU9yZGVycztcbiAgICAgIHJldHVybiAodG90YWxfc3RlZW0gKiBwcmljZV9wZXJfc3RlZW0gKyB0b3RhbF9zYmQpLnRvRml4ZWQoMik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdWdnZXN0ZWRQYXNzd29yZCgpIHtcbiAgICB2YXIgUEFTU1dPUkRfTEVOR1RIID0gMzI7XG5cbiAgICB2YXIgcHJpdmF0ZUtleSA9IF9lY2Mua2V5X3V0aWxzLmdldF9yYW5kb21fa2V5KCk7XG5cbiAgICByZXR1cm4gcHJpdmF0ZUtleS50b1dpZigpLnN1YnN0cmluZygzLCAzICsgUEFTU1dPUkRfTEVOR1RIKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcmVwdXRhdGlvbjogZnVuY3Rpb24gcmVwdXRhdGlvbihfcmVwdXRhdGlvbikge1xuICAgICAgdmFyIHdpdGhEZWNpbWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIGlmIChfcmVwdXRhdGlvbiA9PSBudWxsKSByZXR1cm4gX3JlcHV0YXRpb247XG4gICAgICBfcmVwdXRhdGlvbiA9IHBhcnNlSW50KF9yZXB1dGF0aW9uKTtcbiAgICAgIHZhciByZXAgPSBTdHJpbmcoX3JlcHV0YXRpb24pO1xuICAgICAgdmFyIG5lZyA9IHJlcC5jaGFyQXQoMCkgPT09IFwiLVwiO1xuICAgICAgcmVwID0gbmVnID8gcmVwLnN1YnN0cmluZygxKSA6IHJlcDtcbiAgICAgIHZhciBzdHIgPSByZXA7XG4gICAgICB2YXIgbGVhZGluZ0RpZ2l0cyA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoMCwgNCkpO1xuICAgICAgdmFyIGxvZyA9IE1hdGgubG9nKGxlYWRpbmdEaWdpdHMpIC8gTWF0aC5MTjEwICsgMC4wMDAwMDAwMTtcbiAgICAgIHZhciBuID0gc3RyLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgb3V0ID0gbiArIChsb2cgLSBwYXJzZUludChsb2cpKTtcbiAgICAgIGlmIChpc05hTihvdXQpKSBvdXQgPSAwO1xuICAgICAgb3V0ID0gTWF0aC5tYXgob3V0IC0gOSwgMCk7XG4gICAgICBvdXQgPSAobmVnID8gLTEgOiAxKSAqIG91dDtcbiAgICAgIG91dCA9IG91dCAqIDkgKyAobmVnID8gMCA6IDI1KTtcbiAgICAgIGlmIChuZWcgJiYgb3V0ID09PSAwKSBvdXQgPSAtMTtcblxuICAgICAgaWYgKCF3aXRoRGVjaW1hbCkge1xuICAgICAgICBvdXQgPSBwYXJzZUludChvdXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0O1xuICAgIH0sXG4gICAgdmVzdFRvR29sb3M6IGZ1bmN0aW9uIHZlc3RUb0dvbG9zKHZlc3RpbmdTaGFyZXMsIHRvdGFsVmVzdGluZ1NoYXJlcywgdG90YWxWZXN0aW5nRnVuZEdvbG9zKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCh0b3RhbFZlc3RpbmdGdW5kR29sb3MpICogKHBhcnNlRmxvYXQodmVzdGluZ1NoYXJlcykgLyBwYXJzZUZsb2F0KHRvdGFsVmVzdGluZ1NoYXJlcykpO1xuICAgIH0sXG4gICAgY29tbWVudFBlcm1saW5rOiBmdW5jdGlvbiBjb21tZW50UGVybWxpbmsocGFyZW50QXV0aG9yLCBwYXJlbnRQZXJtbGluaykge1xuICAgICAgdmFyIHRpbWVTdHIgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvW15hLXpBLVowLTldKy9nLCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcGFyZW50UGVybWxpbmsgPSBwYXJlbnRQZXJtbGluay5yZXBsYWNlKC8oLVxcZHs4fXRcXGR7OX16KS9nLCBcIlwiKTtcbiAgICAgIHJldHVybiBcInJlLVwiICsgcGFyZW50QXV0aG9yICsgXCItXCIgKyBwYXJlbnRQZXJtbGluayArIFwiLVwiICsgdGltZVN0cjtcbiAgICB9LFxuICAgIGFtb3VudDogZnVuY3Rpb24gYW1vdW50KF9hbW91bnQsIGFzc2V0KSB7XG4gICAgICByZXR1cm4gX2Ftb3VudC50b0ZpeGVkKDMpICsgXCIgXCIgKyBhc3NldDtcbiAgICB9LFxuICAgIG51bWJlcldpdGhDb21tYXM6IG51bWJlcldpdGhDb21tYXMsXG4gICAgdmVzdGluZ0dvbG9zOiB2ZXN0aW5nR29sb3MsXG4gICAgZXN0aW1hdGVBY2NvdW50VmFsdWU6IGVzdGltYXRlQWNjb3VudFZhbHVlLFxuICAgIGNyZWF0ZVN1Z2dlc3RlZFBhc3N3b3JkOiBjcmVhdGVTdWdnZXN0ZWRQYXNzd29yZFxuICB9O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGFwaSA9IHJlcXVpcmUoJy4vYXBpJyk7XG5cbnZhciBhdXRoID0gcmVxdWlyZSgnLi9hdXRoJyk7XG5cbnZhciBvYXV0aCA9IHJlcXVpcmUoJy4vb2F1dGgnKTtcblxudmFyIG1pZGRsZXdhcmVzID0gcmVxdWlyZSgnLi9taWRkbGV3YXJlcycpO1xuXG52YXIgYnJvYWRjYXN0ID0gcmVxdWlyZSgnLi9icm9hZGNhc3QnKTtcblxudmFyIGZvcm1hdHRlciA9IHJlcXVpcmUoJy4vZm9ybWF0dGVyJykoYXBpKTtcblxudmFyIG1lbW8gPSByZXF1aXJlKCcuL2F1dGgvbWVtbycpO1xuXG52YXIgbWVzc2FnZXMgPSByZXF1aXJlKCcuL2F1dGgvbWVzc2FnZXMnKTtcblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIGVjYyA9IHJlcXVpcmUoJy4vYXV0aC9lY2MvJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vY29yZScpLFxuICAgIGltcG9ydE5hdGl2ZUxpYkN0eCA9IF9yZXF1aXJlLmltcG9ydE5hdGl2ZUxpYkN0eCxcbiAgICBpbXBvcnROYXRpdmVMaWIgPSBfcmVxdWlyZS5pbXBvcnROYXRpdmVMaWIsXG4gICAgaXNOYXRpdmVMaWJMb2FkZWQgPSBfcmVxdWlyZS5pc05hdGl2ZUxpYkxvYWRlZCxcbiAgICBhc3NlcnROYXRpdmVMaWIgPSBfcmVxdWlyZS5hc3NlcnROYXRpdmVMaWI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbXBvcnROYXRpdmVMaWJDdHg6IGltcG9ydE5hdGl2ZUxpYkN0eCxcbiAgaW1wb3J0TmF0aXZlTGliOiBpbXBvcnROYXRpdmVMaWIsXG4gIGlzTmF0aXZlTGliTG9hZGVkOiBpc05hdGl2ZUxpYkxvYWRlZCxcbiAgYXNzZXJ0TmF0aXZlTGliOiBhc3NlcnROYXRpdmVMaWIsXG4gIGFwaTogYXBpLFxuICBhdXRoOiBhdXRoLFxuICBvYXV0aDogb2F1dGgsXG4gIGJyb2FkY2FzdDogYnJvYWRjYXN0LFxuICBmb3JtYXR0ZXI6IGZvcm1hdHRlcixcbiAgbWVtbzogbWVtbyxcbiAgbWVzc2FnZXM6IG1lc3NhZ2VzLFxuICBtaWRkbGV3YXJlczogbWlkZGxld2FyZXMsXG4gIGNvbmZpZzogY29uZmlnLFxuICB1c2U6IG1pZGRsZXdhcmVzLnVzZSxcbiAgdXRpbHM6IHV0aWxzLFxuICBlY2M6IGVjY1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UuanNcIik7XG5cbnJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcIik7XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIEVtcHR5TWlkZGxld2FyZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVtcHR5TWlkZGxld2FyZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW1wdHlNaWRkbGV3YXJlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFbXB0eU1pZGRsZXdhcmUsIFt7XG4gICAga2V5OiBcImJyb2FkY2FzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2Jyb2FkY2FzdCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShfcmVmKSB7XG4gICAgICAgIHZhciB0eCwgcHJpdktleXMsIG9yaWc7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0eCA9IF9yZWYudHgsIHByaXZLZXlzID0gX3JlZi5wcml2S2V5cywgb3JpZyA9IF9yZWYub3JpZztcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZyh0eCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBicm9hZGNhc3QoX3gpIHtcbiAgICAgICAgcmV0dXJuIF9icm9hZGNhc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJyb2FkY2FzdDtcbiAgICB9KClcbiAgfV0pO1xuXG4gIHJldHVybiBFbXB0eU1pZGRsZXdhcmU7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRW1wdHlNaWRkbGV3YXJlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVmbGVjdC5jb25zdHJ1Y3QuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVmbGVjdC5nZXQuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvd2ViLnVybC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy93ZWIudXJsLXNlYXJjaC1wYXJhbXMuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzXCIpO1xuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIEVtcHR5TWlkZGxld2FyZSA9IHJlcXVpcmUoJy4vRW1wdHlNaWRkbGV3YXJlJyk7XG5cbnZhciBvYXV0aCA9IHJlcXVpcmUoJy4uL29hdXRoJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4uL3V0aWxzJyksXG4gICAgZGVsYXkgPSBfcmVxdWlyZS5kZWxheTtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJy4uL2FwaS90cmFuc3BvcnRzL2h0dHAnKSxcbiAgICBSUENFcnJvciA9IF9yZXF1aXJlMi5SUENFcnJvcjtcblxudmFyIE9BdXRoTWlkZGxld2FyZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VtcHR5TWlkZGxld2FyZSkge1xuICBfaW5oZXJpdHMoT0F1dGhNaWRkbGV3YXJlLCBfRW1wdHlNaWRkbGV3YXJlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE9BdXRoTWlkZGxld2FyZSk7XG5cbiAgZnVuY3Rpb24gT0F1dGhNaWRkbGV3YXJlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPQXV0aE1pZGRsZXdhcmUpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE9BdXRoTWlkZGxld2FyZSwgW3tcbiAgICBrZXk6IFwiX2NoZWNrUGVuZGluZ0FsbG93ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrUGVuZGluZ0FsbG93ZWQodHgpIHtcbiAgICAgIHZhciB1cmwgPSBuZXcgVVJMKCcvYXBpL29hdXRoL2NoZWNrLycgKyBvYXV0aC5jbGllbnRJZCgpLCBvYXV0aC5hcGlIb3N0KCkpO1xuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ1BPU1QnLCB1cmwudG9TdHJpbmcoKSwgZmFsc2UpO1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICB4aHIuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHR4OiB0eFxuICAgICAgfSkpO1xuICAgICAgdmFyIHJlcyA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB2YXIgcmVxdWlyZWRQZXJtcyA9IHJlcy5yZXF1aXJlZFBlcm1zO1xuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgYWxsb3dlZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgaWYgKHJlcXVpcmVkUGVybXMgJiYgcmVxdWlyZWRQZXJtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0LmFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0LnR4SGFzaCA9IG9hdXRoLl9oYXNoT3BzKHR4Lm9wZXJhdGlvbnMpO1xuICAgICAgICByZXQud2luID0gb2F1dGgubG9naW4oW10sICc/b3BzX2hhc2g9JyArIHJldC50eEhhc2gpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcHJlcGFyZVBlbmRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9wcmVwYXJlUGVuZGluZzIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUodHgsIHR4SGFzaCkge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9hdXRoLl9jYWxsQXBpKCcvYXBpL29hdXRoL3ByZXBhcmVfcGVuZGluZycsIHtcbiAgICAgICAgICAgICAgICAgIHR4OiB0eCxcbiAgICAgICAgICAgICAgICAgIHR4SGFzaDogdHhIYXNoXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJlcyA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJlcyA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShyZXMuc3RhdHVzID09PSAnb2snKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIGlmICghcmVzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoanNvbi5lcnJvcik7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIFNlcnZlciBFcnJvcicpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9wcmVwYXJlUGVuZGluZyhfeCwgX3gyKSB7XG4gICAgICAgIHJldHVybiBfcHJlcGFyZVBlbmRpbmcyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcHJlcGFyZVBlbmRpbmc7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX3dhaXRGb3JQZW5kaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfd2FpdEZvclBlbmRpbmcyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMyh0eEhhc2gpIHtcbiAgICAgICAgdmFyIGludGVydmFsLCBtYXgsIGxvb3A7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSAyICogMTAwMDtcbiAgICAgICAgICAgICAgICBtYXggPSBpbnRlcnZhbCAqIDMwO1xuXG4gICAgICAgICAgICAgICAgbG9vcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3YWl0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yYmlkZGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3JlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hcmdzMiA9IGFyZ3VtZW50cztcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRlZCA9IF9hcmdzMi5sZW5ndGggPiAwICYmIF9hcmdzMlswXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MyWzBdIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGF5KGludGVydmFsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYXV0aC5fY2FsbEFwaSgnL2FwaS9vYXV0aC93YWl0X2Zvcl9wZW5kaW5nLycgKyB0eEhhc2gpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGpzb24uc3RhdHVzID09PSAnb2snKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmJpZGRlbiA9IGpzb24uZm9yYmlkZGVuLCBlcnIgPSBqc29uLmVyciwgX3JlcyA9IGpzb24ucmVzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3JiaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGZvcmJpZGRlbicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXM6IF9yZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRlZCArPSBpbnRlcnZhbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHdhaXRlZCA+PSBtYXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiB0aW1lb3V0ZWQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvb3Aod2FpdGVkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Mi5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMik7XG4gICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBsb29wKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvb3AoKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQzLnNlbnQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfd2FpdEZvclBlbmRpbmcoX3gzKSB7XG4gICAgICAgIHJldHVybiBfd2FpdEZvclBlbmRpbmcyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfd2FpdEZvclBlbmRpbmc7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Byb2Nlc3NQZW5kaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcHJvY2Vzc1BlbmRpbmcyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNCh0eCkge1xuICAgICAgICB2YXIgX3RoaXMkX2NoZWNrUGVuZGluZ0FsLCBhbGxvd2VkLCB3aW4sIHR4SGFzaCwgY2xvc2VXaW4sIHJlcywgZXJyLCByZXN1bHQ7XG5cbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfdGhpcyRfY2hlY2tQZW5kaW5nQWwgPSB0aGlzLl9jaGVja1BlbmRpbmdBbGxvd2VkKHR4KSwgYWxsb3dlZCA9IF90aGlzJF9jaGVja1BlbmRpbmdBbC5hbGxvd2VkLCB3aW4gPSBfdGhpcyRfY2hlY2tQZW5kaW5nQWwud2luLCB0eEhhc2ggPSBfdGhpcyRfY2hlY2tQZW5kaW5nQWwudHhIYXNoO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjbG9zZVdpbiA9IGZ1bmN0aW9uIGNsb3NlV2luKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKHdpbiAmJiAhd2luLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICB3aW4uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDM7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmVwYXJlUGVuZGluZyh0eCwgdHhIYXNoKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSA4O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NC50MCA9IF9jb250ZXh0NFtcImNhdGNoXCJdKDMpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ19wcmVwYXJlUGVuZGluZycsIF9jb250ZXh0NC50MCk7XG4gICAgICAgICAgICAgICAgY2xvc2VXaW4oKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDQudDA7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDEzO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dhaXRGb3JQZW5kaW5nKHR4SGFzaCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgICAgICByZXMgPSByZXN1bHQucmVzO1xuICAgICAgICAgICAgICAgIGVyciA9IHJlc3VsdC5lcnI7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyNjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMjE7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0LnQxID0gX2NvbnRleHQ0W1wiY2F0Y2hcIl0oMTMpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ193YWl0Rm9yUGVuZGluZycsIF9jb250ZXh0NC50MSk7XG4gICAgICAgICAgICAgICAgY2xvc2VXaW4oKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDQudDE7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICBicm9hZGNhc3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgcmVzOiByZXMsXG4gICAgICAgICAgICAgICAgICBlcnI6IGVyclxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0OiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMsIFtbMywgOF0sIFsxMywgMjFdXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9wcm9jZXNzUGVuZGluZyhfeDQpIHtcbiAgICAgICAgcmV0dXJuIF9wcm9jZXNzUGVuZGluZzIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9wcm9jZXNzUGVuZGluZztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJicm9hZGNhc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9icm9hZGNhc3QgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KF9yZWYyKSB7XG4gICAgICAgIHZhciB0eCwgcHJpdktleXMsIG9yaWcsIHJlc3VsdCwgX3Jlc3VsdCwgZXJyLCB0O1xuXG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdHggPSBfcmVmMi50eCwgcHJpdktleXMgPSBfcmVmMi5wcml2S2V5cywgb3JpZyA9IF9yZWYyLm9yaWc7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0OiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmICghKHR4Ll9tZXRhICYmIHR4Ll9tZXRhLl9rZXlzKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzUGVuZGluZyh0eCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0NS5zZW50O1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5icm9hZGNhc3QpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKE9BdXRoTWlkZGxld2FyZS5wcm90b3R5cGUpLCBcImJyb2FkY2FzdFwiLCB0aGlzKS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgIHR4OiB0eCxcbiAgICAgICAgICAgICAgICAgIHByaXZLZXlzOiBwcml2S2V5cyxcbiAgICAgICAgICAgICAgICAgIG9yaWc6IG9yaWdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ1LnNlbnQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQucmVzKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0LnJlcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBfcmVzdWx0ID0gcmVzdWx0LCBlcnIgPSBfcmVzdWx0LmVycjsgLy8gaHR0cFxuXG4gICAgICAgICAgICAgICAgaWYgKCEoZXJyICYmIGVyci5uYW1lID09PSAnUlBDRXJyb3InKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxNztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSUENFcnJvcihlcnIsIGVycik7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICBpZiAoIShlcnIgJiYgZXJyLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDIxO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdCA9IG5ldyBFcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdC5wYXlsb2FkID0gZXJyLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgdDtcblxuICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ09BdXRoTWlkZGxld2FyZSBicm9hZGNhc3QnLCBlcnIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gYnJvYWRjYXN0KF94NSkge1xuICAgICAgICByZXR1cm4gX2Jyb2FkY2FzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJvYWRjYXN0O1xuICAgIH0oKVxuICB9XSk7XG5cbiAgcmV0dXJuIE9BdXRoTWlkZGxld2FyZTtcbn0oRW1wdHlNaWRkbGV3YXJlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPQXV0aE1pZGRsZXdhcmU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFbXB0eU1pZGRsZXdhcmUgPSByZXF1aXJlKCcuL0VtcHR5TWlkZGxld2FyZScpO1xuXG52YXIgT0F1dGhNaWRkbGV3YXJlID0gcmVxdWlyZSgnLi9PQXV0aE1pZGRsZXdhcmUnKTtcblxudmFyIGN1cnJlbnQgPSBuZXcgRW1wdHlNaWRkbGV3YXJlKCk7XG5cbmZ1bmN0aW9uIHVzZShtaWRkbGV3YXJlKSB7XG4gIGN1cnJlbnQgPSBtaWRkbGV3YXJlO1xufVxuXG5mdW5jdGlvbiBtdygpIHtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFbXB0eU1pZGRsZXdhcmU6IEVtcHR5TWlkZGxld2FyZSxcbiAgT0F1dGhNaWRkbGV3YXJlOiBPQXV0aE1pZGRsZXdhcmUsXG4gIHVzZTogdXNlLFxuICBtdzogbXdcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5qc1wiKTtcblxucmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3RhcnRzLXdpdGguanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy93ZWIudXJsLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL3dlYi51cmwtc2VhcmNoLXBhcmFtcy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luLmpzXCIpO1xuXG52YXIgX2RlYnVnID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuXG52YXIgX2NvbmZpZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2NvbmZpZ1wiKSk7XG5cbnZhciBfZWNjID0gcmVxdWlyZShcIi4uL2F1dGgvZWNjXCIpO1xuXG52YXIgX2ZldGNoRXggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy9mZXRjaEV4XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxudmFyIF9hcGlIb3N0O1xuXG52YXIgX3VpSG9zdDtcblxudmFyIF9jbGllbnRJZDtcblxudmFyIGRlYnVnID0gKDAsIF9kZWJ1Zy5kZWZhdWx0KSgnZ29sb3M6b2F1dGgnKTtcblxuZnVuY3Rpb24gYXBpSG9zdCgpIHtcbiAgaWYgKF9hcGlIb3N0KSByZXR1cm4gX2FwaUhvc3Q7XG4gIHZhciBLRVkgPSAnb2F1dGguaG9zdCc7XG5cbiAgdmFyIGhvc3QgPSBfY29uZmlnLmRlZmF1bHQuZ2V0KEtFWSk7XG5cbiAgaWYgKCFob3N0KSB0aHJvdyBuZXcgRXJyb3IoS0VZICsgJyBpcyBub3Qgc2V0IGluIGdvbG9zLmNvbmZpZycpO1xuICBpZiAoIWhvc3Quc3RhcnRzV2l0aCgnaHR0cDovLycpICYmICFob3N0LnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpIGhvc3QgPSAnaHR0cHM6Ly8nICsgaG9zdDtcblxuICB0cnkge1xuICAgIF9hcGlIb3N0ID0gbmV3IFVSTChob3N0KS5vcmlnaW47XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihLRVkgKyAnIGNhbm5vdCBiZSBwYXJzZWQgYXMgVVJMOiAnICsgaG9zdCk7XG4gIH1cblxuICByZXR1cm4gX2FwaUhvc3Q7XG59XG5cbmZ1bmN0aW9uIHVpSG9zdCgpIHtcbiAgaWYgKF91aUhvc3QpIHJldHVybiBfdWlIb3N0O1xuICB2YXIgS0VZID0gJ29hdXRoLnVpX2hvc3QnO1xuXG4gIHZhciBob3N0ID0gX2NvbmZpZy5kZWZhdWx0LmdldChLRVkpO1xuXG4gIGlmICghaG9zdCkge1xuICAgIF91aUhvc3QgPSBhcGlIb3N0KCk7XG4gICAgcmV0dXJuIF91aUhvc3Q7XG4gIH1cblxuICBpZiAoIWhvc3Quc3RhcnRzV2l0aCgnaHR0cDovLycpICYmICFob3N0LnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpIGhvc3QgPSAnaHR0cHM6Ly8nICsgaG9zdDtcblxuICB0cnkge1xuICAgIF91aUhvc3QgPSBuZXcgVVJMKGhvc3QpLm9yaWdpbjtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEtFWSArICcgY2Fubm90IGJlIHBhcnNlZCBhcyBVUkw6ICcgKyBob3N0KTtcbiAgfVxuXG4gIHJldHVybiBfdWlIb3N0O1xufVxuXG5mdW5jdGlvbiBjbGllbnRJZCgpIHtcbiAgaWYgKF9jbGllbnRJZCkgcmV0dXJuIF9jbGllbnRJZDtcbiAgdmFyIEtFWSA9ICdvYXV0aC5jbGllbnQnO1xuXG4gIHZhciBjbGllbnQgPSBfY29uZmlnLmRlZmF1bHQuZ2V0KEtFWSk7XG5cbiAgaWYgKCFjbGllbnQpIHRocm93IG5ldyBFcnJvcihLRVkgKyAnIGlzIG5vdCBzZXQgaW4gZ29sb3MuY29uZmlnJyk7XG4gIF9jbGllbnRJZCA9IGNsaWVudDtcbiAgcmV0dXJuIF9jbGllbnRJZDtcbn1cblxuZnVuY3Rpb24gX2NhbGxBcGkodXJsLCBkYXRhKSB7XG4gIHZhciBnZXRIb3N0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBhcGlIb3N0O1xuICB2YXIgcmVxdWVzdCA9IHtcbiAgICBtZXRob2Q6IGRhdGEgPyAncG9zdCcgOiAnZ2V0JyxcbiAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgJ0NvbnRlbnQtdHlwZSc6IGRhdGEgPyAnYXBwbGljYXRpb24vanNvbicgOiB1bmRlZmluZWRcbiAgICB9LFxuICAgIGJvZHk6IGRhdGEgPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IHVuZGVmaW5lZFxuICB9O1xuICByZXR1cm4gKDAsIF9mZXRjaEV4LmRlZmF1bHQpKG5ldyBVUkwodXJsLCBnZXRIb3N0KCkpLCByZXF1ZXN0KTtcbn1cblxuZnVuY3Rpb24gY2hlY2soKSB7XG4gIHJldHVybiBfY2hlY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2NoZWNrKCkge1xuICBfY2hlY2sgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgdmFyIHJlcztcbiAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiBfY2FsbEFwaSgnL2FwaS9vYXV0aC9jaGVjay8nICsgY2xpZW50SWQoKSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXMgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmpzb24oKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfY2hlY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tSZWxpYWJsZSgpIHtcbiAgcmV0dXJuIF9jaGVja1JlbGlhYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9jaGVja1JlbGlhYmxlKCkge1xuICBfY2hlY2tSZWxpYWJsZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgdmFyIG9uRXJyb3IsXG4gICAgICAgIHJldHJ5LFxuICAgICAgICByZXMsXG4gICAgICAgIF9hcmdzMiA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgb25FcnJvciA9IF9hcmdzMi5sZW5ndGggPiAwICYmIF9hcmdzMlswXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MyWzBdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0cnkgPSBfYXJnczIubGVuZ3RoID4gMSAmJiBfYXJnczJbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMlsxXSA6IDE7XG4gICAgICAgICAgICByZXMgPSBudWxsO1xuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAzO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrKCk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXMgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlcyk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxMDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDMpO1xuXG4gICAgICAgICAgICBpZiAoIShvbkVycm9yICYmIG9uRXJyb3Ioe1xuICAgICAgICAgICAgICByZXRyeTogcmV0cnlcbiAgICAgICAgICAgIH0pKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQyLnQwO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIGlmICghb25FcnJvcikgY29uc29sZS5lcnJvcignb2F1dGguY2hlY2sgZXJyb3I6JywgX2NvbnRleHQyLnQwLCAncmV0cnlpbmcuLi4nKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjaGVja1JlbGlhYmxlKG9uRXJyb3IsICsrcmV0cnkpO1xuICAgICAgICAgICAgfSwgMzAwMCk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIG51bGwsIFtbMywgMTBdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9jaGVja1JlbGlhYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHdhaXRGb3JMb2dpbihfeCwgX3gyKSB7XG4gIHJldHVybiBfd2FpdEZvckxvZ2luLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF93YWl0Rm9yTG9naW4oKSB7XG4gIF93YWl0Rm9yTG9naW4gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKG9uRmluaXNoLCBvbkZhaWwpIHtcbiAgICB2YXIgcmV0cmllcyxcbiAgICAgICAgb25SZXRyeSxcbiAgICAgICAgcmVzLFxuICAgICAgICBfYXJnczMgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHJpZXMgPSBfYXJnczMubGVuZ3RoID4gMiAmJiBfYXJnczNbMl0gIT09IHVuZGVmaW5lZCA/IF9hcmdzM1syXSA6IDE4MDtcbiAgICAgICAgICAgIG9uUmV0cnkgPSBfYXJnczMubGVuZ3RoID4gMyAmJiBfYXJnczNbM10gIT09IHVuZGVmaW5lZCA/IF9hcmdzM1szXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgaWYgKHJldHJpZXMpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignd2FpdGluZyBmb3IgbG9naW4gaXMgdGltZW91dGVkJyk7XG4gICAgICAgICAgICBvbkZhaWwoKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA4O1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrUmVsaWFibGUoKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJlcyA9IF9jb250ZXh0My5zZW50O1xuXG4gICAgICAgICAgICBpZiAoIXJlcy5hdXRob3JpemVkKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvbkZpbmlzaChyZXMpO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxODtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGlmICghKG9uUmV0cnkgJiYgb25SZXRyeSh7XG4gICAgICAgICAgICAgIHJldHJpZXNMZWZ0OiByZXRyaWVzXG4gICAgICAgICAgICB9KSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9uRmFpbCgpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgZGVidWcoJ3dhaXRpbmcgZm9yIGxvZ2luLi4uJyk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgd2FpdEZvckxvZ2luKG9uRmluaXNoLCBvbkZhaWwsIC0tcmV0cmllcywgb25SZXRyeSk7XG4gICAgICAgICAgICB9LCAxMDAwKTtcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMyk7XG4gIH0pKTtcbiAgcmV0dXJuIF93YWl0Rm9yTG9naW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gbG9naW4oKSB7XG4gIHZhciBwZXJtaXNzaW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIHZhciBleHRyYVBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPQXV0aCB3b3JrcyBvbmx5IGluIGJyb3dzZXIgZW52aXJvbm1lbnQgKHdpbmRvdyBzaG91bGQgYmUgZGVmaW5lZCknKTtcbiAgfVxuXG4gIHJldHVybiB3aW5kb3cub3Blbih1aUhvc3QoKSArICcvb2F1dGgvJyArIGNsaWVudElkKCkgKyAnLycgKyBwZXJtaXNzaW9ucy5qb2luKCcsJykgKyBleHRyYVBhcmFtcyk7XG59XG5cbmZ1bmN0aW9uIGxvZ291dCgpIHtcbiAgcmV0dXJuIF9sb2dvdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2xvZ291dCgpIHtcbiAgX2xvZ291dCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoKSB7XG4gICAgdmFyIHJlcztcbiAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIF9jYWxsQXBpKCcvYXBpL29hdXRoL2xvZ291dC8nICsgY2xpZW50SWQoKSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXMgPSBfY29udGV4dDQuc2VudDtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0KTtcbiAgfSkpO1xuICByZXR1cm4gX2xvZ291dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaGFzaE9wcyhvcGVyYXRpb25zKSB7XG4gIHZhciBqc29uID0gSlNPTi5zdHJpbmdpZnkob3BlcmF0aW9ucyk7XG5cbiAgdmFyIGlkSGFzaCA9IF9lY2MuaGFzaC5zaGEyNTYoanNvbiwgJ2hleCcpO1xuXG4gIHJldHVybiBpZEhhc2g7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjbGllbnRJZDogY2xpZW50SWQsXG4gIGFwaUhvc3Q6IGFwaUhvc3QsXG4gIHVpSG9zdDogdWlIb3N0LFxuICBfY2FsbEFwaTogX2NhbGxBcGksXG4gIGNoZWNrOiBjaGVjayxcbiAgY2hlY2tSZWxpYWJsZTogY2hlY2tSZWxpYWJsZSxcbiAgbG9naW46IGxvZ2luLFxuICB3YWl0Rm9yTG9naW46IHdhaXRGb3JMb2dpbixcbiAgbG9nb3V0OiBsb2dvdXQsXG4gIF9oYXNoT3BzOiBfaGFzaE9wc1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5ub2RlaWZ5ID0gbm9kZWlmeTtcbmV4cG9ydHMucHJvbWlzaWZ5ID0gcHJvbWlzaWZ5O1xuZXhwb3J0cy5wcm9taXNpZnlBbGwgPSBwcm9taXNpZnlBbGw7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnNldC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXCIpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBQcm9taXNlRXJyb3IgPSBmdW5jdGlvbiBQcm9taXNlRXJyb3IoZXJyb3IpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb21pc2VFcnJvcik7XG5cbiAgdGhpcy5jYXVzZSA9IGVycm9yO1xuICB0aGlzLm1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICB0aGlzLm5hbWUgPSBlcnJvci5uYW1lIHx8ICdFcnJvcic7XG4gIGlmIChlcnJvci5wYXlsb2FkKSB0aGlzLnBheWxvYWQgPSBlcnJvci5wYXlsb2FkO1xuICB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG59O1xuXG5mdW5jdGlvbiBwcm9taXNpZnkoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmbi5jYWxsLmFwcGx5KGZuLCBbX3RoaXNdLmNvbmNhdChhcmdzLCBbZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpO2Vsc2UgcmVzb2x2ZShyZXMpO1xuICAgICAgfV0pKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvbWlzaWZ5QWxsKG9iaikge1xuICB2YXIgc3VmZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnQXN5bmMnO1xuICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaik7XG4gIHZhciByZXQgPSBuZXcgU2V0KCk7XG5cbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGtleXMpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuICAgICAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJykgY29udGludWU7XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuXG4gICAgICBpZiAoZGVzYyAhPSBudWxsICYmIGRlc2MuZ2V0ID09IG51bGwgJiYgZGVzYy5zZXQgPT0gbnVsbCkge1xuICAgICAgICByZXQuYWRkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cblxuICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJldCksXG4gICAgICBfc3RlcDI7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgdmFyIF9rZXkyID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgb2JqW19rZXkyICsgc3VmZml4XSA9IHByb21pc2lmeShvYmpbX2tleTJdKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjIuZigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5vZGVpZnkocHJvbWlzZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVyciwgbnVsbCk7ZWxzZSB0aHJvdyBlcnI7XG4gIH0pO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXNzZXRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NvcmUuQXNzZXQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXNzZXRFZGl0b3JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NvcmUuQXNzZXRFZGl0b3I7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJpY2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NvcmUuUHJpY2U7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX0Fzc2V0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jb3JlLl9Bc3NldDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfQXNzZXRFZGl0b3JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NvcmUuX0Fzc2V0RWRpdG9yO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9QcmljZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29yZS5fUHJpY2U7XG4gIH1cbn0pO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKFwiLi4vY29yZVwiKTsiLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5cy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanNcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLmpzXCIpO1xuXG52YXIgX2Nyb3NzRmV0Y2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjcm9zcy1mZXRjaFwiKSk7XG5cbnZhciBfYWJvcnRDb250cm9sbGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiYWJvcnQtY29udHJvbGxlclwiKSk7XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJ0aW1lb3V0XCJdO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuXG52YXIgQ09NTU9OX1RJTUVPVVQgPSAxMDAwMDtcblxuZnVuY3Rpb24gZmV0Y2hFeChfeCwgX3gyKSB7XG4gIHJldHVybiBfZmV0Y2hFeC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZmV0Y2hFeCgpIHtcbiAgX2ZldGNoRXggPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUodXJsLCBvcHRzKSB7XG4gICAgdmFyIHRpbWVvdXQsIHJlc3RPcHRzLCBjb250cm9sbGVyO1xuICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRpbWVvdXQgPSBvcHRzLnRpbWVvdXQsIHJlc3RPcHRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9wdHMsIF9leGNsdWRlZCk7XG5cbiAgICAgICAgICAgIGlmICghcmVzdE9wdHMuc2lnbmFsKSB7XG4gICAgICAgICAgICAgIGlmICh0aW1lb3V0ID09PSAwIHx8IHRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBDT01NT05fVElNRU9VVDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlciA9IG5ldyBfYWJvcnRDb250cm9sbGVyLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgcmVzdE9wdHMuc2lnbmFsID0gY29udHJvbGxlci5zaWduYWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9jcm9zc0ZldGNoLmRlZmF1bHQpKHVybCwgcmVzdE9wdHMpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9mZXRjaEV4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZldGNoRXguQ09NTU9OX1RJTUVPVVQgPSBDT01NT05fVElNRU9VVDtcbmZldGNoRXguQWJvcnRDb250cm9sbGVyID0gX2Fib3J0Q29udHJvbGxlci5kZWZhdWx0O1xudmFyIF9kZWZhdWx0ID0gZmV0Y2hFeDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXNzZXRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0Fzc2V0LkFzc2V0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzc2V0RWRpdG9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Bc3NldC5Bc3NldEVkaXRvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcmljZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfQXNzZXQuUHJpY2U7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX0Fzc2V0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Bc3NldC5fQXNzZXQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX0Fzc2V0RWRpdG9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Bc3NldC5fQXNzZXRFZGl0b3I7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX1ByaWNlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Bc3NldC5fUHJpY2U7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2FtZWxDYXNlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9taXNjLmNhbWVsQ2FzZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWxheVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWlzYy5kZWxheTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmZXRjaEV4XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9mZXRjaEV4LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZml0SW1hZ2VUb1NpemVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX21pc2MuZml0SW1hZ2VUb1NpemU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmFsaWRhdGVBY2NvdW50TmFtZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWlzYy52YWxpZGF0ZUFjY291bnROYW1lO1xuICB9XG59KTtcblxudmFyIF9Bc3NldCA9IHJlcXVpcmUoXCIuL0Fzc2V0XCIpO1xuXG52YXIgX21pc2MgPSByZXF1aXJlKFwiLi9taXNjXCIpO1xuXG52YXIgX2ZldGNoRXggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ZldGNoRXhcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG5leHBvcnRzLmRlbGF5ID0gZGVsYXk7XG5leHBvcnRzLmZpdEltYWdlVG9TaXplID0gZml0SW1hZ2VUb1NpemU7XG5leHBvcnRzLnZhbGlkYXRlQWNjb3VudE5hbWUgPSB2YWxpZGF0ZUFjY291bnROYW1lO1xuXG5yZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdC5qc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UuanNcIik7XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIGRlbGF5KF94KSB7XG4gIHJldHVybiBfZGVsYXkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2RlbGF5KCkge1xuICBfZGVsYXkgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUobXNlYykge1xuICAgIHZhciBnZXRUaW1lb3V0SWQsXG4gICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGdldFRpbWVvdXRJZCA9IF9hcmdzLmxlbmd0aCA+IDEgJiYgX2FyZ3NbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICB2YXIgaWQgPSBzZXRUaW1lb3V0KHJlc29sdmUsIG1zZWMpO1xuICAgICAgICAgICAgICBpZiAoZ2V0VGltZW91dElkKSBnZXRUaW1lb3V0SWQoaWQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfZGVsYXkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxudmFyIHNuYWtlQ2FzZVJlID0gL18oW2Etel0pL2c7XG5cbmZ1bmN0aW9uIGNhbWVsQ2FzZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHNuYWtlQ2FzZVJlLCBmdW5jdGlvbiAoX20sIGwpIHtcbiAgICByZXR1cm4gbC50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVBY2NvdW50TmFtZSh2YWx1ZSkge1xuICB2YXIgaSwgbGFiZWwsIGxlbiwgc3VmZml4O1xuICB2YXIgcmVzID0ge1xuICAgIGVycm9yOiBudWxsLFxuICAgIG1zZzogJydcbiAgfTtcbiAgc3VmZml4ID0gXCJBY2NvdW50IG5hbWUgc2hvdWxkIFwiO1xuXG4gIGlmICghdmFsdWUpIHtcbiAgICByZXMubXNnID0gc3VmZml4ICsgXCJub3QgYmUgZW1wdHkuXCI7XG4gICAgcmVzLmVycm9yID0gJ2FjY291bnRfbmFtZV9zaG91bGRfbm90X2JlX2VtcHR5JztcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgMykge1xuICAgIHJlcy5tc2cgPSBzdWZmaXggKyBcImJlIGxvbmdlci5cIjtcbiAgICByZXMuZXJyb3IgPSAnYWNjb3VudF9uYW1lX3Nob3VsZF9iZV9sb25nZXInO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBpZiAobGVuZ3RoID4gMTYpIHtcbiAgICByZXMubXNnID0gc3VmZml4ICsgXCJiZSBzaG9ydGVyLlwiO1xuICAgIHJlcy5lcnJvciA9ICdhY2NvdW50X25hbWVfc2hvdWxkX2JlX3Nob3J0ZXInO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBpZiAoL1xcLi8udGVzdCh2YWx1ZSkpIHtcbiAgICBzdWZmaXggPSBcIkVhY2ggYWNjb3VudCBzZWdtZW50IHNob3VsZCBcIjtcbiAgfVxuXG4gIHZhciByZWYgPSB2YWx1ZS5zcGxpdChcIi5cIik7XG5cbiAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbGFiZWwgPSByZWZbaV07XG5cbiAgICBpZiAoIS9eW2Etel0vLnRlc3QobGFiZWwpKSB7XG4gICAgICByZXMubXNnID0gc3VmZml4ICsgXCJzdGFydCB3aXRoIGEgbGV0dGVyLlwiO1xuICAgICAgcmVzLmVycm9yID0gJ2VhY2hfYWNjb3VudF9zZWdtZW50X3Nob3VsZF9zdGFydF93aXRoX2FfbGV0dGVyJztcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKCEvXlthLXowLTktXSokLy50ZXN0KGxhYmVsKSkge1xuICAgICAgcmVzLm1zZyA9IHN1ZmZpeCArIFwiaGF2ZSBvbmx5IGxldHRlcnMsIGRpZ2l0cywgb3IgZGFzaGVzLlwiO1xuICAgICAgcmVzLmVycm9yID0gJ2VhY2hfYWNjb3VudF9zZWdtZW50X3Nob3VsZF9oYXZlX29ubHlfbGV0dGVyc19kaWdpdHNfb3JfZGFzaGVzJztcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKC8tLS8udGVzdChsYWJlbCkpIHtcbiAgICAgIHJlcy5tc2cgPSBzdWZmaXggKyBcImhhdmUgb25seSBvbmUgZGFzaCBpbiBhIHJvdy5cIjtcbiAgICAgIHJlcy5lcnJvciA9ICdlYWNoX2FjY291bnRfc2VnbWVudF9zaG91bGRfaGF2ZV9vbmx5X29uZV9kYXNoX2luX2Ffcm93JztcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKCEvW2EtejAtOV0kLy50ZXN0KGxhYmVsKSkge1xuICAgICAgcmVzLm1zZyA9IHN1ZmZpeCArIFwiZW5kIHdpdGggYSBsZXR0ZXIgb3IgZGlnaXQuXCI7XG4gICAgICByZXMuZXJyb3IgPSAnZWFjaF9hY2NvdW50X3NlZ21lbnRfc2hvdWxkX2VuZF93aXRoX2FfbGV0dGVyX29yX2RpZ2l0JztcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKCEobGFiZWwubGVuZ3RoID49IDMpKSB7XG4gICAgICByZXMubXNnID0gc3VmZml4ICsgXCJiZSBsb25nZXJcIjtcbiAgICAgIHJlcy5lcnJvciA9ICdlYWNoX2FjY291bnRfc2VnbWVudF9zaG91bGRfYmVfbG9uZ2VyJztcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gZml0SW1hZ2VUb1NpemUod2lkdGgsIGhlaWdodCwgZ29vZFdpZHRoLCBnb29kSGVpZ2h0KSB7XG4gIHZhciBvdmVyV2lkdGggPSB3aWR0aCAvIGdvb2RXaWR0aDtcbiAgdmFyIG92ZXJIZWlnaHQgPSBoZWlnaHQgLyBnb29kSGVpZ2h0O1xuXG4gIGlmIChvdmVyV2lkdGggPD0gMSAmJiBvdmVySGVpZ2h0IDw9IDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgdmFyIHByb3BvcnRpb24gPSB3aWR0aCAvIGhlaWdodDtcblxuICBpZiAob3ZlcldpZHRoID4gb3ZlckhlaWdodCkge1xuICAgIHdpZHRoID0gZ29vZFdpZHRoO1xuICAgIGhlaWdodCA9IE1hdGgucm91bmQod2lkdGggLyBwcm9wb3J0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBoZWlnaHQgPSBnb29kSGVpZ2h0O1xuICAgIHdpZHRoID0gTWF0aC5yb3VuZChoZWlnaHQgKiBwcm9wb3J0aW9uKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59IiwiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9hc3NlcnQuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMmE1MWFlNDI0YTUxM2VjOWE2YWEzNDY2YmFhMGNjMWQ1NWRkNGYzYlxuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL2Vycm9ycycpLFxuICAgIF9yZXF1aXJlJGNvZGVzID0gX3JlcXVpcmUuY29kZXMsXG4gICAgRVJSX0FNQklHVU9VU19BUkdVTUVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9BTUJJR1VPVVNfQVJHVU1FTlQsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVkFMVUUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVkFMVUUsXG4gICAgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFLFxuICAgIEVSUl9NSVNTSU5HX0FSR1MgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUlTU0lOR19BUkdTO1xuXG52YXIgQXNzZXJ0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3InKTtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJ3V0aWwvJyksXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlMi5pbnNwZWN0O1xuXG52YXIgX3JlcXVpcmUkdHlwZXMgPSByZXF1aXJlKCd1dGlsLycpLnR5cGVzLFxuICAgIGlzUHJvbWlzZSA9IF9yZXF1aXJlJHR5cGVzLmlzUHJvbWlzZSxcbiAgICBpc1JlZ0V4cCA9IF9yZXF1aXJlJHR5cGVzLmlzUmVnRXhwO1xuXG52YXIgb2JqZWN0QXNzaWduID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24gOiByZXF1aXJlKCdlczYtb2JqZWN0LWFzc2lnbicpLmFzc2lnbjtcbnZhciBvYmplY3RJcyA9IE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IHJlcXVpcmUoJ29iamVjdC1pcycpO1xudmFyIGVycm9yQ2FjaGUgPSBuZXcgTWFwKCk7XG52YXIgaXNEZWVwRXF1YWw7XG52YXIgaXNEZWVwU3RyaWN0RXF1YWw7XG52YXIgcGFyc2VFeHByZXNzaW9uQXQ7XG52YXIgZmluZE5vZGVBcm91bmQ7XG52YXIgZGVjb2RlcjtcblxuZnVuY3Rpb24gbGF6eUxvYWRDb21wYXJpc29uKCkge1xuICB2YXIgY29tcGFyaXNvbiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvdXRpbC9jb21wYXJpc29ucycpO1xuXG4gIGlzRGVlcEVxdWFsID0gY29tcGFyaXNvbi5pc0RlZXBFcXVhbDtcbiAgaXNEZWVwU3RyaWN0RXF1YWwgPSBjb21wYXJpc29uLmlzRGVlcFN0cmljdEVxdWFsO1xufSAvLyBFc2NhcGUgY29udHJvbCBjaGFyYWN0ZXJzIGJ1dCBub3QgXFxuIGFuZCBcXHQgdG8ga2VlcCB0aGUgbGluZSBicmVha3MgYW5kXG4vLyBpbmRlbnRhdGlvbiBpbnRhY3QuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuXG5cbnZhciBlc2NhcGVTZXF1ZW5jZXNSZWdFeHAgPSAvW1xceDAwLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXS9nO1xudmFyIG1ldGEgPSBbXCJcXFxcdTAwMDBcIiwgXCJcXFxcdTAwMDFcIiwgXCJcXFxcdTAwMDJcIiwgXCJcXFxcdTAwMDNcIiwgXCJcXFxcdTAwMDRcIiwgXCJcXFxcdTAwMDVcIiwgXCJcXFxcdTAwMDZcIiwgXCJcXFxcdTAwMDdcIiwgJ1xcXFxiJywgJycsICcnLCBcIlxcXFx1MDAwYlwiLCAnXFxcXGYnLCAnJywgXCJcXFxcdTAwMGVcIiwgXCJcXFxcdTAwMGZcIiwgXCJcXFxcdTAwMTBcIiwgXCJcXFxcdTAwMTFcIiwgXCJcXFxcdTAwMTJcIiwgXCJcXFxcdTAwMTNcIiwgXCJcXFxcdTAwMTRcIiwgXCJcXFxcdTAwMTVcIiwgXCJcXFxcdTAwMTZcIiwgXCJcXFxcdTAwMTdcIiwgXCJcXFxcdTAwMThcIiwgXCJcXFxcdTAwMTlcIiwgXCJcXFxcdTAwMWFcIiwgXCJcXFxcdTAwMWJcIiwgXCJcXFxcdTAwMWNcIiwgXCJcXFxcdTAwMWRcIiwgXCJcXFxcdTAwMWVcIiwgXCJcXFxcdTAwMWZcIl07XG5cbnZhciBlc2NhcGVGbiA9IGZ1bmN0aW9uIGVzY2FwZUZuKHN0cikge1xuICByZXR1cm4gbWV0YVtzdHIuY2hhckNvZGVBdCgwKV07XG59O1xuXG52YXIgd2FybmVkID0gZmFsc2U7IC8vIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcbnZhciBOT19FWENFUFRJT05fU0VOVElORUwgPSB7fTsgLy8gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBpbm5lckZhaWwob2JqKSB7XG4gIGlmIChvYmoubWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyBvYmoubWVzc2FnZTtcbiAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG9iaik7XG59XG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGbikge1xuICB2YXIgYXJnc0xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbnRlcm5hbE1lc3NhZ2U7XG5cbiAgaWYgKGFyZ3NMZW4gPT09IDApIHtcbiAgICBpbnRlcm5hbE1lc3NhZ2UgPSAnRmFpbGVkJztcbiAgfSBlbHNlIGlmIChhcmdzTGVuID09PSAxKSB7XG4gICAgbWVzc2FnZSA9IGFjdHVhbDtcbiAgICBhY3R1YWwgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdhcm5lZCA9PT0gZmFsc2UpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB2YXIgd2FybiA9IHByb2Nlc3MuZW1pdFdhcm5pbmcgPyBwcm9jZXNzLmVtaXRXYXJuaW5nIDogY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG4gICAgICB3YXJuKCdhc3NlcnQuZmFpbCgpIHdpdGggbW9yZSB0aGFuIG9uZSBhcmd1bWVudCBpcyBkZXByZWNhdGVkLiAnICsgJ1BsZWFzZSB1c2UgYXNzZXJ0LnN0cmljdEVxdWFsKCkgaW5zdGVhZCBvciBvbmx5IHBhc3MgYSBtZXNzYWdlLicsICdEZXByZWNhdGlvbldhcm5pbmcnLCAnREVQMDA5NCcpO1xuICAgIH1cblxuICAgIGlmIChhcmdzTGVuID09PSAyKSBvcGVyYXRvciA9ICchPSc7XG4gIH1cblxuICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyBtZXNzYWdlO1xuICB2YXIgZXJyQXJncyA9IHtcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yID09PSB1bmRlZmluZWQgPyAnZmFpbCcgOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGbiB8fCBmYWlsXG4gIH07XG5cbiAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgIGVyckFyZ3MubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cblxuICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKGVyckFyZ3MpO1xuXG4gIGlmIChpbnRlcm5hbE1lc3NhZ2UpIHtcbiAgICBlcnIubWVzc2FnZSA9IGludGVybmFsTWVzc2FnZTtcbiAgICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cblxuICB0aHJvdyBlcnI7XG59XG5cbmFzc2VydC5mYWlsID0gZmFpbDsgLy8gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gaW50ZXJuYWwvZXJyb3IuXG5cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IEFzc2VydGlvbkVycm9yO1xuXG5mdW5jdGlvbiBpbm5lck9rKGZuLCBhcmdMZW4sIHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuXG4gICAgaWYgKGFyZ0xlbiA9PT0gMCkge1xuICAgICAgZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gICAgICBtZXNzYWdlID0gJ05vIHZhbHVlIGFyZ3VtZW50IHBhc3NlZCB0byBgYXNzZXJ0Lm9rKClgJztcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgbWVzc2FnZTtcbiAgICB9XG5cbiAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgIGFjdHVhbDogdmFsdWUsXG4gICAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJz09JyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICB9KTtcbiAgICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IGdlbmVyYXRlZE1lc3NhZ2U7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59IC8vIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhdmFsdWUuXG5cblxuZnVuY3Rpb24gb2soKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpbm5lck9rLmFwcGx5KHZvaWQgMCwgW29rLCBhcmdzLmxlbmd0aF0uY29uY2F0KGFyZ3MpKTtcbn1cblxuYXNzZXJ0Lm9rID0gb2s7IC8vIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aCA9PS5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzICovXG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblxuXG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICc9PScsXG4gICAgICBzdGFja1N0YXJ0Rm46IGVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3Rcbi8vIGVxdWFsIHdpdGggIT0uXG5cblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXG5cbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJyE9JyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RXF1YWxcbiAgICB9KTtcbiAgfVxufTsgLy8gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG5cblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoIWlzRGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnZGVlcEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZGVlcEVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuXG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKGlzRGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RGVlcEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cblxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIGRlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoIWlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZGVlcFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWw7XG5cbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdub3REZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3REZWVwU3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufVxuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmICghb2JqZWN0SXMoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdzdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKG9iamVjdElzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90U3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3RTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgQ29tcGFyaXNvbiA9IGZ1bmN0aW9uIENvbXBhcmlzb24ob2JqLCBrZXlzLCBhY3R1YWwpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcGFyaXNvbik7XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgaWYgKGFjdHVhbCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBhY3R1YWxba2V5XSA9PT0gJ3N0cmluZycgJiYgaXNSZWdFeHAob2JqW2tleV0pICYmIG9ialtrZXldLnRlc3QoYWN0dWFsW2tleV0pKSB7XG4gICAgICAgIF90aGlzW2tleV0gPSBhY3R1YWxba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzW2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gY29tcGFyZUV4Y2VwdGlvbktleShhY3R1YWwsIGV4cGVjdGVkLCBrZXksIG1lc3NhZ2UsIGtleXMsIGZuKSB7XG4gIGlmICghKGtleSBpbiBhY3R1YWwpIHx8ICFpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWxba2V5XSwgZXhwZWN0ZWRba2V5XSkpIHtcbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgIC8vIENyZWF0ZSBwbGFjZWhvbGRlciBvYmplY3RzIHRvIGNyZWF0ZSBhIG5pY2Ugb3V0cHV0LlxuICAgICAgdmFyIGEgPSBuZXcgQ29tcGFyaXNvbihhY3R1YWwsIGtleXMpO1xuICAgICAgdmFyIGIgPSBuZXcgQ29tcGFyaXNvbihleHBlY3RlZCwga2V5cywgYWN0dWFsKTtcbiAgICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICBhY3R1YWw6IGEsXG4gICAgICAgIGV4cGVjdGVkOiBiLFxuICAgICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICAgIH0pO1xuICAgICAgZXJyLmFjdHVhbCA9IGFjdHVhbDtcbiAgICAgIGVyci5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgICAgZXJyLm9wZXJhdG9yID0gZm4ubmFtZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6IGZuLm5hbWUsXG4gICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCwgbXNnLCBmbikge1xuICBpZiAodHlwZW9mIGV4cGVjdGVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGlzUmVnRXhwKGV4cGVjdGVkKSkgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTsgLy8gYXNzZXJ0LmRvZXNOb3RUaHJvdyBkb2VzIG5vdCBhY2NlcHQgb2JqZWN0cy5cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2V4cGVjdGVkJywgWydGdW5jdGlvbicsICdSZWdFeHAnXSwgZXhwZWN0ZWQpO1xuICAgIH0gLy8gSGFuZGxlIHByaW1pdGl2ZXMgcHJvcGVybHkuXG5cblxuICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgIT09ICdvYmplY3QnIHx8IGFjdHVhbCA9PT0gbnVsbCkge1xuICAgICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgICB9KTtcbiAgICAgIGVyci5vcGVyYXRvciA9IGZuLm5hbWU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBlY3RlZCk7IC8vIFNwZWNpYWwgaGFuZGxlIGVycm9ycyB0byBtYWtlIHN1cmUgdGhlIG5hbWUgYW5kIHRoZSBtZXNzYWdlIGFyZSBjb21wYXJlZFxuICAgIC8vIGFzIHdlbGwuXG5cbiAgICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAga2V5cy5wdXNoKCduYW1lJywgJ21lc3NhZ2UnKTtcbiAgICB9IGVsc2UgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKCdlcnJvcicsIGV4cGVjdGVkLCAnbWF5IG5vdCBiZSBhbiBlbXB0eSBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgYWN0dWFsW2tleV0gPT09ICdzdHJpbmcnICYmIGlzUmVnRXhwKGV4cGVjdGVkW2tleV0pICYmIGV4cGVjdGVkW2tleV0udGVzdChhY3R1YWxba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb21wYXJlRXhjZXB0aW9uS2V5KGFjdHVhbCwgZXhwZWN0ZWQsIGtleSwgbXNnLCBrZXlzLCBmbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gR3VhcmQgaW5zdGFuY2VvZiBhZ2FpbnN0IGFycm93IGZ1bmN0aW9ucyBhcyB0aGV5IGRvbid0IGhhdmUgYSBwcm90b3R5cGUuXG5cblxuICBpZiAoZXhwZWN0ZWQucHJvdG90eXBlICE9PSB1bmRlZmluZWQgJiYgYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRBY3R1YWwoZm4pIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZm4nLCAnRnVuY3Rpb24nLCBmbik7XG4gIH1cblxuICB0cnkge1xuICAgIGZuKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIHJldHVybiBOT19FWENFUFRJT05fU0VOVElORUw7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSXNQcm9taXNlKG9iaikge1xuICAvLyBBY2NlcHQgbmF0aXZlIEVTNiBwcm9taXNlcyBhbmQgcHJvbWlzZXMgdGhhdCBhcmUgaW1wbGVtZW50ZWQgaW4gYSBzaW1pbGFyXG4gIC8vIHdheS4gRG8gbm90IGFjY2VwdCB0aGVuYWJsZXMgdGhhdCB1c2UgYSBmdW5jdGlvbiBhcyBgb2JqYCBhbmQgdGhhdCBoYXZlIG5vXG4gIC8vIGBjYXRjaGAgaGFuZGxlci5cbiAgLy8gVE9ETzogdGhlbmFibGVzIGFyZSBjaGVja2VkIHVwIHVudGlsIHRoZXkgaGF2ZSB0aGUgY29ycmVjdCBtZXRob2RzLFxuICAvLyBidXQgYWNjb3JkaW5nIHRvIGRvY3VtZW50YXRpb24sIHRoZSBgdGhlbmAgbWV0aG9kIHNob3VsZCByZWNlaXZlXG4gIC8vIHRoZSBgZnVsZmlsbGAgYW5kIGByZWplY3RgIGFyZ3VtZW50cyBhcyB3ZWxsIG9yIGl0IG1heSBiZSBuZXZlciByZXNvbHZlZC5cbiAgcmV0dXJuIGlzUHJvbWlzZShvYmopIHx8IG9iaiAhPT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLmNhdGNoID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiB3YWl0Rm9yQWN0dWFsKHByb21pc2VGbikge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdFByb21pc2U7XG5cbiAgICBpZiAodHlwZW9mIHByb21pc2VGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gUmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZSBpZiBgcHJvbWlzZUZuYCB0aHJvd3Mgc3luY2hyb25vdXNseS5cbiAgICAgIHJlc3VsdFByb21pc2UgPSBwcm9taXNlRm4oKTsgLy8gRmFpbCBpbiBjYXNlIG5vIHByb21pc2UgaXMgcmV0dXJuZWQuXG5cbiAgICAgIGlmICghY2hlY2tJc1Byb21pc2UocmVzdWx0UHJvbWlzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSgnaW5zdGFuY2Ugb2YgUHJvbWlzZScsICdwcm9taXNlRm4nLCByZXN1bHRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoZWNrSXNQcm9taXNlKHByb21pc2VGbikpIHtcbiAgICAgIHJlc3VsdFByb21pc2UgPSBwcm9taXNlRm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgncHJvbWlzZUZuJywgWydGdW5jdGlvbicsICdQcm9taXNlJ10sIHByb21pc2VGbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdFByb21pc2U7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTk9fRVhDRVBUSU9OX1NFTlRJTkVMO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGV4cGVjdHNFcnJvcihzdGFja1N0YXJ0Rm4sIGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdlcnJvcicsIFsnT2JqZWN0JywgJ0Vycm9yJywgJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLCBlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XG4gICAgICBpZiAoYWN0dWFsLm1lc3NhZ2UgPT09IGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UKCdlcnJvci9tZXNzYWdlJywgXCJUaGUgZXJyb3IgbWVzc2FnZSBcXFwiXCIuY29uY2F0KGFjdHVhbC5tZXNzYWdlLCBcIlxcXCIgaXMgaWRlbnRpY2FsIHRvIHRoZSBtZXNzYWdlLlwiKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhY3R1YWwgPT09IGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0FNQklHVU9VU19BUkdVTUVOVCgnZXJyb3IvbWVzc2FnZScsIFwiVGhlIGVycm9yIFxcXCJcIi5jb25jYXQoYWN0dWFsLCBcIlxcXCIgaXMgaWRlbnRpY2FsIHRvIHRoZSBtZXNzYWdlLlwiKSk7XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IGVycm9yO1xuICAgIGVycm9yID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKGVycm9yICE9IG51bGwgJiYgX3R5cGVvZihlcnJvcikgIT09ICdvYmplY3QnICYmIHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXJyb3InLCBbJ09iamVjdCcsICdFcnJvcicsICdGdW5jdGlvbicsICdSZWdFeHAnXSwgZXJyb3IpO1xuICB9XG5cbiAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OX1NFTlRJTkVMKSB7XG4gICAgdmFyIGRldGFpbHMgPSAnJztcblxuICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lKSB7XG4gICAgICBkZXRhaWxzICs9IFwiIChcIi5jb25jYXQoZXJyb3IubmFtZSwgXCIpXCIpO1xuICAgIH1cblxuICAgIGRldGFpbHMgKz0gbWVzc2FnZSA/IFwiOiBcIi5jb25jYXQobWVzc2FnZSkgOiAnLic7XG4gICAgdmFyIGZuVHlwZSA9IHN0YWNrU3RhcnRGbi5uYW1lID09PSAncmVqZWN0cycgPyAncmVqZWN0aW9uJyA6ICdleGNlcHRpb24nO1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IHVuZGVmaW5lZCxcbiAgICAgIGV4cGVjdGVkOiBlcnJvcixcbiAgICAgIG9wZXJhdG9yOiBzdGFja1N0YXJ0Rm4ubmFtZSxcbiAgICAgIG1lc3NhZ2U6IFwiTWlzc2luZyBleHBlY3RlZCBcIi5jb25jYXQoZm5UeXBlKS5jb25jYXQoZGV0YWlscyksXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGblxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGVycm9yICYmICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGVycm9yLCBtZXNzYWdlLCBzdGFja1N0YXJ0Rm4pKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cGVjdHNOb0Vycm9yKHN0YWNrU3RhcnRGbiwgYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT05fU0VOVElORUwpIHJldHVybjtcblxuICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBlcnJvcjtcbiAgICBlcnJvciA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICghZXJyb3IgfHwgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBlcnJvcikpIHtcbiAgICB2YXIgZGV0YWlscyA9IG1lc3NhZ2UgPyBcIjogXCIuY29uY2F0KG1lc3NhZ2UpIDogJy4nO1xuICAgIHZhciBmblR5cGUgPSBzdGFja1N0YXJ0Rm4ubmFtZSA9PT0gJ2RvZXNOb3RSZWplY3QnID8gJ3JlamVjdGlvbicgOiAnZXhjZXB0aW9uJztcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogc3RhY2tTdGFydEZuLm5hbWUsXG4gICAgICBtZXNzYWdlOiBcIkdvdCB1bndhbnRlZCBcIi5jb25jYXQoZm5UeXBlKS5jb25jYXQoZGV0YWlscywgXCJcXG5cIikgKyBcIkFjdHVhbCBtZXNzYWdlOiBcXFwiXCIuY29uY2F0KGFjdHVhbCAmJiBhY3R1YWwubWVzc2FnZSwgXCJcXFwiXCIpLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm5cbiAgICB9KTtcbiAgfVxuXG4gIHRocm93IGFjdHVhbDtcbn1cblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uIHRocm93cyhwcm9taXNlRm4pIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgZXhwZWN0c0Vycm9yLmFwcGx5KHZvaWQgMCwgW3Rocm93cywgZ2V0QWN0dWFsKHByb21pc2VGbildLmNvbmNhdChhcmdzKSk7XG59O1xuXG5hc3NlcnQucmVqZWN0cyA9IGZ1bmN0aW9uIHJlamVjdHMocHJvbWlzZUZuKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuXG4gIHJldHVybiB3YWl0Rm9yQWN0dWFsKHByb21pc2VGbikudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIGV4cGVjdHNFcnJvci5hcHBseSh2b2lkIDAsIFtyZWplY3RzLCByZXN1bHRdLmNvbmNhdChhcmdzKSk7XG4gIH0pO1xufTtcblxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uIGRvZXNOb3RUaHJvdyhmbikge1xuICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQgPiAxID8gX2xlbjQgLSAxIDogMCksIF9rZXk0ID0gMTsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgIGFyZ3NbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gIH1cblxuICBleHBlY3RzTm9FcnJvci5hcHBseSh2b2lkIDAsIFtkb2VzTm90VGhyb3csIGdldEFjdHVhbChmbildLmNvbmNhdChhcmdzKSk7XG59O1xuXG5hc3NlcnQuZG9lc05vdFJlamVjdCA9IGZ1bmN0aW9uIGRvZXNOb3RSZWplY3QoZm4pIHtcbiAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41ID4gMSA/IF9sZW41IC0gMSA6IDApLCBfa2V5NSA9IDE7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICBhcmdzW19rZXk1IC0gMV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICB9XG5cbiAgcmV0dXJuIHdhaXRGb3JBY3R1YWwoZm4pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiBleHBlY3RzTm9FcnJvci5hcHBseSh2b2lkIDAsIFtkb2VzTm90UmVqZWN0LCByZXN1bHRdLmNvbmNhdChhcmdzKSk7XG4gIH0pO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbiBpZkVycm9yKGVycikge1xuICBpZiAoZXJyICE9PSBudWxsICYmIGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnaWZFcnJvciBnb3QgdW53YW50ZWQgZXhjZXB0aW9uOiAnO1xuXG4gICAgaWYgKF90eXBlb2YoZXJyKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGVyci5tZXNzYWdlLmxlbmd0aCA9PT0gMCAmJiBlcnIuY29uc3RydWN0b3IpIHtcbiAgICAgICAgbWVzc2FnZSArPSBlcnIuY29uc3RydWN0b3IubmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UgKz0gaW5zcGVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBuZXdFcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgYWN0dWFsOiBlcnIsXG4gICAgICBleHBlY3RlZDogbnVsbCxcbiAgICAgIG9wZXJhdG9yOiAnaWZFcnJvcicsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgc3RhY2tTdGFydEZuOiBpZkVycm9yXG4gICAgfSk7IC8vIE1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgc3RhY2sgdHJhY2UhXG5cbiAgICB2YXIgb3JpZ1N0YWNrID0gZXJyLnN0YWNrO1xuXG4gICAgaWYgKHR5cGVvZiBvcmlnU3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgcmVtb3ZlIGFueSBkdXBsaWNhdGVkIGZyYW1lcyBmcm9tIHRoZSBlcnJvciBmcmFtZXMgdGFrZW5cbiAgICAgIC8vIGZyb20gd2l0aGluIGBpZkVycm9yYCBhbmQgYWRkIHRoZSBvcmlnaW5hbCBlcnJvciBmcmFtZXMgdG8gdGhlIG5ld2x5XG4gICAgICAvLyBjcmVhdGVkIG9uZXMuXG4gICAgICB2YXIgdG1wMiA9IG9yaWdTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB0bXAyLnNoaWZ0KCk7IC8vIEZpbHRlciBhbGwgZnJhbWVzIGV4aXN0aW5nIGluIGVyci5zdGFjay5cblxuICAgICAgdmFyIHRtcDEgPSBuZXdFcnIuc3RhY2suc3BsaXQoJ1xcbicpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcDIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgZnJhbWUuXG4gICAgICAgIHZhciBwb3MgPSB0bXAxLmluZGV4T2YodG1wMltpXSk7XG5cbiAgICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBPbmx5IGtlZXAgbmV3IGZyYW1lcy5cbiAgICAgICAgICB0bXAxID0gdG1wMS5zbGljZSgwLCBwb3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5ld0Vyci5zdGFjayA9IFwiXCIuY29uY2F0KHRtcDEuam9pbignXFxuJyksIFwiXFxuXCIpLmNvbmNhdCh0bXAyLmpvaW4oJ1xcbicpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXdFcnI7XG4gIH1cbn07IC8vIEV4cG9zZSBhIHN0cmljdCBvbmx5IHZhcmlhbnQgb2YgYXNzZXJ0XG5cblxuZnVuY3Rpb24gc3RyaWN0KCkge1xuICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gIH1cblxuICBpbm5lck9rLmFwcGx5KHZvaWQgMCwgW3N0cmljdCwgYXJncy5sZW5ndGhdLmNvbmNhdChhcmdzKSk7XG59XG5cbmFzc2VydC5zdHJpY3QgPSBvYmplY3RBc3NpZ24oc3RyaWN0LCBhc3NlcnQsIHtcbiAgZXF1YWw6IGFzc2VydC5zdHJpY3RFcXVhbCxcbiAgZGVlcEVxdWFsOiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsLFxuICBub3RFcXVhbDogYXNzZXJ0Lm5vdFN0cmljdEVxdWFsLFxuICBub3REZWVwRXF1YWw6IGFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWxcbn0pO1xuYXNzZXJ0LnN0cmljdC5zdHJpY3QgPSBhc3NlcnQuc3RyaWN0OyIsIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvYXNzZXJ0L2Fzc2VydGlvbl9lcnJvci5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8wODE3ODQwZjc3NTAzMjE2OWRkZDcwYzg1YWMwNTlmMThmZmNjODFjXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykgeyBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlOyB9KSk7IH0gb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7IGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHsgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7IF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7IH07IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTsgfVxuXG5mdW5jdGlvbiBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IGlmIChpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7IH0gZWxzZSB7IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgdmFyIGEgPSBbbnVsbF07IGEucHVzaC5hcHBseShhLCBhcmdzKTsgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpOyB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTsgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7IHJldHVybiBpbnN0YW5jZTsgfTsgfSByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7IHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCd1dGlsLycpLFxuICAgIGluc3BlY3QgPSBfcmVxdWlyZS5pbnNwZWN0O1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgnLi4vZXJyb3JzJyksXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZTIuY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEU7IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvcmVwZWF0XG5cblxuZnVuY3Rpb24gcmVwZWF0KHN0ciwgY291bnQpIHtcbiAgY291bnQgPSBNYXRoLmZsb29yKGNvdW50KTtcbiAgaWYgKHN0ci5sZW5ndGggPT0gMCB8fCBjb3VudCA9PSAwKSByZXR1cm4gJyc7XG4gIHZhciBtYXhDb3VudCA9IHN0ci5sZW5ndGggKiBjb3VudDtcbiAgY291bnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKGNvdW50KSAvIE1hdGgubG9nKDIpKTtcblxuICB3aGlsZSAoY291bnQpIHtcbiAgICBzdHIgKz0gc3RyO1xuICAgIGNvdW50LS07XG4gIH1cblxuICBzdHIgKz0gc3RyLnN1YnN0cmluZygwLCBtYXhDb3VudCAtIHN0ci5sZW5ndGgpO1xuICByZXR1cm4gc3RyO1xufVxuXG52YXIgYmx1ZSA9ICcnO1xudmFyIGdyZWVuID0gJyc7XG52YXIgcmVkID0gJyc7XG52YXIgd2hpdGUgPSAnJztcbnZhciBrUmVhZGFibGVPcGVyYXRvciA9IHtcbiAgZGVlcFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGRlZXAtZXF1YWw6JyxcbiAgc3RyaWN0RXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgc3RyaWN0bHkgZXF1YWw6JyxcbiAgc3RyaWN0RXF1YWxPYmplY3Q6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIHJlZmVyZW5jZS1lcXVhbCB0byBcImV4cGVjdGVkXCI6JyxcbiAgZGVlcEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIGxvb3NlbHkgZGVlcC1lcXVhbDonLFxuICBlcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGVxdWFsOicsXG4gIG5vdERlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgbm90IHRvIGJlIHN0cmljdGx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90U3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIHN0cmljdGx5IHVuZXF1YWwgdG86JyxcbiAgbm90U3RyaWN0RXF1YWxPYmplY3Q6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSByZWZlcmVuY2UtZXF1YWwgdG8gXCJleHBlY3RlZFwiOicsXG4gIG5vdERlZXBFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgbm90IHRvIGJlIGxvb3NlbHkgZGVlcC1lcXVhbCB0bzonLFxuICBub3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgbG9vc2VseSB1bmVxdWFsIHRvOicsXG4gIG5vdElkZW50aWNhbDogJ1ZhbHVlcyBpZGVudGljYWwgYnV0IG5vdCByZWZlcmVuY2UtZXF1YWw6J1xufTsgLy8gQ29tcGFyaW5nIHNob3J0IHByaW1pdGl2ZXMgc2hvdWxkIGp1c3Qgc2hvdyA9PT0gLyAhPT0gaW5zdGVhZCBvZiB1c2luZyB0aGVcbi8vIGRpZmYuXG5cbnZhciBrTWF4U2hvcnRMZW5ndGggPSAxMDtcblxuZnVuY3Rpb24gY29weUVycm9yKHNvdXJjZSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciB0YXJnZXQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihzb3VyY2UpKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgJ21lc3NhZ2UnLCB7XG4gICAgdmFsdWU6IHNvdXJjZS5tZXNzYWdlXG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0VmFsdWUodmFsKSB7XG4gIC8vIFRoZSB1dGlsLmluc3BlY3QgZGVmYXVsdCB2YWx1ZXMgY291bGQgYmUgY2hhbmdlZC4gVGhpcyBtYWtlcyBzdXJlIHRoZVxuICAvLyBlcnJvciBtZXNzYWdlcyBjb250YWluIHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb24gbmV2ZXJ0aGVsZXNzLlxuICByZXR1cm4gaW5zcGVjdCh2YWwsIHtcbiAgICBjb21wYWN0OiBmYWxzZSxcbiAgICBjdXN0b21JbnNwZWN0OiBmYWxzZSxcbiAgICBkZXB0aDogMTAwMCxcbiAgICBtYXhBcnJheUxlbmd0aDogSW5maW5pdHksXG4gICAgLy8gQXNzZXJ0IGNvbXBhcmVzIG9ubHkgZW51bWVyYWJsZSBwcm9wZXJ0aWVzICh3aXRoIGEgZmV3IGV4Y2VwdGlvbnMpLlxuICAgIHNob3dIaWRkZW46IGZhbHNlLFxuICAgIC8vIEhhdmluZyBhIGxvbmcgbGluZSBhcyBlcnJvciBpcyBiZXR0ZXIgdGhhbiB3cmFwcGluZyB0aGUgbGluZSBmb3JcbiAgICAvLyBjb21wYXJpc29uIGZvciBub3cuXG4gICAgLy8gVE9ETyhCcmlkZ2VBUik6IGBicmVha0xlbmd0aGAgc2hvdWxkIGJlIGxpbWl0ZWQgYXMgc29vbiBhcyBzb29uIGFzIHdlXG4gICAgLy8gaGF2ZSBtZXRhIGluZm9ybWF0aW9uIGFib3V0IHRoZSBpbnNwZWN0ZWQgcHJvcGVydGllcyAoaS5lLiwga25vdyB3aGVyZVxuICAgIC8vIGluIHdoYXQgbGluZSB0aGUgcHJvcGVydHkgc3RhcnRzIGFuZCBlbmRzKS5cbiAgICBicmVha0xlbmd0aDogSW5maW5pdHksXG4gICAgLy8gQXNzZXJ0IGRvZXMgbm90IGRldGVjdCBwcm94aWVzIGN1cnJlbnRseS5cbiAgICBzaG93UHJveHk6IGZhbHNlLFxuICAgIHNvcnRlZDogdHJ1ZSxcbiAgICAvLyBJbnNwZWN0IGdldHRlcnMgYXMgd2UgYWxzbyBjaGVjayB0aGVtIHdoZW4gY29tcGFyaW5nIGVudHJpZXMuXG4gICAgZ2V0dGVyczogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXJyRGlmZihhY3R1YWwsIGV4cGVjdGVkLCBvcGVyYXRvcikge1xuICB2YXIgb3RoZXIgPSAnJztcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgbGFzdFBvcyA9IDA7XG4gIHZhciBlbmQgPSAnJztcbiAgdmFyIHNraXBwZWQgPSBmYWxzZTtcbiAgdmFyIGFjdHVhbEluc3BlY3RlZCA9IGluc3BlY3RWYWx1ZShhY3R1YWwpO1xuICB2YXIgYWN0dWFsTGluZXMgPSBhY3R1YWxJbnNwZWN0ZWQuc3BsaXQoJ1xcbicpO1xuICB2YXIgZXhwZWN0ZWRMaW5lcyA9IGluc3BlY3RWYWx1ZShleHBlY3RlZCkuc3BsaXQoJ1xcbicpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBpbmRpY2F0b3IgPSAnJzsgLy8gSW4gY2FzZSBib3RoIHZhbHVlcyBhcmUgb2JqZWN0cyBleHBsaWNpdGx5IG1hcmsgdGhlbSBhcyBub3QgcmVmZXJlbmNlIGVxdWFsXG4gIC8vIGZvciB0aGUgYHN0cmljdEVxdWFsYCBvcGVyYXRvci5cblxuICBpZiAob3BlcmF0b3IgPT09ICdzdHJpY3RFcXVhbCcgJiYgX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJiBfdHlwZW9mKGV4cGVjdGVkKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsICYmIGV4cGVjdGVkICE9PSBudWxsKSB7XG4gICAgb3BlcmF0b3IgPSAnc3RyaWN0RXF1YWxPYmplY3QnO1xuICB9IC8vIElmIFwiYWN0dWFsXCIgYW5kIFwiZXhwZWN0ZWRcIiBmaXQgb24gYSBzaW5nbGUgbGluZSBhbmQgdGhleSBhcmUgbm90IHN0cmljdGx5XG4gIC8vIGVxdWFsLCBjaGVjayBmdXJ0aGVyIHNwZWNpYWwgaGFuZGxpbmcuXG5cblxuICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoID09PSAxICYmIGV4cGVjdGVkTGluZXMubGVuZ3RoID09PSAxICYmIGFjdHVhbExpbmVzWzBdICE9PSBleHBlY3RlZExpbmVzWzBdKSB7XG4gICAgdmFyIGlucHV0TGVuZ3RoID0gYWN0dWFsTGluZXNbMF0ubGVuZ3RoICsgZXhwZWN0ZWRMaW5lc1swXS5sZW5ndGg7IC8vIElmIHRoZSBjaGFyYWN0ZXIgbGVuZ3RoIG9mIFwiYWN0dWFsXCIgYW5kIFwiZXhwZWN0ZWRcIiB0b2dldGhlciBpcyBsZXNzIHRoYW5cbiAgICAvLyBrTWF4U2hvcnRMZW5ndGggYW5kIGlmIG5laXRoZXIgaXMgYW4gb2JqZWN0IGFuZCBhdCBsZWFzdCBvbmUgb2YgdGhlbSBpc1xuICAgIC8vIG5vdCBgemVyb2AsIHVzZSB0aGUgc3RyaWN0IGVxdWFsIGNvbXBhcmlzb24gdG8gdmlzdWFsaXplIHRoZSBvdXRwdXQuXG5cbiAgICBpZiAoaW5wdXRMZW5ndGggPD0ga01heFNob3J0TGVuZ3RoKSB7XG4gICAgICBpZiAoKF90eXBlb2YoYWN0dWFsKSAhPT0gJ29iamVjdCcgfHwgYWN0dWFsID09PSBudWxsKSAmJiAoX3R5cGVvZihleHBlY3RlZCkgIT09ICdvYmplY3QnIHx8IGV4cGVjdGVkID09PSBudWxsKSAmJiAoYWN0dWFsICE9PSAwIHx8IGV4cGVjdGVkICE9PSAwKSkge1xuICAgICAgICAvLyAtMCA9PT0gKzBcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSwgXCJcXG5cXG5cIikgKyBcIlwiLmNvbmNhdChhY3R1YWxMaW5lc1swXSwgXCIgIT09IFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lc1swXSwgXCJcXG5cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcGVyYXRvciAhPT0gJ3N0cmljdEVxdWFsT2JqZWN0Jykge1xuICAgICAgLy8gSWYgdGhlIHN0ZGVyciBpcyBhIHR0eSBhbmQgdGhlIGlucHV0IGxlbmd0aCBpcyBsb3dlciB0aGFuIHRoZSBjdXJyZW50XG4gICAgICAvLyBjb2x1bW5zIHBlciBsaW5lLCBhZGQgYSBtaXNtYXRjaCBpbmRpY2F0b3IgYmVsb3cgdGhlIG91dHB1dC4gSWYgaXQgaXNcbiAgICAgIC8vIG5vdCBhIHR0eSwgdXNlIGEgZGVmYXVsdCB2YWx1ZSBvZiA4MCBjaGFyYWN0ZXJzLlxuICAgICAgdmFyIG1heExlbmd0aCA9IHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZID8gcHJvY2Vzcy5zdGRlcnIuY29sdW1ucyA6IDgwO1xuXG4gICAgICBpZiAoaW5wdXRMZW5ndGggPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgd2hpbGUgKGFjdHVhbExpbmVzWzBdW2ldID09PSBleHBlY3RlZExpbmVzWzBdW2ldKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9IC8vIElnbm9yZSB0aGUgZmlyc3QgY2hhcmFjdGVycy5cblxuXG4gICAgICAgIGlmIChpID4gMikge1xuICAgICAgICAgIC8vIEFkZCBwb3NpdGlvbiBpbmRpY2F0b3IgZm9yIHRoZSBmaXJzdCBtaXNtYXRjaCBpbiBjYXNlIGl0IGlzIGFcbiAgICAgICAgICAvLyBzaW5nbGUgbGluZSBhbmQgdGhlIGlucHV0IGxlbmd0aCBpcyBsZXNzIHRoYW4gdGhlIGNvbHVtbiBsZW5ndGguXG4gICAgICAgICAgaW5kaWNhdG9yID0gXCJcXG4gIFwiLmNvbmNhdChyZXBlYXQoJyAnLCBpKSwgXCJeXCIpO1xuICAgICAgICAgIGkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJlbW92ZSBhbGwgZW5kaW5nIGxpbmVzIHRoYXQgbWF0Y2ggKHRoaXMgb3B0aW1pemVzIHRoZSBvdXRwdXQgZm9yXG4gIC8vIHJlYWRhYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBudW1iZXIgb2YgdG90YWwgY2hhbmdlZCBsaW5lcykuXG5cblxuICB2YXIgYSA9IGFjdHVhbExpbmVzW2FjdHVhbExpbmVzLmxlbmd0aCAtIDFdO1xuICB2YXIgYiA9IGV4cGVjdGVkTGluZXNbZXhwZWN0ZWRMaW5lcy5sZW5ndGggLSAxXTtcblxuICB3aGlsZSAoYSA9PT0gYikge1xuICAgIGlmIChpKysgPCAyKSB7XG4gICAgICBlbmQgPSBcIlxcbiAgXCIuY29uY2F0KGEpLmNvbmNhdChlbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdGhlciA9IGE7XG4gICAgfVxuXG4gICAgYWN0dWFsTGluZXMucG9wKCk7XG4gICAgZXhwZWN0ZWRMaW5lcy5wb3AoKTtcbiAgICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoID09PSAwIHx8IGV4cGVjdGVkTGluZXMubGVuZ3RoID09PSAwKSBicmVhaztcbiAgICBhID0gYWN0dWFsTGluZXNbYWN0dWFsTGluZXMubGVuZ3RoIC0gMV07XG4gICAgYiA9IGV4cGVjdGVkTGluZXNbZXhwZWN0ZWRMaW5lcy5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIHZhciBtYXhMaW5lcyA9IE1hdGgubWF4KGFjdHVhbExpbmVzLmxlbmd0aCwgZXhwZWN0ZWRMaW5lcy5sZW5ndGgpOyAvLyBTdHJpY3QgZXF1YWwgd2l0aCBpZGVudGljYWwgb2JqZWN0cyB0aGF0IGFyZSBub3QgaWRlbnRpY2FsIGJ5IHJlZmVyZW5jZS5cbiAgLy8gRS5nLiwgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCh7IGE6IFN5bWJvbCgpIH0sIHsgYTogU3ltYm9sKCkgfSlcblxuICBpZiAobWF4TGluZXMgPT09IDApIHtcbiAgICAvLyBXZSBoYXZlIHRvIGdldCB0aGUgcmVzdWx0IGFnYWluLiBUaGUgbGluZXMgd2VyZSBhbGwgcmVtb3ZlZCBiZWZvcmUuXG4gICAgdmFyIF9hY3R1YWxMaW5lcyA9IGFjdHVhbEluc3BlY3RlZC5zcGxpdCgnXFxuJyk7IC8vIE9ubHkgcmVtb3ZlIGxpbmVzIGluIGNhc2UgaXQgbWFrZXMgc2Vuc2UgdG8gY29sbGFwc2UgdGhvc2UuXG4gICAgLy8gVE9ETzogQWNjZXB0IGVudiB0byBhbHdheXMgc2hvdyB0aGUgZnVsbCBlcnJvci5cblxuXG4gICAgaWYgKF9hY3R1YWxMaW5lcy5sZW5ndGggPiAzMCkge1xuICAgICAgX2FjdHVhbExpbmVzWzI2XSA9IFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG5cbiAgICAgIHdoaWxlIChfYWN0dWFsTGluZXMubGVuZ3RoID4gMjcpIHtcbiAgICAgICAgX2FjdHVhbExpbmVzLnBvcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvci5ub3RJZGVudGljYWwsIFwiXFxuXFxuXCIpLmNvbmNhdChfYWN0dWFsTGluZXMuam9pbignXFxuJyksIFwiXFxuXCIpO1xuICB9XG5cbiAgaWYgKGkgPiAzKSB7XG4gICAgZW5kID0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKS5jb25jYXQoZW5kKTtcbiAgICBza2lwcGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChvdGhlciAhPT0gJycpIHtcbiAgICBlbmQgPSBcIlxcbiAgXCIuY29uY2F0KG90aGVyKS5jb25jYXQoZW5kKTtcbiAgICBvdGhlciA9ICcnO1xuICB9XG5cbiAgdmFyIHByaW50ZWRMaW5lcyA9IDA7XG4gIHZhciBtc2cgPSBrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0gKyBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrIGFjdHVhbFwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQocmVkLCBcIi0gZXhwZWN0ZWRcIikuY29uY2F0KHdoaXRlKTtcbiAgdmFyIHNraXBwZWRNc2cgPSBcIiBcIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlLCBcIiBMaW5lcyBza2lwcGVkXCIpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBtYXhMaW5lczsgaSsrKSB7XG4gICAgLy8gT25seSBleHRyYSBleHBlY3RlZCBsaW5lcyBleGlzdFxuICAgIHZhciBjdXIgPSBpIC0gbGFzdFBvcztcblxuICAgIGlmIChhY3R1YWxMaW5lcy5sZW5ndGggPCBpICsgMSkge1xuICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChleHBlY3RlZExpbmVzW2kgLSAyXSk7XG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChleHBlY3RlZExpbmVzW2kgLSAxXSk7XG4gICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgfSAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cblxuXG4gICAgICBsYXN0UG9zID0gaTsgLy8gQWRkIHRoZSBleHBlY3RlZCBsaW5lIHRvIHRoZSBjYWNoZS5cblxuICAgICAgb3RoZXIgKz0gXCJcXG5cIi5jb25jYXQocmVkLCBcIi1cIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkTGluZXNbaV0pO1xuICAgICAgcHJpbnRlZExpbmVzKys7IC8vIE9ubHkgZXh0cmEgYWN0dWFsIGxpbmVzIGV4aXN0XG4gICAgfSBlbHNlIGlmIChleHBlY3RlZExpbmVzLmxlbmd0aCA8IGkgKyAxKSB7XG4gICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgLy8gY3VycmVudCBsaW5lIGlzIGF0IGxlYXN0IGxpbmUgdGhyZWUsIGFkZCBzb21lIG9mIHRoZSBmb3JtZXIgbGluZXMgYW5kXG4gICAgICAvLyBhbHNvIGFkZCBkb3RzIHRvIGluZGljYXRlIHNraXBwZWQgZW50cmllcy5cbiAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgIGlmIChjdXIgPiA0KSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyID4gMykge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAyXSk7XG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMV0pO1xuICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cblxuICAgICAgbGFzdFBvcyA9IGk7IC8vIEFkZCB0aGUgYWN0dWFsIGxpbmUgdG8gdGhlIHJlc3VsdC5cblxuICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIitcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGFjdHVhbExpbmVzW2ldKTtcbiAgICAgIHByaW50ZWRMaW5lcysrOyAvLyBMaW5lcyBkaXZlcmdlXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBleHBlY3RlZExpbmUgPSBleHBlY3RlZExpbmVzW2ldO1xuICAgICAgdmFyIGFjdHVhbExpbmUgPSBhY3R1YWxMaW5lc1tpXTsgLy8gSWYgdGhlIGxpbmVzIGRpdmVyZ2UsIHNwZWNpZmljYWxseSBjaGVjayBmb3IgbGluZXMgdGhhdCBvbmx5IGRpdmVyZ2UgYnlcbiAgICAgIC8vIGEgdHJhaWxpbmcgY29tbWEuIEluIHRoYXQgY2FzZSBpdCBpcyBhY3R1YWxseSBpZGVudGljYWwgYW5kIHdlIHNob3VsZFxuICAgICAgLy8gbWFyayBpdCBhcyBzdWNoLlxuXG4gICAgICB2YXIgZGl2ZXJnaW5nTGluZXMgPSBhY3R1YWxMaW5lICE9PSBleHBlY3RlZExpbmUgJiYgKCFlbmRzV2l0aChhY3R1YWxMaW5lLCAnLCcpIHx8IGFjdHVhbExpbmUuc2xpY2UoMCwgLTEpICE9PSBleHBlY3RlZExpbmUpOyAvLyBJZiB0aGUgZXhwZWN0ZWQgbGluZSBoYXMgYSB0cmFpbGluZyBjb21tYSBidXQgaXMgb3RoZXJ3aXNlIGlkZW50aWNhbCxcbiAgICAgIC8vIGFkZCBhIGNvbW1hIGF0IHRoZSBlbmQgb2YgdGhlIGFjdHVhbCBsaW5lLiBPdGhlcndpc2UgdGhlIG91dHB1dCBjb3VsZFxuICAgICAgLy8gbG9vayB3ZWlyZCBhcyBpbjpcbiAgICAgIC8vXG4gICAgICAvLyAgIFtcbiAgICAgIC8vICAgICAxICAgICAgICAgLy8gTm8gY29tbWEgYXQgdGhlIGVuZCFcbiAgICAgIC8vICsgICAyXG4gICAgICAvLyAgIF1cbiAgICAgIC8vXG5cbiAgICAgIGlmIChkaXZlcmdpbmdMaW5lcyAmJiBlbmRzV2l0aChleHBlY3RlZExpbmUsICcsJykgJiYgZXhwZWN0ZWRMaW5lLnNsaWNlKDAsIC0xKSA9PT0gYWN0dWFsTGluZSkge1xuICAgICAgICBkaXZlcmdpbmdMaW5lcyA9IGZhbHNlO1xuICAgICAgICBhY3R1YWxMaW5lICs9ICcsJztcbiAgICAgIH1cblxuICAgICAgaWYgKGRpdmVyZ2luZ0xpbmVzKSB7XG4gICAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgICAvLyBhbHNvIGFkZCBkb3RzIHRvIGluZGljYXRlIHNraXBwZWQgZW50cmllcy5cbiAgICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAyXSk7XG4gICAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMV0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG5cbiAgICAgICAgbGFzdFBvcyA9IGk7IC8vIEFkZCB0aGUgYWN0dWFsIGxpbmUgdG8gdGhlIHJlc3VsdCBhbmQgY2FjaGUgdGhlIGV4cGVjdGVkIGRpdmVyZ2luZ1xuICAgICAgICAvLyBsaW5lIHNvIGNvbnNlY3V0aXZlIGRpdmVyZ2luZyBsaW5lcyBzaG93IHVwIGFzICsrKy0tLSBhbmQgbm90ICstKy0rLS5cblxuICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiK1wiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoYWN0dWFsTGluZSk7XG4gICAgICAgIG90aGVyICs9IFwiXFxuXCIuY29uY2F0KHJlZCwgXCItXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChleHBlY3RlZExpbmUpO1xuICAgICAgICBwcmludGVkTGluZXMgKz0gMjsgLy8gTGluZXMgYXJlIGlkZW50aWNhbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWRkIGFsbCBjYWNoZWQgaW5mb3JtYXRpb24gdG8gdGhlIHJlc3VsdCBiZWZvcmUgYWRkaW5nIG90aGVyIHRoaW5nc1xuICAgICAgICAvLyBhbmQgcmVzZXQgdGhlIGNhY2hlLlxuICAgICAgICByZXMgKz0gb3RoZXI7XG4gICAgICAgIG90aGVyID0gJyc7IC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIGV4YWN0bHkgb25lIGxpbmUgYWJvdmUgb3IgaWYgaXQgaXMgdGhlXG4gICAgICAgIC8vIHZlcnkgZmlyc3QgbGluZSwgYWRkIHRoZSBsaW5lIHRvIHRoZSByZXN1bHQuXG5cbiAgICAgICAgaWYgKGN1ciA9PT0gMSB8fCBpID09PSAwKSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZSk7XG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEluc3BlY3RlZCBvYmplY3QgdG8gYmlnIChTaG93IH4yMCByb3dzIG1heClcblxuXG4gICAgaWYgKHByaW50ZWRMaW5lcyA+IDIwICYmIGkgPCBtYXhMaW5lcyAtIDIpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChtc2cpLmNvbmNhdChza2lwcGVkTXNnLCBcIlxcblwiKS5jb25jYXQocmVzLCBcIlxcblwiKS5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKS5jb25jYXQob3RoZXIsIFwiXFxuXCIpICsgXCJcIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gXCJcIi5jb25jYXQobXNnKS5jb25jYXQoc2tpcHBlZCA/IHNraXBwZWRNc2cgOiAnJywgXCJcXG5cIikuY29uY2F0KHJlcykuY29uY2F0KG90aGVyKS5jb25jYXQoZW5kKS5jb25jYXQoaW5kaWNhdG9yKTtcbn1cblxudmFyIEFzc2VydGlvbkVycm9yID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKEFzc2VydGlvbkVycm9yLCBfRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXNzZXJ0aW9uRXJyb3IpO1xuXG4gICAgaWYgKF90eXBlb2Yob3B0aW9ucykgIT09ICdvYmplY3QnIHx8IG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnb3B0aW9ucycsICdPYmplY3QnLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgbWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSxcbiAgICAgICAgb3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yLFxuICAgICAgICBzdGFja1N0YXJ0Rm4gPSBvcHRpb25zLnN0YWNrU3RhcnRGbjtcbiAgICB2YXIgYWN0dWFsID0gb3B0aW9ucy5hY3R1YWwsXG4gICAgICAgIGV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgICB2YXIgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMDtcblxuICAgIGlmIChtZXNzYWdlICE9IG51bGwpIHtcbiAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFN0cmluZyhtZXNzYWdlKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5zdGRlcnIgJiYgcHJvY2Vzcy5zdGRlcnIuaXNUVFkpIHtcbiAgICAgICAgLy8gUmVzZXQgb24gZWFjaCBjYWxsIHRvIG1ha2Ugc3VyZSB3ZSBoYW5kbGUgZHluYW1pY2FsbHkgc2V0IGVudmlyb25tZW50XG4gICAgICAgIC8vIHZhcmlhYmxlcyBjb3JyZWN0LlxuICAgICAgICBpZiAocHJvY2Vzcy5zdGRlcnIgJiYgcHJvY2Vzcy5zdGRlcnIuZ2V0Q29sb3JEZXB0aCAmJiBwcm9jZXNzLnN0ZGVyci5nZXRDb2xvckRlcHRoKCkgIT09IDEpIHtcbiAgICAgICAgICBibHVlID0gXCJcXHgxQlszNG1cIjtcbiAgICAgICAgICBncmVlbiA9IFwiXFx4MUJbMzJtXCI7XG4gICAgICAgICAgd2hpdGUgPSBcIlxceDFCWzM5bVwiO1xuICAgICAgICAgIHJlZCA9IFwiXFx4MUJbMzFtXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmx1ZSA9ICcnO1xuICAgICAgICAgIGdyZWVuID0gJyc7XG4gICAgICAgICAgd2hpdGUgPSAnJztcbiAgICAgICAgICByZWQgPSAnJztcbiAgICAgICAgfVxuICAgICAgfSAvLyBQcmV2ZW50IHRoZSBlcnJvciBzdGFjayBmcm9tIGJlaW5nIHZpc2libGUgYnkgZHVwbGljYXRpbmcgdGhlIGVycm9yXG4gICAgICAvLyBpbiBhIHZlcnkgY2xvc2Ugd2F5IHRvIHRoZSBvcmlnaW5hbCBpbiBjYXNlIGJvdGggc2lkZXMgYXJlIGFjdHVhbGx5XG4gICAgICAvLyBpbnN0YW5jZXMgb2YgRXJyb3IuXG5cblxuICAgICAgaWYgKF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsICYmIF90eXBlb2YoZXhwZWN0ZWQpID09PSAnb2JqZWN0JyAmJiBleHBlY3RlZCAhPT0gbnVsbCAmJiAnc3RhY2snIGluIGFjdHVhbCAmJiBhY3R1YWwgaW5zdGFuY2VvZiBFcnJvciAmJiAnc3RhY2snIGluIGV4cGVjdGVkICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgYWN0dWFsID0gY29weUVycm9yKGFjdHVhbCk7XG4gICAgICAgIGV4cGVjdGVkID0gY29weUVycm9yKGV4cGVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wZXJhdG9yID09PSAnZGVlcFN0cmljdEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ3N0cmljdEVxdWFsJykge1xuICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBjcmVhdGVFcnJEaWZmKGFjdHVhbCwgZXhwZWN0ZWQsIG9wZXJhdG9yKSkpO1xuICAgICAgfSBlbHNlIGlmIChvcGVyYXRvciA9PT0gJ25vdERlZXBTdHJpY3RFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdub3RTdHJpY3RFcXVhbCcpIHtcbiAgICAgICAgLy8gSW4gY2FzZSB0aGUgb2JqZWN0cyBhcmUgZXF1YWwgYnV0IHRoZSBvcGVyYXRvciByZXF1aXJlcyB1bmVxdWFsLCBzaG93XG4gICAgICAgIC8vIHRoZSBmaXJzdCBvYmplY3QgYW5kIHNheSBBIGVxdWFscyBCXG4gICAgICAgIHZhciBiYXNlID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdO1xuICAgICAgICB2YXIgcmVzID0gaW5zcGVjdFZhbHVlKGFjdHVhbCkuc3BsaXQoJ1xcbicpOyAvLyBJbiBjYXNlIFwiYWN0dWFsXCIgaXMgYW4gb2JqZWN0LCBpdCBzaG91bGQgbm90IGJlIHJlZmVyZW5jZSBlcXVhbC5cblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdub3RTdHJpY3RFcXVhbCcgJiYgX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwpIHtcbiAgICAgICAgICBiYXNlID0ga1JlYWRhYmxlT3BlcmF0b3Iubm90U3RyaWN0RXF1YWxPYmplY3Q7XG4gICAgICAgIH0gLy8gT25seSByZW1vdmUgbGluZXMgaW4gY2FzZSBpdCBtYWtlcyBzZW5zZSB0byBjb2xsYXBzZSB0aG9zZS5cbiAgICAgICAgLy8gVE9ETzogQWNjZXB0IGVudiB0byBhbHdheXMgc2hvdyB0aGUgZnVsbCBlcnJvci5cblxuXG4gICAgICAgIGlmIChyZXMubGVuZ3RoID4gMzApIHtcbiAgICAgICAgICByZXNbMjZdID0gXCJcIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcblxuICAgICAgICAgIHdoaWxlIChyZXMubGVuZ3RoID4gMjcpIHtcbiAgICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gT25seSBwcmludCBhIHNpbmdsZSBpbnB1dC5cblxuXG4gICAgICAgIGlmIChyZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoYmFzZSwgXCIgXCIpLmNvbmNhdChyZXNbMF0pKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoYmFzZSwgXCJcXG5cXG5cIikuY29uY2F0KHJlcy5qb2luKCdcXG4nKSwgXCJcXG5cIikpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9yZXMgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKTtcblxuICAgICAgICB2YXIgb3RoZXIgPSAnJztcbiAgICAgICAgdmFyIGtub3duT3BlcmF0b3JzID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdO1xuXG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ25vdERlZXBFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdub3RFcXVhbCcpIHtcbiAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdLCBcIlxcblxcblwiKS5jb25jYXQoX3Jlcyk7XG5cbiAgICAgICAgICBpZiAoX3Jlcy5sZW5ndGggPiAxMDI0KSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoX3Jlcy5zbGljZSgwLCAxMDIxKSwgXCIuLi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG90aGVyID0gXCJcIi5jb25jYXQoaW5zcGVjdFZhbHVlKGV4cGVjdGVkKSk7XG5cbiAgICAgICAgICBpZiAoX3Jlcy5sZW5ndGggPiA1MTIpIHtcbiAgICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChfcmVzLnNsaWNlKDAsIDUwOSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvdGhlci5sZW5ndGggPiA1MTIpIHtcbiAgICAgICAgICAgIG90aGVyID0gXCJcIi5jb25jYXQob3RoZXIuc2xpY2UoMCwgNTA5KSwgXCIuLi5cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnZGVlcEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ2VxdWFsJykge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KGtub3duT3BlcmF0b3JzLCBcIlxcblxcblwiKS5jb25jYXQoX3JlcywgXCJcXG5cXG5zaG91bGQgZXF1YWxcXG5cXG5cIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG90aGVyID0gXCIgXCIuY29uY2F0KG9wZXJhdG9yLCBcIiBcIikuY29uY2F0KG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBcIlwiLmNvbmNhdChfcmVzKS5jb25jYXQob3RoZXIpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gbGltaXQ7XG4gICAgX3RoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9ICFtZXNzYWdlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgJ25hbWUnLCB7XG4gICAgICB2YWx1ZTogJ0Fzc2VydGlvbkVycm9yIFtFUlJfQVNTRVJUSU9OXScsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgX3RoaXMuY29kZSA9ICdFUlJfQVNTRVJUSU9OJztcbiAgICBfdGhpcy5hY3R1YWwgPSBhY3R1YWw7XG4gICAgX3RoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICBfdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuXG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBzdGFja1N0YXJ0Rm4pO1xuICAgIH0gLy8gQ3JlYXRlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlIGluIHRoZSBuYW1lLlxuXG5cbiAgICBfdGhpcy5zdGFjazsgLy8gUmVzZXQgdGhlIG5hbWUuXG5cbiAgICBfdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFzc2VydGlvbkVycm9yLCBbe1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiIFtcIikuY29uY2F0KHRoaXMuY29kZSwgXCJdOiBcIikuY29uY2F0KHRoaXMubWVzc2FnZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBpbnNwZWN0LmN1c3RvbSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocmVjdXJzZVRpbWVzLCBjdHgpIHtcbiAgICAgIC8vIFRoaXMgbGltaXRzIHRoZSBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYCBwcm9wZXJ0eSBkZWZhdWx0IGluc3BlY3Rpb24gdG9cbiAgICAgIC8vIHRoZSBtaW5pbXVtIGRlcHRoLiBPdGhlcndpc2UgdGhvc2UgdmFsdWVzIHdvdWxkIGJlIHRvbyB2ZXJib3NlIGNvbXBhcmVkXG4gICAgICAvLyB0byB0aGUgYWN0dWFsIGVycm9yIG1lc3NhZ2Ugd2hpY2ggY29udGFpbnMgYSBjb21iaW5lZCB2aWV3IG9mIHRoZXNlIHR3b1xuICAgICAgLy8gaW5wdXQgdmFsdWVzLlxuICAgICAgcmV0dXJuIGluc3BlY3QodGhpcywgX29iamVjdFNwcmVhZCh7fSwgY3R4LCB7XG4gICAgICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlLFxuICAgICAgICBkZXB0aDogMFxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBc3NlcnRpb25FcnJvcjtcbn0oX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFzc2VydGlvbkVycm9yOyIsIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvZXJyb3JzLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzNiMDQ0OTYyYzQ4ZmUzMTM5MDU4NzdhOTZiNWQwODk0YTU0MDRmNmZcblxuLyogZXNsaW50IG5vZGUtY29yZS9kb2N1bWVudGVkLWVycm9yczogXCJlcnJvclwiICovXG5cbi8qIGVzbGludCBub2RlLWNvcmUvYWxwaGFiZXRpemUtZXJyb3JzOiBcImVycm9yXCIgKi9cblxuLyogZXNsaW50IG5vZGUtY29yZS9wcmVmZXItdXRpbC1mb3JtYXQtZXJyb3JzOiBcImVycm9yXCIgKi9cbid1c2Ugc3RyaWN0JzsgLy8gVGhlIHdob2xlIHBvaW50IGJlaGluZCB0aGlzIGludGVybmFsIG1vZHVsZSBpcyB0byBhbGxvdyBOb2RlLmpzIHRvIG5vXG4vLyBsb25nZXIgYmUgZm9yY2VkIHRvIHRyZWF0IGV2ZXJ5IGVycm9yIG1lc3NhZ2UgY2hhbmdlIGFzIGEgc2VtdmVyLW1ham9yXG4vLyBjaGFuZ2UuIFRoZSBOb2RlRXJyb3IgY2xhc3NlcyBoZXJlIGFsbCBleHBvc2UgYSBgY29kZWAgcHJvcGVydHkgd2hvc2Vcbi8vIHZhbHVlIHN0YXRpY2FsbHkgYW5kIHBlcm1hbmVudGx5IGlkZW50aWZpZXMgdGhlIGVycm9yLiBXaGlsZSB0aGUgZXJyb3Jcbi8vIG1lc3NhZ2UgbWF5IGNoYW5nZSwgdGhlIGNvZGUgc2hvdWxkIG5vdC5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgY29kZXMgPSB7fTsgLy8gTGF6eSBsb2FkZWRcblxudmFyIGFzc2VydDtcbnZhciB1dGlsO1xuXG5mdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoY29kZSwgbWVzc2FnZSwgQmFzZSkge1xuICBpZiAoIUJhc2UpIHtcbiAgICBCYXNlID0gRXJyb3I7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIE5vZGVFcnJvciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9CYXNlKSB7XG4gICAgX2luaGVyaXRzKE5vZGVFcnJvciwgX0Jhc2UpO1xuXG4gICAgZnVuY3Rpb24gTm9kZUVycm9yKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVFcnJvcik7XG5cbiAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE5vZGVFcnJvcikuY2FsbCh0aGlzLCBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpKSk7XG4gICAgICBfdGhpcy5jb2RlID0gY29kZTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gTm9kZUVycm9yO1xuICB9KEJhc2UpO1xuXG4gIGNvZGVzW2NvZGVdID0gTm9kZUVycm9yO1xufSAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTAuOC4wL2xpYi9pbnRlcm5hbC9lcnJvcnMuanNcblxuXG5mdW5jdGlvbiBvbmVPZihleHBlY3RlZCwgdGhpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XG4gICAgdmFyIGxlbiA9IGV4cGVjdGVkLmxlbmd0aDtcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpKTtcbiAgICB9KTtcblxuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyksIFwiLCBvciBcIikgKyBleHBlY3RlZFtsZW4gLSAxXTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSwgXCIgb3IgXCIpLmNvbmNhdChleHBlY3RlZFsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChTdHJpbmcoZXhwZWN0ZWQpKTtcbiAgfVxufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aFxuXG5cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBzZWFyY2gsIHBvcykge1xuICByZXR1cm4gc3RyLnN1YnN0cighcG9zIHx8IHBvcyA8IDAgPyAwIDogK3Bvcywgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXG5cblxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XG4gIGlmICh0aGlzX2xlbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXNfbGVuID4gc3RyLmxlbmd0aCkge1xuICAgIHRoaXNfbGVuID0gc3RyLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9pbmNsdWRlc1xuXG5cbmZ1bmN0aW9uIGluY2x1ZGVzKHN0ciwgc2VhcmNoLCBzdGFydCkge1xuICBpZiAodHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJykge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuXG4gIGlmIChzdGFydCArIHNlYXJjaC5sZW5ndGggPiBzdHIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihzZWFyY2gsIHN0YXJ0KSAhPT0gLTE7XG4gIH1cbn1cblxuY3JlYXRlRXJyb3JUeXBlKCdFUlJfQU1CSUdVT1VTX0FSR1VNRU5UJywgJ1RoZSBcIiVzXCIgYXJndW1lbnQgaXMgYW1iaWd1b3VzLiAlcycsIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJywgZnVuY3Rpb24gKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgaWYgKGFzc2VydCA9PT0gdW5kZWZpbmVkKSBhc3NlcnQgPSByZXF1aXJlKCcuLi9hc3NlcnQnKTtcbiAgYXNzZXJ0KHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgXCInbmFtZScgbXVzdCBiZSBhIHN0cmluZ1wiKTsgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcblxuICB2YXIgZGV0ZXJtaW5lcjtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiBzdGFydHNXaXRoKGV4cGVjdGVkLCAnbm90ICcpKSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcbiAgfSBlbHNlIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xuICB9XG5cbiAgdmFyIG1zZztcblxuICBpZiAoZW5kc1dpdGgobmFtZSwgJyBhcmd1bWVudCcpKSB7XG4gICAgLy8gRm9yIGNhc2VzIGxpa2UgJ2ZpcnN0IGFyZ3VtZW50J1xuICAgIG1zZyA9IFwiVGhlIFwiLmNvbmNhdChuYW1lLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0eXBlID0gaW5jbHVkZXMobmFtZSwgJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuICAgIG1zZyA9IFwiVGhlIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIFwiKS5jb25jYXQodHlwZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSAvLyBUT0RPKEJyaWRnZUFSKTogSW1wcm92ZSB0aGUgb3V0cHV0IGJ5IHNob3dpbmcgYG51bGxgIGFuZCBzaW1pbGFyLlxuXG5cbiAgbXNnICs9IFwiLiBSZWNlaXZlZCB0eXBlIFwiLmNvbmNhdChfdHlwZW9mKGFjdHVhbCkpO1xuICByZXR1cm4gbXNnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHZhciByZWFzb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdpcyBpbnZhbGlkJztcbiAgaWYgKHV0aWwgPT09IHVuZGVmaW5lZCkgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG4gIHZhciBpbnNwZWN0ZWQgPSB1dGlsLmluc3BlY3QodmFsdWUpO1xuXG4gIGlmIChpbnNwZWN0ZWQubGVuZ3RoID4gMTI4KSB7XG4gICAgaW5zcGVjdGVkID0gXCJcIi5jb25jYXQoaW5zcGVjdGVkLnNsaWNlKDAsIDEyOCksIFwiLi4uXCIpO1xuICB9XG5cbiAgcmV0dXJuIFwiVGhlIGFyZ3VtZW50ICdcIi5jb25jYXQobmFtZSwgXCInIFwiKS5jb25jYXQocmVhc29uLCBcIi4gUmVjZWl2ZWQgXCIpLmNvbmNhdChpbnNwZWN0ZWQpO1xufSwgVHlwZUVycm9yLCBSYW5nZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFJywgZnVuY3Rpb24gKGlucHV0LCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgdHlwZTtcblxuICBpZiAodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgIHR5cGUgPSBcImluc3RhbmNlIG9mIFwiLmNvbmNhdCh2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gXCJ0eXBlIFwiLmNvbmNhdChfdHlwZW9mKHZhbHVlKSk7XG4gIH1cblxuICByZXR1cm4gXCJFeHBlY3RlZCBcIi5jb25jYXQoaW5wdXQsIFwiIHRvIGJlIHJldHVybmVkIGZyb20gdGhlIFxcXCJcIikuY29uY2F0KG5hbWUsIFwiXFxcIlwiKSArIFwiIGZ1bmN0aW9uIGJ1dCBnb3QgXCIuY29uY2F0KHR5cGUsIFwiLlwiKTtcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NSVNTSU5HX0FSR1MnLCBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoYXNzZXJ0ID09PSB1bmRlZmluZWQpIGFzc2VydCA9IHJlcXVpcmUoJy4uL2Fzc2VydCcpO1xuICBhc3NlcnQoYXJncy5sZW5ndGggPiAwLCAnQXQgbGVhc3Qgb25lIGFyZyBuZWVkcyB0byBiZSBzcGVjaWZpZWQnKTtcbiAgdmFyIG1zZyA9ICdUaGUgJztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICBhcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gXCJcXFwiXCIuY29uY2F0KGEsIFwiXFxcIlwiKTtcbiAgfSk7XG5cbiAgc3dpdGNoIChsZW4pIHtcbiAgICBjYXNlIDE6XG4gICAgICBtc2cgKz0gXCJcIi5jb25jYXQoYXJnc1swXSwgXCIgYXJndW1lbnRcIik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMjpcbiAgICAgIG1zZyArPSBcIlwiLmNvbmNhdChhcmdzWzBdLCBcIiBhbmQgXCIpLmNvbmNhdChhcmdzWzFdLCBcIiBhcmd1bWVudHNcIik7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBtc2cgKz0gYXJncy5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpO1xuICAgICAgbXNnICs9IFwiLCBhbmQgXCIuY29uY2F0KGFyZ3NbbGVuIC0gMV0sIFwiIGFyZ3VtZW50c1wiKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZywgXCIgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG59LCBUeXBlRXJyb3IpO1xubW9kdWxlLmV4cG9ydHMuY29kZXMgPSBjb2RlczsiLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIHJlZ2V4RmxhZ3NTdXBwb3J0ZWQgPSAvYS9nLmZsYWdzICE9PSB1bmRlZmluZWQ7XG5cbnZhciBhcnJheUZyb21TZXQgPSBmdW5jdGlvbiBhcnJheUZyb21TZXQoc2V0KSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gYXJyYXkucHVzaCh2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgYXJyYXlGcm9tTWFwID0gZnVuY3Rpb24gYXJyYXlGcm9tTWFwKG1hcCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gYXJyYXkucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9KTtcbiAgcmV0dXJuIGFycmF5O1xufTtcblxudmFyIG9iamVjdElzID0gT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogcmVxdWlyZSgnb2JqZWN0LWlzJyk7XG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbXTtcbn07XG52YXIgbnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gPyBOdW1iZXIuaXNOYU4gOiByZXF1aXJlKCdpcy1uYW4nKTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSk7XG52YXIgb2JqZWN0VG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxudmFyIF9yZXF1aXJlJHR5cGVzID0gcmVxdWlyZSgndXRpbC8nKS50eXBlcyxcbiAgICBpc0FueUFycmF5QnVmZmVyID0gX3JlcXVpcmUkdHlwZXMuaXNBbnlBcnJheUJ1ZmZlcixcbiAgICBpc0FycmF5QnVmZmVyVmlldyA9IF9yZXF1aXJlJHR5cGVzLmlzQXJyYXlCdWZmZXJWaWV3LFxuICAgIGlzRGF0ZSA9IF9yZXF1aXJlJHR5cGVzLmlzRGF0ZSxcbiAgICBpc01hcCA9IF9yZXF1aXJlJHR5cGVzLmlzTWFwLFxuICAgIGlzUmVnRXhwID0gX3JlcXVpcmUkdHlwZXMuaXNSZWdFeHAsXG4gICAgaXNTZXQgPSBfcmVxdWlyZSR0eXBlcy5pc1NldCxcbiAgICBpc05hdGl2ZUVycm9yID0gX3JlcXVpcmUkdHlwZXMuaXNOYXRpdmVFcnJvcixcbiAgICBpc0JveGVkUHJpbWl0aXZlID0gX3JlcXVpcmUkdHlwZXMuaXNCb3hlZFByaW1pdGl2ZSxcbiAgICBpc051bWJlck9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzTnVtYmVyT2JqZWN0LFxuICAgIGlzU3RyaW5nT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNTdHJpbmdPYmplY3QsXG4gICAgaXNCb29sZWFuT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNCb29sZWFuT2JqZWN0LFxuICAgIGlzQmlnSW50T2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNCaWdJbnRPYmplY3QsXG4gICAgaXNTeW1ib2xPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc1N5bWJvbE9iamVjdCxcbiAgICBpc0Zsb2F0MzJBcnJheSA9IF9yZXF1aXJlJHR5cGVzLmlzRmxvYXQzMkFycmF5LFxuICAgIGlzRmxvYXQ2NEFycmF5ID0gX3JlcXVpcmUkdHlwZXMuaXNGbG9hdDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzTm9uSW5kZXgoa2V5KSB7XG4gIGlmIChrZXkubGVuZ3RoID09PSAwIHx8IGtleS5sZW5ndGggPiAxMCkgcmV0dXJuIHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29kZSA9IGtleS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IDU3KSByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBUaGUgbWF4aW11bSBzaXplIGZvciBhbiBhcnJheSBpcyAyICoqIDMyIC0xLlxuXG5cbiAgcmV0dXJuIGtleS5sZW5ndGggPT09IDEwICYmIGtleSA+PSBNYXRoLnBvdygyLCAzMik7XG59XG5cbmZ1bmN0aW9uIGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihpc05vbkluZGV4KS5jb25jYXQob2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbHVlKS5maWx0ZXIoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5iaW5kKHZhbHVlKSkpO1xufSAvLyBUYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2Jsb2IvNjgwZTllNWU0ODhmMjJhYWMyNzU5OWE1N2RjODQ0YTYzMTU5MjhkZC9pbmRleC5qc1xuLy8gb3JpZ2luYWwgbm90aWNlOlxuXG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cblxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBpZiAoeSA8IHgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG52YXIgT05MWV9FTlVNRVJBQkxFID0gdW5kZWZpbmVkO1xudmFyIGtTdHJpY3QgPSB0cnVlO1xudmFyIGtMb29zZSA9IGZhbHNlO1xudmFyIGtOb0l0ZXJhdG9yID0gMDtcbnZhciBrSXNBcnJheSA9IDE7XG52YXIga0lzU2V0ID0gMjtcbnZhciBrSXNNYXAgPSAzOyAvLyBDaGVjayBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgc291cmNlIGFuZCBmbGFnc1xuXG5mdW5jdGlvbiBhcmVTaW1pbGFyUmVnRXhwcyhhLCBiKSB7XG4gIHJldHVybiByZWdleEZsYWdzU3VwcG9ydGVkID8gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3MgOiBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSkgPT09IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKTtcbn1cblxuZnVuY3Rpb24gYXJlU2ltaWxhckZsb2F0QXJyYXlzKGEsIGIpIHtcbiAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYS5ieXRlTGVuZ3RoOyBvZmZzZXQrKykge1xuICAgIGlmIChhW29mZnNldF0gIT09IGJbb2Zmc2V0XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBhcmVTaW1pbGFyVHlwZWRBcnJheXMoYSwgYikge1xuICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gY29tcGFyZShuZXcgVWludDhBcnJheShhLmJ1ZmZlciwgYS5ieXRlT2Zmc2V0LCBhLmJ5dGVMZW5ndGgpLCBuZXcgVWludDhBcnJheShiLmJ1ZmZlciwgYi5ieXRlT2Zmc2V0LCBiLmJ5dGVMZW5ndGgpKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gYXJlRXF1YWxBcnJheUJ1ZmZlcnMoYnVmMSwgYnVmMikge1xuICByZXR1cm4gYnVmMS5ieXRlTGVuZ3RoID09PSBidWYyLmJ5dGVMZW5ndGggJiYgY29tcGFyZShuZXcgVWludDhBcnJheShidWYxKSwgbmV3IFVpbnQ4QXJyYXkoYnVmMikpID09PSAwO1xufVxuXG5mdW5jdGlvbiBpc0VxdWFsQm94ZWRQcmltaXRpdmUodmFsMSwgdmFsMikge1xuICBpZiAoaXNOdW1iZXJPYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNOdW1iZXJPYmplY3QodmFsMikgJiYgb2JqZWN0SXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSksIE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpKTtcbiAgfVxuXG4gIGlmIChpc1N0cmluZ09iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc1N0cmluZ09iamVjdCh2YWwyKSAmJiBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG4gIH1cblxuICBpZiAoaXNCb29sZWFuT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzQm9vbGVhbk9iamVjdCh2YWwyKSAmJiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0ludE9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc0JpZ0ludE9iamVjdCh2YWwyKSAmJiBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG4gIH1cblxuICByZXR1cm4gaXNTeW1ib2xPYmplY3QodmFsMikgJiYgU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xufSAvLyBOb3RlczogVHlwZSB0YWdzIGFyZSBoaXN0b3JpY2FsIFtbQ2xhc3NdXSBwcm9wZXJ0aWVzIHRoYXQgY2FuIGJlIHNldCBieVxuLy8gRnVuY3Rpb25UZW1wbGF0ZTo6U2V0Q2xhc3NOYW1lKCkgaW4gQysrIG9yIFN5bWJvbC50b1N0cmluZ1RhZyBpbiBKU1xuLy8gYW5kIHJldHJpZXZlZCB1c2luZyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSBpbiBKU1xuLy8gU2VlIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcbi8vIGZvciBhIGxpc3Qgb2YgdGFncyBwcmUtZGVmaW5lZCBpbiB0aGUgc3BlYy5cbi8vIFRoZXJlIGFyZSBzb21lIHVuc3BlY2lmaWVkIHRhZ3MgaW4gdGhlIHdpbGQgdG9vIChlLmcuIHR5cGVkIGFycmF5IHRhZ3MpLlxuLy8gU2luY2UgdGFncyBjYW4gYmUgYWx0ZXJlZCwgdGhleSBvbmx5IHNlcnZlIGZhc3QgZmFpbHVyZXNcbi8vXG4vLyBUeXBlZCBhcnJheXMgYW5kIGJ1ZmZlcnMgYXJlIGNoZWNrZWQgYnkgY29tcGFyaW5nIHRoZSBjb250ZW50IGluIHRoZWlyXG4vLyB1bmRlcmx5aW5nIEFycmF5QnVmZmVyLiBUaGlzIG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGF0IGl0J3Ncbi8vIHJlYXNvbmFibGUgdG8gaW50ZXJwcmV0IHRoZWlyIHVuZGVybHlpbmcgbWVtb3J5IGluIHRoZSBzYW1lIHdheSxcbi8vIHdoaWNoIGlzIGNoZWNrZWQgYnkgY29tcGFyaW5nIHRoZWlyIHR5cGUgdGFncy5cbi8vIChlLmcuIGEgVWludDhBcnJheSBhbmQgYSBVaW50MTZBcnJheSB3aXRoIHRoZSBzYW1lIG1lbW9yeSBjb250ZW50XG4vLyBjb3VsZCBzdGlsbCBiZSBkaWZmZXJlbnQgYmVjYXVzZSB0aGV5IHdpbGwgYmUgaW50ZXJwcmV0ZWQgZGlmZmVyZW50bHkpLlxuLy9cbi8vIEZvciBzdHJpY3QgY29tcGFyaXNvbiwgb2JqZWN0cyBzaG91bGQgaGF2ZVxuLy8gYSkgVGhlIHNhbWUgYnVpbHQtaW4gdHlwZSB0YWdzXG4vLyBiKSBUaGUgc2FtZSBwcm90b3R5cGVzLlxuXG5cbmZ1bmN0aW9uIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MpIHtcbiAgLy8gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAodmFsMSA9PT0gdmFsMikge1xuICAgIGlmICh2YWwxICE9PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gc3RyaWN0ID8gb2JqZWN0SXModmFsMSwgdmFsMikgOiB0cnVlO1xuICB9IC8vIENoZWNrIG1vcmUgY2xvc2VseSBpZiB2YWwxIGFuZCB2YWwyIGFyZSBlcXVhbC5cblxuXG4gIGlmIChzdHJpY3QpIHtcbiAgICBpZiAoX3R5cGVvZih2YWwxKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsMSA9PT0gJ251bWJlcicgJiYgbnVtYmVySXNOYU4odmFsMSkgJiYgbnVtYmVySXNOYU4odmFsMik7XG4gICAgfVxuXG4gICAgaWYgKF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnIHx8IHZhbDEgPT09IG51bGwgfHwgdmFsMiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsMSkgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsMSA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDEpICE9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHZhbDIgPT09IG51bGwgfHwgX3R5cGVvZih2YWwyKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICByZXR1cm4gdmFsMSA9PSB2YWwyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHZhbDIgPT09IG51bGwgfHwgX3R5cGVvZih2YWwyKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB2YXIgdmFsMVRhZyA9IG9iamVjdFRvU3RyaW5nKHZhbDEpO1xuICB2YXIgdmFsMlRhZyA9IG9iamVjdFRvU3RyaW5nKHZhbDIpO1xuXG4gIGlmICh2YWwxVGFnICE9PSB2YWwyVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsMSkpIHtcbiAgICAvLyBDaGVjayBmb3Igc3BhcnNlIGFycmF5cyBhbmQgZ2VuZXJhbCBmYXN0IHBhdGhcbiAgICBpZiAodmFsMS5sZW5ndGggIT09IHZhbDIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGtleXMxID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDEsIE9OTFlfRU5VTUVSQUJMRSk7XG4gICAgdmFyIGtleXMyID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDIsIE9OTFlfRU5VTUVSQUJMRSk7XG5cbiAgICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga0lzQXJyYXksIGtleXMxKTtcbiAgfSAvLyBbYnJvd3NlcmlmeV0gVGhpcyB0cmlnZ2VycyBvbiBjZXJ0YWluIHR5cGVzIGluIElFIChNYXAvU2V0KSBzbyB3ZSBkb24ndFxuICAvLyB3YW4ndCB0byBlYXJseSByZXR1cm4gb3V0IG9mIHRoZSByZXN0IG9mIHRoZSBjaGVja3MuIEhvd2V2ZXIgd2UgY2FuIGNoZWNrXG4gIC8vIGlmIHRoZSBzZWNvbmQgdmFsdWUgaXMgb25lIG9mIHRoZXNlIHZhbHVlcyBhbmQgdGhlIGZpcnN0IGlzbid0LlxuXG5cbiAgaWYgKHZhbDFUYWcgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgLy8gcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yKTtcbiAgICBpZiAoIWlzTWFwKHZhbDEpICYmIGlzTWFwKHZhbDIpIHx8ICFpc1NldCh2YWwxKSAmJiBpc1NldCh2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0RhdGUodmFsMSkpIHtcbiAgICBpZiAoIWlzRGF0ZSh2YWwyKSB8fCBEYXRlLnByb3RvdHlwZS5nZXRUaW1lLmNhbGwodmFsMSkgIT09IERhdGUucHJvdG90eXBlLmdldFRpbWUuY2FsbCh2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1JlZ0V4cCh2YWwxKSkge1xuICAgIGlmICghaXNSZWdFeHAodmFsMikgfHwgIWFyZVNpbWlsYXJSZWdFeHBzKHZhbDEsIHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTmF0aXZlRXJyb3IodmFsMSkgfHwgdmFsMSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgLy8gRG8gbm90IGNvbXBhcmUgdGhlIHN0YWNrIGFzIGl0IG1pZ2h0IGRpZmZlciBldmVuIHRob3VnaCB0aGUgZXJyb3IgaXRzZWxmXG4gICAgLy8gaXMgb3RoZXJ3aXNlIGlkZW50aWNhbC5cbiAgICBpZiAodmFsMS5tZXNzYWdlICE9PSB2YWwyLm1lc3NhZ2UgfHwgdmFsMS5uYW1lICE9PSB2YWwyLm5hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlclZpZXcodmFsMSkpIHtcbiAgICBpZiAoIXN0cmljdCAmJiAoaXNGbG9hdDMyQXJyYXkodmFsMSkgfHwgaXNGbG9hdDY0QXJyYXkodmFsMSkpKSB7XG4gICAgICBpZiAoIWFyZVNpbWlsYXJGbG9hdEFycmF5cyh2YWwxLCB2YWwyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYXJlU2ltaWxhclR5cGVkQXJyYXlzKHZhbDEsIHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBCdWZmZXIuY29tcGFyZSByZXR1cm5zIHRydWUsIHNvIHZhbDEubGVuZ3RoID09PSB2YWwyLmxlbmd0aC4gSWYgdGhleSBib3RoXG4gICAgLy8gb25seSBjb250YWluIG51bWVyaWMga2V5cywgd2UgZG9uJ3QgbmVlZCB0byBleGFtIGZ1cnRoZXIgdGhhbiBjaGVja2luZ1xuICAgIC8vIHRoZSBzeW1ib2xzLlxuXG5cbiAgICB2YXIgX2tleXMgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMSwgT05MWV9FTlVNRVJBQkxFKTtcblxuICAgIHZhciBfa2V5czIgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMiwgT05MWV9FTlVNRVJBQkxFKTtcblxuICAgIGlmIChfa2V5cy5sZW5ndGggIT09IF9rZXlzMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga05vSXRlcmF0b3IsIF9rZXlzKTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWwxKSkge1xuICAgIGlmICghaXNTZXQodmFsMikgfHwgdmFsMS5zaXplICE9PSB2YWwyLnNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga0lzU2V0KTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWwxKSkge1xuICAgIGlmICghaXNNYXAodmFsMikgfHwgdmFsMS5zaXplICE9PSB2YWwyLnNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga0lzTWFwKTtcbiAgfSBlbHNlIGlmIChpc0FueUFycmF5QnVmZmVyKHZhbDEpKSB7XG4gICAgaWYgKCFhcmVFcXVhbEFycmF5QnVmZmVycyh2YWwxLCB2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0JveGVkUHJpbWl0aXZlKHZhbDEpICYmICFpc0VxdWFsQm94ZWRQcmltaXRpdmUodmFsMSwgdmFsMikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga05vSXRlcmF0b3IpO1xufVxuXG5mdW5jdGlvbiBnZXRFbnVtZXJhYmxlcyh2YWwsIGtleXMpIHtcbiAgcmV0dXJuIGtleXMuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbCwgayk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBpdGVyYXRpb25UeXBlLCBhS2V5cykge1xuICAvLyBGb3IgYWxsIHJlbWFpbmluZyBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSwgb2JqZWN0cyBhbmQgTWFwcyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSBoYXZpbmc6XG4gIC8vIGEpIFRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBlbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAgLy8gYikgVGhlIHNhbWUgc2V0IG9mIGtleXMvaW5kZXhlcyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKVxuICAvLyBjKSBFcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXkvaW5kZXhcbiAgLy8gZCkgRm9yIFNldHMgYW5kIE1hcHMsIGVxdWFsIGNvbnRlbnRzXG4gIC8vIE5vdGU6IHRoaXMgYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XG4gICAgYUtleXMgPSBPYmplY3Qua2V5cyh2YWwxKTtcbiAgICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyh2YWwyKTsgLy8gVGhlIHBhaXIgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzLlxuXG4gICAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIENoZWFwIGtleSB0ZXN0XG5cblxuICB2YXIgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBhS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkodmFsMiwgYUtleXNbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0cmljdCAmJiBhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XG4gICAgdmFyIHN5bWJvbEtleXNBID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbDEpO1xuXG4gICAgaWYgKHN5bWJvbEtleXNBLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdmFyIGNvdW50ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHN5bWJvbEtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBzeW1ib2xLZXlzQVtpXTtcblxuICAgICAgICBpZiAocHJvcGVydHlJc0VudW1lcmFibGUodmFsMSwga2V5KSkge1xuICAgICAgICAgIGlmICghcHJvcGVydHlJc0VudW1lcmFibGUodmFsMiwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDIsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN5bWJvbEtleXNCID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbDIpO1xuXG4gICAgICBpZiAoc3ltYm9sS2V5c0EubGVuZ3RoICE9PSBzeW1ib2xLZXlzQi5sZW5ndGggJiYgZ2V0RW51bWVyYWJsZXModmFsMiwgc3ltYm9sS2V5c0IpLmxlbmd0aCAhPT0gY291bnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3N5bWJvbEtleXNCID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbDIpO1xuXG4gICAgICBpZiAoX3N5bWJvbEtleXNCLmxlbmd0aCAhPT0gMCAmJiBnZXRFbnVtZXJhYmxlcyh2YWwyLCBfc3ltYm9sS2V5c0IpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGFLZXlzLmxlbmd0aCA9PT0gMCAmJiAoaXRlcmF0aW9uVHlwZSA9PT0ga05vSXRlcmF0b3IgfHwgaXRlcmF0aW9uVHlwZSA9PT0ga0lzQXJyYXkgJiYgdmFsMS5sZW5ndGggPT09IDAgfHwgdmFsMS5zaXplID09PSAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIFVzZSBtZW1vcyB0byBoYW5kbGUgY3ljbGVzLlxuXG5cbiAgaWYgKG1lbW9zID09PSB1bmRlZmluZWQpIHtcbiAgICBtZW1vcyA9IHtcbiAgICAgIHZhbDE6IG5ldyBNYXAoKSxcbiAgICAgIHZhbDI6IG5ldyBNYXAoKSxcbiAgICAgIHBvc2l0aW9uOiAwXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBwcmV2ZW50IHVwIHRvIHR3byBtYXAuaGFzKHgpIGNhbGxzIGJ5IGRpcmVjdGx5IHJldHJpZXZpbmcgdGhlIHZhbHVlXG4gICAgLy8gYW5kIGNoZWNraW5nIGZvciB1bmRlZmluZWQuIFRoZSBtYXAgY2FuIG9ubHkgY29udGFpbiBudW1iZXJzLCBzbyBpdCBpc1xuICAgIC8vIHNhZmUgdG8gY2hlY2sgZm9yIHVuZGVmaW5lZCBvbmx5LlxuICAgIHZhciB2YWwyTWVtb0EgPSBtZW1vcy52YWwxLmdldCh2YWwxKTtcblxuICAgIGlmICh2YWwyTWVtb0EgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHZhbDJNZW1vQiA9IG1lbW9zLnZhbDIuZ2V0KHZhbDIpO1xuXG4gICAgICBpZiAodmFsMk1lbW9CICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbDJNZW1vQSA9PT0gdmFsMk1lbW9CO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9zLnBvc2l0aW9uKys7XG4gIH1cblxuICBtZW1vcy52YWwxLnNldCh2YWwxLCBtZW1vcy5wb3NpdGlvbik7XG4gIG1lbW9zLnZhbDIuc2V0KHZhbDIsIG1lbW9zLnBvc2l0aW9uKTtcbiAgdmFyIGFyZUVxID0gb2JqRXF1aXYodmFsMSwgdmFsMiwgc3RyaWN0LCBhS2V5cywgbWVtb3MsIGl0ZXJhdGlvblR5cGUpO1xuICBtZW1vcy52YWwxLmRlbGV0ZSh2YWwxKTtcbiAgbWVtb3MudmFsMi5kZWxldGUodmFsMik7XG4gIHJldHVybiBhcmVFcTtcbn1cblxuZnVuY3Rpb24gc2V0SGFzRXF1YWxFbGVtZW50KHNldCwgdmFsMSwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIEdvIGxvb2tpbmcuXG4gIHZhciBzZXRWYWx1ZXMgPSBhcnJheUZyb21TZXQoc2V0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2YWwyID0gc2V0VmFsdWVzW2ldO1xuXG4gICAgaWYgKGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgbWF0Y2hpbmcgZWxlbWVudCB0byBtYWtlIHN1cmUgd2UgZG8gbm90IGNoZWNrIHRoYXQgYWdhaW4uXG4gICAgICBzZXQuZGVsZXRlKHZhbDIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9FcXVhbGl0eV9jb21wYXJpc29uc19hbmRfc2FtZW5lc3MjTG9vc2VfZXF1YWxpdHlfdXNpbmdcbi8vIFNhZGx5IGl0IGlzIG5vdCBwb3NzaWJsZSB0byBkZXRlY3QgY29ycmVzcG9uZGluZyB2YWx1ZXMgcHJvcGVybHkgaW4gY2FzZSB0aGVcbi8vIHR5cGUgaXMgYSBzdHJpbmcsIG51bWJlciwgYmlnaW50IG9yIGJvb2xlYW4uIFRoZSByZWFzb24gaXMgdGhhdCB0aG9zZSB2YWx1ZXNcbi8vIGNhbiBtYXRjaCBsb3RzIG9mIGRpZmZlcmVudCBzdHJpbmcgdmFsdWVzIChlLmcuLCAxbiA9PSAnKzAwMDAxJykuXG5cblxuZnVuY3Rpb24gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pIHtcbiAgc3dpdGNoIChfdHlwZW9mKHByaW0pKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIC8vIE9ubHkgcGFzcyBpbiBudWxsIGFzIG9iamVjdCFcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHByaW0gPSArcHJpbTtcbiAgICAvLyBMb29zZSBlcXVhbCBlbnRyaWVzIGV4aXN0IG9ubHkgaWYgdGhlIHN0cmluZyBpcyBwb3NzaWJsZSB0byBjb252ZXJ0IHRvXG4gICAgLy8gYSByZWd1bGFyIG51bWJlciBhbmQgbm90IE5hTi5cbiAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAobnVtYmVySXNOYU4ocHJpbSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc2V0TWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHByaW0pIHtcbiAgdmFyIGFsdFZhbHVlID0gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pO1xuICBpZiAoYWx0VmFsdWUgIT0gbnVsbCkgcmV0dXJuIGFsdFZhbHVlO1xuICByZXR1cm4gYi5oYXMoYWx0VmFsdWUpICYmICFhLmhhcyhhbHRWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIG1hcE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBwcmltLCBpdGVtLCBtZW1vKSB7XG4gIHZhciBhbHRWYWx1ZSA9IGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKTtcblxuICBpZiAoYWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBhbHRWYWx1ZTtcbiAgfVxuXG4gIHZhciBjdXJCID0gYi5nZXQoYWx0VmFsdWUpO1xuXG4gIGlmIChjdXJCID09PSB1bmRlZmluZWQgJiYgIWIuaGFzKGFsdFZhbHVlKSB8fCAhaW5uZXJEZWVwRXF1YWwoaXRlbSwgY3VyQiwgZmFsc2UsIG1lbW8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICFhLmhhcyhhbHRWYWx1ZSkgJiYgaW5uZXJEZWVwRXF1YWwoaXRlbSwgY3VyQiwgZmFsc2UsIG1lbW8pO1xufVxuXG5mdW5jdGlvbiBzZXRFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW8pIHtcbiAgLy8gVGhpcyBpcyBhIGxhemlseSBpbml0aWF0ZWQgU2V0IG9mIGVudHJpZXMgd2hpY2ggaGF2ZSB0byBiZSBjb21wYXJlZFxuICAvLyBwYWlyd2lzZS5cbiAgdmFyIHNldCA9IG51bGw7XG4gIHZhciBhVmFsdWVzID0gYXJyYXlGcm9tU2V0KGEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYVZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2YWwgPSBhVmFsdWVzW2ldOyAvLyBOb3RlOiBDaGVja2luZyBmb3IgdGhlIG9iamVjdHMgZmlyc3QgaW1wcm92ZXMgdGhlIHBlcmZvcm1hbmNlIGZvciBvYmplY3RcbiAgICAvLyBoZWF2eSBzZXRzIGJ1dCBpdCBpcyBhIG1pbm9yIHNsb3cgZG93biBmb3IgcHJpbWl0aXZlcy4gQXMgdGhleSBhcmUgZmFzdFxuICAgIC8vIHRvIGNoZWNrIHRoaXMgaW1wcm92ZXMgdGhlIHdvcnN0IGNhc2Ugc2NlbmFyaW8gaW5zdGVhZC5cblxuICAgIGlmIChfdHlwZW9mKHZhbCkgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICB9IC8vIElmIHRoZSBzcGVjaWZpZWQgdmFsdWUgZG9lc24ndCBleGlzdCBpbiB0aGUgc2Vjb25kIHNldCBpdHMgYW4gbm90IG51bGxcbiAgICAgIC8vIG9iamVjdCAob3Igbm9uIHN0cmljdCBvbmx5OiBhIG5vdCBtYXRjaGluZyBwcmltaXRpdmUpIHdlJ2xsIG5lZWQgdG8gZ29cbiAgICAgIC8vIGh1bnRpbmcgZm9yIHNvbWV0aGluZyB0aGF0cyBkZWVwLShzdHJpY3QtKWVxdWFsIHRvIGl0LiBUbyBtYWtlIHRoaXNcbiAgICAgIC8vIE8obiBsb2cgbikgY29tcGxleGl0eSB3ZSBoYXZlIHRvIGNvcHkgdGhlc2UgdmFsdWVzIGluIGEgbmV3IHNldCBmaXJzdC5cblxuXG4gICAgICBzZXQuYWRkKHZhbCk7XG4gICAgfSBlbHNlIGlmICghYi5oYXModmFsKSkge1xuICAgICAgaWYgKHN0cmljdCkgcmV0dXJuIGZhbHNlOyAvLyBGYXN0IHBhdGggdG8gZGV0ZWN0IG1pc3Npbmcgc3RyaW5nLCBzeW1ib2wsIHVuZGVmaW5lZCBhbmQgbnVsbCB2YWx1ZXMuXG5cbiAgICAgIGlmICghc2V0TWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH1cblxuICAgICAgc2V0LmFkZCh2YWwpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZXQgIT09IG51bGwpIHtcbiAgICB2YXIgYlZhbHVlcyA9IGFycmF5RnJvbVNldChiKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBiVmFsdWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF92YWwgPSBiVmFsdWVzW19pXTsgLy8gV2UgaGF2ZSB0byBjaGVjayBpZiBhIHByaW1pdGl2ZSB2YWx1ZSBpcyBhbHJlYWR5XG4gICAgICAvLyBtYXRjaGluZyBhbmQgb25seSBpZiBpdCdzIG5vdCwgZ28gaHVudGluZyBmb3IgaXQuXG5cbiAgICAgIGlmIChfdHlwZW9mKF92YWwpID09PSAnb2JqZWN0JyAmJiBfdmFsICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghc2V0SGFzRXF1YWxFbGVtZW50KHNldCwgX3ZhbCwgc3RyaWN0LCBtZW1vKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmICFhLmhhcyhfdmFsKSAmJiAhc2V0SGFzRXF1YWxFbGVtZW50KHNldCwgX3ZhbCwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldC5zaXplID09PSAwO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG1hcEhhc0VxdWFsRW50cnkoc2V0LCBtYXAsIGtleTEsIGl0ZW0xLCBzdHJpY3QsIG1lbW8pIHtcbiAgLy8gVG8gYmUgYWJsZSB0byBoYW5kbGUgY2FzZXMgbGlrZTpcbiAgLy8gICBNYXAoW1t7fSwgJ2EnXSwgW3t9LCAnYiddXSkgdnMgTWFwKFtbe30sICdiJ10sIFt7fSwgJ2EnXV0pXG4gIC8vIC4uLiB3ZSBuZWVkIHRvIGNvbnNpZGVyICphbGwqIG1hdGNoaW5nIGtleXMsIG5vdCBqdXN0IHRoZSBmaXJzdCB3ZSBmaW5kLlxuICB2YXIgc2V0VmFsdWVzID0gYXJyYXlGcm9tU2V0KHNldCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5MiA9IHNldFZhbHVlc1tpXTtcblxuICAgIGlmIChpbm5lckRlZXBFcXVhbChrZXkxLCBrZXkyLCBzdHJpY3QsIG1lbW8pICYmIGlubmVyRGVlcEVxdWFsKGl0ZW0xLCBtYXAuZ2V0KGtleTIpLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICBzZXQuZGVsZXRlKGtleTIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtYXBFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW8pIHtcbiAgdmFyIHNldCA9IG51bGw7XG4gIHZhciBhRW50cmllcyA9IGFycmF5RnJvbU1hcChhKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9hRW50cmllcyRpID0gX3NsaWNlZFRvQXJyYXkoYUVudHJpZXNbaV0sIDIpLFxuICAgICAgICBrZXkgPSBfYUVudHJpZXMkaVswXSxcbiAgICAgICAgaXRlbTEgPSBfYUVudHJpZXMkaVsxXTtcblxuICAgIGlmIChfdHlwZW9mKGtleSkgPT09ICdvYmplY3QnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHNldC5hZGQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQnkgZGlyZWN0bHkgcmV0cmlldmluZyB0aGUgdmFsdWUgd2UgcHJldmVudCBhbm90aGVyIGIuaGFzKGtleSkgY2hlY2sgaW5cbiAgICAgIC8vIGFsbW9zdCBhbGwgcG9zc2libGUgY2FzZXMuXG4gICAgICB2YXIgaXRlbTIgPSBiLmdldChrZXkpO1xuXG4gICAgICBpZiAoaXRlbTIgPT09IHVuZGVmaW5lZCAmJiAhYi5oYXMoa2V5KSB8fCAhaW5uZXJEZWVwRXF1YWwoaXRlbTEsIGl0ZW0yLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAgIGlmIChzdHJpY3QpIHJldHVybiBmYWxzZTsgLy8gRmFzdCBwYXRoIHRvIGRldGVjdCBtaXNzaW5nIHN0cmluZywgc3ltYm9sLCB1bmRlZmluZWQgYW5kIG51bGxcbiAgICAgICAgLy8ga2V5cy5cblxuICAgICAgICBpZiAoIW1hcE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBrZXksIGl0ZW0xLCBtZW1vKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXQuYWRkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHNldCAhPT0gbnVsbCkge1xuICAgIHZhciBiRW50cmllcyA9IGFycmF5RnJvbU1hcChiKTtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGJFbnRyaWVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBfYkVudHJpZXMkX2kgPSBfc2xpY2VkVG9BcnJheShiRW50cmllc1tfaTJdLCAyKSxcbiAgICAgICAgICBrZXkgPSBfYkVudHJpZXMkX2lbMF0sXG4gICAgICAgICAgaXRlbSA9IF9iRW50cmllcyRfaVsxXTtcblxuICAgICAgaWYgKF90eXBlb2Yoa2V5KSA9PT0gJ29iamVjdCcgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghbWFwSGFzRXF1YWxFbnRyeShzZXQsIGEsIGtleSwgaXRlbSwgc3RyaWN0LCBtZW1vKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmICghYS5oYXMoa2V5KSB8fCAhaW5uZXJEZWVwRXF1YWwoYS5nZXQoa2V5KSwgaXRlbSwgZmFsc2UsIG1lbW8pKSAmJiAhbWFwSGFzRXF1YWxFbnRyeShzZXQsIGEsIGtleSwgaXRlbSwgZmFsc2UsIG1lbW8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2V0LnNpemUgPT09IDA7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgc3RyaWN0LCBrZXlzLCBtZW1vcywgaXRlcmF0aW9uVHlwZSkge1xuICAvLyBTZXRzIGFuZCBtYXBzIGRvbid0IGhhdmUgdGhlaXIgZW50cmllcyBhY2Nlc3NpYmxlIHZpYSBub3JtYWwgb2JqZWN0XG4gIC8vIHByb3BlcnRpZXMuXG4gIHZhciBpID0gMDtcblxuICBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzU2V0KSB7XG4gICAgaWYgKCFzZXRFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNNYXApIHtcbiAgICBpZiAoIW1hcEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc0FycmF5KSB7XG4gICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkoYSwgaSkpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShiLCBpKSB8fCAhaW5uZXJEZWVwRXF1YWwoYVtpXSwgYltpXSwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaGFzT3duUHJvcGVydHkoYiwgaSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXJyYXkgaXMgc3BhcnNlLlxuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcblxuICAgICAgICBmb3IgKDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNBW2ldO1xuXG4gICAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShiLCBrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5c0EubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gVGhlIHBhaXIgbXVzdCBoYXZlIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleS5cbiAgLy8gUG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdDpcblxuXG4gIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9rZXkgPSBrZXlzW2ldO1xuXG4gICAgaWYgKCFpbm5lckRlZXBFcXVhbChhW19rZXldLCBiW19rZXldLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0RlZXBFcXVhbCh2YWwxLCB2YWwyKSB7XG4gIHJldHVybiBpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBrTG9vc2UpO1xufVxuXG5mdW5jdGlvbiBpc0RlZXBTdHJpY3RFcXVhbCh2YWwxLCB2YWwyKSB7XG4gIHJldHVybiBpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBrU3RyaWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzRGVlcEVxdWFsOiBpc0RlZXBFcXVhbCxcbiAgaXNEZWVwU3RyaWN0RXF1YWw6IGlzRGVlcFN0cmljdEVxdWFsXG59OyIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG5jb25zdCBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5jb25zdCBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgPyBTeW1ib2xbJ2ZvciddKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuY29uc3QgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBjb25zdCBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlWaWV3KHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGNvbnN0IGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgY29uc3QgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgbGV0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgY29uc3QgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlWaWV3IChhcnJheVZpZXcpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkge1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpXG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KVxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgbGV0IGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICBjb25zdCBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICBsZXQgeCA9IGEubGVuZ3RoXG4gIGxldCB5ID0gYi5sZW5ndGhcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIGxldCBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgbGV0IHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIGJ1ZixcbiAgICAgICAgICBwb3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICB9XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGNvbnN0IG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2VyY2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIGNvbnN0IGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIGxldCBzdHIgPSAnJ1xuICBjb25zdCBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICBsZXQgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgbGV0IHkgPSBlbmQgLSBzdGFydFxuICBjb25zdCBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIGNvbnN0IHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICBsZXQgaW5kZXhTaXplID0gMVxuICBsZXQgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICBsZXQgaVxuICBpZiAoZGlyKSB7XG4gICAgbGV0IGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICBjb25zdCByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIGNvbnN0IHJlcyA9IFtdXG5cbiAgbGV0IGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIGxldCBjb2RlUG9pbnQgPSBudWxsXG4gICAgbGV0IGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRilcbiAgICAgID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERilcbiAgICAgICAgICA/IDNcbiAgICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKVxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG5jb25zdCBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgY29uc3QgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgbGV0IG91dCA9ICcnXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgbGV0IHJlcyA9ICcnXG4gIC8vIElmIGJ5dGVzLmxlbmd0aCBpcyBvZGQsIHRoZSBsYXN0IDggYml0cyBtdXN0IGJlIGlnbm9yZWQgKHNhbWUgYXMgbm9kZS5qcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICBsZXQgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGxvID0gZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNFxuXG4gIGNvbnN0IGhpID0gdGhpc1srK29mZnNldF0gK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIGxhc3QgKiAyICoqIDI0XG5cbiAgcmV0dXJuIEJpZ0ludChsbykgKyAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgaGkgPSBmaXJzdCAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgY29uc3QgbG8gPSB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3RcblxuICByZXR1cm4gKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQobG8pXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoXG4gIGxldCBtdWwgPSAxXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDRdICtcbiAgICB0aGlzW29mZnNldCArIDVdICogMiAqKiA4ICtcbiAgICB0aGlzW29mZnNldCArIDZdICogMiAqKiAxNiArXG4gICAgKGxhc3QgPDwgMjQpIC8vIE92ZXJmbG93XG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gKGZpcnN0IDw8IDI0KSArIC8vIE92ZXJmbG93XG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQodGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRMRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICByZXR1cm4gb2Zmc2V0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyA3XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNl0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDVdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA0XSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgM10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDJdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAxXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0XSA9IGhpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gMFxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgY29uc3QgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICBsZXQgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBDVVNUT00gRVJST1JTXG4vLyA9PT09PT09PT09PT09XG5cbi8vIFNpbXBsaWZpZWQgdmVyc2lvbnMgZnJvbSBOb2RlLCBjaGFuZ2VkIGZvciBCdWZmZXItb25seSB1c2FnZVxuY29uc3QgZXJyb3JzID0ge31cbmZ1bmN0aW9uIEUgKHN5bSwgZ2V0TWVzc2FnZSwgQmFzZSkge1xuICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHN1cGVyKClcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywge1xuICAgICAgICB2YWx1ZTogZ2V0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KVxuXG4gICAgICAvLyBBZGQgdGhlIGVycm9yIGNvZGUgdG8gdGhlIG5hbWUgdG8gaW5jbHVkZSBpdCBpbiB0aGUgc3RhY2sgdHJhY2UuXG4gICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLm5hbWV9IFske3N5bX1dYFxuICAgICAgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgICAgIC8vIGZyb20gdGhlIG5hbWUuXG4gICAgICB0aGlzLnN0YWNrIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgICAvLyBSZXNldCB0aGUgbmFtZSB0byB0aGUgYWN0dWFsIG5hbWUuXG4gICAgICBkZWxldGUgdGhpcy5uYW1lXG4gICAgfVxuXG4gICAgZ2V0IGNvZGUgKCkge1xuICAgICAgcmV0dXJuIHN5bVxuICAgIH1cblxuICAgIHNldCBjb2RlICh2YWx1ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2RlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgIH1cbiAgfVxufVxuXG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLFxuICBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gYCR7bmFtZX0gaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzYFxuICAgIH1cblxuICAgIHJldHVybiAnQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcydcbiAgfSwgUmFuZ2VFcnJvcilcbkUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJyxcbiAgZnVuY3Rpb24gKG5hbWUsIGFjdHVhbCkge1xuICAgIHJldHVybiBgVGhlIFwiJHtuYW1lfVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWBcbiAgfSwgVHlwZUVycm9yKVxuRSgnRVJSX09VVF9PRl9SQU5HRScsXG4gIGZ1bmN0aW9uIChzdHIsIHJhbmdlLCBpbnB1dCkge1xuICAgIGxldCBtc2cgPSBgVGhlIHZhbHVlIG9mIFwiJHtzdHJ9XCIgaXMgb3V0IG9mIHJhbmdlLmBcbiAgICBsZXQgcmVjZWl2ZWQgPSBpbnB1dFxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7XG4gICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihTdHJpbmcoaW5wdXQpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnYmlnaW50Jykge1xuICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpXG4gICAgICBpZiAoaW5wdXQgPiBCaWdJbnQoMikgKiogQmlnSW50KDMyKSB8fCBpbnB1dCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSB7XG4gICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKVxuICAgICAgfVxuICAgICAgcmVjZWl2ZWQgKz0gJ24nXG4gICAgfVxuICAgIG1zZyArPSBgIEl0IG11c3QgYmUgJHtyYW5nZX0uIFJlY2VpdmVkICR7cmVjZWl2ZWR9YFxuICAgIHJldHVybiBtc2dcbiAgfSwgUmFuZ2VFcnJvcilcblxuZnVuY3Rpb24gYWRkTnVtZXJpY2FsU2VwYXJhdG9yICh2YWwpIHtcbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gdmFsLmxlbmd0aFxuICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gJy0nID8gMSA6IDBcbiAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHtcbiAgICByZXMgPSBgXyR7dmFsLnNsaWNlKGkgLSAzLCBpKX0ke3Jlc31gXG4gIH1cbiAgcmV0dXJuIGAke3ZhbC5zbGljZSgwLCBpKX0ke3Jlc31gXG59XG5cbi8vIENIRUNLIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIGNoZWNrQm91bmRzIChidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBpZiAoYnVmW29mZnNldF0gPT09IHVuZGVmaW5lZCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmLmxlbmd0aCAtIChieXRlTGVuZ3RoICsgMSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbnRCSSAodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHtcbiAgICBjb25zdCBuID0gdHlwZW9mIG1pbiA9PT0gJ2JpZ2ludCcgPyAnbicgOiAnJ1xuICAgIGxldCByYW5nZVxuICAgIGlmIChieXRlTGVuZ3RoID4gMykge1xuICAgICAgaWYgKG1pbiA9PT0gMCB8fCBtaW4gPT09IEJpZ0ludCgwKSkge1xuICAgICAgICByYW5nZSA9IGA+PSAwJHtufSBhbmQgPCAyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4fSR7bn1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZSA9IGA+PSAtKDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn0pIGFuZCA8IDIgKiogYCArXG4gICAgICAgICAgICAgICAgYCR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn1gXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlID0gYD49ICR7bWlufSR7bn0gYW5kIDw9ICR7bWF4fSR7bn1gXG4gICAgfVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSgndmFsdWUnLCByYW5nZSwgdmFsdWUpXG4gIH1cbiAgY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyICh2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ251bWJlcicsIHZhbHVlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJvdW5kc0Vycm9yICh2YWx1ZSwgbGVuZ3RoLCB0eXBlKSB7XG4gIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHtcbiAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZSlcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JywgJ2FuIGludGVnZXInLCB2YWx1ZSlcbiAgfVxuXG4gIGlmIChsZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoKVxuICB9XG5cbiAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgPj0gJHt0eXBlID8gMSA6IDB9IGFuZCA8PSAke2xlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUpXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuY29uc3QgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIGxldCBjb2RlUG9pbnRcbiAgY29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgY29uc3QgYnl0ZXMgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIGxldCBjLCBoaSwgbG9cbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxuY29uc3QgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgY29uc3QgaTE2ID0gaSAqIDE2XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG5cbi8vIFJldHVybiBub3QgZnVuY3Rpb24gd2l0aCBFcnJvciBpZiBCaWdJbnQgbm90IHN1cHBvcnRlZFxuZnVuY3Rpb24gZGVmaW5lQmlnSW50TWV0aG9kIChmbikge1xuICByZXR1cm4gdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyBCdWZmZXJCaWdJbnROb3REZWZpbmVkIDogZm5cbn1cblxuZnVuY3Rpb24gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQmlnSW50IG5vdCBzdXBwb3J0ZWQnKVxufVxuIiwidmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciB0cnlUb1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90cnktdG8tc3RyaW5nJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NhbGxhYmxlKGFyZ3VtZW50KSBpcyB0cnVlYFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IodHJ5VG9TdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xufTtcbiIsInZhciBpc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNvbnN0cnVjdG9yJyk7XG52YXIgdHJ5VG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZycpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkgaXMgdHJ1ZWBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yKHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbn07XG4iLCJ2YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50ID09ICdvYmplY3QnIHx8IGlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IoXCJDYW4ndCBzZXQgXCIgKyAkU3RyaW5nKGFyZ3VtZW50KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbn07XG4iLCJ2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcblxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmlmIChBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSB7XG4gIGRlZmluZVByb3BlcnR5KEFycmF5UHJvdG90eXBlLCBVTlNDT1BBQkxFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogY3JlYXRlKG51bGwpXG4gIH0pO1xufVxuXG4vLyBhZGQgYSBrZXkgdG8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjaGFyQXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZScpLmNoYXJBdDtcblxuLy8gYEFkdmFuY2VTdHJpbmdJbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFkdmFuY2VzdHJpbmdpbmRleFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUywgaW5kZXgsIHVuaWNvZGUpIHtcbiAgcmV0dXJuIGluZGV4ICsgKHVuaWNvZGUgPyBjaGFyQXQoUywgaW5kZXgpLmxlbmd0aCA6IDEpO1xufTtcbiIsInZhciBpc1Byb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBQcm90b3R5cGUpIHtcbiAgaWYgKGlzUHJvdG90eXBlT2YoUHJvdG90eXBlLCBpdCkpIHJldHVybiBpdDtcbiAgdGhyb3cgJFR5cGVFcnJvcignSW5jb3JyZWN0IGludm9jYXRpb24nKTtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IFR5cGUoYXJndW1lbnQpIGlzIE9iamVjdGBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc09iamVjdChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvcigkU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcbiIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLXR5cGVkLWFycmF5cyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgRGF0YVZpZXcgIT0gJ3VuZGVmaW5lZCc7XG4iLCIvLyBGRjI2LSBidWc6IEFycmF5QnVmZmVycyBhcmUgbm9uLWV4dGVuc2libGUsIGJ1dCBPYmplY3QuaXNFeHRlbnNpYmxlIGRvZXMgbm90IHJlcG9ydCBpdFxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1pc2V4dGVuc2libGUsIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbiAgICBpZiAoT2JqZWN0LmlzRXh0ZW5zaWJsZShidWZmZXIpKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnVmZmVyLCAnYScsIHsgdmFsdWU6IDggfSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIE5BVElWRV9BUlJBWV9CVUZGRVIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLW5hdGl2ZScpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xudmFyIHRyeVRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RyeS10by1zdHJpbmcnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBpc1Byb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xuXG52YXIgSW50OEFycmF5ID0gZ2xvYmFsLkludDhBcnJheTtcbnZhciBJbnQ4QXJyYXlQcm90b3R5cGUgPSBJbnQ4QXJyYXkgJiYgSW50OEFycmF5LnByb3RvdHlwZTtcbnZhciBVaW50OENsYW1wZWRBcnJheSA9IGdsb2JhbC5VaW50OENsYW1wZWRBcnJheTtcbnZhciBVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSA9IFVpbnQ4Q2xhbXBlZEFycmF5ICYmIFVpbnQ4Q2xhbXBlZEFycmF5LnByb3RvdHlwZTtcbnZhciBUeXBlZEFycmF5ID0gSW50OEFycmF5ICYmIGdldFByb3RvdHlwZU9mKEludDhBcnJheSk7XG52YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IEludDhBcnJheVByb3RvdHlwZSAmJiBnZXRQcm90b3R5cGVPZihJbnQ4QXJyYXlQcm90b3R5cGUpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgVFlQRURfQVJSQVlfVEFHID0gdWlkKCdUWVBFRF9BUlJBWV9UQUcnKTtcbnZhciBUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUiA9IHVpZCgnVFlQRURfQVJSQVlfQ09OU1RSVUNUT1InKTtcbi8vIEZpeGluZyBuYXRpdmUgdHlwZWQgYXJyYXlzIGluIE9wZXJhIFByZXN0byBjcmFzaGVzIHRoZSBicm93c2VyLCBzZWUgIzU5NVxudmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgPSBOQVRJVkVfQVJSQVlfQlVGRkVSICYmICEhc2V0UHJvdG90eXBlT2YgJiYgY2xhc3NvZihnbG9iYWwub3BlcmEpICE9PSAnT3BlcmEnO1xudmFyIFRZUEVEX0FSUkFZX1RBR19SRVFVSVJFRCA9IGZhbHNlO1xudmFyIE5BTUUsIENvbnN0cnVjdG9yLCBQcm90b3R5cGU7XG5cbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCA9IHtcbiAgSW50OEFycmF5OiAxLFxuICBVaW50OEFycmF5OiAxLFxuICBVaW50OENsYW1wZWRBcnJheTogMSxcbiAgSW50MTZBcnJheTogMixcbiAgVWludDE2QXJyYXk6IDIsXG4gIEludDMyQXJyYXk6IDQsXG4gIFVpbnQzMkFycmF5OiA0LFxuICBGbG9hdDMyQXJyYXk6IDQsXG4gIEZsb2F0NjRBcnJheTogOFxufTtcblxudmFyIEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCA9IHtcbiAgQmlnSW50NjRBcnJheTogOCxcbiAgQmlnVWludDY0QXJyYXk6IDhcbn07XG5cbnZhciBpc1ZpZXcgPSBmdW5jdGlvbiBpc1ZpZXcoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBmYWxzZTtcbiAgdmFyIGtsYXNzID0gY2xhc3NvZihpdCk7XG4gIHJldHVybiBrbGFzcyA9PT0gJ0RhdGFWaWV3J1xuICAgIHx8IGhhc093bihUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpXG4gICAgfHwgaGFzT3duKEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpO1xufTtcblxudmFyIGlzVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGZhbHNlO1xuICB2YXIga2xhc3MgPSBjbGFzc29mKGl0KTtcbiAgcmV0dXJuIGhhc093bihUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpXG4gICAgfHwgaGFzT3duKEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpO1xufTtcblxudmFyIGFUeXBlZEFycmF5ID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc1R5cGVkQXJyYXkoaXQpKSByZXR1cm4gaXQ7XG4gIHRocm93IFR5cGVFcnJvcignVGFyZ2V0IGlzIG5vdCBhIHR5cGVkIGFycmF5Jyk7XG59O1xuXG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChDKSB7XG4gIGlmIChpc0NhbGxhYmxlKEMpICYmICghc2V0UHJvdG90eXBlT2YgfHwgaXNQcm90b3R5cGVPZihUeXBlZEFycmF5LCBDKSkpIHJldHVybiBDO1xuICB0aHJvdyBUeXBlRXJyb3IodHJ5VG9TdHJpbmcoQykgKyAnIGlzIG5vdCBhIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yJyk7XG59O1xuXG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCA9IGZ1bmN0aW9uIChLRVksIHByb3BlcnR5LCBmb3JjZWQsIG9wdGlvbnMpIHtcbiAgaWYgKCFERVNDUklQVE9SUykgcmV0dXJuO1xuICBpZiAoZm9yY2VkKSBmb3IgKHZhciBBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWxbQVJSQVldO1xuICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgaGFzT3duKFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIEtFWSkpIHRyeSB7XG4gICAgICBkZWxldGUgVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZVtLRVldO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBvbGQgV2ViS2l0IGJ1ZyAtIHNvbWUgbWV0aG9kcyBhcmUgbm9uLWNvbmZpZ3VyYWJsZVxuICAgICAgdHJ5IHtcbiAgICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZVtLRVldID0gcHJvcGVydHk7XG4gICAgICB9IGNhdGNoIChlcnJvcjIpIHsgLyogZW1wdHkgKi8gfVxuICAgIH1cbiAgfVxuICBpZiAoIVR5cGVkQXJyYXlQcm90b3R5cGVbS0VZXSB8fCBmb3JjZWQpIHtcbiAgICBkZWZpbmVCdWlsdEluKFR5cGVkQXJyYXlQcm90b3R5cGUsIEtFWSwgZm9yY2VkID8gcHJvcGVydHlcbiAgICAgIDogTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyAmJiBJbnQ4QXJyYXlQcm90b3R5cGVbS0VZXSB8fCBwcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbnZhciBleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kID0gZnVuY3Rpb24gKEtFWSwgcHJvcGVydHksIGZvcmNlZCkge1xuICB2YXIgQVJSQVksIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbiAgaWYgKCFERVNDUklQVE9SUykgcmV0dXJuO1xuICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICBpZiAoZm9yY2VkKSBmb3IgKEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWxbQVJSQVldO1xuICAgICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBoYXNPd24oVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBLRVkpKSB0cnkge1xuICAgICAgICBkZWxldGUgVHlwZWRBcnJheUNvbnN0cnVjdG9yW0tFWV07XG4gICAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgfVxuICAgIGlmICghVHlwZWRBcnJheVtLRVldIHx8IGZvcmNlZCkge1xuICAgICAgLy8gVjggfiBDaHJvbWUgNDktNTAgYCVUeXBlZEFycmF5JWAgbWV0aG9kcyBhcmUgbm9uLXdyaXRhYmxlIG5vbi1jb25maWd1cmFibGVcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWZpbmVCdWlsdEluKFR5cGVkQXJyYXksIEtFWSwgZm9yY2VkID8gcHJvcGVydHkgOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIFR5cGVkQXJyYXlbS0VZXSB8fCBwcm9wZXJ0eSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgfSBlbHNlIHJldHVybjtcbiAgfVxuICBmb3IgKEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsW0FSUkFZXTtcbiAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmICghVHlwZWRBcnJheUNvbnN0cnVjdG9yW0tFWV0gfHwgZm9yY2VkKSkge1xuICAgICAgZGVmaW5lQnVpbHRJbihUeXBlZEFycmF5Q29uc3RydWN0b3IsIEtFWSwgcHJvcGVydHkpO1xuICAgIH1cbiAgfVxufTtcblxuZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gIENvbnN0cnVjdG9yID0gZ2xvYmFsW05BTUVdO1xuICBQcm90b3R5cGUgPSBDb25zdHJ1Y3RvciAmJiBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIGlmIChQcm90b3R5cGUpIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShQcm90b3R5cGUsIFRZUEVEX0FSUkFZX0NPTlNUUlVDVE9SLCBDb25zdHJ1Y3Rvcik7XG4gIGVsc2UgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyA9IGZhbHNlO1xufVxuXG5mb3IgKE5BTUUgaW4gQmlnSW50QXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gIENvbnN0cnVjdG9yID0gZ2xvYmFsW05BTUVdO1xuICBQcm90b3R5cGUgPSBDb25zdHJ1Y3RvciAmJiBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIGlmIChQcm90b3R5cGUpIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShQcm90b3R5cGUsIFRZUEVEX0FSUkFZX0NPTlNUUlVDVE9SLCBDb25zdHJ1Y3Rvcik7XG59XG5cbi8vIFdlYktpdCBidWcgLSB0eXBlZCBhcnJheXMgY29uc3RydWN0b3JzIHByb3RvdHlwZSBpcyBPYmplY3QucHJvdG90eXBlXG5pZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgfHwgIWlzQ2FsbGFibGUoVHlwZWRBcnJheSkgfHwgVHlwZWRBcnJheSA9PT0gRnVuY3Rpb24ucHJvdG90eXBlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3cgLS0gc2FmZVxuICBUeXBlZEFycmF5ID0gZnVuY3Rpb24gVHlwZWRBcnJheSgpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XG4gIH07XG4gIGlmIChOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTKSBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICBpZiAoZ2xvYmFsW05BTUVdKSBzZXRQcm90b3R5cGVPZihnbG9iYWxbTkFNRV0sIFR5cGVkQXJyYXkpO1xuICB9XG59XG5cbmlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB8fCAhVHlwZWRBcnJheVByb3RvdHlwZSB8fCBUeXBlZEFycmF5UHJvdG90eXBlID09PSBPYmplY3RQcm90b3R5cGUpIHtcbiAgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkucHJvdG90eXBlO1xuICBpZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUykgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgaWYgKGdsb2JhbFtOQU1FXSkgc2V0UHJvdG90eXBlT2YoZ2xvYmFsW05BTUVdLnByb3RvdHlwZSwgVHlwZWRBcnJheVByb3RvdHlwZSk7XG4gIH1cbn1cblxuLy8gV2ViS2l0IGJ1ZyAtIG9uZSBtb3JlIG9iamVjdCBpbiBVaW50OENsYW1wZWRBcnJheSBwcm90b3R5cGUgY2hhaW5cbmlmIChOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIGdldFByb3RvdHlwZU9mKFVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlKSAhPT0gVHlwZWRBcnJheVByb3RvdHlwZSkge1xuICBzZXRQcm90b3R5cGVPZihVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSwgVHlwZWRBcnJheVByb3RvdHlwZSk7XG59XG5cbmlmIChERVNDUklQVE9SUyAmJiAhaGFzT3duKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRPX1NUUklOR19UQUcpKSB7XG4gIFRZUEVEX0FSUkFZX1RBR19SRVFVSVJFRCA9IHRydWU7XG4gIGRlZmluZVByb3BlcnR5KFR5cGVkQXJyYXlQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHRoaXMpID8gdGhpc1tUWVBFRF9BUlJBWV9UQUddIDogdW5kZWZpbmVkO1xuICB9IH0pO1xuICBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIGlmIChnbG9iYWxbTkFNRV0pIHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoZ2xvYmFsW05BTUVdLCBUWVBFRF9BUlJBWV9UQUcsIE5BTUUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTLFxuICBUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUjogVFlQRURfQVJSQVlfQ09OU1RSVUNUT1IsXG4gIFRZUEVEX0FSUkFZX1RBRzogVFlQRURfQVJSQVlfVEFHX1JFUVVJUkVEICYmIFRZUEVEX0FSUkFZX1RBRyxcbiAgYVR5cGVkQXJyYXk6IGFUeXBlZEFycmF5LFxuICBhVHlwZWRBcnJheUNvbnN0cnVjdG9yOiBhVHlwZWRBcnJheUNvbnN0cnVjdG9yLFxuICBleHBvcnRUeXBlZEFycmF5TWV0aG9kOiBleHBvcnRUeXBlZEFycmF5TWV0aG9kLFxuICBleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kOiBleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kLFxuICBpc1ZpZXc6IGlzVmlldyxcbiAgaXNUeXBlZEFycmF5OiBpc1R5cGVkQXJyYXksXG4gIFR5cGVkQXJyYXk6IFR5cGVkQXJyYXksXG4gIFR5cGVkQXJyYXlQcm90b3R5cGU6IFR5cGVkQXJyYXlQcm90b3R5cGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItbmF0aXZlJyk7XG52YXIgRnVuY3Rpb25OYW1lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgZGVmaW5lQnVpbHRJbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWlucycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1pbnN0YW5jZScpO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eScpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXgnKTtcbnZhciBJRUVFNzU0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2llZWU3NTQnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpLmY7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG52YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWZpbGwnKTtcbnZhciBhcnJheVNsaWNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNsaWNlLXNpbXBsZScpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xuXG52YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUgPSBGdW5jdGlvbk5hbWUuUFJPUEVSO1xudmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FID0gRnVuY3Rpb25OYW1lLkNPTkZJR1VSQUJMRTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG52YXIgREFUQV9WSUVXID0gJ0RhdGFWaWV3JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoJztcbnZhciBXUk9OR19JTkRFWCA9ICdXcm9uZyBpbmRleCc7XG52YXIgTmF0aXZlQXJyYXlCdWZmZXIgPSBnbG9iYWxbQVJSQVlfQlVGRkVSXTtcbnZhciAkQXJyYXlCdWZmZXIgPSBOYXRpdmVBcnJheUJ1ZmZlcjtcbnZhciBBcnJheUJ1ZmZlclByb3RvdHlwZSA9ICRBcnJheUJ1ZmZlciAmJiAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXTtcbnZhciAkRGF0YVZpZXcgPSBnbG9iYWxbREFUQV9WSUVXXTtcbnZhciBEYXRhVmlld1Byb3RvdHlwZSA9ICREYXRhVmlldyAmJiAkRGF0YVZpZXdbUFJPVE9UWVBFXTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIEFycmF5ID0gZ2xvYmFsLkFycmF5O1xudmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjtcbnZhciBmaWxsID0gdW5jdXJyeVRoaXMoYXJyYXlGaWxsKTtcbnZhciByZXZlcnNlID0gdW5jdXJyeVRoaXMoW10ucmV2ZXJzZSk7XG5cbnZhciBwYWNrSUVFRTc1NCA9IElFRUU3NTQucGFjaztcbnZhciB1bnBhY2tJRUVFNzU0ID0gSUVFRTc1NC51bnBhY2s7XG5cbnZhciBwYWNrSW50OCA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIFtudW1iZXIgJiAweEZGXTtcbn07XG5cbnZhciBwYWNrSW50MTYgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBbbnVtYmVyICYgMHhGRiwgbnVtYmVyID4+IDggJiAweEZGXTtcbn07XG5cbnZhciBwYWNrSW50MzIgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBbbnVtYmVyICYgMHhGRiwgbnVtYmVyID4+IDggJiAweEZGLCBudW1iZXIgPj4gMTYgJiAweEZGLCBudW1iZXIgPj4gMjQgJiAweEZGXTtcbn07XG5cbnZhciB1bnBhY2tJbnQzMiA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlclszXSA8PCAyNCB8IGJ1ZmZlclsyXSA8PCAxNiB8IGJ1ZmZlclsxXSA8PCA4IHwgYnVmZmVyWzBdO1xufTtcblxudmFyIHBhY2tGbG9hdDMyID0gZnVuY3Rpb24gKG51bWJlcikge1xuICByZXR1cm4gcGFja0lFRUU3NTQobnVtYmVyLCAyMywgNCk7XG59O1xuXG52YXIgcGFja0Zsb2F0NjQgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChudW1iZXIsIDUyLCA4KTtcbn07XG5cbnZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGtleSkge1xuICBkZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvcltQUk9UT1RZUEVdLCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpW2tleV07IH0gfSk7XG59O1xuXG52YXIgZ2V0ID0gZnVuY3Rpb24gKHZpZXcsIGNvdW50LCBpbmRleCwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChpbmRleCk7XG4gIHZhciBzdG9yZSA9IGdldEludGVybmFsU3RhdGUodmlldyk7XG4gIGlmIChpbnRJbmRleCArIGNvdW50ID4gc3RvcmUuYnl0ZUxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBieXRlcyA9IGdldEludGVybmFsU3RhdGUoc3RvcmUuYnVmZmVyKS5ieXRlcztcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyBzdG9yZS5ieXRlT2Zmc2V0O1xuICB2YXIgcGFjayA9IGFycmF5U2xpY2UoYnl0ZXMsIHN0YXJ0LCBzdGFydCArIGNvdW50KTtcbiAgcmV0dXJuIGlzTGl0dGxlRW5kaWFuID8gcGFjayA6IHJldmVyc2UocGFjayk7XG59O1xuXG52YXIgc2V0ID0gZnVuY3Rpb24gKHZpZXcsIGNvdW50LCBpbmRleCwgY29udmVyc2lvbiwgdmFsdWUsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgoaW5kZXgpO1xuICB2YXIgc3RvcmUgPSBnZXRJbnRlcm5hbFN0YXRlKHZpZXcpO1xuICBpZiAoaW50SW5kZXggKyBjb3VudCA+IHN0b3JlLmJ5dGVMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgYnl0ZXMgPSBnZXRJbnRlcm5hbFN0YXRlKHN0b3JlLmJ1ZmZlcikuYnl0ZXM7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgc3RvcmUuYnl0ZU9mZnNldDtcbiAgdmFyIHBhY2sgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykgYnl0ZXNbc3RhcnQgKyBpXSA9IHBhY2tbaXNMaXR0bGVFbmRpYW4gPyBpIDogY291bnQgLSBpIC0gMV07XG59O1xuXG5pZiAoIU5BVElWRV9BUlJBWV9CVUZGRVIpIHtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCBBcnJheUJ1ZmZlclByb3RvdHlwZSk7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0b0luZGV4KGxlbmd0aCk7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgICBieXRlczogZmlsbChBcnJheShieXRlTGVuZ3RoKSwgMCksXG4gICAgICBieXRlTGVuZ3RoOiBieXRlTGVuZ3RoXG4gICAgfSk7XG4gICAgaWYgKCFERVNDUklQVE9SUykgdGhpcy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICBBcnJheUJ1ZmZlclByb3RvdHlwZSA9ICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdO1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgRGF0YVZpZXdQcm90b3R5cGUpO1xuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCBBcnJheUJ1ZmZlclByb3RvdHlwZSk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGdldEludGVybmFsU3RhdGUoYnVmZmVyKS5ieXRlTGVuZ3RoO1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXJPckluZmluaXR5KGJ5dGVPZmZzZXQpO1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0Jyk7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoKGJ5dGVMZW5ndGgpO1xuICAgIGlmIChvZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgIGJ5dGVMZW5ndGg6IGJ5dGVMZW5ndGgsXG4gICAgICBieXRlT2Zmc2V0OiBvZmZzZXRcbiAgICB9KTtcbiAgICBpZiAoIURFU0NSSVBUT1JTKSB7XG4gICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG4gICAgICB0aGlzLmJ5dGVPZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuICB9O1xuXG4gIERhdGFWaWV3UHJvdG90eXBlID0gJERhdGFWaWV3W1BST1RPVFlQRV07XG5cbiAgaWYgKERFU0NSSVBUT1JTKSB7XG4gICAgYWRkR2V0dGVyKCRBcnJheUJ1ZmZlciwgJ2J5dGVMZW5ndGgnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCAnYnVmZmVyJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgJ2J5dGVMZW5ndGgnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCAnYnl0ZU9mZnNldCcpO1xuICB9XG5cbiAgZGVmaW5lQnVpbHRJbnMoRGF0YVZpZXdQcm90b3R5cGUsIHtcbiAgICBnZXRJbnQ4OiBmdW5jdGlvbiBnZXRJbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfSxcbiAgICBnZXRVaW50ODogZnVuY3Rpb24gZ2V0VWludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgICAgcmV0dXJuIChieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF0pIDw8IDE2ID4+IDE2O1xuICAgIH0sXG4gICAgZ2V0VWludDE2OiBmdW5jdGlvbiBnZXRVaW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICAgIHJldHVybiBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG4gICAgfSxcbiAgICBnZXRJbnQzMjogZnVuY3Rpb24gZ2V0SW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0ludDMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0ludDMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpID4+PiAwO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpLCAyMyk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCksIDUyKTtcbiAgICB9LFxuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSW50OCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0ludDgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldEludDE2OiBmdW5jdGlvbiBzZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJbnQxNiwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNldFVpbnQxNjogZnVuY3Rpb24gc2V0VWludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0ludDE2LCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc2V0SW50MzI6IGZ1bmN0aW9uIHNldEludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0ludDMyLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc2V0VWludDMyOiBmdW5jdGlvbiBzZXRVaW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSW50MzIsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDMyOiBmdW5jdGlvbiBzZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0Zsb2F0MzIsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgcGFja0Zsb2F0NjQsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHZhciBJTkNPUlJFQ1RfQVJSQVlfQlVGRkVSX05BTUUgPSBQUk9QRVJfRlVOQ1RJT05fTkFNRSAmJiBOYXRpdmVBcnJheUJ1ZmZlci5uYW1lICE9PSBBUlJBWV9CVUZGRVI7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuICBpZiAoIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBOYXRpdmVBcnJheUJ1ZmZlcigxKTtcbiAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoLTEpO1xuICB9KSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IE5hdGl2ZUFycmF5QnVmZmVyKCk7XG4gICAgbmV3IE5hdGl2ZUFycmF5QnVmZmVyKDEuNSk7XG4gICAgbmV3IE5hdGl2ZUFycmF5QnVmZmVyKE5hTik7XG4gICAgcmV0dXJuIElOQ09SUkVDVF9BUlJBWV9CVUZGRVJfTkFNRSAmJiAhQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUU7XG4gIH0pKSB7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tbmV3IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG4gICAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgICBhbkluc3RhbmNlKHRoaXMsIEFycmF5QnVmZmVyUHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBuZXcgTmF0aXZlQXJyYXlCdWZmZXIodG9JbmRleChsZW5ndGgpKTtcbiAgICB9O1xuXG4gICAgJEFycmF5QnVmZmVyW1BST1RPVFlQRV0gPSBBcnJheUJ1ZmZlclByb3RvdHlwZTtcblxuICAgIGZvciAodmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKE5hdGl2ZUFycmF5QnVmZmVyKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOykge1xuICAgICAgaWYgKCEoKGtleSA9IGtleXNbaisrXSkgaW4gJEFycmF5QnVmZmVyKSkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoJEFycmF5QnVmZmVyLCBrZXksIE5hdGl2ZUFycmF5QnVmZmVyW2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIEFycmF5QnVmZmVyUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9IGVsc2UgaWYgKElOQ09SUkVDVF9BUlJBWV9CVUZGRVJfTkFNRSAmJiBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShOYXRpdmVBcnJheUJ1ZmZlciwgJ25hbWUnLCBBUlJBWV9CVUZGRVIpO1xuICB9XG5cbiAgLy8gV2ViS2l0IGJ1ZyAtIHRoZSBzYW1lIHBhcmVudCBwcm90b3R5cGUgZm9yIHR5cGVkIGFycmF5cyBhbmQgZGF0YSB2aWV3XG4gIGlmIChzZXRQcm90b3R5cGVPZiAmJiBnZXRQcm90b3R5cGVPZihEYXRhVmlld1Byb3RvdHlwZSkgIT09IE9iamVjdFByb3RvdHlwZSkge1xuICAgIHNldFByb3RvdHlwZU9mKERhdGFWaWV3UHJvdG90eXBlLCBPYmplY3RQcm90b3R5cGUpO1xuICB9XG5cbiAgLy8gaU9TIFNhZmFyaSA3LnggYnVnXG4gIHZhciB0ZXN0VmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSk7XG4gIHZhciAkc2V0SW50OCA9IHVuY3VycnlUaGlzKERhdGFWaWV3UHJvdG90eXBlLnNldEludDgpO1xuICB0ZXN0Vmlldy5zZXRJbnQ4KDAsIDIxNDc0ODM2NDgpO1xuICB0ZXN0Vmlldy5zZXRJbnQ4KDEsIDIxNDc0ODM2NDkpO1xuICBpZiAodGVzdFZpZXcuZ2V0SW50OCgwKSB8fCAhdGVzdFZpZXcuZ2V0SW50OCgxKSkgZGVmaW5lQnVpbHRJbnMoRGF0YVZpZXdQcm90b3R5cGUsIHtcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4KHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9XG4gIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG5zZXRUb1N0cmluZ1RhZygkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG5zZXRUb1N0cmluZ1RhZygkRGF0YVZpZXcsIERBVEFfVklFVyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBcnJheUJ1ZmZlcjogJEFycmF5QnVmZmVyLFxuICBEYXRhVmlldzogJERhdGFWaWV3XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlJyk7XG52YXIgZGVsZXRlUHJvcGVydHlPclRocm93ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlbGV0ZS1wcm9wZXJ0eS1vci10aHJvdycpO1xuXG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbmAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5jb3B5d2l0aGluXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1hcnJheS1wcm90b3R5cGUtY29weXdpdGhpbiAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQgLyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICB2YXIgdG8gPSB0b0Fic29sdXRlSW5kZXgodGFyZ2V0LCBsZW4pO1xuICB2YXIgZnJvbSA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuKTtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgY291bnQgPSBtaW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKSkgLSBmcm9tLCBsZW4gLSB0byk7XG4gIHZhciBpbmMgPSAxO1xuICBpZiAoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KSB7XG4gICAgaW5jID0gLTE7XG4gICAgZnJvbSArPSBjb3VudCAtIDE7XG4gICAgdG8gKz0gY291bnQgLSAxO1xuICB9XG4gIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZVByb3BlcnR5T3JUaHJvdyhPLCB0byk7XG4gICAgdG8gKz0gaW5jO1xuICAgIGZyb20gKz0gaW5jO1xuICB9IHJldHVybiBPO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZpbGxgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsbFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShPKTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xuICB2YXIgZW5kID0gYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5mb3JFYWNoO1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdCcpO1xuXG52YXIgU1RSSUNUX01FVEhPRCA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ2ZvckVhY2gnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbm1vZHVsZS5leHBvcnRzID0gIVNUUklDVF9NRVRIT0QgPyBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1hcnJheS1wcm90b3R5cGUtZm9yZWFjaCAtLSBzYWZlXG59IDogW10uZm9yRWFjaDtcbiIsInZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgbGlzdCkge1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UobGlzdCk7XG4gIHZhciByZXN1bHQgPSBuZXcgQ29uc3RydWN0b3IobGVuZ3RoKTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nJyk7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIGlzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY29uc3RydWN0b3InKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvcicpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QnKTtcblxudmFyICRBcnJheSA9IEFycmF5O1xuXG4vLyBgQXJyYXkuZnJvbWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gIHZhciBJU19DT05TVFJVQ1RPUiA9IGlzQ29uc3RydWN0b3IodGhpcyk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgbWFwZm4gPSBhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gIGlmIChtYXBwaW5nKSBtYXBmbiA9IGJpbmQobWFwZm4sIGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChPKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvciwgbmV4dCwgdmFsdWU7XG4gIC8vIGlmIHRoZSB0YXJnZXQgaXMgbm90IGl0ZXJhYmxlIG9yIGl0J3MgYW4gYXJyYXkgd2l0aCB0aGUgZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBhIHNpbXBsZSBjYXNlXG4gIGlmIChpdGVyYXRvck1ldGhvZCAmJiAhKHRoaXMgPT09ICRBcnJheSAmJiBpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlcmF0b3JNZXRob2QpKSkge1xuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoTywgaXRlcmF0b3JNZXRob2QpO1xuICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICAgIHJlc3VsdCA9IElTX0NPTlNUUlVDVE9SID8gbmV3IHRoaXMoKSA6IFtdO1xuICAgIGZvciAoOyEoc3RlcCA9IGNhbGwobmV4dCwgaXRlcmF0b3IpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICB2YWx1ZSA9IG1hcHBpbmcgPyBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlO1xuICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShPKTtcbiAgICByZXN1bHQgPSBJU19DT05TVFJVQ1RPUiA/IG5ldyB0aGlzKGxlbmd0aCkgOiAkQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgdmFsdWUgPSBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdO1xuICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwidmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kKHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG4iLCJ2YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UnKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGZvckVhY2gsIG1hcCwgZmlsdGVyLCBzb21lLCBldmVyeSwgZmluZCwgZmluZEluZGV4LCBmaWx0ZXJSZWplY3QgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgSVNfRklMVEVSX1JFSkVDVCA9IFRZUEUgPT0gNztcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQsIHNwZWNpZmljQ3JlYXRlKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJbmRleGVkT2JqZWN0KE8pO1xuICAgIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZChjYWxsYmFja2ZuLCB0aGF0KTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2Uoc2VsZik7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY3JlYXRlID0gc3BlY2lmaWNDcmVhdGUgfHwgYXJyYXlTcGVjaWVzQ3JlYXRlO1xuICAgIHZhciB0YXJnZXQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgfHwgSVNfRklMVEVSX1JFSkVDVCA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbHVlLCByZXN1bHQ7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWx1ZSA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzdWx0ID0gYm91bmRGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgdGFyZ2V0W2luZGV4XSA9IHJlc3VsdDsgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdCkgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWx1ZTsgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHB1c2godGFyZ2V0LCB2YWx1ZSk7ICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBmYWxzZTsgICAgICAgICAgICAgLy8gZXZlcnlcbiAgICAgICAgICBjYXNlIDc6IHB1c2godGFyZ2V0LCB2YWx1ZSk7ICAgICAgLy8gZmlsdGVyUmVqZWN0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHRhcmdldDtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG4gIGZvckVhY2g6IGNyZWF0ZU1ldGhvZCgwKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5tYXBgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5tYXBcbiAgbWFwOiBjcmVhdGVNZXRob2QoMSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsdGVyXG4gIGZpbHRlcjogY3JlYXRlTWV0aG9kKDIpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLnNvbWVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb21lXG4gIHNvbWU6IGNyZWF0ZU1ldGhvZCgzKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5ldmVyeWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmV2ZXJ5XG4gIGV2ZXJ5OiBjcmVhdGVNZXRob2QoNCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRcbiAgZmluZDogY3JlYXRlTWV0aG9kKDUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRJbmRleFxuICBmaW5kSW5kZXg6IGNyZWF0ZU1ldGhvZCg2KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJSZWplY3RgIG1ldGhvZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hcnJheS1maWx0ZXJpbmdcbiAgZmlsdGVyUmVqZWN0OiBjcmVhdGVNZXRob2QoNylcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLWFycmF5LXByb3RvdHlwZS1sYXN0aW5kZXhvZiAtLSBzYWZlICovXG52YXIgYXBwbHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYXBwbHknKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHknKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdCcpO1xuXG52YXIgbWluID0gTWF0aC5taW47XG52YXIgJGxhc3RJbmRleE9mID0gW10ubGFzdEluZGV4T2Y7XG52YXIgTkVHQVRJVkVfWkVSTyA9ICEhJGxhc3RJbmRleE9mICYmIDEgLyBbMV0ubGFzdEluZGV4T2YoMSwgLTApIDwgMDtcbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgnbGFzdEluZGV4T2YnKTtcbnZhciBGT1JDRUQgPSBORUdBVElWRV9aRVJPIHx8ICFTVFJJQ1RfTUVUSE9EO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmxhc3RpbmRleG9mXG5tb2R1bGUuZXhwb3J0cyA9IEZPUkNFRCA/IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggPSBAWyotMV0gKi8pIHtcbiAgLy8gY29udmVydCAtMCB0byArMFxuICBpZiAoTkVHQVRJVkVfWkVSTykgcmV0dXJuIGFwcGx5KCRsYXN0SW5kZXhPZiwgdGhpcywgYXJndW1lbnRzKSB8fCAwO1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGluZGV4ID0gbWluKGluZGV4LCB0b0ludGVnZXJPckluZmluaXR5KGFyZ3VtZW50c1sxXSkpO1xuICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IGxlbmd0aCArIGluZGV4O1xuICBmb3IgKDtpbmRleCA+PSAwOyBpbmRleC0tKSBpZiAoaW5kZXggaW4gTyAmJiBPW2luZGV4XSA9PT0gc2VhcmNoRWxlbWVudCkgcmV0dXJuIGluZGV4IHx8IDA7XG4gIHJldHVybiAtMTtcbn0gOiAkbGFzdEluZGV4T2Y7XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBWOF9WRVJTSU9OID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuICAvLyBkZW9wdGltaXphdGlvbiBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc3XG4gIHJldHVybiBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gYXJyYXkuY29uc3RydWN0b3IgPSB7fTtcbiAgICBjb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGZvbzogMSB9O1xuICAgIH07XG4gICAgcmV0dXJuIGFycmF5W01FVEhPRF9OQU1FXShCb29sZWFuKS5mb28gIT09IDE7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSwgYXJndW1lbnQpIHtcbiAgdmFyIG1ldGhvZCA9IFtdW01FVEhPRF9OQU1FXTtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgbWV0aG9kLmNhbGwobnVsbCwgYXJndW1lbnQgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gMTsgfSwgMSk7XG4gIH0pO1xufTtcbiIsInZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IHJlZHVjZSwgcmVkdWNlUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19SSUdIVCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c0xlbmd0aCwgbWVtbykge1xuICAgIGFDYWxsYWJsZShjYWxsYmFja2ZuKTtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gICAgdmFyIGluZGV4ID0gSVNfUklHSFQgPyBsZW5ndGggLSAxIDogMDtcbiAgICB2YXIgaSA9IElTX1JJR0hUID8gLTEgOiAxO1xuICAgIGlmIChhcmd1bWVudHNMZW5ndGggPCAyKSB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGluZGV4ICs9IGk7XG4gICAgICBpZiAoSVNfUklHSFQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgICAgdGhyb3cgJFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKDtJU19SSUdIVCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIHNlbGZbaW5kZXhdLCBpbmRleCwgTyk7XG4gICAgfVxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG4gIGxlZnQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VyaWdodFxuICByaWdodDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuIiwidmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5Jyk7XG5cbnZhciAkQXJyYXkgPSBBcnJheTtcbnZhciBtYXggPSBNYXRoLm1heDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gIHZhciBrID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpO1xuICB2YXIgcmVzdWx0ID0gJEFycmF5KG1heChmaW4gLSBrLCAwKSk7XG4gIGZvciAodmFyIG4gPSAwOyBrIDwgZmluOyBrKyssIG4rKykgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBuLCBPW2tdKTtcbiAgcmVzdWx0Lmxlbmd0aCA9IG47XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwidmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVuY3VycnlUaGlzKFtdLnNsaWNlKTtcbiIsInZhciBhcnJheVNsaWNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNsaWNlLXNpbXBsZScpO1xuXG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG52YXIgbWVyZ2VTb3J0ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIG1pZGRsZSA9IGZsb29yKGxlbmd0aCAvIDIpO1xuICByZXR1cm4gbGVuZ3RoIDwgOCA/IGluc2VydGlvblNvcnQoYXJyYXksIGNvbXBhcmVmbikgOiBtZXJnZShcbiAgICBhcnJheSxcbiAgICBtZXJnZVNvcnQoYXJyYXlTbGljZShhcnJheSwgMCwgbWlkZGxlKSwgY29tcGFyZWZuKSxcbiAgICBtZXJnZVNvcnQoYXJyYXlTbGljZShhcnJheSwgbWlkZGxlKSwgY29tcGFyZWZuKSxcbiAgICBjb21wYXJlZm5cbiAgKTtcbn07XG5cbnZhciBpbnNlcnRpb25Tb3J0ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIGkgPSAxO1xuICB2YXIgZWxlbWVudCwgajtcblxuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIGogPSBpO1xuICAgIGVsZW1lbnQgPSBhcnJheVtpXTtcbiAgICB3aGlsZSAoaiAmJiBjb21wYXJlZm4oYXJyYXlbaiAtIDFdLCBlbGVtZW50KSA+IDApIHtcbiAgICAgIGFycmF5W2pdID0gYXJyYXlbLS1qXTtcbiAgICB9XG4gICAgaWYgKGogIT09IGkrKykgYXJyYXlbal0gPSBlbGVtZW50O1xuICB9IHJldHVybiBhcnJheTtcbn07XG5cbnZhciBtZXJnZSA9IGZ1bmN0aW9uIChhcnJheSwgbGVmdCwgcmlnaHQsIGNvbXBhcmVmbikge1xuICB2YXIgbGxlbmd0aCA9IGxlZnQubGVuZ3RoO1xuICB2YXIgcmxlbmd0aCA9IHJpZ2h0Lmxlbmd0aDtcbiAgdmFyIGxpbmRleCA9IDA7XG4gIHZhciByaW5kZXggPSAwO1xuXG4gIHdoaWxlIChsaW5kZXggPCBsbGVuZ3RoIHx8IHJpbmRleCA8IHJsZW5ndGgpIHtcbiAgICBhcnJheVtsaW5kZXggKyByaW5kZXhdID0gKGxpbmRleCA8IGxsZW5ndGggJiYgcmluZGV4IDwgcmxlbmd0aClcbiAgICAgID8gY29tcGFyZWZuKGxlZnRbbGluZGV4XSwgcmlnaHRbcmluZGV4XSkgPD0gMCA/IGxlZnRbbGluZGV4KytdIDogcmlnaHRbcmluZGV4KytdXG4gICAgICA6IGxpbmRleCA8IGxsZW5ndGggPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXTtcbiAgfSByZXR1cm4gYXJyYXk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlU29ydDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG52YXIgaXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jb25zdHJ1Y3RvcicpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xudmFyICRBcnJheSA9IEFycmF5O1xuXG4vLyBhIHBhcnQgb2YgYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWxBcnJheSkpIHtcbiAgICBDID0gb3JpZ2luYWxBcnJheS5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmIChpc0NvbnN0cnVjdG9yKEMpICYmIChDID09PSAkQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGVsc2UgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gJEFycmF5IDogQztcbn07XG4iLCJ2YXIgYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG4vLyBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoYXJyYXlTcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWxBcnJheSkpKGxlbmd0aCA9PT0gMCA/IDAgOiBsZW5ndGgpO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpdGVyYXRvckNsb3NlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlJyk7XG5cbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIEVOVFJJRVMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gRU5UUklFUyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICd0aHJvdycsIGVycm9yKTtcbiAgfVxufTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgY2FsbGVkID0gMDtcbiAgdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBkb25lOiAhIWNhbGxlZCsrIH07XG4gICAgfSxcbiAgICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xuICAgICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGl0ZXJhdG9yV2l0aFJldHVybltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWFycmF5LWZyb20sIG5vLXRocm93LWxpdGVyYWwgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgQXJyYXkuZnJvbShpdGVyYXRvcldpdGhSZXR1cm4sIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIFNLSVBfQ0xPU0lORykge1xuICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICBvYmplY3RbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IElURVJBVElPTl9TVVBQT1JUID0gdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhlYyhvYmplY3QpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBJVEVSQVRJT05fU1VQUE9SVDtcbn07XG4iLCJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG5cbnZhciB0b1N0cmluZyA9IHVuY3VycnlUaGlzKHt9LnRvU3RyaW5nKTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHN0cmluZ1NsaWNlKHRvU3RyaW5nKGl0KSwgOCwgLTEpO1xufTtcbiIsInZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGNsYXNzb2ZSYXcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2Bcbm1vZHVsZS5leHBvcnRzID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9ICRPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiBpc0NhbGxhYmxlKE8uY2FsbGVlKSA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlZmluZUJ1aWx0SW5zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbnMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2UnKTtcbnZhciBpdGVyYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdGUnKTtcbnZhciBkZWZpbmVJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3InKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1zcGVjaWVzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBmYXN0S2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhJykuZmFzdEtleTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG5cbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgaW50ZXJuYWxTdGF0ZUdldHRlckZvciA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgUHJvdG90eXBlKTtcbiAgICAgIHNldEludGVybmFsU3RhdGUodGhhdCwge1xuICAgICAgICB0eXBlOiBDT05TVFJVQ1RPUl9OQU1FLFxuICAgICAgICBpbmRleDogY3JlYXRlKG51bGwpLFxuICAgICAgICBmaXJzdDogdW5kZWZpbmVkLFxuICAgICAgICBsYXN0OiB1bmRlZmluZWQsXG4gICAgICAgIHNpemU6IDBcbiAgICAgIH0pO1xuICAgICAgaWYgKCFERVNDUklQVE9SUykgdGhhdC5zaXplID0gMDtcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGl0ZXJhdGUoaXRlcmFibGUsIHRoYXRbQURERVJdLCB7IHRoYXQ6IHRoYXQsIEFTX0VOVFJJRVM6IElTX01BUCB9KTtcbiAgICB9KTtcblxuICAgIHZhciBQcm90b3R5cGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoQ09OU1RSVUNUT1JfTkFNRSk7XG5cbiAgICB2YXIgZGVmaW5lID0gZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgdmFyIHByZXZpb3VzLCBpbmRleDtcbiAgICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIGVudHJ5LnZhbHVlID0gdmFsdWU7XG4gICAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5sYXN0ID0gZW50cnkgPSB7XG4gICAgICAgICAgaW5kZXg6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLFxuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBwcmV2aW91czogcHJldmlvdXMgPSBzdGF0ZS5sYXN0LFxuICAgICAgICAgIG5leHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICByZW1vdmVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXN0YXRlLmZpcnN0KSBzdGF0ZS5maXJzdCA9IGVudHJ5O1xuICAgICAgICBpZiAocHJldmlvdXMpIHByZXZpb3VzLm5leHQgPSBlbnRyeTtcbiAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplKys7XG4gICAgICAgIGVsc2UgdGhhdC5zaXplKys7XG4gICAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgICBpZiAoaW5kZXggIT09ICdGJykgc3RhdGUuaW5kZXhbaW5kZXhdID0gZW50cnk7XG4gICAgICB9IHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgLy8gZmFzdCBjYXNlXG4gICAgICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSk7XG4gICAgICB2YXIgZW50cnk7XG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHN0YXRlLmluZGV4W2luZGV4XTtcbiAgICAgIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICAgICAgZm9yIChlbnRyeSA9IHN0YXRlLmZpcnN0OyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uZXh0KSB7XG4gICAgICAgIGlmIChlbnRyeS5rZXkgPT0ga2V5KSByZXR1cm4gZW50cnk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRlZmluZUJ1aWx0SW5zKFByb3RvdHlwZSwge1xuICAgICAgLy8gYHsgTWFwLCBTZXQgfS5wcm90b3R5cGUuY2xlYXIoKWAgbWV0aG9kc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmNsZWFyXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuY2xlYXJcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgICB2YXIgZGF0YSA9IHN0YXRlLmluZGV4O1xuICAgICAgICB2YXIgZW50cnkgPSBzdGF0ZS5maXJzdDtcbiAgICAgICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICAgICAgZW50cnkucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKGVudHJ5LnByZXZpb3VzKSBlbnRyeS5wcmV2aW91cyA9IGVudHJ5LnByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaW5kZXhdO1xuICAgICAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5maXJzdCA9IHN0YXRlLmxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChERVNDUklQVE9SUykgc3RhdGUuc2l6ZSA9IDA7XG4gICAgICAgIGVsc2UgdGhhdC5zaXplID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS5kZWxldGUoa2V5KWAgbWV0aG9kc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmRlbGV0ZVxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmRlbGV0ZVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5leHQ7XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wcmV2aW91cztcbiAgICAgICAgICBkZWxldGUgc3RhdGUuaW5kZXhbZW50cnkuaW5kZXhdO1xuICAgICAgICAgIGVudHJ5LnJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm5leHQgPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnByZXZpb3VzID0gcHJldjtcbiAgICAgICAgICBpZiAoc3RhdGUuZmlyc3QgPT0gZW50cnkpIHN0YXRlLmZpcnN0ID0gbmV4dDtcbiAgICAgICAgICBpZiAoc3RhdGUubGFzdCA9PSBlbnRyeSkgc3RhdGUubGFzdCA9IHByZXY7XG4gICAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplLS07XG4gICAgICAgICAgZWxzZSB0aGF0LnNpemUtLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuZm9yZWFjaFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmZvcmVhY2hcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm5leHQgOiBzdGF0ZS5maXJzdCkge1xuICAgICAgICAgIGJvdW5kRnVuY3Rpb24oZW50cnkudmFsdWUsIGVudHJ5LmtleSwgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpIGVudHJ5ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBgeyBNYXAsIFNldH0ucHJvdG90eXBlLmhhcyhrZXkpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuaGFzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuaGFzXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRlZmluZUJ1aWx0SW5zKFByb3RvdHlwZSwgSVNfTUFQID8ge1xuICAgICAgLy8gYE1hcC5wcm90b3R5cGUuZ2V0KGtleSlgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmdldFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52YWx1ZTtcbiAgICAgIH0sXG4gICAgICAvLyBgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLnNldFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IDoge1xuICAgICAgLy8gYFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuYWRkXG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5KFByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH0sXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApIHtcbiAgICB2YXIgSVRFUkFUT1JfTkFNRSA9IENPTlNUUlVDVE9SX05BTUUgKyAnIEl0ZXJhdG9yJztcbiAgICB2YXIgZ2V0SW50ZXJuYWxDb2xsZWN0aW9uU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKENPTlNUUlVDVE9SX05BTUUpO1xuICAgIHZhciBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKElURVJBVE9SX05BTUUpO1xuICAgIC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlLnsga2V5cywgdmFsdWVzLCBlbnRyaWVzLCBAQGl0ZXJhdG9yIH0oKWAgbWV0aG9kc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5lbnRyaWVzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmtleXNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUudmFsdWVzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLUBAaXRlcmF0b3JcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuZW50cmllc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5rZXlzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLnZhbHVlc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4gICAgZGVmaW5lSXRlcmF0b3IoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IElURVJBVE9SX05BTUUsXG4gICAgICAgIHRhcmdldDogaXRlcmF0ZWQsXG4gICAgICAgIHN0YXRlOiBnZXRJbnRlcm5hbENvbGxlY3Rpb25TdGF0ZShpdGVyYXRlZCksXG4gICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgIGxhc3Q6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlKHRoaXMpO1xuICAgICAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICAgICAgdmFyIGVudHJ5ID0gc3RhdGUubGFzdDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpIGVudHJ5ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYgKCFzdGF0ZS50YXJnZXQgfHwgIShzdGF0ZS5sYXN0ID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm5leHQgOiBzdGF0ZS5zdGF0ZS5maXJzdCkpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7IHZhbHVlOiBlbnRyeS5rZXksIGRvbmU6IGZhbHNlIH07XG4gICAgICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHsgdmFsdWU6IGVudHJ5LnZhbHVlLCBkb25lOiBmYWxzZSB9O1xuICAgICAgcmV0dXJuIHsgdmFsdWU6IFtlbnRyeS5rZXksIGVudHJ5LnZhbHVlXSwgZG9uZTogZmFsc2UgfTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZVtAQHNwZWNpZXNdYCBhY2Nlc3NvcnNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1tYXAtQEBzcGVjaWVzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtc2V0LUBAc3BlY2llc1xuICAgIHNldFNwZWNpZXMoQ09OU1RSVUNUT1JfTkFNRSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhJyk7XG52YXIgaXRlcmF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRlJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1pbnN0YW5jZScpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24nKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSwgd3JhcHBlciwgY29tbW9uKSB7XG4gIHZhciBJU19NQVAgPSBDT05TVFJVQ1RPUl9OQU1FLmluZGV4T2YoJ01hcCcpICE9PSAtMTtcbiAgdmFyIElTX1dFQUsgPSBDT05TVFJVQ1RPUl9OQU1FLmluZGV4T2YoJ1dlYWsnKSAhPT0gLTE7XG4gIHZhciBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCc7XG4gIHZhciBOYXRpdmVDb25zdHJ1Y3RvciA9IGdsb2JhbFtDT05TVFJVQ1RPUl9OQU1FXTtcbiAgdmFyIE5hdGl2ZVByb3RvdHlwZSA9IE5hdGl2ZUNvbnN0cnVjdG9yICYmIE5hdGl2ZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgdmFyIENvbnN0cnVjdG9yID0gTmF0aXZlQ29uc3RydWN0b3I7XG4gIHZhciBleHBvcnRlZCA9IHt9O1xuXG4gIHZhciBmaXhNZXRob2QgPSBmdW5jdGlvbiAoS0VZKSB7XG4gICAgdmFyIHVuY3VycmllZE5hdGl2ZU1ldGhvZCA9IHVuY3VycnlUaGlzKE5hdGl2ZVByb3RvdHlwZVtLRVldKTtcbiAgICBkZWZpbmVCdWlsdEluKE5hdGl2ZVByb3RvdHlwZSwgS0VZLFxuICAgICAgS0VZID09ICdhZGQnID8gZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgICAgIHVuY3VycmllZE5hdGl2ZU1ldGhvZCh0aGlzLCB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSA6IEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGtleSkgPyBmYWxzZSA6IHVuY3VycmllZE5hdGl2ZU1ldGhvZCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5KTtcbiAgICAgIH0gOiBLRVkgPT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChrZXkpID8gdW5kZWZpbmVkIDogdW5jdXJyaWVkTmF0aXZlTWV0aG9kKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXkpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGtleSkgPyBmYWxzZSA6IHVuY3VycmllZE5hdGl2ZU1ldGhvZCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5KTtcbiAgICAgIH0gOiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB1bmN1cnJpZWROYXRpdmVNZXRob2QodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICApO1xuICB9O1xuXG4gIHZhciBSRVBMQUNFID0gaXNGb3JjZWQoXG4gICAgQ09OU1RSVUNUT1JfTkFNRSxcbiAgICAhaXNDYWxsYWJsZShOYXRpdmVDb25zdHJ1Y3RvcikgfHwgIShJU19XRUFLIHx8IE5hdGl2ZVByb3RvdHlwZS5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBuZXcgTmF0aXZlQ29uc3RydWN0b3IoKS5lbnRyaWVzKCkubmV4dCgpO1xuICAgIH0pKVxuICApO1xuXG4gIGlmIChSRVBMQUNFKSB7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDb25zdHJ1Y3RvciA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlLmVuYWJsZSgpO1xuICB9IGVsc2UgaWYgKGlzRm9yY2VkKENPTlNUUlVDVE9SX05BTUUsIHRydWUpKSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgLy8gZWFybHkgaW1wbGVtZW50YXRpb25zIG5vdCBzdXBwb3J0cyBjaGFpbmluZ1xuICAgIHZhciBIQVNOVF9DSEFJTklORyA9IGluc3RhbmNlW0FEREVSXShJU19XRUFLID8ge30gOiAtMCwgMSkgIT0gaW5zdGFuY2U7XG4gICAgLy8gVjggfiBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XG4gICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXcgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgICB2YXIgQUNDRVBUX0lURVJBQkxFUyA9IGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHsgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGl0ZXJhYmxlKTsgfSk7XG4gICAgLy8gZm9yIGVhcmx5IGltcGxlbWVudGF0aW9ucyAtMCBhbmQgKzAgbm90IHRoZSBzYW1lXG4gICAgdmFyIEJVR0dZX1pFUk8gPSAhSVNfV0VBSyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBWOCB+IENocm9taXVtIDQyLSBmYWlscyBvbmx5IHdpdGggNSsgZWxlbWVudHNcbiAgICAgIHZhciAkaW5zdGFuY2UgPSBuZXcgTmF0aXZlQ29uc3RydWN0b3IoKTtcbiAgICAgIHZhciBpbmRleCA9IDU7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICB9KTtcblxuICAgIGlmICghQUNDRVBUX0lURVJBQkxFUykge1xuICAgICAgQ29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uIChkdW1teSwgaXRlcmFibGUpIHtcbiAgICAgICAgYW5JbnN0YW5jZShkdW1teSwgTmF0aXZlUHJvdG90eXBlKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgTmF0aXZlQ29uc3RydWN0b3IoKSwgZHVtbXksIENvbnN0cnVjdG9yKTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgaXRlcmF0ZShpdGVyYWJsZSwgdGhhdFtBRERFUl0sIHsgdGhhdDogdGhhdCwgQVNfRU5UUklFUzogSVNfTUFQIH0pO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gTmF0aXZlUHJvdG90eXBlO1xuICAgICAgTmF0aXZlUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgfVxuXG4gICAgaWYgKFRIUk9XU19PTl9QUklNSVRJVkVTIHx8IEJVR0dZX1pFUk8pIHtcbiAgICAgIGZpeE1ldGhvZCgnZGVsZXRlJyk7XG4gICAgICBmaXhNZXRob2QoJ2hhcycpO1xuICAgICAgSVNfTUFQICYmIGZpeE1ldGhvZCgnZ2V0Jyk7XG4gICAgfVxuXG4gICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7XG5cbiAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIHNob3VsZCBub3QgY29udGFpbnMgLmNsZWFyIG1ldGhvZFxuICAgIGlmIChJU19XRUFLICYmIE5hdGl2ZVByb3RvdHlwZS5jbGVhcikgZGVsZXRlIE5hdGl2ZVByb3RvdHlwZS5jbGVhcjtcbiAgfVxuXG4gIGV4cG9ydGVkW0NPTlNUUlVDVE9SX05BTUVdID0gQ29uc3RydWN0b3I7XG4gICQoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCBmb3JjZWQ6IENvbnN0cnVjdG9yICE9IE5hdGl2ZUNvbnN0cnVjdG9yIH0sIGV4cG9ydGVkKTtcblxuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSk7XG5cbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn07XG4iLCJ2YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL293bi1rZXlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBleGNlcHRpb25zKSB7XG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICghaGFzT3duKHRhcmdldCwga2V5KSAmJiAhKGV4Y2VwdGlvbnMgJiYgaGFzT3duKGV4Y2VwdGlvbnMsIGtleSkpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfVxuICB9XG59O1xuIiwidmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgTUFUQ0ggPSB3ZWxsS25vd25TeW1ib2woJ21hdGNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIHZhciByZWdleHAgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG4gIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgIHRyeSB7XG4gICAgICByZWdleHBbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7IC8qIGVtcHR5ICovIH1cbiAgfSByZXR1cm4gZmFsc2U7XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlJykuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0LCBFTlVNRVJBQkxFX05FWFQpIHtcbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIEl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigrIUVOVU1FUkFCTEVfTkVYVCwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcbiAgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXknKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChwcm9wZXJ0eUtleSBpbiBvYmplY3QpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W3Byb3BlcnR5S2V5XSA9IHZhbHVlO1xufTtcbiIsInZhciBtYWtlQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9tYWtlLWJ1aWx0LWluJyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgaWYgKGRlc2NyaXB0b3IuZ2V0KSBtYWtlQnVpbHRJbihkZXNjcmlwdG9yLmdldCwgbmFtZSwgeyBnZXR0ZXI6IHRydWUgfSk7XG4gIGlmIChkZXNjcmlwdG9yLnNldCkgbWFrZUJ1aWx0SW4oZGVzY3JpcHRvci5zZXQsIG5hbWUsIHsgc2V0dGVyOiB0cnVlIH0pO1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkuZih0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpO1xufTtcbiIsInZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIG1ha2VCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL21ha2UtYnVpbHQtaW4nKTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtZ2xvYmFsLXByb3BlcnR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zLmVudW1lcmFibGU7XG4gIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5hbWUgOiBrZXk7XG4gIGlmIChpc0NhbGxhYmxlKHZhbHVlKSkgbWFrZUJ1aWx0SW4odmFsdWUsIG5hbWUsIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5nbG9iYWwpIHtcbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIGRlZmluZUdsb2JhbFByb3BlcnR5KGtleSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGlmICghb3B0aW9ucy51bnNhZmUpIGRlbGV0ZSBPW2tleV07XG4gICAgZWxzZSBpZiAoT1trZXldKSBzaW1wbGUgPSB0cnVlO1xuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KE8sIGtleSwgdmFsdWUpO1xuICB9IHJldHVybiBPO1xufTtcbiIsInZhciBkZWZpbmVCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBkZWZpbmVCdWlsdEluKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGRlZmluZVByb3BlcnR5KGdsb2JhbCwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBnbG9iYWxba2V5XSA9IHZhbHVlO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBGdW5jdGlvbk5hbWUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZScpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3RvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBkZWZpbmVCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbicpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcbnZhciBJdGVyYXRvcnNDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlJyk7XG5cbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSA9IEZ1bmN0aW9uTmFtZS5QUk9QRVI7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSBGdW5jdGlvbk5hbWUuQ09ORklHVVJBQkxFO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gSXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gSXRlcmF0b3JzQ29yZS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTO1xudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG52YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcblxuICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcbiAgICBpZiAoS0lORCA9PT0gREVGQVVMVCAmJiBkZWZhdWx0SXRlcmF0b3IpIHJldHVybiBkZWZhdWx0SXRlcmF0b3I7XG4gICAgaWYgKCFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTtcbiAgICBzd2l0Y2ggKEtJTkQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIEVOVFJJRVM6IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcyk7IH07XG4gIH07XG5cbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuICB2YXIgbmF0aXZlSXRlcmF0b3IgPSBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl1cbiAgICB8fCBJdGVyYWJsZVByb3RvdHlwZVsnQEBpdGVyYXRvciddXG4gICAgfHwgREVGQVVMVCAmJiBJdGVyYWJsZVByb3RvdHlwZVtERUZBVUxUXTtcbiAgdmFyIGRlZmF1bHRJdGVyYXRvciA9ICFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIG5hdGl2ZUl0ZXJhdG9yIHx8IGdldEl0ZXJhdGlvbk1ldGhvZChERUZBVUxUKTtcbiAgdmFyIGFueU5hdGl2ZUl0ZXJhdG9yID0gTkFNRSA9PSAnQXJyYXknID8gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcyB8fCBuYXRpdmVJdGVyYXRvciA6IG5hdGl2ZUl0ZXJhdG9yO1xuICB2YXIgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBtZXRob2RzLCBLRVk7XG5cbiAgLy8gZml4IG5hdGl2ZVxuICBpZiAoYW55TmF0aXZlSXRlcmF0b3IpIHtcbiAgICBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihhbnlOYXRpdmVJdGVyYXRvci5jYWxsKG5ldyBJdGVyYWJsZSgpKSk7XG4gICAgaWYgKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgaWYgKCFJU19QVVJFICYmIGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgIHNldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0NhbGxhYmxlKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0pKSB7XG4gICAgICAgICAgZGVmaW5lQnVpbHRJbihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCB0cnVlLCB0cnVlKTtcbiAgICAgIGlmIChJU19QVVJFKSBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpeCBBcnJheS5wcm90b3R5cGUueyB2YWx1ZXMsIEBAaXRlcmF0b3IgfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKFBST1BFUl9GVU5DVElPTl9OQU1FICYmIERFRkFVTFQgPT0gVkFMVUVTICYmIG5hdGl2ZUl0ZXJhdG9yICYmIG5hdGl2ZUl0ZXJhdG9yLm5hbWUgIT09IFZBTFVFUykge1xuICAgIGlmICghSVNfUFVSRSAmJiBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEl0ZXJhYmxlUHJvdG90eXBlLCAnbmFtZScsIFZBTFVFUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XG4gICAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBjYWxsKG5hdGl2ZUl0ZXJhdG9yLCB0aGlzKTsgfTtcbiAgICB9XG4gIH1cblxuICAvLyBleHBvcnQgYWRkaXRpb25hbCBtZXRob2RzXG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiBnZXRJdGVyYXRpb25NZXRob2QoRU5UUklFUylcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcbiAgICAgIGlmIChCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB8fCAhKEtFWSBpbiBJdGVyYWJsZVByb3RvdHlwZSkpIHtcbiAgICAgICAgZGVmaW5lQnVpbHRJbihJdGVyYWJsZVByb3RvdHlwZSwgS0VZLCBtZXRob2RzW0tFWV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSAkKHsgdGFyZ2V0OiBOQU1FLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB9LCBtZXRob2RzKTtcbiAgfVxuXG4gIC8vIGRlZmluZSBpdGVyYXRvclxuICBpZiAoKCFJU19QVVJFIHx8IEZPUkNFRCkgJiYgSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdICE9PSBkZWZhdWx0SXRlcmF0b3IpIHtcbiAgICBkZWZpbmVCdWlsdEluKEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiwgZGVmYXVsdEl0ZXJhdG9yLCB7IG5hbWU6IERFRkFVTFQgfSk7XG4gIH1cbiAgSXRlcmF0b3JzW05BTUVdID0gZGVmYXVsdEl0ZXJhdG9yO1xuXG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsInZhciBwYXRoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BhdGgnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtd3JhcHBlZCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FKSB7XG4gIHZhciBTeW1ib2wgPSBwYXRoLlN5bWJvbCB8fCAocGF0aC5TeW1ib2wgPSB7fSk7XG4gIGlmICghaGFzT3duKFN5bWJvbCwgTkFNRSkpIGRlZmluZVByb3BlcnR5KFN5bWJvbCwgTkFNRSwge1xuICAgIHZhbHVlOiB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYoTkFNRSlcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRyeVRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RyeS10by1zdHJpbmcnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIFApIHtcbiAgaWYgKCFkZWxldGUgT1tQXSkgdGhyb3cgJFR5cGVFcnJvcignQ2Fubm90IGRlbGV0ZSBwcm9wZXJ0eSAnICsgdHJ5VG9TdHJpbmcoUCkgKyAnIG9mICcgKyB0cnlUb1N0cmluZyhPKSk7XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbi8vIERldGVjdCBJRTgncyBpbmNvbXBsZXRlIGRlZmluZVByb3BlcnR5IGltcGxlbWVudGF0aW9uXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPSA3O1xufSk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG52YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBFWElTVFMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsInZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFGRkZGRkZGRkZGRkZGOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA+IE1BWF9TQUZFX0lOVEVHRVIpIHRocm93ICRUeXBlRXJyb3IoJ01heGltdW0gYWxsb3dlZCBpbmRleCBleGNlZWRlZCcpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gaXRlcmFibGUgRE9NIGNvbGxlY3Rpb25zXG4vLyBmbGFnIC0gYGl0ZXJhYmxlYCBpbnRlcmZhY2UgLSAnZW50cmllcycsICdrZXlzJywgJ3ZhbHVlcycsICdmb3JFYWNoJyBtZXRob2RzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IDAsXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IDAsXG4gIENTU1ZhbHVlTGlzdDogMCxcbiAgQ2xpZW50UmVjdExpc3Q6IDAsXG4gIERPTVJlY3RMaXN0OiAwLFxuICBET01TdHJpbmdMaXN0OiAwLFxuICBET01Ub2tlbkxpc3Q6IDEsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiAwLFxuICBGaWxlTGlzdDogMCxcbiAgSFRNTEFsbENvbGxlY3Rpb246IDAsXG4gIEhUTUxDb2xsZWN0aW9uOiAwLFxuICBIVE1MRm9ybUVsZW1lbnQ6IDAsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiAwLFxuICBNZWRpYUxpc3Q6IDAsXG4gIE1pbWVUeXBlQXJyYXk6IDAsXG4gIE5hbWVkTm9kZU1hcDogMCxcbiAgTm9kZUxpc3Q6IDEsXG4gIFBhaW50UmVxdWVzdExpc3Q6IDAsXG4gIFBsdWdpbjogMCxcbiAgUGx1Z2luQXJyYXk6IDAsXG4gIFNWR0xlbmd0aExpc3Q6IDAsXG4gIFNWR051bWJlckxpc3Q6IDAsXG4gIFNWR1BhdGhTZWdMaXN0OiAwLFxuICBTVkdQb2ludExpc3Q6IDAsXG4gIFNWR1N0cmluZ0xpc3Q6IDAsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IDAsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsXG4gIFN0eWxlU2hlZXRMaXN0OiAwLFxuICBUZXh0VHJhY2tDdWVMaXN0OiAwLFxuICBUZXh0VHJhY2tMaXN0OiAwLFxuICBUb3VjaExpc3Q6IDBcbn07XG4iLCIvLyBpbiBvbGQgV2ViS2l0IHZlcnNpb25zLCBgZWxlbWVudC5jbGFzc0xpc3RgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBnbG9iYWwgYERPTVRva2VuTGlzdGBcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcblxudmFyIGNsYXNzTGlzdCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnc3BhbicpLmNsYXNzTGlzdDtcbnZhciBET01Ub2tlbkxpc3RQcm90b3R5cGUgPSBjbGFzc0xpc3QgJiYgY2xhc3NMaXN0LmNvbnN0cnVjdG9yICYmIGNsYXNzTGlzdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NVG9rZW5MaXN0UHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlID8gdW5kZWZpbmVkIDogRE9NVG9rZW5MaXN0UHJvdG90eXBlO1xuIiwidmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudCcpO1xuXG52YXIgZmlyZWZveCA9IHVzZXJBZ2VudC5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS9pKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhIWZpcmVmb3ggJiYgK2ZpcmVmb3hbMV07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgdHlwZW9mIERlbm8gIT0gJ29iamVjdCc7XG4iLCJ2YXIgVUEgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAvTVNJRXxUcmlkZW50Ly50ZXN0KFVBKTtcbiIsInZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gL2lwYWR8aXBob25lfGlwb2QvaS50ZXN0KHVzZXJBZ2VudCkgJiYgZ2xvYmFsLlBlYmJsZSAhPT0gdW5kZWZpbmVkO1xuIiwidmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IC8oPzppcGFkfGlwaG9uZXxpcG9kKS4qYXBwbGV3ZWJraXQvaS50ZXN0KHVzZXJBZ2VudCk7XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzc29mKGdsb2JhbC5wcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG4iLCJ2YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gL3dlYjBzKD8hLipjaHJvbWUpL2kudGVzdCh1c2VyQWdlbnQpO1xuIiwidmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQnKTtcblxudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBEZW5vID0gZ2xvYmFsLkRlbm87XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnMgfHwgRGVubyAmJiBEZW5vLnZlcnNpb247XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcbiAgLy8gaW4gb2xkIENocm9tZSwgdmVyc2lvbnMgb2YgVjggaXNuJ3QgVjggPSBDaHJvbWUgLyAxMFxuICAvLyBidXQgdGhlaXIgY29ycmVjdCB2ZXJzaW9ucyBhcmUgbm90IGludGVyZXN0aW5nIGZvciB1c1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPiAwICYmIG1hdGNoWzBdIDwgNCA/IDEgOiArKG1hdGNoWzBdICsgbWF0Y2hbMV0pO1xufVxuXG4vLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcbi8vIHNvIGNoZWNrIGB1c2VyQWdlbnRgIGV2ZW4gaWYgYC52OGAgZXhpc3RzLCBidXQgMFxuaWYgKCF2ZXJzaW9uICYmIHVzZXJBZ2VudCkge1xuICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9ICttYXRjaFsxXTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZlcnNpb247XG4iLCJ2YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50Jyk7XG5cbnZhciB3ZWJraXQgPSB1c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvKFxcZCspXFwuLyk7XG5cbm1vZHVsZS5leHBvcnRzID0gISF3ZWJraXQgJiYgK3dlYmtpdFsxXTtcbiIsIi8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdjb25zdHJ1Y3RvcicsXG4gICdoYXNPd25Qcm9wZXJ0eScsXG4gICdpc1Byb3RvdHlwZU9mJyxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgJ3RvU3RyaW5nJyxcbiAgJ3ZhbHVlT2YnXG5dO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIGRlZmluZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluJyk7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWdsb2JhbC1wcm9wZXJ0eScpO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAgICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMuZG9udENhbGxHZXRTZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4gIG9wdGlvbnMubmFtZSAgICAgICAgICAgLSB0aGUgLm5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlmIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBrZXlcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG4gIGlmIChHTE9CQUwpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAoU1RBVElDKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsW1RBUkdFVF0gfHwgZGVmaW5lR2xvYmFsUHJvcGVydHkoVEFSR0VULCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gKGdsb2JhbFtUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG4gIH1cbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAob3B0aW9ucy5kb250Q2FsbEdldFNldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgIC8vIGNvbnRhaW5lZCBpbiB0YXJnZXRcbiAgICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICBkZWZpbmVCdWlsdEluKHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGAgc2luY2UgaXQncyBtb3ZlZCB0byBlbnRyeSBwb2ludHNcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBkZWZpbmVCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbicpO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMsIEZPUkNFRCwgU0hBTSkge1xuICB2YXIgU1lNQk9MID0gd2VsbEtub3duU3ltYm9sKEtFWSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19TWU1CT0wgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN0cmluZyBtZXRob2RzIGNhbGwgc3ltYm9sLW5hbWVkIFJlZ0VwIG1ldGhvZHNcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH07XG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19FWEVDID0gREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN5bWJvbC1uYW1lZCBSZWdFeHAgbWV0aG9kcyBjYWxsIC5leGVjXG4gICAgdmFyIGV4ZWNDYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgcmUgPSAvYS87XG5cbiAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XG4gICAgICAvLyBXZSBjYW4ndCB1c2UgcmVhbCByZWdleCBoZXJlIHNpbmNlIGl0IGNhdXNlcyBkZW9wdGltaXphdGlvblxuICAgICAgLy8gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb24gaW4gVjhcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMDZcbiAgICAgIHJlID0ge307XG4gICAgICAvLyBSZWdFeHBbQEBzcGxpdF0gZG9lc24ndCBjYWxsIHRoZSByZWdleCdzIGV4ZWMgbWV0aG9kLCBidXQgZmlyc3QgY3JlYXRlc1xuICAgICAgLy8gYSBuZXcgb25lLiBXZSBuZWVkIHRvIHJldHVybiB0aGUgcGF0Y2hlZCByZWdleCB3aGVuIGNyZWF0aW5nIHRoZSBuZXcgb25lLlxuICAgICAgcmUuY29uc3RydWN0b3IgPSB7fTtcbiAgICAgIHJlLmNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmU7IH07XG4gICAgICByZS5mbGFncyA9ICcnO1xuICAgICAgcmVbU1lNQk9MXSA9IC8uL1tTWU1CT0xdO1xuICAgIH1cblxuICAgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IGV4ZWNDYWxsZWQgPSB0cnVlOyByZXR1cm4gbnVsbDsgfTtcblxuICAgIHJlW1NZTUJPTF0oJycpO1xuICAgIHJldHVybiAhZXhlY0NhbGxlZDtcbiAgfSk7XG5cbiAgaWYgKFxuICAgICFERUxFR0FURVNfVE9fU1lNQk9MIHx8XG4gICAgIURFTEVHQVRFU19UT19FWEVDIHx8XG4gICAgRk9SQ0VEXG4gICkge1xuICAgIHZhciB1bmN1cnJpZWROYXRpdmVSZWdFeHBNZXRob2QgPSB1bmN1cnJ5VGhpcygvLi9bU1lNQk9MXSk7XG4gICAgdmFyIG1ldGhvZHMgPSBleGVjKFNZTUJPTCwgJydbS0VZXSwgZnVuY3Rpb24gKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICB2YXIgdW5jdXJyaWVkTmF0aXZlTWV0aG9kID0gdW5jdXJyeVRoaXMobmF0aXZlTWV0aG9kKTtcbiAgICAgIHZhciAkZXhlYyA9IHJlZ2V4cC5leGVjO1xuICAgICAgaWYgKCRleGVjID09PSByZWdleHBFeGVjIHx8ICRleGVjID09PSBSZWdFeHBQcm90b3R5cGUuZXhlYykge1xuICAgICAgICBpZiAoREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgICAgICAvLyBUaGUgbmF0aXZlIFN0cmluZyBtZXRob2QgYWxyZWFkeSBkZWxlZ2F0ZXMgdG8gQEBtZXRob2QgKHRoaXNcbiAgICAgICAgICAvLyBwb2x5ZmlsbGVkIGZ1bmN0aW9uKSwgbGVhc2luZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgICAgICAgLy8gV2UgYXZvaWQgaXQgYnkgZGlyZWN0bHkgY2FsbGluZyB0aGUgbmF0aXZlIEBAbWV0aG9kIG1ldGhvZC5cbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5jdXJyaWVkTmF0aXZlUmVnRXhwTWV0aG9kKHJlZ2V4cCwgc3RyLCBhcmcyKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmN1cnJpZWROYXRpdmVNZXRob2Qoc3RyLCByZWdleHAsIGFyZzIpIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBkb25lOiBmYWxzZSB9O1xuICAgIH0pO1xuXG4gICAgZGVmaW5lQnVpbHRJbihTdHJpbmcucHJvdG90eXBlLCBLRVksIG1ldGhvZHNbMF0pO1xuICAgIGRlZmluZUJ1aWx0SW4oUmVnRXhwUHJvdG90eXBlLCBTWU1CT0wsIG1ldGhvZHNbMV0pO1xuICB9XG5cbiAgaWYgKFNIQU0pIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShSZWdFeHBQcm90b3R5cGVbU1lNQk9MXSwgJ3NoYW0nLCB0cnVlKTtcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtaXNleHRlbnNpYmxlLCBlcy14L25vLW9iamVjdC1wcmV2ZW50ZXh0ZW5zaW9ucyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xuIiwidmFyIE5BVElWRV9CSU5EID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlJyk7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBhcHBseSA9IEZ1bmN0aW9uUHJvdG90eXBlLmFwcGx5O1xudmFyIGNhbGwgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1yZWZsZWN0IC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFJlZmxlY3QgPT0gJ29iamVjdCcgJiYgUmVmbGVjdC5hcHBseSB8fCAoTkFUSVZFX0JJTkQgPyBjYWxsLmJpbmQoYXBwbHkpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbC5hcHBseShhcHBseSwgYXJndW1lbnRzKTtcbn0pO1xuIiwidmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGFDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWNhbGxhYmxlJyk7XG52YXIgTkFUSVZFX0JJTkQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUnKTtcblxudmFyIGJpbmQgPSB1bmN1cnJ5VGhpcyh1bmN1cnJ5VGhpcy5iaW5kKTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCkge1xuICBhQ2FsbGFibGUoZm4pO1xuICByZXR1cm4gdGhhdCA9PT0gdW5kZWZpbmVkID8gZm4gOiBOQVRJVkVfQklORCA/IGJpbmQoZm4sIHRoYXQpIDogZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG4gIHZhciB0ZXN0ID0gKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkuYmluZCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgYXJyYXlTbGljZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zbGljZScpO1xudmFyIE5BVElWRV9CSU5EID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlJyk7XG5cbnZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xudmFyIGpvaW4gPSB1bmN1cnJ5VGhpcyhbXS5qb2luKTtcbnZhciBmYWN0b3JpZXMgPSB7fTtcblxudmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uIChDLCBhcmdzTGVuZ3RoLCBhcmdzKSB7XG4gIGlmICghaGFzT3duKGZhY3RvcmllcywgYXJnc0xlbmd0aCkpIHtcbiAgICBmb3IgKHZhciBsaXN0ID0gW10sIGkgPSAwOyBpIDwgYXJnc0xlbmd0aDsgaSsrKSBsaXN0W2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgZmFjdG9yaWVzW2FyZ3NMZW5ndGhdID0gJEZ1bmN0aW9uKCdDLGEnLCAncmV0dXJuIG5ldyBDKCcgKyBqb2luKGxpc3QsICcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbYXJnc0xlbmd0aF0oQywgYXJncyk7XG59O1xuXG4vLyBgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYmluZFxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfQklORCA/ICRGdW5jdGlvbi5iaW5kIDogZnVuY3Rpb24gYmluZCh0aGF0IC8qICwgLi4uYXJncyAqLykge1xuICB2YXIgRiA9IGFDYWxsYWJsZSh0aGlzKTtcbiAgdmFyIFByb3RvdHlwZSA9IEYucHJvdG90eXBlO1xuICB2YXIgcGFydEFyZ3MgPSBhcnJheVNsaWNlKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZEZ1bmN0aW9uID0gZnVuY3Rpb24gYm91bmQoLyogYXJncy4uLiAqLykge1xuICAgIHZhciBhcmdzID0gY29uY2F0KHBhcnRBcmdzLCBhcnJheVNsaWNlKGFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgYm91bmRGdW5jdGlvbiA/IGNvbnN0cnVjdChGLCBhcmdzLmxlbmd0aCwgYXJncykgOiBGLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9O1xuICBpZiAoaXNPYmplY3QoUHJvdG90eXBlKSkgYm91bmRGdW5jdGlvbi5wcm90b3R5cGUgPSBQcm90b3R5cGU7XG4gIHJldHVybiBib3VuZEZ1bmN0aW9uO1xufTtcbiIsInZhciBOQVRJVkVfQklORCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZScpO1xuXG52YXIgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9CSU5EID8gY2FsbC5iaW5kKGNhbGwpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbC5hcHBseShjYWxsLCBhcmd1bWVudHMpO1xufTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG52YXIgRVhJU1RTID0gaGFzT3duKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpO1xuLy8gYWRkaXRpb25hbCBwcm90ZWN0aW9uIGZyb20gbWluaWZpZWQgLyBtYW5nbGVkIC8gZHJvcHBlZCBmdW5jdGlvbiBuYW1lc1xudmFyIFBST1BFUiA9IEVYSVNUUyAmJiAoZnVuY3Rpb24gc29tZXRoaW5nKCkgeyAvKiBlbXB0eSAqLyB9KS5uYW1lID09PSAnc29tZXRoaW5nJztcbnZhciBDT05GSUdVUkFCTEUgPSBFWElTVFMgJiYgKCFERVNDUklQVE9SUyB8fCAoREVTQ1JJUFRPUlMgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKS5jb25maWd1cmFibGUpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVYSVNUUzogRVhJU1RTLFxuICBQUk9QRVI6IFBST1BFUixcbiAgQ09ORklHVVJBQkxFOiBDT05GSUdVUkFCTEVcbn07XG4iLCJ2YXIgTkFUSVZFX0JJTkQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUnKTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGJpbmQgPSBGdW5jdGlvblByb3RvdHlwZS5iaW5kO1xudmFyIGNhbGwgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xudmFyIHVuY3VycnlUaGlzID0gTkFUSVZFX0JJTkQgJiYgYmluZC5iaW5kKGNhbGwsIGNhbGwpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9CSU5EID8gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiAmJiB1bmN1cnJ5VGhpcyhmbik7XG59IDogZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiAmJiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGwuYXBwbHkoZm4sIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUoYXJndW1lbnQpID8gYXJndW1lbnQgOiB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1ldGhvZCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24oZ2xvYmFsW25hbWVzcGFjZV0pIDogZ2xvYmFsW25hbWVzcGFjZV0gJiYgZ2xvYmFsW25hbWVzcGFjZV1bbWV0aG9kXTtcbn07XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgZ2V0TWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1tZXRob2QnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGdldE1ldGhvZChpdCwgSVRFUkFUT1IpXG4gICAgfHwgZ2V0TWV0aG9kKGl0LCAnQEBpdGVyYXRvcicpXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCJ2YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgYUNhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtY2FsbGFibGUnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0cnlUb1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90cnktdG8tc3RyaW5nJyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQsIHVzaW5nSXRlcmF0b3IpIHtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBnZXRJdGVyYXRvck1ldGhvZChhcmd1bWVudCkgOiB1c2luZ0l0ZXJhdG9yO1xuICBpZiAoYUNhbGxhYmxlKGl0ZXJhdG9yTWV0aG9kKSkgcmV0dXJuIGFuT2JqZWN0KGNhbGwoaXRlcmF0b3JNZXRob2QsIGFyZ3VtZW50KSk7XG4gIHRocm93ICRUeXBlRXJyb3IodHJ5VG9TdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbn07XG4iLCJ2YXIgYUNhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtY2FsbGFibGUnKTtcblxuLy8gYEdldE1ldGhvZGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoViwgUCkge1xuICB2YXIgZnVuYyA9IFZbUF07XG4gIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhQ2FsbGFibGUoZnVuYyk7XG59O1xuIiwidmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xuXG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGNoYXJBdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJBdCk7XG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzKCcnLnJlcGxhY2UpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xudmFyIFNVQlNUSVRVVElPTl9TWU1CT0xTID0gL1xcJChbJCYnYF18XFxkezEsMn18PFtePl0qPikvZztcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCA9IC9cXCQoWyQmJ2BdfFxcZHsxLDJ9KS9nO1xuXG4vLyBgR2V0U3Vic3RpdHV0aW9uYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0c3Vic3RpdHV0aW9uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRjaGVkLCBzdHIsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZW1lbnQpIHtcbiAgdmFyIHRhaWxQb3MgPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICB2YXIgbSA9IGNhcHR1cmVzLmxlbmd0aDtcbiAgdmFyIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRDtcbiAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIG5hbWVkQ2FwdHVyZXMgPSB0b09iamVjdChuYW1lZENhcHR1cmVzKTtcbiAgICBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFM7XG4gIH1cbiAgcmV0dXJuIHJlcGxhY2UocmVwbGFjZW1lbnQsIHN5bWJvbHMsIGZ1bmN0aW9uIChtYXRjaCwgY2gpIHtcbiAgICB2YXIgY2FwdHVyZTtcbiAgICBzd2l0Y2ggKGNoYXJBdChjaCwgMCkpIHtcbiAgICAgIGNhc2UgJyQnOiByZXR1cm4gJyQnO1xuICAgICAgY2FzZSAnJic6IHJldHVybiBtYXRjaGVkO1xuICAgICAgY2FzZSAnYCc6IHJldHVybiBzdHJpbmdTbGljZShzdHIsIDAsIHBvc2l0aW9uKTtcbiAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzdHJpbmdTbGljZShzdHIsIHRhaWxQb3MpO1xuICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGNhcHR1cmUgPSBuYW1lZENhcHR1cmVzW3N0cmluZ1NsaWNlKGNoLCAxLCAtMSldO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIFxcZFxcZD9cbiAgICAgICAgdmFyIG4gPSArY2g7XG4gICAgICAgIGlmIChuID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgIGlmIChuID4gbSkge1xuICAgICAgICAgIHZhciBmID0gZmxvb3IobiAvIDEwKTtcbiAgICAgICAgICBpZiAoZiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIGlmIChmIDw9IG0pIHJldHVybiBjYXB0dXJlc1tmIC0gMV0gPT09IHVuZGVmaW5lZCA/IGNoYXJBdChjaCwgMSkgOiBjYXB0dXJlc1tmIC0gMV0gKyBjaGFyQXQoY2gsIDEpO1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgICAgICBjYXB0dXJlID0gY2FwdHVyZXNbbiAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gY2FwdHVyZSA9PT0gdW5kZWZpbmVkID8gJycgOiBjYXB0dXJlO1xuICB9KTtcbn07XG4iLCJ2YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG5tb2R1bGUuZXhwb3J0cyA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCkgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jIC0tIGZhbGxiYWNrXG4gIChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4iLCJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKHt9Lmhhc093blByb3BlcnR5KTtcblxuLy8gYEhhc093blByb3BlcnR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaGFzb3ducHJvcGVydHlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1oYXNvd24gLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eSh0b09iamVjdChpdCksIGtleSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZTtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgIGFyZ3VtZW50cy5sZW5ndGggPT0gMSA/IGNvbnNvbGUuZXJyb3IoYSkgOiBjb25zb2xlLmVycm9yKGEsIGIpO1xuICB9XG59O1xuIiwidmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcblxuLy8gVGhhbmtzIHRvIElFOCBmb3IgaXRzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XG4gIH0pLmEgIT0gNztcbn0pO1xuIiwiLy8gSUVFRTc1NCBjb252ZXJzaW9ucyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2llZWU3NTRcbnZhciAkQXJyYXkgPSBBcnJheTtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG5cbnZhciBwYWNrID0gZnVuY3Rpb24gKG51bWJlciwgbWFudGlzc2FMZW5ndGgsIGJ5dGVzKSB7XG4gIHZhciBidWZmZXIgPSAkQXJyYXkoYnl0ZXMpO1xuICB2YXIgZXhwb25lbnRMZW5ndGggPSBieXRlcyAqIDggLSBtYW50aXNzYUxlbmd0aCAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZXhwb25lbnRMZW5ndGgpIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSBtYW50aXNzYUxlbmd0aCA9PT0gMjMgPyBwb3coMiwgLTI0KSAtIHBvdygyLCAtNzcpIDogMDtcbiAgdmFyIHNpZ24gPSBudW1iZXIgPCAwIHx8IG51bWJlciA9PT0gMCAmJiAxIC8gbnVtYmVyIDwgMCA/IDEgOiAwO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgZXhwb25lbnQsIG1hbnRpc3NhLCBjO1xuICBudW1iZXIgPSBhYnMobnVtYmVyKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgaWYgKG51bWJlciAhPSBudW1iZXIgfHwgbnVtYmVyID09PSBJbmZpbml0eSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgbWFudGlzc2EgPSBudW1iZXIgIT0gbnVtYmVyID8gMSA6IDA7XG4gICAgZXhwb25lbnQgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGV4cG9uZW50ID0gZmxvb3IobG9nKG51bWJlcikgLyBMTjIpO1xuICAgIGMgPSBwb3coMiwgLWV4cG9uZW50KTtcbiAgICBpZiAobnVtYmVyICogYyA8IDEpIHtcbiAgICAgIGV4cG9uZW50LS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChleHBvbmVudCArIGVCaWFzID49IDEpIHtcbiAgICAgIG51bWJlciArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bWJlciArPSBydCAqIHBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAobnVtYmVyICogYyA+PSAyKSB7XG4gICAgICBleHBvbmVudCsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cbiAgICBpZiAoZXhwb25lbnQgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtYW50aXNzYSA9IDA7XG4gICAgICBleHBvbmVudCA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChleHBvbmVudCArIGVCaWFzID49IDEpIHtcbiAgICAgIG1hbnRpc3NhID0gKG51bWJlciAqIGMgLSAxKSAqIHBvdygyLCBtYW50aXNzYUxlbmd0aCk7XG4gICAgICBleHBvbmVudCA9IGV4cG9uZW50ICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hbnRpc3NhID0gbnVtYmVyICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbWFudGlzc2FMZW5ndGgpO1xuICAgICAgZXhwb25lbnQgPSAwO1xuICAgIH1cbiAgfVxuICB3aGlsZSAobWFudGlzc2FMZW5ndGggPj0gOCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IG1hbnRpc3NhICYgMjU1O1xuICAgIG1hbnRpc3NhIC89IDI1NjtcbiAgICBtYW50aXNzYUxlbmd0aCAtPSA4O1xuICB9XG4gIGV4cG9uZW50ID0gZXhwb25lbnQgPDwgbWFudGlzc2FMZW5ndGggfCBtYW50aXNzYTtcbiAgZXhwb25lbnRMZW5ndGggKz0gbWFudGlzc2FMZW5ndGg7XG4gIHdoaWxlIChleHBvbmVudExlbmd0aCA+IDApIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBleHBvbmVudCAmIDI1NTtcbiAgICBleHBvbmVudCAvPSAyNTY7XG4gICAgZXhwb25lbnRMZW5ndGggLT0gODtcbiAgfVxuICBidWZmZXJbLS1pbmRleF0gfD0gc2lnbiAqIDEyODtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbnZhciB1bnBhY2sgPSBmdW5jdGlvbiAoYnVmZmVyLCBtYW50aXNzYUxlbmd0aCkge1xuICB2YXIgYnl0ZXMgPSBidWZmZXIubGVuZ3RoO1xuICB2YXIgZXhwb25lbnRMZW5ndGggPSBieXRlcyAqIDggLSBtYW50aXNzYUxlbmd0aCAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZXhwb25lbnRMZW5ndGgpIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSBleHBvbmVudExlbmd0aCAtIDc7XG4gIHZhciBpbmRleCA9IGJ5dGVzIC0gMTtcbiAgdmFyIHNpZ24gPSBidWZmZXJbaW5kZXgtLV07XG4gIHZhciBleHBvbmVudCA9IHNpZ24gJiAxMjc7XG4gIHZhciBtYW50aXNzYTtcbiAgc2lnbiA+Pj0gNztcbiAgd2hpbGUgKG5CaXRzID4gMCkge1xuICAgIGV4cG9uZW50ID0gZXhwb25lbnQgKiAyNTYgKyBidWZmZXJbaW5kZXgtLV07XG4gICAgbkJpdHMgLT0gODtcbiAgfVxuICBtYW50aXNzYSA9IGV4cG9uZW50ICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGV4cG9uZW50ID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1hbnRpc3NhTGVuZ3RoO1xuICB3aGlsZSAobkJpdHMgPiAwKSB7XG4gICAgbWFudGlzc2EgPSBtYW50aXNzYSAqIDI1NiArIGJ1ZmZlcltpbmRleC0tXTtcbiAgICBuQml0cyAtPSA4O1xuICB9XG4gIGlmIChleHBvbmVudCA9PT0gMCkge1xuICAgIGV4cG9uZW50ID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGV4cG9uZW50ID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG1hbnRpc3NhID8gTmFOIDogc2lnbiA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICB9IGVsc2Uge1xuICAgIG1hbnRpc3NhID0gbWFudGlzc2EgKyBwb3coMiwgbWFudGlzc2FMZW5ndGgpO1xuICAgIGV4cG9uZW50ID0gZXhwb25lbnQgLSBlQmlhcztcbiAgfSByZXR1cm4gKHNpZ24gPyAtMSA6IDEpICogbWFudGlzc2EgKiBwb3coMiwgZXhwb25lbnQgLSBtYW50aXNzYUxlbmd0aCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFjazogcGFjayxcbiAgdW5wYWNrOiB1bnBhY2tcbn07XG4iLCJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xudmFyIHNwbGl0ID0gdW5jdXJyeVRoaXMoJycuc3BsaXQpO1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiAhJE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YoaXQpID09ICdTdHJpbmcnID8gc3BsaXQoaXQsICcnKSA6ICRPYmplY3QoaXQpO1xufSA6ICRPYmplY3Q7XG4iLCJ2YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mJyk7XG5cbi8vIG1ha2VzIHN1YmNsYXNzaW5nIHdvcmsgY29ycmVjdCBmb3Igd3JhcHBlZCBidWlsdC1pbnNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCR0aGlzLCBkdW1teSwgV3JhcHBlcikge1xuICB2YXIgTmV3VGFyZ2V0LCBOZXdUYXJnZXRQcm90b3R5cGU7XG4gIGlmIChcbiAgICAvLyBpdCBjYW4gd29yayBvbmx5IHdpdGggbmF0aXZlIGBzZXRQcm90b3R5cGVPZmBcbiAgICBzZXRQcm90b3R5cGVPZiAmJlxuICAgIC8vIHdlIGhhdmVuJ3QgY29tcGxldGVseSBjb3JyZWN0IHByZS1FUzYgd2F5IGZvciBnZXR0aW5nIGBuZXcudGFyZ2V0YCwgc28gdXNlIHRoaXNcbiAgICBpc0NhbGxhYmxlKE5ld1RhcmdldCA9IGR1bW15LmNvbnN0cnVjdG9yKSAmJlxuICAgIE5ld1RhcmdldCAhPT0gV3JhcHBlciAmJlxuICAgIGlzT2JqZWN0KE5ld1RhcmdldFByb3RvdHlwZSA9IE5ld1RhcmdldC5wcm90b3R5cGUpICYmXG4gICAgTmV3VGFyZ2V0UHJvdG90eXBlICE9PSBXcmFwcGVyLnByb3RvdHlwZVxuICApIHNldFByb3RvdHlwZU9mKCR0aGlzLCBOZXdUYXJnZXRQcm90b3R5cGUpO1xuICByZXR1cm4gJHRoaXM7XG59O1xuIiwidmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBzdG9yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcblxudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhGdW5jdGlvbi50b1N0cmluZyk7XG5cbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgY29yZS1qc0AzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcbmlmICghaXNDYWxsYWJsZShzdG9yZS5pbnNwZWN0U291cmNlKSkge1xuICBzdG9yZS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcoaXQpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlLmluc3BlY3RTb3VyY2U7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsJyk7XG52YXIgaXNFeHRlbnNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1pcy1leHRlbnNpYmxlJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xudmFyIEZSRUVaSU5HID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZyZWV6aW5nJyk7XG5cbnZhciBSRVFVSVJFRCA9IGZhbHNlO1xudmFyIE1FVEFEQVRBID0gdWlkKCdtZXRhJyk7XG52YXIgaWQgPSAwO1xuXG52YXIgc2V0TWV0YWRhdGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgZGVmaW5lUHJvcGVydHkoaXQsIE1FVEFEQVRBLCB7IHZhbHVlOiB7XG4gICAgb2JqZWN0SUQ6ICdPJyArIGlkKyssIC8vIG9iamVjdCBJRFxuICAgIHdlYWtEYXRhOiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcblxudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gYSBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzT3duKGl0LCBNRVRBREFUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YWRhdGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFEQVRBXS5vYmplY3RJRDtcbn07XG5cbnZhciBnZXRXZWFrRGF0YSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzT3duKGl0LCBNRVRBREFUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YWRhdGEoaXQpO1xuICAvLyByZXR1cm4gdGhlIHN0b3JlIG9mIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFEQVRBXS53ZWFrRGF0YTtcbn07XG5cbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWklORyAmJiBSRVFVSVJFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXNPd24oaXQsIE1FVEFEQVRBKSkgc2V0TWV0YWRhdGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICBtZXRhLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbiAgUkVRVUlSRUQgPSB0cnVlO1xuICB2YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZjtcbiAgdmFyIHNwbGljZSA9IHVuY3VycnlUaGlzKFtdLnNwbGljZSk7XG4gIHZhciB0ZXN0ID0ge307XG4gIHRlc3RbTUVUQURBVEFdID0gMTtcblxuICAvLyBwcmV2ZW50IGV4cG9zaW5nIG9mIG1ldGFkYXRhIGtleVxuICBpZiAoZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0KS5sZW5ndGgpIHtcbiAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSByZXN1bHQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlc3VsdFtpXSA9PT0gTUVUQURBVEEpIHtcbiAgICAgICAgICBzcGxpY2UocmVzdWx0LCBpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAkKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIHtcbiAgICAgIGdldE93blByb3BlcnR5TmFtZXM6IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbE1vZHVsZS5mXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuYWJsZTogZW5hYmxlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrRGF0YTogZ2V0V2Vha0RhdGEsXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcblxuaGlkZGVuS2V5c1tNRVRBREFUQV0gPSB0cnVlO1xuIiwidmFyIE5BVElWRV9XRUFLX01BUCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZScpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuICAgIH0gcmV0dXJuIHN0YXRlO1xuICB9O1xufTtcblxuaWYgKE5BVElWRV9XRUFLX01BUCB8fCBzaGFyZWQuc3RhdGUpIHtcbiAgdmFyIHN0b3JlID0gc2hhcmVkLnN0YXRlIHx8IChzaGFyZWQuc3RhdGUgPSBuZXcgV2Vha01hcCgpKTtcbiAgdmFyIHdtZ2V0ID0gdW5jdXJyeVRoaXMoc3RvcmUuZ2V0KTtcbiAgdmFyIHdtaGFzID0gdW5jdXJyeVRoaXMoc3RvcmUuaGFzKTtcbiAgdmFyIHdtc2V0ID0gdW5jdXJyeVRoaXMoc3RvcmUuc2V0KTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmICh3bWhhcyhzdG9yZSwgaXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICB3bXNldChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldChzdG9yZSwgaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMoc3RvcmUsIGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSgnc3RhdGUnKTtcbiAgaGlkZGVuS2V5c1tTVEFURV0gPSB0cnVlO1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKGhhc093bihpdCwgU1RBVEUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093bihpdCwgU1RBVEUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXQsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG4iLCJ2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbi8vIGBJc0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNhcnJheVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tYXJyYXktaXNhcnJheSAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmd1bWVudCkge1xuICByZXR1cm4gY2xhc3NvZihhcmd1bWVudCkgPT0gJ0FycmF5Jztcbn07XG4iLCIvLyBgSXNDYWxsYWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJztcbn07XG4iLCJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBpbnNwZWN0U291cmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlJyk7XG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIGVtcHR5ID0gW107XG52YXIgY29uc3RydWN0ID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcbnZhciBjb25zdHJ1Y3RvclJlZ0V4cCA9IC9eXFxzKig/OmNsYXNzfGZ1bmN0aW9uKVxcYi87XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzKGNvbnN0cnVjdG9yUmVnRXhwLmV4ZWMpO1xudmFyIElOQ09SUkVDVF9UT19TVFJJTkcgPSAhY29uc3RydWN0b3JSZWdFeHAuZXhlYyhub29wKTtcblxudmFyIGlzQ29uc3RydWN0b3JNb2Rlcm4gPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gIGlmICghaXNDYWxsYWJsZShhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdHJ1Y3Qobm9vcCwgZW1wdHksIGFyZ3VtZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBpc0NvbnN0cnVjdG9yTGVnYWN5ID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICBpZiAoIWlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAoY2xhc3NvZihhcmd1bWVudCkpIHtcbiAgICBjYXNlICdBc3luY0Z1bmN0aW9uJzpcbiAgICBjYXNlICdHZW5lcmF0b3JGdW5jdGlvbic6XG4gICAgY2FzZSAnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbic6IHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIC8vIHdlIGNhbid0IGNoZWNrIC5wcm90b3R5cGUgc2luY2UgY29uc3RydWN0b3JzIHByb2R1Y2VkIGJ5IC5iaW5kIGhhdmVuJ3QgaXRcbiAgICAvLyBgRnVuY3Rpb24jdG9TdHJpbmdgIHRocm93cyBvbiBzb21lIGJ1aWx0LWl0IGZ1bmN0aW9uIGluIHNvbWUgbGVnYWN5IGVuZ2luZXNcbiAgICAvLyAoZm9yIGV4YW1wbGUsIGBET01RdWFkYCBhbmQgc2ltaWxhciBpbiBGRjQxLSlcbiAgICByZXR1cm4gSU5DT1JSRUNUX1RPX1NUUklORyB8fCAhIWV4ZWMoY29uc3RydWN0b3JSZWdFeHAsIGluc3BlY3RTb3VyY2UoYXJndW1lbnQpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuaXNDb25zdHJ1Y3RvckxlZ2FjeS5zaGFtID0gdHJ1ZTtcblxuLy8gYElzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NvbnN0cnVjdG9yXG5tb2R1bGUuZXhwb3J0cyA9ICFjb25zdHJ1Y3QgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGVkO1xuICByZXR1cm4gaXNDb25zdHJ1Y3Rvck1vZGVybihpc0NvbnN0cnVjdG9yTW9kZXJuLmNhbGwpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oT2JqZWN0KVxuICAgIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKGZ1bmN0aW9uICgpIHsgY2FsbGVkID0gdHJ1ZTsgfSlcbiAgICB8fCBjYWxsZWQ7XG59KSA/IGlzQ29uc3RydWN0b3JMZWdhY3kgOiBpc0NvbnN0cnVjdG9yTW9kZXJuO1xuIiwidmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIGRlc2NyaXB0b3IgIT09IHVuZGVmaW5lZCAmJiAoaGFzT3duKGRlc2NyaXB0b3IsICd2YWx1ZScpIHx8IGhhc093bihkZXNjcmlwdG9yLCAnd3JpdGFibGUnKSk7XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IGlzQ2FsbGFibGUoZGV0ZWN0aW9uKSA/IGZhaWxzKGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkLlBPTFlGSUxMID0gJ1AnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRm9yY2VkO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgSXNJbnRlZ3JhbE51bWJlcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzaW50ZWdyYWxudW1iZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW51bWJlci1pc2ludGVnZXIgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IGZ1bmN0aW9uIGlzSW50ZWdlcihpdCkge1xuICByZXR1cm4gIWlzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcbn07XG4iLCJ2YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlKGl0KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIE1BVENIID0gd2VsbEtub3duU3ltYm9sKCdtYXRjaCcpO1xuXG4vLyBgSXNSZWdFeHBgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc3JlZ2V4cFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY2xhc3NvZihpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcbiIsInZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc1Byb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YnKTtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZCcpO1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxubW9kdWxlLmV4cG9ydHMgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4oJ1N5bWJvbCcpO1xuICByZXR1cm4gaXNDYWxsYWJsZSgkU3ltYm9sKSAmJiBpc1Byb3RvdHlwZU9mKCRTeW1ib2wucHJvdG90eXBlLCAkT2JqZWN0KGl0KSk7XG59O1xuIiwidmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdHJ5VG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZycpO1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xudmFyIGlzUHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZicpO1xudmFyIGdldEl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvcicpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBpdGVyYXRvckNsb3NlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG52YXIgUmVzdWx0ID0gZnVuY3Rpb24gKHN0b3BwZWQsIHJlc3VsdCkge1xuICB0aGlzLnN0b3BwZWQgPSBzdG9wcGVkO1xuICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbn07XG5cbnZhciBSZXN1bHRQcm90b3R5cGUgPSBSZXN1bHQucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgdW5ib3VuZEZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gIHZhciB0aGF0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnRoYXQ7XG4gIHZhciBBU19FTlRSSUVTID0gISEob3B0aW9ucyAmJiBvcHRpb25zLkFTX0VOVFJJRVMpO1xuICB2YXIgSVNfSVRFUkFUT1IgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfSVRFUkFUT1IpO1xuICB2YXIgSU5URVJSVVBURUQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSU5URVJSVVBURUQpO1xuICB2YXIgZm4gPSBiaW5kKHVuYm91bmRGdW5jdGlvbiwgdGhhdCk7XG4gIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIG5leHQsIHN0ZXA7XG5cbiAgdmFyIHN0b3AgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgaWYgKGl0ZXJhdG9yKSBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAnbm9ybWFsJywgY29uZGl0aW9uKTtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xuICB9O1xuXG4gIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoQVNfRU5UUklFUykge1xuICAgICAgYW5PYmplY3QodmFsdWUpO1xuICAgICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWVbMF0sIHZhbHVlWzFdLCBzdG9wKSA6IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgfSByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZSwgc3RvcCkgOiBmbih2YWx1ZSk7XG4gIH07XG5cbiAgaWYgKElTX0lURVJBVE9SKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcbiAgfSBlbHNlIHtcbiAgICBpdGVyRm4gPSBnZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSk7XG4gICAgaWYgKCFpdGVyRm4pIHRocm93ICRUeXBlRXJyb3IodHJ5VG9TdHJpbmcoaXRlcmFibGUpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlckZuKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKGl0ZXJhYmxlKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdWx0ID0gY2FsbEZuKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgaXNQcm90b3R5cGVPZihSZXN1bHRQcm90b3R5cGUsIHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbiAgICB9XG4gICAgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihpdGVyYWJsZSwgaXRlckZuKTtcbiAgfVxuXG4gIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICB3aGlsZSAoIShzdGVwID0gY2FsbChuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gY2FsbEZuKHN0ZXAudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdvYmplY3QnICYmIHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mKFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG59O1xuIiwidmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGdldE1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtbWV0aG9kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBraW5kLCB2YWx1ZSkge1xuICB2YXIgaW5uZXJSZXN1bHQsIGlubmVyRXJyb3I7XG4gIGFuT2JqZWN0KGl0ZXJhdG9yKTtcbiAgdHJ5IHtcbiAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZChpdGVyYXRvciwgJ3JldHVybicpO1xuICAgIGlmICghaW5uZXJSZXN1bHQpIHtcbiAgICAgIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaW5uZXJSZXN1bHQgPSBjYWxsKGlubmVyUmVzdWx0LCBpdGVyYXRvcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW5uZXJFcnJvciA9IHRydWU7XG4gICAgaW5uZXJSZXN1bHQgPSBlcnJvcjtcbiAgfVxuICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gIGlmIChpbm5lckVycm9yKSB0aHJvdyBpbm5lclJlc3VsdDtcbiAgYW5PYmplY3QoaW5uZXJSZXN1bHQpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBkZWZpbmVCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbicpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IGZhbHNlO1xuXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJWAgb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0XG52YXIgSXRlcmF0b3JQcm90b3R5cGUsIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSwgYXJyYXlJdGVyYXRvcjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1hcnJheS1wcm90b3R5cGUta2V5cyAtLSBzYWZlICovXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoZ2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbnZhciBORVdfSVRFUkFUT1JfUFJPVE9UWVBFID0gSXRlcmF0b3JQcm90b3R5cGUgPT0gdW5kZWZpbmVkIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXG4gIHJldHVybiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0uY2FsbCh0ZXN0KSAhPT0gdGVzdDtcbn0pO1xuXG5pZiAoTkVXX0lURVJBVE9SX1BST1RPVFlQRSkgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbmVsc2UgaWYgKElTX1BVUkUpIEl0ZXJhdG9yUHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtQEBpdGVyYXRvclxuaWYgKCFpc0NhbGxhYmxlKEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSkpIHtcbiAgZGVmaW5lQnVpbHRJbihJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUsXG4gIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlNcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwidmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xuXG4vLyBgTGVuZ3RoT2ZBcnJheUxpa2VgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1sZW5ndGhvZmFycmF5bGlrZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b0xlbmd0aChvYmoubGVuZ3RoKTtcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUnKS5DT05GSUdVUkFCTEU7XG52YXIgaW5zcGVjdFNvdXJjZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZScpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcblxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5lbmZvcmNlO1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBDT05GSUdVUkFCTEVfTEVOR1RIID0gREVTQ1JJUFRPUlMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ2xlbmd0aCcsIHsgdmFsdWU6IDggfSkubGVuZ3RoICE9PSA4O1xufSk7XG5cbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcblxudmFyIG1ha2VCdWlsdEluID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKFN0cmluZyhuYW1lKS5zbGljZSgwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XG4gICAgbmFtZSA9ICdbJyArIFN0cmluZyhuYW1lKS5yZXBsYWNlKC9eU3ltYm9sXFwoKFteKV0qKVxcKS8sICckMScpICsgJ10nO1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2V0dGVyKSBuYW1lID0gJ2dldCAnICsgbmFtZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXR0ZXIpIG5hbWUgPSAnc2V0ICcgKyBuYW1lO1xuICBpZiAoIWhhc093bih2YWx1ZSwgJ25hbWUnKSB8fCAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgJiYgdmFsdWUubmFtZSAhPT0gbmFtZSkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgJ25hbWUnLCB7IHZhbHVlOiBuYW1lLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIH1cbiAgaWYgKENPTkZJR1VSQUJMRV9MRU5HVEggJiYgb3B0aW9ucyAmJiBoYXNPd24ob3B0aW9ucywgJ2FyaXR5JykgJiYgdmFsdWUubGVuZ3RoICE9PSBvcHRpb25zLmFyaXR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkodmFsdWUsICdsZW5ndGgnLCB7IHZhbHVlOiBvcHRpb25zLmFyaXR5IH0pO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsICdjb25zdHJ1Y3RvcicpICYmIG9wdGlvbnMuY29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChERVNDUklQVE9SUykgZGVmaW5lUHJvcGVydHkodmFsdWUsICdwcm90b3R5cGUnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICAvLyBpbiBWOCB+IENocm9tZSA1MywgcHJvdG90eXBlcyBvZiBzb21lIG1ldGhvZHMsIGxpa2UgYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgLCBhcmUgbm9uLXdyaXRhYmxlXG4gICAgfSBlbHNlIGlmICh2YWx1ZS5wcm90b3R5cGUpIHZhbHVlLnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSk7XG4gIGlmICghaGFzT3duKHN0YXRlLCAnc291cmNlJykpIHtcbiAgICBzdGF0ZS5zb3VyY2UgPSBURU1QTEFURS5qb2luKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnID8gbmFtZSA6ICcnKTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRlbmQtbmF0aXZlIC0tIHJlcXVpcmVkXG5GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBtYWtlQnVpbHRJbihmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUodGhpcykgJiYgZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSh0aGlzKTtcbn0sICd0b1N0cmluZycpO1xuIiwidmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgTWF0aC50cnVuY2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hdGgudHJ1bmNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW1hdGgtdHJ1bmMgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgdmFyIG4gPSAreDtcbiAgcmV0dXJuIChuID4gMCA/IGZsb29yIDogY2VpbCkobik7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dCcpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJykuZjtcbnZhciBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdGFzaycpLnNldDtcbnZhciBJU19JT1MgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLWlzLWlvcycpO1xudmFyIElTX0lPU19QRUJCTEUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLWlzLWlvcy1wZWJibGUnKTtcbnZhciBJU19XRUJPU19XRUJLSVQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLWlzLXdlYm9zLXdlYmtpdCcpO1xudmFyIElTX05PREUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLWlzLW5vZGUnKTtcblxudmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xuLy8gTm9kZS5qcyAxMSBzaG93cyBFeHBlcmltZW50YWxXYXJuaW5nIG9uIGdldHRpbmcgYHF1ZXVlTWljcm90YXNrYFxudmFyIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihnbG9iYWwsICdxdWV1ZU1pY3JvdGFzaycpO1xudmFyIHF1ZXVlTWljcm90YXNrID0gcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yICYmIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvci52YWx1ZTtcblxudmFyIGZsdXNoLCBoZWFkLCBsYXN0LCBub3RpZnksIHRvZ2dsZSwgbm9kZSwgcHJvbWlzZSwgdGhlbjtcblxuLy8gbW9kZXJuIGVuZ2luZXMgaGF2ZSBxdWV1ZU1pY3JvdGFzayBtZXRob2RcbmlmICghcXVldWVNaWNyb3Rhc2spIHtcbiAgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKElTX05PREUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcbiAgLy8gYWxzbyBleGNlcHQgV2ViT1MgV2Via2l0IGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84OThcbiAgaWYgKCFJU19JT1MgJiYgIUlTX05PREUgJiYgIUlTX1dFQk9TX1dFQktJVCAmJiBNdXRhdGlvbk9ic2VydmVyICYmIGRvY3VtZW50KSB7XG4gICAgdG9nZ2xlID0gdHJ1ZTtcbiAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoIUlTX0lPU19QRUJCTEUgJiYgUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgICAvLyBQcm9taXNlLnJlc29sdmUgd2l0aG91dCBhbiBhcmd1bWVudCB0aHJvd3MgYW4gZXJyb3IgaW4gTEcgV2ViT1MgMlxuICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAvLyB3b3JrYXJvdW5kIG9mIFdlYktpdCB+IGlPUyBTYWZhcmkgMTAuMSBidWdcbiAgICBwcm9taXNlLmNvbnN0cnVjdG9yID0gUHJvbWlzZTtcbiAgICB0aGVuID0gYmluZChwcm9taXNlLnRoZW4sIHByb21pc2UpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIE5vZGUuanMgd2l0aG91dCBwcm9taXNlc1xuICB9IGVsc2UgaWYgKElTX05PREUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdlXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5iaW5kKGdsb2JhbClcbiAgICBtYWNyb3Rhc2sgPSBiaW5kKG1hY3JvdGFzaywgZ2xvYmFsKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtYWNyb3Rhc2soZmx1c2gpO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBxdWV1ZU1pY3JvdGFzayB8fCBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICBpZiAoIWhlYWQpIHtcbiAgICBoZWFkID0gdGFzaztcbiAgICBub3RpZnkoKTtcbiAgfSBsYXN0ID0gdGFzaztcbn07XG4iLCJ2YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sJyk7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tc3ltYm9sIC0tIHNhZmUgKi9cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTCAmJiAhIVN5bWJvbFsnZm9yJ10gJiYgISFTeW1ib2wua2V5Rm9yO1xuIiwiLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbnZhciBWOF9WRVJTSU9OID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXG4gIHJldHVybiAhU3RyaW5nKHN5bWJvbCkgfHwgIShPYmplY3Qoc3ltYm9sKSBpbnN0YW5jZW9mIFN5bWJvbCkgfHxcbiAgICAvLyBDaHJvbWUgMzgtNDAgc3ltYm9scyBhcmUgbm90IGluaGVyaXRlZCBmcm9tIERPTSBjb2xsZWN0aW9ucyBwcm90b3R5cGVzIHRvIGluc3RhbmNlc1xuICAgICFTeW1ib2wuc2hhbSAmJiBWOF9WRVJTSU9OICYmIFY4X1ZFUlNJT04gPCA0MTtcbn0pO1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9yZWxhdGl2ZS11cmwtc3R5bGUgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgdmFyIHVybCA9IG5ldyBVUkwoJ2I/YT0xJmI9MiZjPTMnLCAnaHR0cDovL2EnKTtcbiAgdmFyIHNlYXJjaFBhcmFtcyA9IHVybC5zZWFyY2hQYXJhbXM7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdXJsLnBhdGhuYW1lID0gJ2MlMjBkJztcbiAgc2VhcmNoUGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICBzZWFyY2hQYXJhbXNbJ2RlbGV0ZSddKCdiJyk7XG4gICAgcmVzdWx0ICs9IGtleSArIHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIChJU19QVVJFICYmICF1cmwudG9KU09OKVxuICAgIHx8ICFzZWFyY2hQYXJhbXMuc29ydFxuICAgIHx8IHVybC5ocmVmICE9PSAnaHR0cDovL2EvYyUyMGQ/YT0xJmM9MydcbiAgICB8fCBzZWFyY2hQYXJhbXMuZ2V0KCdjJykgIT09ICczJ1xuICAgIHx8IFN0cmluZyhuZXcgVVJMU2VhcmNoUGFyYW1zKCc/YT0xJykpICE9PSAnYT0xJ1xuICAgIHx8ICFzZWFyY2hQYXJhbXNbSVRFUkFUT1JdXG4gICAgLy8gdGhyb3dzIGluIEVkZ2VcbiAgICB8fCBuZXcgVVJMKCdodHRwczovL2FAYicpLnVzZXJuYW1lICE9PSAnYSdcbiAgICB8fCBuZXcgVVJMU2VhcmNoUGFyYW1zKG5ldyBVUkxTZWFyY2hQYXJhbXMoJ2E9YicpKS5nZXQoJ2EnKSAhPT0gJ2InXG4gICAgLy8gbm90IHB1bnljb2RlZCBpbiBFZGdlXG4gICAgfHwgbmV3IFVSTCgnaHR0cDovL9GC0LXRgdGCJykuaG9zdCAhPT0gJ3huLS1lMWF5YmMnXG4gICAgLy8gbm90IGVzY2FwZWQgaW4gQ2hyb21lIDYyLVxuICAgIHx8IG5ldyBVUkwoJ2h0dHA6Ly9hI9CxJykuaGFzaCAhPT0gJyMlRDAlQjEnXG4gICAgLy8gZmFpbHMgaW4gQ2hyb21lIDY2LVxuICAgIHx8IHJlc3VsdCAhPT0gJ2ExYzMnXG4gICAgLy8gdGhyb3dzIGluIFNhZmFyaVxuICAgIHx8IG5ldyBVUkwoJ2h0dHA6Ly94JywgdW5kZWZpbmVkKS5ob3N0ICE9PSAneCc7XG59KTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGluc3BlY3RTb3VyY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UnKTtcblxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0NhbGxhYmxlKFdlYWtNYXApICYmIC9uYXRpdmUgY29kZS8udGVzdChpbnNwZWN0U291cmNlKFdlYWtNYXApKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xuXG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUNhbGxhYmxlKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFDYWxsYWJsZShyZWplY3QpO1xufTtcblxuLy8gYE5ld1Byb21pc2VDYXBhYmlsaXR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbmV3cHJvbWlzZWNhcGFiaWxpdHlcbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbiIsInZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1yZWdleHAnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc1JlZ0V4cChpdCkpIHtcbiAgICB0aHJvdyAkVHlwZUVycm9yKFwiVGhlIG1ldGhvZCBkb2Vzbid0IGFjY2VwdCByZWd1bGFyIGV4cHJlc3Npb25zXCIpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scycpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtYXNzaWduIC0tIHNhZmVcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGNvbmNhdCA9IHVuY3VycnlUaGlzKFtdLmNvbmNhdCk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIHNob3VsZCBoYXZlIGNvcnJlY3Qgb3JkZXIgb2Ygb3BlcmF0aW9ucyAoRWRnZSBidWcpXG4gIGlmIChERVNDUklQVE9SUyAmJiAkYXNzaWduKHsgYjogMSB9LCAkYXNzaWduKGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywgJ2InLCB7XG4gICAgICAgIHZhbHVlOiAzLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KSwgeyBiOiAyIH0pKS5iICE9PSAxKSByZXR1cm4gdHJ1ZTtcbiAgLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLXN5bWJvbCAtLSBzYWZlXG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgdmFyIGFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtzeW1ib2xdID0gNztcbiAgYWxwaGFiZXQuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNocikgeyBCW2Nocl0gPSBjaHI7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbc3ltYm9sXSAhPSA3IHx8IG9iamVjdEtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IGFscGhhYmV0O1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcbiAgd2hpbGUgKGFyZ3VtZW50c0xlbmd0aCA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJbmRleGVkT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQob2JqZWN0S2V5cyhTKSwgZ2V0T3duUHJvcGVydHlTeW1ib2xzKFMpKSA6IG9iamVjdEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICAgICBrZXkgPSBrZXlzW2orK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTIHx8IGNhbGwocHJvcGVydHlJc0VudW1lcmFibGUsIFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcbiIsIi8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0IC0tIG9sZCBJRSwgV1NIICovXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgZGVmaW5lUHJvcGVydGllc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaHRtbCcpO1xudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCcpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG5cbnZhciBHVCA9ICc+JztcbnZhciBMVCA9ICc8JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBTQ1JJUFQgPSAnc2NyaXB0JztcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcblxudmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cbnZhciBzY3JpcHRUYWcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIEFjdGl2ZVggT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xuICBhY3RpdmVYRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCcnKSk7XG4gIGFjdGl2ZVhEb2N1bWVudC5jbG9zZSgpO1xuICB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsOyAvLyBhdm9pZCBtZW1vcnkgbGVha1xuICByZXR1cm4gdGVtcDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbn07XG5cbi8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbi8vIGF2b2lkIElFIEdDIGJ1Z1xudmFyIGFjdGl2ZVhEb2N1bWVudDtcbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgYWN0aXZlWERvY3VtZW50ID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGlnbm9yZSAqLyB9XG4gIE51bGxQcm90b09iamVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJ1xuICAgID8gZG9jdW1lbnQuZG9tYWluICYmIGFjdGl2ZVhEb2N1bWVudFxuICAgICAgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgLy8gb2xkIElFXG4gICAgICA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpXG4gICAgOiBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCk7IC8vIFdTSFxuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1jcmVhdGUgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5Q29uc3RydWN0b3IoKTtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllc01vZHVsZS5mKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdjgtcHJvdG90eXBlLWRlZmluZS1idWcnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnRpZXMgLS0gc2FmZVxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgJiYgIVY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBwcm9wcyA9IHRvSW5kZXhlZE9iamVjdChQcm9wZXJ0aWVzKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBwcm9wc1trZXldKTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy92OC1wcm90b3R5cGUtZGVmaW5lLWJ1ZycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5Jyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBFTlVNRVJBQkxFID0gJ2VudW1lcmFibGUnO1xudmFyIENPTkZJR1VSQUJMRSA9ICdjb25maWd1cmFibGUnO1xudmFyIFdSSVRBQkxFID0gJ3dyaXRhYmxlJztcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKHR5cGVvZiBPID09PSAnZnVuY3Rpb24nICYmIFAgPT09ICdwcm90b3R5cGUnICYmICd2YWx1ZScgaW4gQXR0cmlidXRlcyAmJiBXUklUQUJMRSBpbiBBdHRyaWJ1dGVzICYmICFBdHRyaWJ1dGVzW1dSSVRBQkxFXSkge1xuICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50W1dSSVRBQkxFXSkge1xuICAgICAgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gICAgICBBdHRyaWJ1dGVzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IENPTkZJR1VSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tDT05GSUdVUkFCTEVdIDogY3VycmVudFtDT05GSUdVUkFCTEVdLFxuICAgICAgICBlbnVtZXJhYmxlOiBFTlVNRVJBQkxFIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0VOVU1FUkFCTEVdIDogY3VycmVudFtFTlVNRVJBQkxFXSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfSByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xufSA6ICRkZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgJFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXknKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhc093bihPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighY2FsbChwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLCBPLCBQKSwgT1tQXSk7XG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlICovXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJykuZjtcbnZhciBhcnJheVNsaWNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNsaWNlLXNpbXBsZScpO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gYXJyYXlTbGljZSh3aW5kb3dOYW1lcyk7XG4gIH1cbn07XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiBjbGFzc29mKGl0KSA9PSAnV2luZG93J1xuICAgID8gZ2V0V2luZG93TmFtZXMoaXQpXG4gICAgOiAkZ2V0T3duUHJvcGVydHlOYW1lcyh0b0luZGV4ZWRPYmplY3QoaXQpKTtcbn07XG4iLCJ2YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xuXG52YXIgaGlkZGVuS2V5cyA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwidmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlcicpO1xuXG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcbnZhciBPYmplY3RQcm90b3R5cGUgPSAkT2JqZWN0LnByb3RvdHlwZTtcblxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID8gJE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG4gIHZhciBvYmplY3QgPSB0b09iamVjdChPKTtcbiAgaWYgKGhhc093bihvYmplY3QsIElFX1BST1RPKSkgcmV0dXJuIG9iamVjdFtJRV9QUk9UT107XG4gIHZhciBjb25zdHJ1Y3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgaWYgKGlzQ2FsbGFibGUoY29uc3RydWN0b3IpICYmIG9iamVjdCBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgJE9iamVjdCA/IE9iamVjdFByb3RvdHlwZSA6IG51bGw7XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIEFSUkFZX0JVRkZFUl9OT05fRVhURU5TSUJMRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItbm9uLWV4dGVuc2libGUnKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWlzZXh0ZW5zaWJsZSAtLSBzYWZlXG52YXIgJGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgJGlzRXh0ZW5zaWJsZSgxKTsgfSk7XG5cbi8vIGBPYmplY3QuaXNFeHRlbnNpYmxlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmlzZXh0ZW5zaWJsZVxubW9kdWxlLmV4cG9ydHMgPSAoRkFJTFNfT05fUFJJTUlUSVZFUyB8fCBBUlJBWV9CVUZGRVJfTk9OX0VYVEVOU0lCTEUpID8gZnVuY3Rpb24gaXNFeHRlbnNpYmxlKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChBUlJBWV9CVUZGRVJfTk9OX0VYVEVOU0lCTEUgJiYgY2xhc3NvZihpdCkgPT0gJ0FycmF5QnVmZmVyJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUoaXQpIDogdHJ1ZTtcbn0gOiAkaXNFeHRlbnNpYmxlO1xuIiwidmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVuY3VycnlUaGlzKHt9LmlzUHJvdG90eXBlT2YpO1xuIiwidmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlcycpLmluZGV4T2Y7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xuXG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKFtdLnB1c2gpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzT3duKGhpZGRlbktleXMsIGtleSkgJiYgaGFzT3duKE8sIGtleSkgJiYgcHVzaChyZXN1bHQsIGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXNPd24oTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcHVzaChyZXN1bHQsIGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWtleXMgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5leHBvcnRzLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBhUG9zc2libGVQcm90b3R5cGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1wb3NzaWJsZS1wcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3Qtc2V0cHJvdG90eXBlb2YgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xuICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgdmFyIHNldHRlcjtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbiAgICBzZXR0ZXIgPSB1bmN1cnJ5VGhpcyhPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQpO1xuICAgIHNldHRlcih0ZXN0LCBbXSk7XG4gICAgQ09SUkVDVF9TRVRURVIgPSB0ZXN0IGluc3RhbmNlb2YgQXJyYXk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgYW5PYmplY3QoTyk7XG4gICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgICBpZiAoQ09SUkVDVF9TRVRURVIpIHNldHRlcihPLCBwcm90byk7XG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKS5mO1xuXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSB1bmN1cnJ5VGhpcygkcHJvcGVydHlJc0VudW1lcmFibGUpO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxuLy8gYE9iamVjdC57IGVudHJpZXMsIHZhbHVlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRPX0VOVFJJRVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KGl0KTtcbiAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaSkge1xuICAgICAga2V5ID0ga2V5c1tpKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBwcm9wZXJ0eUlzRW51bWVyYWJsZShPLCBrZXkpKSB7XG4gICAgICAgIHB1c2gocmVzdWx0LCBUT19FTlRSSUVTID8gW2tleSwgT1trZXldXSA6IE9ba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYE9iamVjdC5lbnRyaWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZW50cmllc1xuICBlbnRyaWVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gIC8vIGBPYmplY3QudmFsdWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QudmFsdWVzXG4gIHZhbHVlczogY3JlYXRlTWV0aG9kKGZhbHNlKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyB7fS50b1N0cmluZyA6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG59O1xuIiwidmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChwcmVmID09PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAoaXNDYWxsYWJsZShmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAocHJlZiAhPT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QodmFsID0gY2FsbChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgJFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCJ2YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxudmFyIGNvbmNhdCA9IHVuY3VycnlUaGlzKFtdLmNvbmNhdCk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdvd25LZXlzJykgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQoa2V5cywgZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGVycm9yOiBmYWxzZSwgdmFsdWU6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yOiB0cnVlLCB2YWx1ZTogZXJyb3IgfTtcbiAgfVxufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Byb21pc2UtbmF0aXZlLWNvbnN0cnVjdG9yJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGlzRm9yY2VkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWZvcmNlZCcpO1xudmFyIGluc3BlY3RTb3VyY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBJU19CUk9XU0VSID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS1pcy1icm93c2VyJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgVjhfVkVSU0lPTiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvbicpO1xuXG52YXIgTmF0aXZlUHJvbWlzZVByb3RvdHlwZSA9IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciAmJiBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IucHJvdG90eXBlO1xudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcbnZhciBTVUJDTEFTU0lORyA9IGZhbHNlO1xudmFyIE5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCA9IGlzQ2FsbGFibGUoZ2xvYmFsLlByb21pc2VSZWplY3Rpb25FdmVudCk7XG5cbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiA9IGlzRm9yY2VkKCdQcm9taXNlJywgZnVuY3Rpb24gKCkge1xuICB2YXIgUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UgPSBpbnNwZWN0U291cmNlKE5hdGl2ZVByb21pc2VDb25zdHJ1Y3Rvcik7XG4gIHZhciBHTE9CQUxfQ09SRV9KU19QUk9NSVNFID0gUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UgIT09IFN0cmluZyhOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IpO1xuICAvLyBWOCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTgzMDU2NVxuICAvLyBXZSBjYW4ndCBkZXRlY3QgaXQgc3luY2hyb25vdXNseSwgc28ganVzdCBjaGVjayB2ZXJzaW9uc1xuICBpZiAoIUdMT0JBTF9DT1JFX0pTX1BST01JU0UgJiYgVjhfVkVSU0lPTiA9PT0gNjYpIHJldHVybiB0cnVlO1xuICAvLyBXZSBuZWVkIFByb21pc2UjeyBjYXRjaCwgZmluYWxseSB9IGluIHRoZSBwdXJlIHZlcnNpb24gZm9yIHByZXZlbnRpbmcgcHJvdG90eXBlIHBvbGx1dGlvblxuICBpZiAoSVNfUFVSRSAmJiAhKE5hdGl2ZVByb21pc2VQcm90b3R5cGVbJ2NhdGNoJ10gJiYgTmF0aXZlUHJvbWlzZVByb3RvdHlwZVsnZmluYWxseSddKSkgcmV0dXJuIHRydWU7XG4gIC8vIFdlIGNhbid0IHVzZSBAQHNwZWNpZXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4gIC8vIGRlb3B0aW1pemF0aW9uIGFuZCBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc5XG4gIGlmIChWOF9WRVJTSU9OID49IDUxICYmIC9uYXRpdmUgY29kZS8udGVzdChQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSkpIHJldHVybiBmYWxzZTtcbiAgLy8gRGV0ZWN0IGNvcnJlY3RuZXNzIG9mIHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgdmFyIHByb21pc2UgPSBuZXcgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUoMSk7IH0pO1xuICB2YXIgRmFrZVByb21pc2UgPSBmdW5jdGlvbiAoZXhlYykge1xuICAgIGV4ZWMoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xuICB9O1xuICB2YXIgY29uc3RydWN0b3IgPSBwcm9taXNlLmNvbnN0cnVjdG9yID0ge307XG4gIGNvbnN0cnVjdG9yW1NQRUNJRVNdID0gRmFrZVByb21pc2U7XG4gIFNVQkNMQVNTSU5HID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgaWYgKCFTVUJDTEFTU0lORykgcmV0dXJuIHRydWU7XG4gIC8vIFVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgcmV0dXJuICFHTE9CQUxfQ09SRV9KU19QUk9NSVNFICYmIElTX0JST1dTRVIgJiYgIU5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ09OU1RSVUNUT1I6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SLFxuICBSRUpFQ1RJT05fRVZFTlQ6IE5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCxcbiAgU1VCQ0xBU1NJTkc6IFNVQkNMQVNTSU5HXG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuUHJvbWlzZTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QoQyk7XG4gIGlmIChpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG4iLCJ2YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Byb21pc2UtbmF0aXZlLWNvbnN0cnVjdG9yJyk7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbicpO1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Byb21pc2UtY29uc3RydWN0b3ItZGV0ZWN0aW9uJykuQ09OU1RSVUNUT1I7XG5cbm1vZHVsZS5leHBvcnRzID0gRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yLmFsbChpdGVyYWJsZSkudGhlbih1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KTtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVGFyZ2V0LCBTb3VyY2UsIGtleSkge1xuICBrZXkgaW4gVGFyZ2V0IHx8IGRlZmluZVByb3BlcnR5KFRhcmdldCwga2V5LCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU291cmNlW2tleV07IH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoaXQpIHsgU291cmNlW2tleV0gPSBpdDsgfVxuICB9KTtcbn07XG4iLCJ2YXIgUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IG51bGw7XG4gIHRoaXMudGFpbCA9IG51bGw7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUgPSB7XG4gIGFkZDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgZW50cnkgPSB7IGl0ZW06IGl0ZW0sIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5oZWFkKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O1xuICAgIGVsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuaGVhZDtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5Lm5leHQ7XG4gICAgICBpZiAodGhpcy50YWlsID09PSBlbnRyeSkgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHJldHVybiBlbnRyeS5pdGVtO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWV1ZTtcbiIsInZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwZXhlY1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUiwgUykge1xuICB2YXIgZXhlYyA9IFIuZXhlYztcbiAgaWYgKGlzQ2FsbGFibGUoZXhlYykpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2FsbChleGVjLCBSLCBTKTtcbiAgICBpZiAocmVzdWx0ICE9PSBudWxsKSBhbk9iamVjdChyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNsYXNzb2YoUikgPT09ICdSZWdFeHAnKSByZXR1cm4gY2FsbChyZWdleHBFeGVjLCBSLCBTKTtcbiAgdGhyb3cgJFR5cGVFcnJvcignUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIHJlZ2V4cC9uby1lbXB0eS1jYXB0dXJpbmctZ3JvdXAsIHJlZ2V4cC9uby1lbXB0eS1ncm91cCwgcmVnZXhwL25vLWxhenktZW5kcyAtLSB0ZXN0aW5nICovXG4vKiBlc2xpbnQtZGlzYWJsZSByZWdleHAvbm8tdXNlbGVzcy1xdWFudGlmaWVyIC0tIHRlc3RpbmcgKi9cbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciByZWdleHBGbGFncyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZmxhZ3MnKTtcbnZhciBzdGlja3lIZWxwZXJzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1zdGlja3ktaGVscGVycycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdldEludGVybmFsU3RhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKS5nZXQ7XG52YXIgVU5TVVBQT1JURURfRE9UX0FMTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtdW5zdXBwb3J0ZWQtZG90LWFsbCcpO1xudmFyIFVOU1VQUE9SVEVEX05DRyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtdW5zdXBwb3J0ZWQtbmNnJyk7XG5cbnZhciBuYXRpdmVSZXBsYWNlID0gc2hhcmVkKCduYXRpdmUtc3RyaW5nLXJlcGxhY2UnLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyIG5hdGl2ZUV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7XG52YXIgcGF0Y2hlZEV4ZWMgPSBuYXRpdmVFeGVjO1xudmFyIGNoYXJBdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJBdCk7XG52YXIgaW5kZXhPZiA9IHVuY3VycnlUaGlzKCcnLmluZGV4T2YpO1xudmFyIHJlcGxhY2UgPSB1bmN1cnJ5VGhpcygnJy5yZXBsYWNlKTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS87XG4gIHZhciByZTIgPSAvYiovZztcbiAgY2FsbChuYXRpdmVFeGVjLCByZTEsICdhJyk7XG4gIGNhbGwobmF0aXZlRXhlYywgcmUyLCAnYScpO1xuICByZXR1cm4gcmUxLmxhc3RJbmRleCAhPT0gMCB8fCByZTIubGFzdEluZGV4ICE9PSAwO1xufSkoKTtcblxudmFyIFVOU1VQUE9SVEVEX1kgPSBzdGlja3lIZWxwZXJzLkJST0tFTl9DQVJFVDtcblxuLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXAsIGNvcGllZCBmcm9tIGVzNS1zaGltJ3MgU3RyaW5nI3NwbGl0IHBhdGNoLlxudmFyIE5QQ0dfSU5DTFVERUQgPSAvKCk/Py8uZXhlYygnJylbMV0gIT09IHVuZGVmaW5lZDtcblxudmFyIFBBVENIID0gVVBEQVRFU19MQVNUX0lOREVYX1dST05HIHx8IE5QQ0dfSU5DTFVERUQgfHwgVU5TVVBQT1JURURfWSB8fCBVTlNVUFBPUlRFRF9ET1RfQUxMIHx8IFVOU1VQUE9SVEVEX05DRztcblxuaWYgKFBBVENIKSB7XG4gIHBhdGNoZWRFeGVjID0gZnVuY3Rpb24gZXhlYyhzdHJpbmcpIHtcbiAgICB2YXIgcmUgPSB0aGlzO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUocmUpO1xuICAgIHZhciBzdHIgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgIHZhciByYXcgPSBzdGF0ZS5yYXc7XG4gICAgdmFyIHJlc3VsdCwgcmVDb3B5LCBsYXN0SW5kZXgsIG1hdGNoLCBpLCBvYmplY3QsIGdyb3VwO1xuXG4gICAgaWYgKHJhdykge1xuICAgICAgcmF3Lmxhc3RJbmRleCA9IHJlLmxhc3RJbmRleDtcbiAgICAgIHJlc3VsdCA9IGNhbGwocGF0Y2hlZEV4ZWMsIHJhdywgc3RyKTtcbiAgICAgIHJlLmxhc3RJbmRleCA9IHJhdy5sYXN0SW5kZXg7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBncm91cHMgPSBzdGF0ZS5ncm91cHM7XG4gICAgdmFyIHN0aWNreSA9IFVOU1VQUE9SVEVEX1kgJiYgcmUuc3RpY2t5O1xuICAgIHZhciBmbGFncyA9IGNhbGwocmVnZXhwRmxhZ3MsIHJlKTtcbiAgICB2YXIgc291cmNlID0gcmUuc291cmNlO1xuICAgIHZhciBjaGFyc0FkZGVkID0gMDtcbiAgICB2YXIgc3RyQ29weSA9IHN0cjtcblxuICAgIGlmIChzdGlja3kpIHtcbiAgICAgIGZsYWdzID0gcmVwbGFjZShmbGFncywgJ3knLCAnJyk7XG4gICAgICBpZiAoaW5kZXhPZihmbGFncywgJ2cnKSA9PT0gLTEpIHtcbiAgICAgICAgZmxhZ3MgKz0gJ2cnO1xuICAgICAgfVxuXG4gICAgICBzdHJDb3B5ID0gc3RyaW5nU2xpY2Uoc3RyLCByZS5sYXN0SW5kZXgpO1xuICAgICAgLy8gU3VwcG9ydCBhbmNob3JlZCBzdGlja3kgYmVoYXZpb3IuXG4gICAgICBpZiAocmUubGFzdEluZGV4ID4gMCAmJiAoIXJlLm11bHRpbGluZSB8fCByZS5tdWx0aWxpbmUgJiYgY2hhckF0KHN0ciwgcmUubGFzdEluZGV4IC0gMSkgIT09ICdcXG4nKSkge1xuICAgICAgICBzb3VyY2UgPSAnKD86ICcgKyBzb3VyY2UgKyAnKSc7XG4gICAgICAgIHN0ckNvcHkgPSAnICcgKyBzdHJDb3B5O1xuICAgICAgICBjaGFyc0FkZGVkKys7XG4gICAgICB9XG4gICAgICAvLyBeKD8gKyByeCArICkgaXMgbmVlZGVkLCBpbiBjb21iaW5hdGlvbiB3aXRoIHNvbWUgc3RyIHNsaWNpbmcsIHRvXG4gICAgICAvLyBzaW11bGF0ZSB0aGUgJ3knIGZsYWcuXG4gICAgICByZUNvcHkgPSBuZXcgUmVnRXhwKCdeKD86JyArIHNvdXJjZSArICcpJywgZmxhZ3MpO1xuICAgIH1cblxuICAgIGlmIChOUENHX0lOQ0xVREVEKSB7XG4gICAgICByZUNvcHkgPSBuZXcgUmVnRXhwKCdeJyArIHNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgIH1cbiAgICBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HKSBsYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG5cbiAgICBtYXRjaCA9IGNhbGwobmF0aXZlRXhlYywgc3RpY2t5ID8gcmVDb3B5IDogcmUsIHN0ckNvcHkpO1xuXG4gICAgaWYgKHN0aWNreSkge1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoLmlucHV0ID0gc3RyaW5nU2xpY2UobWF0Y2guaW5wdXQsIGNoYXJzQWRkZWQpO1xuICAgICAgICBtYXRjaFswXSA9IHN0cmluZ1NsaWNlKG1hdGNoWzBdLCBjaGFyc0FkZGVkKTtcbiAgICAgICAgbWF0Y2guaW5kZXggPSByZS5sYXN0SW5kZXg7XG4gICAgICAgIHJlLmxhc3RJbmRleCArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICB9IGVsc2UgcmUubGFzdEluZGV4ID0gMDtcbiAgICB9IGVsc2UgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyAmJiBtYXRjaCkge1xuICAgICAgcmUubGFzdEluZGV4ID0gcmUuZ2xvYmFsID8gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggOiBsYXN0SW5kZXg7XG4gICAgfVxuICAgIGlmIChOUENHX0lOQ0xVREVEICYmIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgICAvLyBmb3IgTlBDRywgbGlrZSBJRTguIE5PVEU6IFRoaXMgZG9lc24nIHdvcmsgZm9yIC8oLj8pPy9cbiAgICAgIGNhbGwobmF0aXZlUmVwbGFjZSwgbWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCAmJiBncm91cHMpIHtcbiAgICAgIG1hdGNoLmdyb3VwcyA9IG9iamVjdCA9IGNyZWF0ZShudWxsKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIG9iamVjdFtncm91cFswXV0gPSBtYXRjaFtncm91cFsxXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoZWRFeGVjO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2AgZ2V0dGVyIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5oYXNJbmRpY2VzKSByZXN1bHQgKz0gJ2QnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQuZG90QWxsKSByZXN1bHQgKz0gJ3MnO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwidmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgaXNQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mJyk7XG52YXIgcmVnRXhwRmxhZ3MgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzJyk7XG5cbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChSKSB7XG4gIHZhciBmbGFncyA9IFIuZmxhZ3M7XG4gIHJldHVybiBmbGFncyA9PT0gdW5kZWZpbmVkICYmICEoJ2ZsYWdzJyBpbiBSZWdFeHBQcm90b3R5cGUpICYmICFoYXNPd24oUiwgJ2ZsYWdzJykgJiYgaXNQcm90b3R5cGVPZihSZWdFeHBQcm90b3R5cGUsIFIpXG4gICAgPyBjYWxsKHJlZ0V4cEZsYWdzLCBSKSA6IGZsYWdzO1xufTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCdhJywgJ3knKSAtPiAvYS95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwID0gZ2xvYmFsLlJlZ0V4cDtcblxudmFyIFVOU1VQUE9SVEVEX1kgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9ICRSZWdFeHAoJ2EnLCAneScpO1xuICByZS5sYXN0SW5kZXggPSAyO1xuICByZXR1cm4gcmUuZXhlYygnYWJjZCcpICE9IG51bGw7XG59KTtcblxuLy8gVUMgQnJvd3NlciBidWdcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xMDA4XG52YXIgTUlTU0VEX1NUSUNLWSA9IFVOU1VQUE9SVEVEX1kgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISRSZWdFeHAoJ2EnLCAneScpLnN0aWNreTtcbn0pO1xuXG52YXIgQlJPS0VOX0NBUkVUID0gVU5TVVBQT1JURURfWSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc3MzY4N1xuICB2YXIgcmUgPSAkUmVnRXhwKCdecicsICdneScpO1xuICByZS5sYXN0SW5kZXggPSAyO1xuICByZXR1cm4gcmUuZXhlYygnc3RyJykgIT0gbnVsbDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQlJPS0VOX0NBUkVUOiBCUk9LRU5fQ0FSRVQsXG4gIE1JU1NFRF9TVElDS1k6IE1JU1NFRF9TVElDS1ksXG4gIFVOU1VQUE9SVEVEX1k6IFVOU1VQUE9SVEVEX1lcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbi8vIGJhYmVsLW1pbmlmeSBhbmQgQ2xvc3VyZSBDb21waWxlciB0cmFuc3BpbGVzIFJlZ0V4cCgnLicsICdzJykgLT4gLy4vcyBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG52YXIgJFJlZ0V4cCA9IGdsb2JhbC5SZWdFeHA7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUgPSAkUmVnRXhwKCcuJywgJ3MnKTtcbiAgcmV0dXJuICEocmUuZG90QWxsICYmIHJlLmV4ZWMoJ1xcbicpICYmIHJlLmZsYWdzID09PSAncycpO1xufSk7XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbi8vIGJhYmVsLW1pbmlmeSBhbmQgQ2xvc3VyZSBDb21waWxlciB0cmFuc3BpbGVzIFJlZ0V4cCgnKD88YT5iKScsICdnJykgLT4gLyg/PGE+YikvZyBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG52YXIgJFJlZ0V4cCA9IGdsb2JhbC5SZWdFeHA7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUgPSAkUmVnRXhwKCcoPzxhPmIpJywgJ2cnKTtcbiAgcmV0dXJuIHJlLmV4ZWMoJ2InKS5ncm91cHMuYSAhPT0gJ2InIHx8XG4gICAgJ2InLnJlcGxhY2UocmUsICckPGE+YycpICE9PSAnYmMnO1xufSk7XG4iLCJ2YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyAkVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSkge1xuICB2YXIgQ29uc3RydWN0b3IgPSBnZXRCdWlsdEluKENPTlNUUlVDVE9SX05BTUUpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiBDb25zdHJ1Y3RvciAmJiAhQ29uc3RydWN0b3JbU1BFQ0lFU10pIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgU1BFQ0lFUywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgfSk7XG4gIH1cbn07XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgVEFHLCBTVEFUSUMpIHtcbiAgaWYgKHRhcmdldCAmJiAhU1RBVElDKSB0YXJnZXQgPSB0YXJnZXQucHJvdG90eXBlO1xuICBpZiAodGFyZ2V0ICYmICFoYXNPd24odGFyZ2V0LCBUT19TVFJJTkdfVEFHKSkge1xuICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwgVE9fU1RSSU5HX1RBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBUQUcgfSk7XG4gIH1cbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91aWQnKTtcblxudmFyIGtleXMgPSBzaGFyZWQoJ2tleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHknKTtcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgZGVmaW5lR2xvYmFsUHJvcGVydHkoU0hBUkVELCB7fSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmU7XG4iLCJ2YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgc3RvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlJyk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4yMi44JyxcbiAgbW9kZTogSVNfUFVSRSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE0LTIwMjIgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknLFxuICBsaWNlbnNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My4yMi44L0xJQ0VOU0UnLFxuICBzb3VyY2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcydcbn0pO1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGFDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWNvbnN0cnVjdG9yJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbi8vIGBTcGVjaWVzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zcGVjaWVzY29uc3RydWN0b3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGRlZmF1bHRDb25zdHJ1Y3Rvcikge1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBkZWZhdWx0Q29uc3RydWN0b3IgOiBhQ29uc3RydWN0b3IoUyk7XG59O1xuIiwidmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eScpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbnZhciBjaGFyQXQgPSB1bmN1cnJ5VGhpcygnJy5jaGFyQXQpO1xudmFyIGNoYXJDb2RlQXQgPSB1bmN1cnJ5VGhpcygnJy5jaGFyQ29kZUF0KTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChDT05WRVJUX1RPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcbiAgICB2YXIgUyA9IHRvU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgICB2YXIgcG9zaXRpb24gPSB0b0ludGVnZXJPckluZmluaXR5KHBvcyk7XG4gICAgdmFyIHNpemUgPSBTLmxlbmd0aDtcbiAgICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGZpcnN0ID0gY2hhckNvZGVBdChTLCBwb3NpdGlvbik7XG4gICAgcmV0dXJuIGZpcnN0IDwgMHhEODAwIHx8IGZpcnN0ID4gMHhEQkZGIHx8IHBvc2l0aW9uICsgMSA9PT0gc2l6ZVxuICAgICAgfHwgKHNlY29uZCA9IGNoYXJDb2RlQXQoUywgcG9zaXRpb24gKyAxKSkgPCAweERDMDAgfHwgc2Vjb25kID4gMHhERkZGXG4gICAgICAgID8gQ09OVkVSVF9UT19TVFJJTkdcbiAgICAgICAgICA/IGNoYXJBdChTLCBwb3NpdGlvbilcbiAgICAgICAgICA6IGZpcnN0XG4gICAgICAgIDogQ09OVkVSVF9UT19TVFJJTkdcbiAgICAgICAgICA/IHN0cmluZ1NsaWNlKFMsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDIpXG4gICAgICAgICAgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmNvZGVwb2ludGF0XG4gIGNvZGVBdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuYXRgIG1ldGhvZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG4gIGNoYXJBdDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3B1bnljb2RlLmpzL2Jsb2IvbWFzdGVyL3B1bnljb2RlLmpzXG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG5cbnZhciBtYXhJbnQgPSAyMTQ3NDgzNjQ3OyAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG52YXIgYmFzZSA9IDM2O1xudmFyIHRNaW4gPSAxO1xudmFyIHRNYXggPSAyNjtcbnZhciBza2V3ID0gMzg7XG52YXIgZGFtcCA9IDcwMDtcbnZhciBpbml0aWFsQmlhcyA9IDcyO1xudmFyIGluaXRpYWxOID0gMTI4OyAvLyAweDgwXG52YXIgZGVsaW1pdGVyID0gJy0nOyAvLyAnXFx4MkQnXG52YXIgcmVnZXhOb25BU0NJSSA9IC9bXlxcMC1cXHUwMDdFXS87IC8vIG5vbi1BU0NJSSBjaGFyc1xudmFyIHJlZ2V4U2VwYXJhdG9ycyA9IC9bLlxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZzsgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xudmFyIE9WRVJGTE9XX0VSUk9SID0gJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJztcbnZhciBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW47XG5cbnZhciAkUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzKHJlZ2V4U2VwYXJhdG9ycy5leGVjKTtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbnZhciBjaGFyQ29kZUF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckNvZGVBdCk7XG52YXIgam9pbiA9IHVuY3VycnlUaGlzKFtdLmpvaW4pO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMoJycucmVwbGFjZSk7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcygnJy5zcGxpdCk7XG52YXIgdG9Mb3dlckNhc2UgPSB1bmN1cnJ5VGhpcygnJy50b0xvd2VyQ2FzZSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICovXG52YXIgdWNzMmRlY29kZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICB2YXIgY291bnRlciA9IDA7XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGNoYXJDb2RlQXQoc3RyaW5nLCBjb3VudGVyKyspO1xuICAgIGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICAgIC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG4gICAgICB2YXIgZXh0cmEgPSBjaGFyQ29kZUF0KHN0cmluZywgY291bnRlcisrKTtcbiAgICAgIGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBMb3cgc3Vycm9nYXRlLlxuICAgICAgICBwdXNoKG91dHB1dCwgKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEl0J3MgYW4gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlXG4gICAgICAgIC8vIG5leHQgY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAgICAgICBwdXNoKG91dHB1dCwgdmFsdWUpO1xuICAgICAgICBjb3VudGVyLS07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gob3V0cHV0LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqL1xudmFyIGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uIChkaWdpdCkge1xuICAvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuICAvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcbiAgcmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KTtcbn07XG5cbi8qKlxuICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG4gKi9cbnZhciBhZGFwdCA9IGZ1bmN0aW9uIChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcbiAgdmFyIGsgPSAwO1xuICBkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuICBkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG4gIHdoaWxlIChkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDEpIHtcbiAgICBkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG4gICAgayArPSBiYXNlO1xuICB9XG4gIHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqL1xudmFyIGVuY29kZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICB2YXIgb3V0cHV0ID0gW107XG5cbiAgLy8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gYW4gYXJyYXkgb2YgVW5pY29kZSBjb2RlIHBvaW50cy5cbiAgaW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuICAvLyBDYWNoZSB0aGUgbGVuZ3RoLlxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuXG4gIHZhciBuID0gaW5pdGlhbE47XG4gIHZhciBkZWx0YSA9IDA7XG4gIHZhciBiaWFzID0gaW5pdGlhbEJpYXM7XG4gIHZhciBpLCBjdXJyZW50VmFsdWU7XG5cbiAgLy8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cy5cbiAgZm9yIChpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY3VycmVudFZhbHVlID0gaW5wdXRbaV07XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcbiAgICAgIHB1c2gob3V0cHV0LCBmcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuICB2YXIgaGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aDsgLy8gbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cbiAgLy8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgd2l0aCBhIGRlbGltaXRlciB1bmxlc3MgaXQncyBlbXB0eS5cbiAgaWYgKGJhc2ljTGVuZ3RoKSB7XG4gICAgcHVzaChvdXRwdXQsIGRlbGltaXRlcik7XG4gIH1cblxuICAvLyBNYWluIGVuY29kaW5nIGxvb3A6XG4gIHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG4gICAgLy8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dCBsYXJnZXIgb25lOlxuICAgIHZhciBtID0gbWF4SW50O1xuICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuICAgICAgICBtID0gY3VycmVudFZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPiwgYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3cuXG4gICAgdmFyIGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcbiAgICBpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuICAgICAgdGhyb3cgJFJhbmdlRXJyb3IoT1ZFUkZMT1dfRVJST1IpO1xuICAgIH1cblxuICAgIGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG4gICAgbiA9IG07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuICAgICAgICB0aHJvdyAkUmFuZ2VFcnJvcihPVkVSRkxPV19FUlJPUik7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFZhbHVlID09IG4pIHtcbiAgICAgICAgLy8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXG4gICAgICAgIHZhciBxID0gZGVsdGE7XG4gICAgICAgIHZhciBrID0gYmFzZTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG4gICAgICAgICAgaWYgKHEgPCB0KSBicmVhaztcbiAgICAgICAgICB2YXIgcU1pbnVzVCA9IHEgLSB0O1xuICAgICAgICAgIHZhciBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG4gICAgICAgICAgcHVzaChvdXRwdXQsIGZyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNUKSkpO1xuICAgICAgICAgIHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG4gICAgICAgICAgayArPSBiYXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVzaChvdXRwdXQsIGZyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSkpKTtcbiAgICAgICAgYmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcbiAgICAgICAgZGVsdGEgPSAwO1xuICAgICAgICBoYW5kbGVkQ1BDb3VudCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlbHRhKys7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBqb2luKG91dHB1dCwgJycpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgdmFyIGVuY29kZWQgPSBbXTtcbiAgdmFyIGxhYmVscyA9IHNwbGl0KHJlcGxhY2UodG9Mb3dlckNhc2UoaW5wdXQpLCByZWdleFNlcGFyYXRvcnMsICdcXHUwMDJFJyksICcuJyk7XG4gIHZhciBpLCBsYWJlbDtcbiAgZm9yIChpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgIGxhYmVsID0gbGFiZWxzW2ldO1xuICAgIHB1c2goZW5jb2RlZCwgZXhlYyhyZWdleE5vbkFTQ0lJLCBsYWJlbCkgPyAneG4tLScgKyBlbmNvZGUobGFiZWwpIDogbGFiZWwpO1xuICB9XG4gIHJldHVybiBqb2luKGVuY29kZWQsICcuJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eScpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbnZhciAkUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnJlcGVhdGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucmVwZWF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGVhdChjb3VudCkge1xuICB2YXIgc3RyID0gdG9TdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIG4gPSB0b0ludGVnZXJPckluZmluaXR5KGNvdW50KTtcbiAgaWYgKG4gPCAwIHx8IG4gPT0gSW5maW5pdHkpIHRocm93ICRSYW5nZUVycm9yKCdXcm9uZyBudW1iZXIgb2YgcmVwZXRpdGlvbnMnKTtcbiAgZm9yICg7biA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKSBpZiAobiAmIDEpIHJlc3VsdCArPSBzdHI7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwidmFyIFBST1BFUl9GVU5DVElPTl9OQU1FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUnKS5QUk9QRVI7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB3aGl0ZXNwYWNlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93aGl0ZXNwYWNlcycpO1xuXG52YXIgbm9uID0gJ1xcdTIwMEJcXHUwMDg1XFx1MTgwRSc7XG5cbi8vIGNoZWNrIHRoYXQgYSBtZXRob2Qgd29ya3Mgd2l0aCB0aGUgY29ycmVjdCBsaXN0XG4vLyBvZiB3aGl0ZXNwYWNlcyBhbmQgaGFzIGEgY29ycmVjdCBuYW1lXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICByZXR1cm4gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXdoaXRlc3BhY2VzW01FVEhPRF9OQU1FXSgpXG4gICAgICB8fCBub25bTUVUSE9EX05BTUVdKCkgIT09IG5vblxuICAgICAgfHwgKFBST1BFUl9GVU5DVElPTl9OQU1FICYmIHdoaXRlc3BhY2VzW01FVEhPRF9OQU1FXS5uYW1lICE9PSBNRVRIT0RfTkFNRSk7XG4gIH0pO1xufTtcbiIsInZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIHdoaXRlc3BhY2VzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3doaXRlc3BhY2VzJyk7XG5cbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMoJycucmVwbGFjZSk7XG52YXIgd2hpdGVzcGFjZSA9ICdbJyArIHdoaXRlc3BhY2VzICsgJ10nO1xudmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cCh3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJCcpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW0sIHRyaW1TdGFydCwgdHJpbUVuZCwgdHJpbUxlZnQsIHRyaW1SaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcykge1xuICAgIHZhciBzdHJpbmcgPSB0b1N0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gICAgaWYgKFRZUEUgJiAxKSBzdHJpbmcgPSByZXBsYWNlKHN0cmluZywgbHRyaW0sICcnKTtcbiAgICBpZiAoVFlQRSAmIDIpIHN0cmluZyA9IHJlcGxhY2Uoc3RyaW5nLCBydHJpbSwgJycpO1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltTGVmdCwgdHJpbVN0YXJ0IH1gIG1ldGhvZHNcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1zdGFydFxuICBzdGFydDogY3JlYXRlTWV0aG9kKDEpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1SaWdodCwgdHJpbUVuZCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltZW5kXG4gIGVuZDogY3JlYXRlTWV0aG9kKDIpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS50cmltYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1cbiAgdHJpbTogY3JlYXRlTWV0aG9kKDMpXG59O1xuIiwidmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBTeW1ib2wgPSBnZXRCdWlsdEluKCdTeW1ib2wnKTtcbiAgdmFyIFN5bWJvbFByb3RvdHlwZSA9IFN5bWJvbCAmJiBTeW1ib2wucHJvdG90eXBlO1xuICB2YXIgdmFsdWVPZiA9IFN5bWJvbFByb3RvdHlwZSAmJiBTeW1ib2xQcm90b3R5cGUudmFsdWVPZjtcbiAgdmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCgndG9QcmltaXRpdmUnKTtcblxuICBpZiAoU3ltYm9sUHJvdG90eXBlICYmICFTeW1ib2xQcm90b3R5cGVbVE9fUFJJTUlUSVZFXSkge1xuICAgIC8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3ByaW1pdGl2ZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgLmxlbmd0aFxuICAgIGRlZmluZUJ1aWx0SW4oU3ltYm9sUHJvdG90eXBlLCBUT19QUklNSVRJVkUsIGZ1bmN0aW9uIChoaW50KSB7XG4gICAgICByZXR1cm4gY2FsbCh2YWx1ZU9mLCB0aGlzKTtcbiAgICB9LCB7IGFyaXR5OiAxIH0pO1xuICB9XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBhcHBseSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1hcHBseScpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2h0bWwnKTtcbnZhciBhcnJheVNsaWNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNsaWNlJyk7XG52YXIgY3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCcpO1xudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3ZhbGlkYXRlLWFyZ3VtZW50cy1sZW5ndGgnKTtcbnZhciBJU19JT1MgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLWlzLWlvcycpO1xudmFyIElTX05PREUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLWlzLW5vZGUnKTtcblxudmFyIHNldCA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXIgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsLkRpc3BhdGNoO1xudmFyIEZ1bmN0aW9uID0gZ2xvYmFsLkZ1bmN0aW9uO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsO1xudmFyIFN0cmluZyA9IGdsb2JhbC5TdHJpbmc7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBsb2NhdGlvbiwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG5cbnRyeSB7XG4gIC8vIERlbm8gdGhyb3dzIGEgUmVmZXJlbmNlRXJyb3Igb24gYGxvY2F0aW9uYCBhY2Nlc3Mgd2l0aG91dCBgLS1sb2NhdGlvbmAgZmxhZ1xuICBsb2NhdGlvbiA9IGdsb2JhbC5sb2NhdGlvbjtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxudmFyIHJ1biA9IGZ1bmN0aW9uIChpZCkge1xuICBpZiAoaGFzT3duKHF1ZXVlLCBpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xuXG52YXIgcnVubmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcnVuKGlkKTtcbiAgfTtcbn07XG5cbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4oZXZlbnQuZGF0YSk7XG59O1xuXG52YXIgcG9zdCA9IGZ1bmN0aW9uIChpZCkge1xuICAvLyBvbGQgZW5naW5lcyBoYXZlIG5vdCBsb2NhdGlvbi5vcmlnaW5cbiAgZ2xvYmFsLnBvc3RNZXNzYWdlKFN0cmluZyhpZCksIGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QpO1xufTtcblxuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXQgfHwgIWNsZWFyKSB7XG4gIHNldCA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShoYW5kbGVyKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIGZuID0gaXNDYWxsYWJsZShoYW5kbGVyKSA/IGhhbmRsZXIgOiBGdW5jdGlvbihoYW5kbGVyKTtcbiAgICB2YXIgYXJncyA9IGFycmF5U2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgYXBwbHkoZm4sIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXIgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAoSVNfTk9ERSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKHJ1bm5lcihpZCkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3cocnVubmVyKGlkKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICAvLyBleGNlcHQgaU9TIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzYyNFxuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsICYmICFJU19JT1MpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGJpbmQocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKFxuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmXG4gICAgaXNDYWxsYWJsZShnbG9iYWwucG9zdE1lc3NhZ2UpICYmXG4gICAgIWdsb2JhbC5pbXBvcnRTY3JpcHRzICYmXG4gICAgbG9jYXRpb24gJiYgbG9jYXRpb24ucHJvdG9jb2wgIT09ICdmaWxlOicgJiZcbiAgICAhZmFpbHMocG9zdClcbiAgKSB7XG4gICAgZGVmZXIgPSBwb3N0O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4oaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KHJ1bm5lcihpZCksIDApO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0LFxuICBjbGVhcjogY2xlYXJcbn07XG4iLCJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG5cbi8vIGB0aGlzTnVtYmVyVmFsdWVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10aGlzbnVtYmVydmFsdWVcbm1vZHVsZS5leHBvcnRzID0gdW5jdXJyeVRoaXMoMS4wLnZhbHVlT2YpO1xuIiwidmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eScpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgdmFyIGludGVnZXIgPSB0b0ludGVnZXJPckluZmluaXR5KGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluKGludGVnZXIsIGxlbmd0aCk7XG59O1xuIiwidmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZScpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYFRvQmlnSW50YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9iaWdpbnRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBwcmltID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdudW1iZXInKTtcbiAgaWYgKHR5cGVvZiBwcmltID09ICdudW1iZXInKSB0aHJvdyAkVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBudW1iZXIgdG8gYmlnaW50XCIpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1iaWdpbnQgLS0gc2FmZVxuICByZXR1cm4gQmlnSW50KHByaW0pO1xufTtcbiIsInZhciB0b0ludGVnZXJPckluZmluaXR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHknKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcblxudmFyICRSYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcblxuLy8gYFRvSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2luZGV4XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIHZhciBudW1iZXIgPSB0b0ludGVnZXJPckluZmluaXR5KGl0KTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKG51bWJlcik7XG4gIGlmIChudW1iZXIgIT09IGxlbmd0aCkgdGhyb3cgJFJhbmdlRXJyb3IoJ1dyb25nIGxlbmd0aCBvciBpbmRleCcpO1xuICByZXR1cm4gbGVuZ3RoO1xufTtcbiIsIi8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoaXQpKTtcbn07XG4iLCJ2YXIgdHJ1bmMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbWF0aC10cnVuYycpO1xuXG4vLyBgVG9JbnRlZ2VyT3JJbmZpbml0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvaW50ZWdlcm9yaW5maW5pdHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogdHJ1bmMobnVtYmVyKTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5Jyk7XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9sZW5ndGhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4odG9JbnRlZ2VyT3JJbmZpbml0eShhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsInZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxuLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9vYmplY3Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiAkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpKTtcbn07XG4iLCJ2YXIgdG9Qb3NpdGl2ZUludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcG9zaXRpdmUtaW50ZWdlcicpO1xuXG52YXIgJFJhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQllURVMpIHtcbiAgdmFyIG9mZnNldCA9IHRvUG9zaXRpdmVJbnRlZ2VyKGl0KTtcbiAgaWYgKG9mZnNldCAlIEJZVEVTKSB0aHJvdyAkUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0Jyk7XG4gIHJldHVybiBvZmZzZXQ7XG59O1xuIiwidmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eScpO1xuXG52YXIgJFJhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gdG9JbnRlZ2VyT3JJbmZpbml0eShpdCk7XG4gIGlmIChyZXN1bHQgPCAwKSB0aHJvdyAkUmFuZ2VFcnJvcihcIlRoZSBhcmd1bWVudCBjYW4ndCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtc3ltYm9sJyk7XG52YXIgZ2V0TWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1tZXRob2QnKTtcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29yZGluYXJ5LXRvLXByaW1pdGl2ZScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbnZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2woJ3RvUHJpbWl0aXZlJyk7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICBpZiAoIWlzT2JqZWN0KGlucHV0KSB8fCBpc1N5bWJvbChpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGV4b3RpY1RvUHJpbSA9IGdldE1ldGhvZChpbnB1dCwgVE9fUFJJTUlUSVZFKTtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGV4b3RpY1RvUHJpbSkge1xuICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnZGVmYXVsdCc7XG4gICAgcmVzdWx0ID0gY2FsbChleG90aWNUb1ByaW0sIGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlc3VsdCkgfHwgaXNTeW1ib2wocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICB0aHJvdyAkVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcbiIsInZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1zeW1ib2wnKTtcblxuLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sKGtleSkgPyBrZXkgOiBrZXkgKyAnJztcbn07XG4iLCJ2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcblxudGVzdFtUT19TVFJJTkdfVEFHXSA9ICd6JztcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmcodGVzdCkgPT09ICdbb2JqZWN0IHpdJztcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcblxudmFyICRTdHJpbmcgPSBTdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChjbGFzc29mKGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xufTtcbiIsInZhciAkU3RyaW5nID0gU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB0cnkge1xuICAgIHJldHVybiAkU3RyaW5nKGFyZ3VtZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBUWVBFRF9BUlJBWVNfQ09OU1RSVUNUT1JTX1JFUVVJUkVTX1dSQVBQRVJTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9ycy1yZXF1aXJlLXdyYXBwZXJzJyk7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgQXJyYXlCdWZmZXJNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1pbnN0YW5jZScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBpc0ludGVncmFsTnVtYmVyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWludGVncmFsLW51bWJlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXgnKTtcbnZhciB0b09mZnNldCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vZmZzZXQnKTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleScpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtc3ltYm9sJyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBpc1Byb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YnKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZicpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKS5mO1xudmFyIHR5cGVkQXJyYXlGcm9tID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWZyb20nKTtcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLmZvckVhY2g7XG52YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtc3BlY2llcycpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG5cbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG52YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xudmFyIEFycmF5QnVmZmVyID0gQXJyYXlCdWZmZXJNb2R1bGUuQXJyYXlCdWZmZXI7XG52YXIgQXJyYXlCdWZmZXJQcm90b3R5cGUgPSBBcnJheUJ1ZmZlci5wcm90b3R5cGU7XG52YXIgRGF0YVZpZXcgPSBBcnJheUJ1ZmZlck1vZHVsZS5EYXRhVmlldztcbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5OQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTO1xudmFyIFRZUEVEX0FSUkFZX0NPTlNUUlVDVE9SID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5UWVBFRF9BUlJBWV9DT05TVFJVQ1RPUjtcbnZhciBUWVBFRF9BUlJBWV9UQUcgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLlRZUEVEX0FSUkFZX1RBRztcbnZhciBUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5UeXBlZEFycmF5O1xudmFyIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLlR5cGVkQXJyYXlQcm90b3R5cGU7XG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbnZhciBpc1R5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmlzVHlwZWRBcnJheTtcbnZhciBCWVRFU19QRVJfRUxFTUVOVCA9ICdCWVRFU19QRVJfRUxFTUVOVCc7XG52YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCc7XG5cbnZhciBmcm9tTGlzdCA9IGZ1bmN0aW9uIChDLCBsaXN0KSB7XG4gIGFUeXBlZEFycmF5Q29uc3RydWN0b3IoQyk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgbmF0aXZlRGVmaW5lUHJvcGVydHkoaXQsIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKVtrZXldO1xuICB9IH0pO1xufTtcblxudmFyIGlzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGtsYXNzO1xuICByZXR1cm4gaXNQcm90b3R5cGVPZihBcnJheUJ1ZmZlclByb3RvdHlwZSwgaXQpIHx8IChrbGFzcyA9IGNsYXNzb2YoaXQpKSA9PSAnQXJyYXlCdWZmZXInIHx8IGtsYXNzID09ICdTaGFyZWRBcnJheUJ1ZmZlcic7XG59O1xuXG52YXIgaXNUeXBlZEFycmF5SW5kZXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgcmV0dXJuIGlzVHlwZWRBcnJheSh0YXJnZXQpXG4gICAgJiYgIWlzU3ltYm9sKGtleSlcbiAgICAmJiBrZXkgaW4gdGFyZ2V0XG4gICAgJiYgaXNJbnRlZ3JhbE51bWJlcigra2V5KVxuICAgICYmIGtleSA+PSAwO1xufTtcblxudmFyIHdyYXBwZWRHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcbiAga2V5ID0gdG9Qcm9wZXJ0eUtleShrZXkpO1xuICByZXR1cm4gaXNUeXBlZEFycmF5SW5kZXgodGFyZ2V0LCBrZXkpXG4gICAgPyBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMiwgdGFyZ2V0W2tleV0pXG4gICAgOiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xufTtcblxudmFyIHdyYXBwZWREZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gIGtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGlzVHlwZWRBcnJheUluZGV4KHRhcmdldCwga2V5KVxuICAgICYmIGlzT2JqZWN0KGRlc2NyaXB0b3IpXG4gICAgJiYgaGFzT3duKGRlc2NyaXB0b3IsICd2YWx1ZScpXG4gICAgJiYgIWhhc093bihkZXNjcmlwdG9yLCAnZ2V0JylcbiAgICAmJiAhaGFzT3duKGRlc2NyaXB0b3IsICdzZXQnKVxuICAgIC8vIFRPRE86IGFkZCB2YWxpZGF0aW9uIGRlc2NyaXB0b3Igdy9vIGNhbGxpbmcgYWNjZXNzb3JzXG4gICAgJiYgIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlXG4gICAgJiYgKCFoYXNPd24oZGVzY3JpcHRvciwgJ3dyaXRhYmxlJykgfHwgZGVzY3JpcHRvci53cml0YWJsZSlcbiAgICAmJiAoIWhhc093bihkZXNjcmlwdG9yLCAnZW51bWVyYWJsZScpIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSlcbiAgKSB7XG4gICAgdGFyZ2V0W2tleV0gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0gcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcbn07XG5cbmlmIChERVNDUklQVE9SUykge1xuICBpZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MpIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZiA9IHdyYXBwZWRHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgZGVmaW5lUHJvcGVydHlNb2R1bGUuZiA9IHdyYXBwZWREZWZpbmVQcm9wZXJ0eTtcbiAgICBhZGRHZXR0ZXIoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2J1ZmZlcicpO1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnYnl0ZU9mZnNldCcpO1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnYnl0ZUxlbmd0aCcpO1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnbGVuZ3RoJyk7XG4gIH1cblxuICAkKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB9LCB7XG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiB3cmFwcGVkR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgIGRlZmluZVByb3BlcnR5OiB3cmFwcGVkRGVmaW5lUHJvcGVydHlcbiAgfSk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVFlQRSwgd3JhcHBlciwgQ0xBTVBFRCkge1xuICAgIHZhciBCWVRFUyA9IFRZUEUubWF0Y2goL1xcZCskLylbMF0gLyA4O1xuICAgIHZhciBDT05TVFJVQ1RPUl9OQU1FID0gVFlQRSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5JztcbiAgICB2YXIgR0VUVEVSID0gJ2dldCcgKyBUWVBFO1xuICAgIHZhciBTRVRURVIgPSAnc2V0JyArIFRZUEU7XG4gICAgdmFyIE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbFtDT05TVFJVQ1RPUl9OQU1FXTtcbiAgICB2YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuICAgIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUgPSBUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICB2YXIgZXhwb3J0ZWQgPSB7fTtcblxuICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgIHJldHVybiBkYXRhLnZpZXdbR0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5ieXRlT2Zmc2V0LCB0cnVlKTtcbiAgICB9O1xuXG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgIGlmIChDTEFNUEVEKSB2YWx1ZSA9ICh2YWx1ZSA9IHJvdW5kKHZhbHVlKSkgPCAwID8gMCA6IHZhbHVlID4gMHhGRiA/IDB4RkYgOiB2YWx1ZSAmIDB4RkY7XG4gICAgICBkYXRhLnZpZXdbU0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5ieXRlT2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIHZhciBhZGRFbGVtZW50ID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eSh0aGF0LCBpbmRleCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0dGVyKHRoaXMsIGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gc2V0dGVyKHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MpIHtcbiAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGRhdGEsIG9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSk7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBieXRlT2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGJ1ZmZlciwgYnl0ZUxlbmd0aCwgbGVuZ3RoO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgbGVuZ3RoID0gdG9JbmRleChkYXRhKTtcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG4gICAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVMZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICBidWZmZXIgPSBkYXRhO1xuICAgICAgICAgIGJ5dGVPZmZzZXQgPSB0b09mZnNldChvZmZzZXQsIEJZVEVTKTtcbiAgICAgICAgICB2YXIgJGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBpZiAoJGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoJGxlbiAlIEJZVEVTKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gJGxlbiAtIGJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8IDApIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IHRvTGVuZ3RoKCRsZW5ndGgpICogQllURVM7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCArIGJ5dGVPZmZzZXQgPiAkbGVuKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCA9IGJ5dGVMZW5ndGggLyBCWVRFUztcbiAgICAgICAgfSBlbHNlIGlmIChpc1R5cGVkQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2FsbCh0eXBlZEFycmF5RnJvbSwgVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIHtcbiAgICAgICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgICAgICBieXRlT2Zmc2V0OiBieXRlT2Zmc2V0LFxuICAgICAgICAgIGJ5dGVMZW5ndGg6IGJ5dGVMZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgdmlldzogbmV3IERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkgYWRkRWxlbWVudCh0aGF0LCBpbmRleCsrKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgVHlwZWRBcnJheSk7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUgPSBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKFR5cGVkQXJyYXlQcm90b3R5cGUpO1xuICAgIH0gZWxzZSBpZiAoVFlQRURfQVJSQVlTX0NPTlNUUlVDVE9SU19SRVFVSVJFU19XUkFQUEVSUykge1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAoZHVtbXksIGRhdGEsIHR5cGVkQXJyYXlPZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZShkdW1teSwgVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIGluaGVyaXRJZlJlcXVpcmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSByZXR1cm4gbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3Rvcih0b0luZGV4KGRhdGEpKTtcbiAgICAgICAgICBpZiAoaXNBcnJheUJ1ZmZlcihkYXRhKSkgcmV0dXJuICRsZW5ndGggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBuZXcgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKGRhdGEsIHRvT2Zmc2V0KHR5cGVkQXJyYXlPZmZzZXQsIEJZVEVTKSwgJGxlbmd0aClcbiAgICAgICAgICAgIDogdHlwZWRBcnJheU9mZnNldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihkYXRhLCB0b09mZnNldCh0eXBlZEFycmF5T2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICAgIDogbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihkYXRhKTtcbiAgICAgICAgICBpZiAoaXNUeXBlZEFycmF5KGRhdGEpKSByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBkYXRhKTtcbiAgICAgICAgICByZXR1cm4gY2FsbCh0eXBlZEFycmF5RnJvbSwgVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBkYXRhKTtcbiAgICAgICAgfSgpLCBkdW1teSwgVHlwZWRBcnJheUNvbnN0cnVjdG9yKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgVHlwZWRBcnJheSk7XG4gICAgICBmb3JFYWNoKGdldE93blByb3BlcnR5TmFtZXMoTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yKSkge1xuICAgICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShUeXBlZEFycmF5Q29uc3RydWN0b3IsIGtleSwgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGU7XG4gICAgfVxuXG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZS5jb25zdHJ1Y3RvciAhPT0gVHlwZWRBcnJheUNvbnN0cnVjdG9yKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBUeXBlZEFycmF5Q29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUsIFRZUEVEX0FSUkFZX0NPTlNUUlVDVE9SLCBUeXBlZEFycmF5Q29uc3RydWN0b3IpO1xuXG4gICAgaWYgKFRZUEVEX0FSUkFZX1RBRykge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSwgVFlQRURfQVJSQVlfVEFHLCBDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICB9XG5cbiAgICB2YXIgRk9SQ0VEID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yICE9IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcblxuICAgIGV4cG9ydGVkW0NPTlNUUlVDVE9SX05BTUVdID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXG4gICAgJCh7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIGZvcmNlZDogRk9SQ0VELCBzaGFtOiAhTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB9LCBleHBvcnRlZCk7XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3IpKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuICAgIH1cblxuICAgIGlmICghKEJZVEVTX1BFUl9FTEVNRU5UIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG4gICAgfVxuXG4gICAgc2V0U3BlY2llcyhDT05TVFJVQ1RPUl9OQU1FKTtcbiAgfTtcbn0gZWxzZSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24nKTtcbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKS5OQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTO1xuXG52YXIgQXJyYXlCdWZmZXIgPSBnbG9iYWwuQXJyYXlCdWZmZXI7XG52YXIgSW50OEFycmF5ID0gZ2xvYmFsLkludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSAhTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBJbnQ4QXJyYXkoMSk7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBuZXcgSW50OEFycmF5KC0xKTtcbn0pIHx8ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gIG5ldyBJbnQ4QXJyYXkoKTtcbiAgbmV3IEludDhBcnJheShudWxsKTtcbiAgbmV3IEludDhBcnJheSgxLjUpO1xuICBuZXcgSW50OEFycmF5KGl0ZXJhYmxlKTtcbn0sIHRydWUpIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gU2FmYXJpICgxMSspIGJ1ZyAtIGEgcmVhc29uIHdoeSBldmVuIFNhZmFyaSAxMyBzaG91bGQgbG9hZCBhIHR5cGVkIGFycmF5IHBvbHlmaWxsXG4gIHJldHVybiBuZXcgSW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlcigyKSwgMSwgdW5kZWZpbmVkKS5sZW5ndGggIT09IDE7XG59KTtcbiIsInZhciBhcnJheUZyb21Db25zdHJ1Y3RvckFuZExpc3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktZnJvbS1jb25zdHJ1Y3Rvci1hbmQtbGlzdCcpO1xudmFyIHR5cGVkQXJyYXlTcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHlwZWQtYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgbGlzdCkge1xuICByZXR1cm4gYXJyYXlGcm9tQ29uc3RydWN0b3JBbmRMaXN0KHR5cGVkQXJyYXlTcGVjaWVzQ29uc3RydWN0b3IoaW5zdGFuY2UpLCBsaXN0KTtcbn07XG4iLCJ2YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBhQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jb25zdHJ1Y3RvcicpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlJyk7XG52YXIgZ2V0SXRlcmF0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yJyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKS5hVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwZm4sIHRoaXNBcmcgKi8pIHtcbiAgdmFyIEMgPSBhQ29uc3RydWN0b3IodGhpcyk7XG4gIHZhciBPID0gdG9PYmplY3Qoc291cmNlKTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBtYXBmbiA9IGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QoTyk7XG4gIHZhciBpLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3IsIG5leHQ7XG4gIGlmIChpdGVyYXRvck1ldGhvZCAmJiAhaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJhdG9yTWV0aG9kKSkge1xuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoTywgaXRlcmF0b3JNZXRob2QpO1xuICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICAgIE8gPSBbXTtcbiAgICB3aGlsZSAoIShzdGVwID0gY2FsbChuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgICAgIE8ucHVzaChzdGVwLnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1hcHBpbmcgJiYgYXJndW1lbnRzTGVuZ3RoID4gMikge1xuICAgIG1hcGZuID0gYmluZChtYXBmbiwgYXJndW1lbnRzWzJdKTtcbiAgfVxuICBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShPKTtcbiAgcmVzdWx0ID0gbmV3IChhVHlwZWRBcnJheUNvbnN0cnVjdG9yKEMpKShsZW5ndGgpO1xuICBmb3IgKGkgPSAwOyBsZW5ndGggPiBpOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwidmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbnZhciBUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUiA9IEFycmF5QnVmZmVyVmlld0NvcmUuVFlQRURfQVJSQVlfQ09OU1RSVUNUT1I7XG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcblxuLy8gYSBwYXJ0IG9mIGBUeXBlZEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jdHlwZWRhcnJheS1zcGVjaWVzLWNyZWF0ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSkge1xuICByZXR1cm4gYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWxBcnJheSwgb3JpZ2luYWxBcnJheVtUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUl0pKTtcbn07XG4iLCJ2YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG5cbnZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG52YXIgdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcygxLjAudG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyB0b1N0cmluZygrK2lkICsgcG9zdGZpeCwgMzYpO1xufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTFxuICAmJiAhU3ltYm9sLnNoYW1cbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbi8vIFY4IH4gQ2hyb21lIDM2LVxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzMzNFxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ3Byb3RvdHlwZScsIHtcbiAgICB2YWx1ZTogNDIsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLnByb3RvdHlwZSAhPSA0Mjtcbn0pO1xuIiwidmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhc3NlZCwgcmVxdWlyZWQpIHtcbiAgaWYgKHBhc3NlZCA8IHJlcXVpcmVkKSB0aHJvdyAkVHlwZUVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xuICByZXR1cm4gcGFzc2VkO1xufTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxuZXhwb3J0cy5mID0gd2VsbEtub3duU3ltYm9sO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sJyk7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQnKTtcblxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG52YXIgU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciBzeW1ib2xGb3IgPSBTeW1ib2wgJiYgU3ltYm9sWydmb3InXTtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbCA6IFN5bWJvbCAmJiBTeW1ib2wud2l0aG91dFNldHRlciB8fCB1aWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXNPd24oV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSAnU3ltYm9sLicgKyBuYW1lO1xuICAgIGlmIChOQVRJVkVfU1lNQk9MICYmIGhhc093bihTeW1ib2wsIG5hbWUpKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBTeW1ib2xbbmFtZV07XG4gICAgfSBlbHNlIGlmIChVU0VfU1lNQk9MX0FTX1VJRCAmJiBzeW1ib2xGb3IpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IHN5bWJvbEZvcihkZXNjcmlwdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgfVxuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuIiwiLy8gYSBzdHJpbmcgb2YgYWxsIHZhbGlkIHVuaWNvZGUgd2hpdGVzcGFjZXNcbm1vZHVsZS5leHBvcnRzID0gJ1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MjAwMFxcdTIwMDFcXHUyMDAyJyArXG4gICdcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xudmFyIGRvZXNOb3RFeGNlZWRTYWZlSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2VzLW5vdC1leGNlZWQtc2FmZS1pbnRlZ2VyJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCcpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIFY4X1ZFUlNJT04gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24nKTtcblxudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFID0gd2VsbEtub3duU3ltYm9sKCdpc0NvbmNhdFNwcmVhZGFibGUnKTtcblxuLy8gV2UgY2FuJ3QgdXNlIHRoaXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4vLyBkZW9wdGltaXphdGlvbiBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3OVxudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgPSBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBhcnJheVtJU19DT05DQVRfU1BSRUFEQUJMRV0gPSBmYWxzZTtcbiAgcmV0dXJuIGFycmF5LmNvbmNhdCgpWzBdICE9PSBhcnJheTtcbn0pO1xuXG52YXIgU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnY29uY2F0Jyk7XG5cbnZhciBpc0NvbmNhdFNwcmVhZGFibGUgPSBmdW5jdGlvbiAoTykge1xuICBpZiAoIWlzT2JqZWN0KE8pKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzcHJlYWRhYmxlID0gT1tJU19DT05DQVRfU1BSRUFEQUJMRV07XG4gIHJldHVybiBzcHJlYWRhYmxlICE9PSB1bmRlZmluZWQgPyAhIXNwcmVhZGFibGUgOiBpc0FycmF5KE8pO1xufTtcblxudmFyIEZPUkNFRCA9ICFJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUIHx8ICFTUEVDSUVTX1NVUFBPUlQ7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuY29uY2F0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmNvbmNhdFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQGlzQ29uY2F0U3ByZWFkYWJsZSBhbmQgQEBzcGVjaWVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgYXJpdHk6IDEsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgY29uY2F0OiBmdW5jdGlvbiBjb25jYXQoYXJnKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICB2YXIgbiA9IDA7XG4gICAgdmFyIGksIGssIGxlbmd0aCwgbGVuLCBFO1xuICAgIGZvciAoaSA9IC0xLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIEUgPSBpID09PSAtMSA/IE8gOiBhcmd1bWVudHNbaV07XG4gICAgICBpZiAoaXNDb25jYXRTcHJlYWRhYmxlKEUpKSB7XG4gICAgICAgIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlKEUpO1xuICAgICAgICBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIobiArIGxlbik7XG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBsZW47IGsrKywgbisrKSBpZiAoayBpbiBFKSBjcmVhdGVQcm9wZXJ0eShBLCBuLCBFW2tdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvZXNOb3RFeGNlZWRTYWZlSW50ZWdlcihuICsgMSk7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KEEsIG4rKywgRSk7XG4gICAgICB9XG4gICAgfVxuICAgIEEubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmaWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWZpbGwnKTtcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcycpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZpbGxgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsbFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUgfSwge1xuICBmaWxsOiBmaWxsXG59KTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcygnZmlsbCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgJGZpbHRlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5maWx0ZXI7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCcpO1xuXG52YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ2ZpbHRlcicpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCB9LCB7XG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRmaWx0ZXIodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZyb20gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktZnJvbScpO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24nKTtcblxudmFyIElOQ09SUkVDVF9JVEVSQVRJT04gPSAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1hcnJheS1mcm9tIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIEFycmF5LmZyb20oaXRlcmFibGUpO1xufSk7XG5cbi8vIGBBcnJheS5mcm9tYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxuJCh7IHRhcmdldDogJ0FycmF5Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfSVRFUkFUSU9OIH0sIHtcbiAgZnJvbTogZnJvbVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkaW5jbHVkZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmNsdWRlcztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzJyk7XG5cbi8vIEZGOTkrIGJ1Z1xudmFyIEJST0tFTl9PTl9TUEFSU0UgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhQXJyYXkoMSkuaW5jbHVkZXMoKTtcbn0pO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCUk9LRU5fT05fU1BBUlNFIH0sIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKGVsIC8qICwgZnJvbUluZGV4ID0gMCAqLykge1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2luY2x1ZGVzJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvcicpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG5cbnZhciBBUlJBWV9JVEVSQVRPUiA9ICdBcnJheSBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihBUlJBWV9JVEVSQVRPUik7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZW50cmllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXG4vLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuLy8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUudmFsdWVzXG4vLyBgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3Jcbi8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVJdGVyYXRvcihBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldDtcbiAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCsrO1xuICBpZiAoIXRhcmdldCB8fCBpbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7IHZhbHVlOiBpbmRleCwgZG9uZTogZmFsc2UgfTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiB7IHZhbHVlOiB0YXJnZXRbaW5kZXhdLCBkb25lOiBmYWxzZSB9O1xuICByZXR1cm4geyB2YWx1ZTogW2luZGV4LCB0YXJnZXRbaW5kZXhdXSwgZG9uZTogZmFsc2UgfTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxudmFyIHZhbHVlcyA9IEl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG4vLyBWOCB+IENocm9tZSA0NS0gYnVnXG5pZiAoIUlTX1BVUkUgJiYgREVTQ1JJUFRPUlMgJiYgdmFsdWVzLm5hbWUgIT09ICd2YWx1ZXMnKSB0cnkge1xuICBkZWZpbmVQcm9wZXJ0eSh2YWx1ZXMsICduYW1lJywgeyB2YWx1ZTogJ3ZhbHVlcycgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0Jyk7XG5cbnZhciB1biRKb2luID0gdW5jdXJyeVRoaXMoW10uam9pbik7XG5cbnZhciBFUzNfU1RSSU5HUyA9IEluZGV4ZWRPYmplY3QgIT0gT2JqZWN0O1xudmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdqb2luJywgJywnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5qb2luYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmpvaW5cbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEVTM19TVFJJTkdTIHx8ICFTVFJJQ1RfTUVUSE9EIH0sIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gdW4kSm9pbih0b0luZGV4ZWRPYmplY3QodGhpcyksIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gJywnIDogc2VwYXJhdG9yKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkbWFwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLm1hcDtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0Jyk7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnbWFwJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUIH0sIHtcbiAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xudmFyIGlzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY29uc3RydWN0b3InKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQnKTtcbnZhciB1biRTbGljZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zbGljZScpO1xuXG52YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ3NsaWNlJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG52YXIgJEFycmF5ID0gQXJyYXk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc2xpY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc2xpY2Vcbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUIH0sIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gICAgdmFyIGsgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbmd0aCk7XG4gICAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcbiAgICAvLyBpbmxpbmUgYEFycmF5U3BlY2llc0NyZWF0ZWAgZm9yIHVzYWdlIG5hdGl2ZSBgQXJyYXkjc2xpY2VgIHdoZXJlIGl0J3MgcG9zc2libGVcbiAgICB2YXIgQ29uc3RydWN0b3IsIHJlc3VsdCwgbjtcbiAgICBpZiAoaXNBcnJheShPKSkge1xuICAgICAgQ29uc3RydWN0b3IgPSBPLmNvbnN0cnVjdG9yO1xuICAgICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICAgIGlmIChpc0NvbnN0cnVjdG9yKENvbnN0cnVjdG9yKSAmJiAoQ29uc3RydWN0b3IgPT09ICRBcnJheSB8fCBpc0FycmF5KENvbnN0cnVjdG9yLnByb3RvdHlwZSkpKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcltTUEVDSUVTXTtcbiAgICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBudWxsKSBDb25zdHJ1Y3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gJEFycmF5IHx8IENvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuJFNsaWNlKE8sIGssIGZpbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdCA9IG5ldyAoQ29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCA/ICRBcnJheSA6IENvbnN0cnVjdG9yKShtYXgoZmluIC0gaywgMCkpO1xuICAgIGZvciAobiA9IDA7IGsgPCBmaW47IGsrKywgbisrKSBpZiAoayBpbiBPKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIG4sIE9ba10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgYUNhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtY2FsbGFibGUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xudmFyIGRlbGV0ZVByb3BlcnR5T3JUaHJvdyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWxldGUtcHJvcGVydHktb3ItdGhyb3cnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGludGVybmFsU29ydCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zb3J0Jyk7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0Jyk7XG52YXIgRkYgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLWZmLXZlcnNpb24nKTtcbnZhciBJRV9PUl9FREdFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS1pcy1pZS1vci1lZGdlJyk7XG52YXIgVjggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24nKTtcbnZhciBXRUJLSVQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXdlYmtpdC12ZXJzaW9uJyk7XG5cbnZhciB0ZXN0ID0gW107XG52YXIgdW4kU29ydCA9IHVuY3VycnlUaGlzKHRlc3Quc29ydCk7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKHRlc3QucHVzaCk7XG5cbi8vIElFOC1cbnZhciBGQUlMU19PTl9VTkRFRklORUQgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHRlc3Quc29ydCh1bmRlZmluZWQpO1xufSk7XG4vLyBWOCBidWdcbnZhciBGQUlMU19PTl9OVUxMID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICB0ZXN0LnNvcnQobnVsbCk7XG59KTtcbi8vIE9sZCBXZWJLaXRcbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgnc29ydCcpO1xuXG52YXIgU1RBQkxFX1NPUlQgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBmZWF0dXJlIGRldGVjdGlvbiBjYW4gYmUgdG9vIHNsb3csIHNvIGNoZWNrIGVuZ2luZXMgdmVyc2lvbnNcbiAgaWYgKFY4KSByZXR1cm4gVjggPCA3MDtcbiAgaWYgKEZGICYmIEZGID4gMykgcmV0dXJuO1xuICBpZiAoSUVfT1JfRURHRSkgcmV0dXJuIHRydWU7XG4gIGlmIChXRUJLSVQpIHJldHVybiBXRUJLSVQgPCA2MDM7XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgY29kZSwgY2hyLCB2YWx1ZSwgaW5kZXg7XG5cbiAgLy8gZ2VuZXJhdGUgYW4gYXJyYXkgd2l0aCBtb3JlIDUxMiBlbGVtZW50cyAoQ2hha3JhIGFuZCBvbGQgVjggZmFpbHMgb25seSBpbiB0aGlzIGNhc2UpXG4gIGZvciAoY29kZSA9IDY1OyBjb2RlIDwgNzY7IGNvZGUrKykge1xuICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG5cbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgNjY6IGNhc2UgNjk6IGNhc2UgNzA6IGNhc2UgNzI6IHZhbHVlID0gMzsgYnJlYWs7XG4gICAgICBjYXNlIDY4OiBjYXNlIDcxOiB2YWx1ZSA9IDQ7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogdmFsdWUgPSAyO1xuICAgIH1cblxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IDQ3OyBpbmRleCsrKSB7XG4gICAgICB0ZXN0LnB1c2goeyBrOiBjaHIgKyBpbmRleCwgdjogdmFsdWUgfSk7XG4gICAgfVxuICB9XG5cbiAgdGVzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiLnYgLSBhLnY7IH0pO1xuXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRlc3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY2hyID0gdGVzdFtpbmRleF0uay5jaGFyQXQoMCk7XG4gICAgaWYgKHJlc3VsdC5jaGFyQXQocmVzdWx0Lmxlbmd0aCAtIDEpICE9PSBjaHIpIHJlc3VsdCArPSBjaHI7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0ICE9PSAnREdCRUZIQUNJSksnO1xufSk7XG5cbnZhciBGT1JDRUQgPSBGQUlMU19PTl9VTkRFRklORUQgfHwgIUZBSUxTX09OX05VTEwgfHwgIVNUUklDVF9NRVRIT0QgfHwgIVNUQUJMRV9TT1JUO1xuXG52YXIgZ2V0U29ydENvbXBhcmUgPSBmdW5jdGlvbiAoY29tcGFyZWZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHJldHVybiAtMTtcbiAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMTtcbiAgICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIHJldHVybiArY29tcGFyZWZuKHgsIHkpIHx8IDA7XG4gICAgcmV0dXJuIHRvU3RyaW5nKHgpID4gdG9TdHJpbmcoeSkgPyAxIDogLTE7XG4gIH07XG59O1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29ydFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIGFDYWxsYWJsZShjb21wYXJlZm4pO1xuXG4gICAgdmFyIGFycmF5ID0gdG9PYmplY3QodGhpcyk7XG5cbiAgICBpZiAoU1RBQkxFX1NPUlQpIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZCA/IHVuJFNvcnQoYXJyYXkpIDogdW4kU29ydChhcnJheSwgY29tcGFyZWZuKTtcblxuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHZhciBhcnJheUxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKGFycmF5KTtcbiAgICB2YXIgaXRlbXNMZW5ndGgsIGluZGV4O1xuXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlMZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmIChpbmRleCBpbiBhcnJheSkgcHVzaChpdGVtcywgYXJyYXlbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpbnRlcm5hbFNvcnQoaXRlbXMsIGdldFNvcnRDb21wYXJlKGNvbXBhcmVmbikpO1xuXG4gICAgaXRlbXNMZW5ndGggPSBpdGVtcy5sZW5ndGg7XG4gICAgaW5kZXggPSAwO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgaXRlbXNMZW5ndGgpIGFycmF5W2luZGV4XSA9IGl0ZW1zW2luZGV4KytdO1xuICAgIHdoaWxlIChpbmRleCA8IGFycmF5TGVuZ3RoKSBkZWxldGVQcm9wZXJ0eU9yVGhyb3coYXJyYXksIGluZGV4KyspO1xuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eScpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlJyk7XG52YXIgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvZXMtbm90LWV4Y2VlZC1zYWZlLWludGVnZXInKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcbnZhciBkZWxldGVQcm9wZXJ0eU9yVGhyb3cgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVsZXRlLXByb3BlcnR5LW9yLXRocm93Jyk7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCcpO1xuXG52YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ3NwbGljZScpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc3BsaWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNwbGljZVxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUIH0sIHtcbiAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50IC8qICwgLi4uaXRlbXMgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZShPKTtcbiAgICB2YXIgYWN0dWFsU3RhcnQgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGluc2VydENvdW50LCBhY3R1YWxEZWxldGVDb3VudCwgQSwgaywgZnJvbSwgdG87XG4gICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA9PT0gMCkge1xuICAgICAgaW5zZXJ0Q291bnQgPSBhY3R1YWxEZWxldGVDb3VudCA9IDA7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNMZW5ndGggPT09IDEpIHtcbiAgICAgIGluc2VydENvdW50ID0gMDtcbiAgICAgIGFjdHVhbERlbGV0ZUNvdW50ID0gbGVuIC0gYWN0dWFsU3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc2VydENvdW50ID0gYXJndW1lbnRzTGVuZ3RoIC0gMjtcbiAgICAgIGFjdHVhbERlbGV0ZUNvdW50ID0gbWluKG1heCh0b0ludGVnZXJPckluZmluaXR5KGRlbGV0ZUNvdW50KSwgMCksIGxlbiAtIGFjdHVhbFN0YXJ0KTtcbiAgICB9XG4gICAgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyKGxlbiArIGluc2VydENvdW50IC0gYWN0dWFsRGVsZXRlQ291bnQpO1xuICAgIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgYWN0dWFsRGVsZXRlQ291bnQpO1xuICAgIGZvciAoayA9IDA7IGsgPCBhY3R1YWxEZWxldGVDb3VudDsgaysrKSB7XG4gICAgICBmcm9tID0gYWN0dWFsU3RhcnQgKyBrO1xuICAgICAgaWYgKGZyb20gaW4gTykgY3JlYXRlUHJvcGVydHkoQSwgaywgT1tmcm9tXSk7XG4gICAgfVxuICAgIEEubGVuZ3RoID0gYWN0dWFsRGVsZXRlQ291bnQ7XG4gICAgaWYgKGluc2VydENvdW50IDwgYWN0dWFsRGVsZXRlQ291bnQpIHtcbiAgICAgIGZvciAoayA9IGFjdHVhbFN0YXJ0OyBrIDwgbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7IGsrKykge1xuICAgICAgICBmcm9tID0gayArIGFjdHVhbERlbGV0ZUNvdW50O1xuICAgICAgICB0byA9IGsgKyBpbnNlcnRDb3VudDtcbiAgICAgICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO1xuICAgICAgICBlbHNlIGRlbGV0ZVByb3BlcnR5T3JUaHJvdyhPLCB0byk7XG4gICAgICB9XG4gICAgICBmb3IgKGsgPSBsZW47IGsgPiBsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGluc2VydENvdW50OyBrLS0pIGRlbGV0ZVByb3BlcnR5T3JUaHJvdyhPLCBrIC0gMSk7XG4gICAgfSBlbHNlIGlmIChpbnNlcnRDb3VudCA+IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICBmb3IgKGsgPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudDsgayA+IGFjdHVhbFN0YXJ0OyBrLS0pIHtcbiAgICAgICAgZnJvbSA9IGsgKyBhY3R1YWxEZWxldGVDb3VudCAtIDE7XG4gICAgICAgIHRvID0gayArIGluc2VydENvdW50IC0gMTtcbiAgICAgICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO1xuICAgICAgICBlbHNlIGRlbGV0ZVByb3BlcnR5T3JUaHJvdyhPLCB0byk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoayA9IDA7IGsgPCBpbnNlcnRDb3VudDsgaysrKSB7XG4gICAgICBPW2sgKyBhY3R1YWxTdGFydF0gPSBhcmd1bWVudHNbayArIDJdO1xuICAgIH1cbiAgICBPLmxlbmd0aCA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaW5zZXJ0Q291bnQ7XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgRlVOQ1RJT05fTkFNRV9FWElTVFMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZScpLkVYSVNUUztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhGdW5jdGlvblByb3RvdHlwZS50b1N0cmluZyk7XG52YXIgbmFtZVJFID0gL2Z1bmN0aW9uXFxiKD86XFxzfFxcL1xcKltcXFNcXHNdKj9cXCpcXC98XFwvXFwvW15cXG5cXHJdKltcXG5cXHJdKykqKFteXFxzKC9dKikvO1xudmFyIHJlZ0V4cEV4ZWMgPSB1bmN1cnJ5VGhpcyhuYW1lUkUuZXhlYyk7XG52YXIgTkFNRSA9ICduYW1lJztcblxuLy8gRnVuY3Rpb24gaW5zdGFuY2VzIGAubmFtZWAgcHJvcGVydHlcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZnVuY3Rpb24taW5zdGFuY2VzLW5hbWVcbmlmIChERVNDUklQVE9SUyAmJiAhRlVOQ1RJT05fTkFNRV9FWElTVFMpIHtcbiAgZGVmaW5lUHJvcGVydHkoRnVuY3Rpb25Qcm90b3R5cGUsIE5BTUUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVnRXhwRXhlYyhuYW1lUkUsIGZ1bmN0aW9uVG9TdHJpbmcodGhpcykpWzFdO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGFwcGx5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWFwcGx5Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXN5bWJvbCcpO1xudmFyIGFycmF5U2xpY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc2xpY2UnKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wnKTtcblxudmFyICRzdHJpbmdpZnkgPSBnZXRCdWlsdEluKCdKU09OJywgJ3N0cmluZ2lmeScpO1xudmFyIGV4ZWMgPSB1bmN1cnJ5VGhpcygvLi8uZXhlYyk7XG52YXIgY2hhckF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckF0KTtcbnZhciBjaGFyQ29kZUF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckNvZGVBdCk7XG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzKCcnLnJlcGxhY2UpO1xudmFyIG51bWJlclRvU3RyaW5nID0gdW5jdXJyeVRoaXMoMS4wLnRvU3RyaW5nKTtcblxudmFyIHRlc3RlciA9IC9bXFx1RDgwMC1cXHVERkZGXS9nO1xudmFyIGxvdyA9IC9eW1xcdUQ4MDAtXFx1REJGRl0kLztcbnZhciBoaSA9IC9eW1xcdURDMDAtXFx1REZGRl0kLztcblxudmFyIFdST05HX1NZTUJPTFNfQ09OVkVSU0lPTiA9ICFOQVRJVkVfU1lNQk9MIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9IGdldEJ1aWx0SW4oJ1N5bWJvbCcpKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIHJldHVybiAkc3RyaW5naWZ5KFtzeW1ib2xdKSAhPSAnW251bGxdJ1xuICAgIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAgIHx8ICRzdHJpbmdpZnkoeyBhOiBzeW1ib2wgfSkgIT0gJ3t9J1xuICAgIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gICAgfHwgJHN0cmluZ2lmeShPYmplY3Qoc3ltYm9sKSkgIT0gJ3t9Jztcbn0pO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC13ZWxsLWZvcm1lZC1zdHJpbmdpZnlcbnZhciBJTExfRk9STUVEX1VOSUNPREUgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAkc3RyaW5naWZ5KCdcXHVERjA2XFx1RDgzNCcpICE9PSAnXCJcXFxcdWRmMDZcXFxcdWQ4MzRcIidcbiAgICB8fCAkc3RyaW5naWZ5KCdcXHVERUFEJykgIT09ICdcIlxcXFx1ZGVhZFwiJztcbn0pO1xuXG52YXIgc3RyaW5naWZ5V2l0aFN5bWJvbHNGaXggPSBmdW5jdGlvbiAoaXQsIHJlcGxhY2VyKSB7XG4gIHZhciBhcmdzID0gYXJyYXlTbGljZShhcmd1bWVudHMpO1xuICB2YXIgJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChpc0NhbGxhYmxlKCRyZXBsYWNlcikpIHZhbHVlID0gY2FsbCgkcmVwbGFjZXIsIHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gIH07XG4gIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgcmV0dXJuIGFwcGx5KCRzdHJpbmdpZnksIG51bGwsIGFyZ3MpO1xufTtcblxudmFyIGZpeElsbEZvcm1lZCA9IGZ1bmN0aW9uIChtYXRjaCwgb2Zmc2V0LCBzdHJpbmcpIHtcbiAgdmFyIHByZXYgPSBjaGFyQXQoc3RyaW5nLCBvZmZzZXQgLSAxKTtcbiAgdmFyIG5leHQgPSBjaGFyQXQoc3RyaW5nLCBvZmZzZXQgKyAxKTtcbiAgaWYgKChleGVjKGxvdywgbWF0Y2gpICYmICFleGVjKGhpLCBuZXh0KSkgfHwgKGV4ZWMoaGksIG1hdGNoKSAmJiAhZXhlYyhsb3csIHByZXYpKSkge1xuICAgIHJldHVybiAnXFxcXHUnICsgbnVtYmVyVG9TdHJpbmcoY2hhckNvZGVBdChtYXRjaCwgMCksIDE2KTtcbiAgfSByZXR1cm4gbWF0Y2g7XG59O1xuXG5pZiAoJHN0cmluZ2lmeSkge1xuICAvLyBgSlNPTi5zdHJpbmdpZnlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5XG4gICQoeyB0YXJnZXQ6ICdKU09OJywgc3RhdDogdHJ1ZSwgYXJpdHk6IDMsIGZvcmNlZDogV1JPTkdfU1lNQk9MU19DT05WRVJTSU9OIHx8IElMTF9GT1JNRURfVU5JQ09ERSB9LCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgICB2YXIgYXJncyA9IGFycmF5U2xpY2UoYXJndW1lbnRzKTtcbiAgICAgIHZhciByZXN1bHQgPSBhcHBseShXUk9OR19TWU1CT0xTX0NPTlZFUlNJT04gPyBzdHJpbmdpZnlXaXRoU3ltYm9sc0ZpeCA6ICRzdHJpbmdpZnksIG51bGwsIGFyZ3MpO1xuICAgICAgcmV0dXJuIElMTF9GT1JNRURfVU5JQ09ERSAmJiB0eXBlb2YgcmVzdWx0ID09ICdzdHJpbmcnID8gcmVwbGFjZShyZXN1bHQsIHRlc3RlciwgZml4SWxsRm9ybWVkKSA6IHJlc3VsdDtcbiAgICB9XG4gIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29sbGVjdGlvbicpO1xudmFyIGNvbGxlY3Rpb25TdHJvbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gYE1hcGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLW9iamVjdHNcbmNvbGxlY3Rpb24oJ01hcCcsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7IHJldHVybiBpbml0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwgY29sbGVjdGlvblN0cm9uZyk7XG4iLCIvLyBUT0RPOiBSZW1vdmUgdGhpcyBtb2R1bGUgZnJvbSBgY29yZS1qc0A0YCBzaW5jZSBpdCdzIHJlcGxhY2VkIHRvIG1vZHVsZSBiZWxvd1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5tYXAuY29uc3RydWN0b3InKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcbnZhciBkZWZpbmVCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbicpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xudmFyIGlzUHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZicpO1xudmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXN5bWJvbCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpLmY7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKS5mO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIHRoaXNOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90aGlzLW51bWJlci12YWx1ZScpO1xudmFyIHRyaW0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLXRyaW0nKS50cmltO1xuXG52YXIgTlVNQkVSID0gJ051bWJlcic7XG52YXIgTmF0aXZlTnVtYmVyID0gZ2xvYmFsW05VTUJFUl07XG52YXIgTnVtYmVyUHJvdG90eXBlID0gTmF0aXZlTnVtYmVyLnByb3RvdHlwZTtcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIGFycmF5U2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG52YXIgY2hhckNvZGVBdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJDb2RlQXQpO1xuXG4vLyBgVG9OdW1lcmljYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9udW1lcmljXG52YXIgdG9OdW1lcmljID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcmltVmFsdWUgPSB0b1ByaW1pdGl2ZSh2YWx1ZSwgJ251bWJlcicpO1xuICByZXR1cm4gdHlwZW9mIHByaW1WYWx1ZSA9PSAnYmlnaW50JyA/IHByaW1WYWx1ZSA6IHRvTnVtYmVyKHByaW1WYWx1ZSk7XG59O1xuXG4vLyBgVG9OdW1iZXJgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b251bWJlclxudmFyIHRvTnVtYmVyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBpdCA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCAnbnVtYmVyJyk7XG4gIHZhciBmaXJzdCwgdGhpcmQsIHJhZGl4LCBtYXhDb2RlLCBkaWdpdHMsIGxlbmd0aCwgaW5kZXgsIGNvZGU7XG4gIGlmIChpc1N5bWJvbChpdCkpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBudW1iZXInKTtcbiAgaWYgKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyKSB7XG4gICAgaXQgPSB0cmltKGl0KTtcbiAgICBmaXJzdCA9IGNoYXJDb2RlQXQoaXQsIDApO1xuICAgIGlmIChmaXJzdCA9PT0gNDMgfHwgZmlyc3QgPT09IDQ1KSB7XG4gICAgICB0aGlyZCA9IGNoYXJDb2RlQXQoaXQsIDIpO1xuICAgICAgaWYgKHRoaXJkID09PSA4OCB8fCB0aGlyZCA9PT0gMTIwKSByZXR1cm4gTmFOOyAvLyBOdW1iZXIoJysweDEnKSBzaG91bGQgYmUgTmFOLCBvbGQgVjggZml4XG4gICAgfSBlbHNlIGlmIChmaXJzdCA9PT0gNDgpIHtcbiAgICAgIHN3aXRjaCAoY2hhckNvZGVBdChpdCwgMSkpIHtcbiAgICAgICAgY2FzZSA2NjogY2FzZSA5ODogcmFkaXggPSAyOyBtYXhDb2RlID0gNDk7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIG9mIC9eMGJbMDFdKyQvaVxuICAgICAgICBjYXNlIDc5OiBjYXNlIDExMTogcmFkaXggPSA4OyBtYXhDb2RlID0gNTU7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIG9mIC9eMG9bMC03XSskL2lcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuICtpdDtcbiAgICAgIH1cbiAgICAgIGRpZ2l0cyA9IGFycmF5U2xpY2UoaXQsIDIpO1xuICAgICAgbGVuZ3RoID0gZGlnaXRzLmxlbmd0aDtcbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb2RlID0gY2hhckNvZGVBdChkaWdpdHMsIGluZGV4KTtcbiAgICAgICAgLy8gcGFyc2VJbnQgcGFyc2VzIGEgc3RyaW5nIHRvIGEgZmlyc3QgdW5hdmFpbGFibGUgc3ltYm9sXG4gICAgICAgIC8vIGJ1dCBUb051bWJlciBzaG91bGQgcmV0dXJuIE5hTiBpZiBhIHN0cmluZyBjb250YWlucyB1bmF2YWlsYWJsZSBzeW1ib2xzXG4gICAgICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IG1heENvZGUpIHJldHVybiBOYU47XG4gICAgICB9IHJldHVybiBwYXJzZUludChkaWdpdHMsIHJhZGl4KTtcbiAgICB9XG4gIH0gcmV0dXJuICtpdDtcbn07XG5cbi8vIGBOdW1iZXJgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW51bWJlci1jb25zdHJ1Y3RvclxuaWYgKGlzRm9yY2VkKE5VTUJFUiwgIU5hdGl2ZU51bWJlcignIDBvMScpIHx8ICFOYXRpdmVOdW1iZXIoJzBiMScpIHx8IE5hdGl2ZU51bWJlcignKzB4MScpKSkge1xuICB2YXIgTnVtYmVyV3JhcHBlciA9IGZ1bmN0aW9uIE51bWJlcih2YWx1ZSkge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgPyAwIDogTmF0aXZlTnVtYmVyKHRvTnVtZXJpYyh2YWx1ZSkpO1xuICAgIHZhciBkdW1teSA9IHRoaXM7XG4gICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgcmV0dXJuIGlzUHJvdG90eXBlT2YoTnVtYmVyUHJvdG90eXBlLCBkdW1teSkgJiYgZmFpbHMoZnVuY3Rpb24gKCkgeyB0aGlzTnVtYmVyVmFsdWUoZHVtbXkpOyB9KVxuICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChPYmplY3QobiksIGR1bW15LCBOdW1iZXJXcmFwcGVyKSA6IG47XG4gIH07XG4gIGZvciAodmFyIGtleXMgPSBERVNDUklQVE9SUyA/IGdldE93blByb3BlcnR5TmFtZXMoTmF0aXZlTnVtYmVyKSA6IChcbiAgICAvLyBFUzM6XG4gICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgIC8vIEVTMjAxNSAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTMjAxNSBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICdFUFNJTE9OLE1BWF9TQUZFX0lOVEVHRVIsTUlOX1NBRkVfSU5URUdFUixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixwYXJzZUZsb2F0LHBhcnNlSW50LCcgK1xuICAgIC8vIEVTTmV4dFxuICAgICdmcm9tU3RyaW5nLHJhbmdlJ1xuICApLnNwbGl0KCcsJyksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgaisrKSB7XG4gICAgaWYgKGhhc093bihOYXRpdmVOdW1iZXIsIGtleSA9IGtleXNbal0pICYmICFoYXNPd24oTnVtYmVyV3JhcHBlciwga2V5KSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkoTnVtYmVyV3JhcHBlciwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTmF0aXZlTnVtYmVyLCBrZXkpKTtcbiAgICB9XG4gIH1cbiAgTnVtYmVyV3JhcHBlci5wcm90b3R5cGUgPSBOdW1iZXJQcm90b3R5cGU7XG4gIE51bWJlclByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE51bWJlcldyYXBwZXI7XG4gIGRlZmluZUJ1aWx0SW4oZ2xvYmFsLCBOVU1CRVIsIE51bWJlcldyYXBwZXIsIHsgY29uc3RydWN0b3I6IHRydWUgfSk7XG59XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBpc0ludGVncmFsTnVtYmVyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWludGVncmFsLW51bWJlcicpO1xuXG4vLyBgTnVtYmVyLmlzSW50ZWdlcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW51bWJlci5pc2ludGVnZXJcbiQoeyB0YXJnZXQ6ICdOdW1iZXInLCBzdGF0OiB0cnVlIH0sIHtcbiAgaXNJbnRlZ2VyOiBpc0ludGVncmFsTnVtYmVyXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eScpO1xudmFyIHRoaXNOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90aGlzLW51bWJlci12YWx1ZScpO1xudmFyICRyZXBlYXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLXJlcGVhdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbnZhciAkUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgcmVwZWF0ID0gdW5jdXJyeVRoaXMoJHJlcGVhdCk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG52YXIgdW4kVG9GaXhlZCA9IHVuY3VycnlUaGlzKDEuMC50b0ZpeGVkKTtcblxudmFyIHBvdyA9IGZ1bmN0aW9uICh4LCBuLCBhY2MpIHtcbiAgcmV0dXJuIG4gPT09IDAgPyBhY2MgOiBuICUgMiA9PT0gMSA/IHBvdyh4LCBuIC0gMSwgYWNjICogeCkgOiBwb3coeCAqIHgsIG4gLyAyLCBhY2MpO1xufTtcblxudmFyIGxvZyA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBuID0gMDtcbiAgdmFyIHgyID0geDtcbiAgd2hpbGUgKHgyID49IDQwOTYpIHtcbiAgICBuICs9IDEyO1xuICAgIHgyIC89IDQwOTY7XG4gIH1cbiAgd2hpbGUgKHgyID49IDIpIHtcbiAgICBuICs9IDE7XG4gICAgeDIgLz0gMjtcbiAgfSByZXR1cm4gbjtcbn07XG5cbnZhciBtdWx0aXBseSA9IGZ1bmN0aW9uIChkYXRhLCBuLCBjKSB7XG4gIHZhciBpbmRleCA9IC0xO1xuICB2YXIgYzIgPSBjO1xuICB3aGlsZSAoKytpbmRleCA8IDYpIHtcbiAgICBjMiArPSBuICogZGF0YVtpbmRleF07XG4gICAgZGF0YVtpbmRleF0gPSBjMiAlIDFlNztcbiAgICBjMiA9IGZsb29yKGMyIC8gMWU3KTtcbiAgfVxufTtcblxudmFyIGRpdmlkZSA9IGZ1bmN0aW9uIChkYXRhLCBuKSB7XG4gIHZhciBpbmRleCA9IDY7XG4gIHZhciBjID0gMDtcbiAgd2hpbGUgKC0taW5kZXggPj0gMCkge1xuICAgIGMgKz0gZGF0YVtpbmRleF07XG4gICAgZGF0YVtpbmRleF0gPSBmbG9vcihjIC8gbik7XG4gICAgYyA9IChjICUgbikgKiAxZTc7XG4gIH1cbn07XG5cbnZhciBkYXRhVG9TdHJpbmcgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgaW5kZXggPSA2O1xuICB2YXIgcyA9ICcnO1xuICB3aGlsZSAoLS1pbmRleCA+PSAwKSB7XG4gICAgaWYgKHMgIT09ICcnIHx8IGluZGV4ID09PSAwIHx8IGRhdGFbaW5kZXhdICE9PSAwKSB7XG4gICAgICB2YXIgdCA9ICRTdHJpbmcoZGF0YVtpbmRleF0pO1xuICAgICAgcyA9IHMgPT09ICcnID8gdCA6IHMgKyByZXBlYXQoJzAnLCA3IC0gdC5sZW5ndGgpICsgdDtcbiAgICB9XG4gIH0gcmV0dXJuIHM7XG59O1xuXG52YXIgRk9SQ0VEID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdW4kVG9GaXhlZCgwLjAwMDA4LCAzKSAhPT0gJzAuMDAwJyB8fFxuICAgIHVuJFRvRml4ZWQoMC45LCAwKSAhPT0gJzEnIHx8XG4gICAgdW4kVG9GaXhlZCgxLjI1NSwgMikgIT09ICcxLjI1JyB8fFxuICAgIHVuJFRvRml4ZWQoMTAwMDAwMDAwMDAwMDAwMDEyOC4wLCAwKSAhPT0gJzEwMDAwMDAwMDAwMDAwMDAxMjgnO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgdW4kVG9GaXhlZCh7fSk7XG59KTtcblxuLy8gYE51bWJlci5wcm90b3R5cGUudG9GaXhlZGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW51bWJlci5wcm90b3R5cGUudG9maXhlZFxuJCh7IHRhcmdldDogJ051bWJlcicsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIHRvRml4ZWQ6IGZ1bmN0aW9uIHRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpIHtcbiAgICB2YXIgbnVtYmVyID0gdGhpc051bWJlclZhbHVlKHRoaXMpO1xuICAgIHZhciBmcmFjdERpZ2l0cyA9IHRvSW50ZWdlck9ySW5maW5pdHkoZnJhY3Rpb25EaWdpdHMpO1xuICAgIHZhciBkYXRhID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIHZhciBzaWduID0gJyc7XG4gICAgdmFyIHJlc3VsdCA9ICcwJztcbiAgICB2YXIgZSwgeiwgaiwgaztcblxuICAgIC8vIFRPRE86IEVTMjAxOCBpbmNyZWFzZWQgdGhlIG1heGltdW0gbnVtYmVyIG9mIGZyYWN0aW9uIGRpZ2l0cyB0byAxMDAsIG5lZWQgdG8gaW1wcm92ZSB0aGUgaW1wbGVtZW50YXRpb25cbiAgICBpZiAoZnJhY3REaWdpdHMgPCAwIHx8IGZyYWN0RGlnaXRzID4gMjApIHRocm93ICRSYW5nZUVycm9yKCdJbmNvcnJlY3QgZnJhY3Rpb24gZGlnaXRzJyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAobnVtYmVyICE9IG51bWJlcikgcmV0dXJuICdOYU4nO1xuICAgIGlmIChudW1iZXIgPD0gLTFlMjEgfHwgbnVtYmVyID49IDFlMjEpIHJldHVybiAkU3RyaW5nKG51bWJlcik7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgIHNpZ24gPSAnLSc7XG4gICAgICBudW1iZXIgPSAtbnVtYmVyO1xuICAgIH1cbiAgICBpZiAobnVtYmVyID4gMWUtMjEpIHtcbiAgICAgIGUgPSBsb2cobnVtYmVyICogcG93KDIsIDY5LCAxKSkgLSA2OTtcbiAgICAgIHogPSBlIDwgMCA/IG51bWJlciAqIHBvdygyLCAtZSwgMSkgOiBudW1iZXIgLyBwb3coMiwgZSwgMSk7XG4gICAgICB6ICo9IDB4MTAwMDAwMDAwMDAwMDA7XG4gICAgICBlID0gNTIgLSBlO1xuICAgICAgaWYgKGUgPiAwKSB7XG4gICAgICAgIG11bHRpcGx5KGRhdGEsIDAsIHopO1xuICAgICAgICBqID0gZnJhY3REaWdpdHM7XG4gICAgICAgIHdoaWxlIChqID49IDcpIHtcbiAgICAgICAgICBtdWx0aXBseShkYXRhLCAxZTcsIDApO1xuICAgICAgICAgIGogLT0gNztcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseShkYXRhLCBwb3coMTAsIGosIDEpLCAwKTtcbiAgICAgICAgaiA9IGUgLSAxO1xuICAgICAgICB3aGlsZSAoaiA+PSAyMykge1xuICAgICAgICAgIGRpdmlkZShkYXRhLCAxIDw8IDIzKTtcbiAgICAgICAgICBqIC09IDIzO1xuICAgICAgICB9XG4gICAgICAgIGRpdmlkZShkYXRhLCAxIDw8IGopO1xuICAgICAgICBtdWx0aXBseShkYXRhLCAxLCAxKTtcbiAgICAgICAgZGl2aWRlKGRhdGEsIDIpO1xuICAgICAgICByZXN1bHQgPSBkYXRhVG9TdHJpbmcoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdWx0aXBseShkYXRhLCAwLCB6KTtcbiAgICAgICAgbXVsdGlwbHkoZGF0YSwgMSA8PCAtZSwgMCk7XG4gICAgICAgIHJlc3VsdCA9IGRhdGFUb1N0cmluZyhkYXRhKSArIHJlcGVhdCgnMCcsIGZyYWN0RGlnaXRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZyYWN0RGlnaXRzID4gMCkge1xuICAgICAgayA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICByZXN1bHQgPSBzaWduICsgKGsgPD0gZnJhY3REaWdpdHNcbiAgICAgICAgPyAnMC4nICsgcmVwZWF0KCcwJywgZnJhY3REaWdpdHMgLSBrKSArIHJlc3VsdFxuICAgICAgICA6IHN0cmluZ1NsaWNlKHJlc3VsdCwgMCwgayAtIGZyYWN0RGlnaXRzKSArICcuJyArIHN0cmluZ1NsaWNlKHJlc3VsdCwgayAtIGZyYWN0RGlnaXRzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHNpZ24gKyByZXN1bHQ7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtYXNzaWduJyk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWFzc2lnbiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGFyaXR5OiAyLCBmb3JjZWQ6IE9iamVjdC5hc3NpZ24gIT09IGFzc2lnbiB9LCB7XG4gIGFzc2lnbjogYXNzaWduXG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRlbnRyaWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC10by1hcnJheScpLmVudHJpZXM7XG5cbi8vIGBPYmplY3QuZW50cmllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5lbnRyaWVzXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSB9LCB7XG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoTykge1xuICAgIHJldHVybiAkZW50cmllcyhPKTtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJykuZjtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xuXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKDEpOyB9KTtcbnZhciBGT1JDRUQgPSAhREVTQ1JJUFRPUlMgfHwgRkFJTFNfT05fUFJJTUlUSVZFUztcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQsIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSW5kZXhlZE9iamVjdChpdCksIGtleSk7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL293bi1rZXlzJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7XG4gICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICAgIHZhciBrZXlzID0gb3duS2V5cyhPKTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIga2V5LCBkZXNjcmlwdG9yO1xuICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIGtleSA9IGtleXNbaW5kZXgrK10pO1xuICAgICAgaWYgKGRlc2NyaXB0b3IgIT09IHVuZGVmaW5lZCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy1leHRlcm5hbCcpLmY7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuICFPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygxKTsgfSk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogZ2V0T3duUHJvcGVydHlOYW1lc1xufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG5cbi8vIFY4IH4gQ2hyb21lIDM4IGFuZCAzOSBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgZmFpbHMgb24gcHJpbWl0aXZlc1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzQ0M1xudmFyIEZPUkNFRCA9ICFOQVRJVkVfU1lNQk9MIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHsgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmYoMSk7IH0pO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eXN5bWJvbHNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIGdldE93blByb3BlcnR5U3ltYm9sczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gICAgdmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5U3ltYm9scyA/ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHModG9PYmplY3QoaXQpKSA6IFtdO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgbmF0aXZlR2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyJyk7XG5cbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBuYXRpdmVHZXRQcm90b3R5cGVPZigxKTsgfSk7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2ZcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMsIHNoYW06ICFDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgfSwge1xuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpIHtcbiAgICByZXR1cm4gbmF0aXZlR2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfVxufSk7XG5cbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgbmF0aXZlS2V5cygxKTsgfSk7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTIH0sIHtcbiAga2V5czogZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH1cbn0pO1xuIiwidmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQnKTtcbnZhciBkZWZpbmVCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbicpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcnKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG5pZiAoIVRPX1NUUklOR19UQUdfU1VQUE9SVCkge1xuICBkZWZpbmVCdWlsdEluKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIHRvU3RyaW5nLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGFDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWNhbGxhYmxlJyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGVyZm9ybScpO1xudmFyIGl0ZXJhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0ZScpO1xudmFyIFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Byb21pc2Utc3RhdGljcy1pbmNvcnJlY3QtaXRlcmF0aW9uJyk7XG5cbi8vIGBQcm9taXNlLmFsbGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UuYWxsXG4kKHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04gfSwge1xuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhQ2FsbGFibGUoQy5yZXNvbHZlKTtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgaXRlcmF0ZShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY291bnRlcisrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgY2FsbCgkcHJvbWlzZVJlc29sdmUsIEMsIHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wcm9taXNlLWNvbnN0cnVjdG9yLWRldGVjdGlvbicpLkNPTlNUUlVDVE9SO1xudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wcm9taXNlLW5hdGl2ZS1jb25zdHJ1Y3RvcicpO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGRlZmluZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluJyk7XG5cbnZhciBOYXRpdmVQcm9taXNlUHJvdG90eXBlID0gTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbi8vIGBQcm9taXNlLnByb3RvdHlwZS5jYXRjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLmNhdGNoXG4kKHsgdGFyZ2V0OiAnUHJvbWlzZScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SLCByZWFsOiB0cnVlIH0sIHtcbiAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gIH1cbn0pO1xuXG4vLyBtYWtlcyBzdXJlIHRoYXQgbmF0aXZlIHByb21pc2UtYmFzZWQgQVBJcyBgUHJvbWlzZSNjYXRjaGAgcHJvcGVybHkgd29ya3Mgd2l0aCBwYXRjaGVkIGBQcm9taXNlI3RoZW5gXG5pZiAoIUlTX1BVUkUgJiYgaXNDYWxsYWJsZShOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IpKSB7XG4gIHZhciBtZXRob2QgPSBnZXRCdWlsdEluKCdQcm9taXNlJykucHJvdG90eXBlWydjYXRjaCddO1xuICBpZiAoTmF0aXZlUHJvbWlzZVByb3RvdHlwZVsnY2F0Y2gnXSAhPT0gbWV0aG9kKSB7XG4gICAgZGVmaW5lQnVpbHRJbihOYXRpdmVQcm9taXNlUHJvdG90eXBlLCAnY2F0Y2gnLCBtZXRob2QsIHsgdW5zYWZlOiB0cnVlIH0pO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBJU19OT0RFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS1pcy1ub2RlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGRlZmluZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluJyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXNwZWNpZXMnKTtcbnZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciB0YXNrID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Rhc2snKS5zZXQ7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL21pY3JvdGFzaycpO1xudmFyIGhvc3RSZXBvcnRFcnJvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaG9zdC1yZXBvcnQtZXJyb3JzJyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wZXJmb3JtJyk7XG52YXIgUXVldWUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcXVldWUnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Byb21pc2UtbmF0aXZlLWNvbnN0cnVjdG9yJyk7XG52YXIgUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Byb21pc2UtY29uc3RydWN0b3ItZGV0ZWN0aW9uJyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiA9IFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcbnZhciBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQgPSBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uUkVKRUNUSU9OX0VWRU5UO1xudmFyIE5BVElWRV9QUk9NSVNFX1NVQkNMQVNTSU5HID0gUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLlNVQkNMQVNTSU5HO1xudmFyIGdldEludGVybmFsUHJvbWlzZVN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoUFJPTUlTRSk7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIE5hdGl2ZVByb21pc2VQcm90b3R5cGUgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IgJiYgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbnZhciBQcm9taXNlQ29uc3RydWN0b3IgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3I7XG52YXIgUHJvbWlzZVByb3RvdHlwZSA9IE5hdGl2ZVByb21pc2VQcm90b3R5cGU7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mO1xudmFyIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5O1xuXG52YXIgRElTUEFUQ0hfRVZFTlQgPSAhIShkb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFdmVudCAmJiBnbG9iYWwuZGlzcGF0Y2hFdmVudCk7XG52YXIgVU5IQU5ETEVEX1JFSkVDVElPTiA9ICd1bmhhbmRsZWRyZWplY3Rpb24nO1xudmFyIFJFSkVDVElPTl9IQU5ETEVEID0gJ3JlamVjdGlvbmhhbmRsZWQnO1xudmFyIFBFTkRJTkcgPSAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xudmFyIEhBTkRMRUQgPSAxO1xudmFyIFVOSEFORExFRCA9IDI7XG5cbnZhciBJbnRlcm5hbCwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFByb21pc2VXcmFwcGVyLCBuYXRpdmVUaGVuO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiBpc0NhbGxhYmxlKHRoZW4gPSBpdC50aGVuKSA/IHRoZW4gOiBmYWxzZTtcbn07XG5cbnZhciBjYWxsUmVhY3Rpb24gPSBmdW5jdGlvbiAocmVhY3Rpb24sIHN0YXRlKSB7XG4gIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICB2YXIgb2sgPSBzdGF0ZS5zdGF0ZSA9PSBGVUxGSUxMRUQ7XG4gIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuICB0cnkge1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBpZiAoIW9rKSB7XG4gICAgICAgIGlmIChzdGF0ZS5yZWplY3Rpb24gPT09IFVOSEFORExFRCkgb25IYW5kbGVVbmhhbmRsZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5yZWplY3Rpb24gPSBIQU5ETEVEO1xuICAgICAgfVxuICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTsgLy8gY2FuIHRocm93XG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgIGV4aXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICBjYWxsKHRoZW4sIHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGRvbWFpbiAmJiAhZXhpdGVkKSBkb21haW4uZXhpdCgpO1xuICAgIHJlamVjdChlcnJvcik7XG4gIH1cbn07XG5cbnZhciBub3RpZnkgPSBmdW5jdGlvbiAoc3RhdGUsIGlzUmVqZWN0KSB7XG4gIGlmIChzdGF0ZS5ub3RpZmllZCkgcmV0dXJuO1xuICBzdGF0ZS5ub3RpZmllZCA9IHRydWU7XG4gIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlYWN0aW9ucyA9IHN0YXRlLnJlYWN0aW9ucztcbiAgICB2YXIgcmVhY3Rpb247XG4gICAgd2hpbGUgKHJlYWN0aW9uID0gcmVhY3Rpb25zLmdldCgpKSB7XG4gICAgICBjYWxsUmVhY3Rpb24ocmVhY3Rpb24sIHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUubm90aWZpZWQgPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXN0YXRlLnJlamVjdGlvbikgb25VbmhhbmRsZWQoc3RhdGUpO1xuICB9KTtcbn07XG5cbnZhciBkaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIHByb21pc2UsIHJlYXNvbikge1xuICB2YXIgZXZlbnQsIGhhbmRsZXI7XG4gIGlmIChESVNQQVRDSF9FVkVOVCkge1xuICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZXZlbnQucmVhc29uID0gcmVhc29uO1xuICAgIGV2ZW50LmluaXRFdmVudChuYW1lLCBmYWxzZSwgdHJ1ZSk7XG4gICAgZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9IGVsc2UgZXZlbnQgPSB7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcmVhc29uIH07XG4gIGlmICghTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UICYmIChoYW5kbGVyID0gZ2xvYmFsWydvbicgKyBuYW1lXSkpIGhhbmRsZXIoZXZlbnQpO1xuICBlbHNlIGlmIChuYW1lID09PSBVTkhBTkRMRURfUkVKRUNUSU9OKSBob3N0UmVwb3J0RXJyb3JzKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCByZWFzb24pO1xufTtcblxudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIGNhbGwodGFzaywgZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBzdGF0ZS5mYWNhZGU7XG4gICAgdmFyIHZhbHVlID0gc3RhdGUudmFsdWU7XG4gICAgdmFyIElTX1VOSEFORExFRCA9IGlzVW5oYW5kbGVkKHN0YXRlKTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChJU19VTkhBTkRMRUQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoSVNfTk9ERSkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgZGlzcGF0Y2hFdmVudChVTkhBTkRMRURfUkVKRUNUSU9OLCBwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBzdGF0ZS5yZWplY3Rpb24gPSBJU19OT0RFIHx8IGlzVW5oYW5kbGVkKHN0YXRlKSA/IFVOSEFORExFRCA6IEhBTkRMRUQ7XG4gICAgICBpZiAocmVzdWx0LmVycm9yKSB0aHJvdyByZXN1bHQudmFsdWU7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUucmVqZWN0aW9uICE9PSBIQU5ETEVEICYmICFzdGF0ZS5wYXJlbnQ7XG59O1xuXG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgY2FsbCh0YXNrLCBnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHN0YXRlLmZhY2FkZTtcbiAgICBpZiAoSVNfTk9ERSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoUkVKRUNUSU9OX0hBTkRMRUQsIHByb21pc2UsIHN0YXRlLnZhbHVlKTtcbiAgfSk7XG59O1xuXG52YXIgYmluZCA9IGZ1bmN0aW9uIChmbiwgc3RhdGUsIHVud3JhcCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgZm4oc3RhdGUsIHZhbHVlLCB1bndyYXApO1xuICB9O1xufTtcblxudmFyIGludGVybmFsUmVqZWN0ID0gZnVuY3Rpb24gKHN0YXRlLCB2YWx1ZSwgdW53cmFwKSB7XG4gIGlmIChzdGF0ZS5kb25lKSByZXR1cm47XG4gIHN0YXRlLmRvbmUgPSB0cnVlO1xuICBpZiAodW53cmFwKSBzdGF0ZSA9IHVud3JhcDtcbiAgc3RhdGUudmFsdWUgPSB2YWx1ZTtcbiAgc3RhdGUuc3RhdGUgPSBSRUpFQ1RFRDtcbiAgbm90aWZ5KHN0YXRlLCB0cnVlKTtcbn07XG5cbnZhciBpbnRlcm5hbFJlc29sdmUgPSBmdW5jdGlvbiAoc3RhdGUsIHZhbHVlLCB1bndyYXApIHtcbiAgaWYgKHN0YXRlLmRvbmUpIHJldHVybjtcbiAgc3RhdGUuZG9uZSA9IHRydWU7XG4gIGlmICh1bndyYXApIHN0YXRlID0gdW53cmFwO1xuICB0cnkge1xuICAgIGlmIChzdGF0ZS5mYWNhZGUgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICB2YXIgdGhlbiA9IGlzVGhlbmFibGUodmFsdWUpO1xuICAgIGlmICh0aGVuKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYWxsKHRoZW4sIHZhbHVlLFxuICAgICAgICAgICAgYmluZChpbnRlcm5hbFJlc29sdmUsIHdyYXBwZXIsIHN0YXRlKSxcbiAgICAgICAgICAgIGJpbmQoaW50ZXJuYWxSZWplY3QsIHdyYXBwZXIsIHN0YXRlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaW50ZXJuYWxSZWplY3Qod3JhcHBlciwgZXJyb3IsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gICAgICBzdGF0ZS5zdGF0ZSA9IEZVTEZJTExFRDtcbiAgICAgIG5vdGlmeShzdGF0ZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpbnRlcm5hbFJlamVjdCh7IGRvbmU6IGZhbHNlIH0sIGVycm9yLCBzdGF0ZSk7XG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgUHJvbWlzZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UodGhpcywgUHJvbWlzZVByb3RvdHlwZSk7XG4gICAgYUNhbGxhYmxlKGV4ZWN1dG9yKTtcbiAgICBjYWxsKEludGVybmFsLCB0aGlzKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoYmluZChpbnRlcm5hbFJlc29sdmUsIHN0YXRlKSwgYmluZChpbnRlcm5hbFJlamVjdCwgc3RhdGUpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaW50ZXJuYWxSZWplY3Qoc3RhdGUsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgUHJvbWlzZVByb3RvdHlwZSA9IFByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgICB0eXBlOiBQUk9NSVNFLFxuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICBub3RpZmllZDogZmFsc2UsXG4gICAgICBwYXJlbnQ6IGZhbHNlLFxuICAgICAgcmVhY3Rpb25zOiBuZXcgUXVldWUoKSxcbiAgICAgIHJlamVjdGlvbjogZmFsc2UsXG4gICAgICBzdGF0ZTogUEVORElORyxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfTtcblxuICAvLyBgUHJvbWlzZS5wcm90b3R5cGUudGhlbmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUudGhlblxuICBJbnRlcm5hbC5wcm90b3R5cGUgPSBkZWZpbmVCdWlsdEluKFByb21pc2VQcm90b3R5cGUsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHRoaXMpO1xuICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IpKTtcbiAgICBzdGF0ZS5wYXJlbnQgPSB0cnVlO1xuICAgIHJlYWN0aW9uLm9rID0gaXNDYWxsYWJsZShvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgcmVhY3Rpb24uZmFpbCA9IGlzQ2FsbGFibGUob25SZWplY3RlZCkgJiYgb25SZWplY3RlZDtcbiAgICByZWFjdGlvbi5kb21haW4gPSBJU19OT0RFID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgaWYgKHN0YXRlLnN0YXRlID09IFBFTkRJTkcpIHN0YXRlLnJlYWN0aW9ucy5hZGQocmVhY3Rpb24pO1xuICAgIGVsc2UgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxSZWFjdGlvbihyZWFjdGlvbiwgc3RhdGUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICB9KTtcblxuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHByb21pc2UpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gYmluZChpbnRlcm5hbFJlc29sdmUsIHN0YXRlKTtcbiAgICB0aGlzLnJlamVjdCA9IGJpbmQoaW50ZXJuYWxSZWplY3QsIHN0YXRlKTtcbiAgfTtcblxuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSBQcm9taXNlQ29uc3RydWN0b3IgfHwgQyA9PT0gUHJvbWlzZVdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcblxuICBpZiAoIUlTX1BVUkUgJiYgaXNDYWxsYWJsZShOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IpICYmIE5hdGl2ZVByb21pc2VQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICBuYXRpdmVUaGVuID0gTmF0aXZlUHJvbWlzZVByb3RvdHlwZS50aGVuO1xuXG4gICAgaWYgKCFOQVRJVkVfUFJPTUlTRV9TVUJDTEFTU0lORykge1xuICAgICAgLy8gbWFrZSBgUHJvbWlzZSN0aGVuYCByZXR1cm4gYSBwb2x5ZmlsbGVkIGBQcm9taXNlYCBmb3IgbmF0aXZlIHByb21pc2UtYmFzZWQgQVBJc1xuICAgICAgZGVmaW5lQnVpbHRJbihOYXRpdmVQcm9taXNlUHJvdG90eXBlLCAndGhlbicsIGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgY2FsbChuYXRpdmVUaGVuLCB0aGF0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NDBcbiAgICAgIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIC8vIG1ha2UgYC5jb25zdHJ1Y3RvciA9PT0gUHJvbWlzZWAgd29yayBmb3IgbmF0aXZlIHByb21pc2UtYmFzZWQgQVBJc1xuICAgIHRyeSB7XG4gICAgICBkZWxldGUgTmF0aXZlUHJvbWlzZVByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbiAgICAvLyBtYWtlIGBpbnN0YW5jZW9mIFByb21pc2VgIHdvcmsgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIHNldFByb3RvdHlwZU9mKE5hdGl2ZVByb21pc2VQcm90b3R5cGUsIFByb21pc2VQcm90b3R5cGUpO1xuICAgIH1cbiAgfVxufVxuXG4kKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgd3JhcDogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiB9LCB7XG4gIFByb21pc2U6IFByb21pc2VDb25zdHJ1Y3RvclxufSk7XG5cbnNldFRvU3RyaW5nVGFnKFByb21pc2VDb25zdHJ1Y3RvciwgUFJPTUlTRSwgZmFsc2UsIHRydWUpO1xuc2V0U3BlY2llcyhQUk9NSVNFKTtcbiIsIi8vIFRPRE86IFJlbW92ZSB0aGlzIG1vZHVsZSBmcm9tIGBjb3JlLWpzQDRgIHNpbmNlIGl0J3Mgc3BsaXQgdG8gbW9kdWxlcyBsaXN0ZWQgYmVsb3dcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMucHJvbWlzZS5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5wcm9taXNlLmFsbCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5wcm9taXNlLmNhdGNoJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnByb21pc2UucmFjZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5wcm9taXNlLnJlamVjdCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5wcm9taXNlLnJlc29sdmUnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGFDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWNhbGxhYmxlJyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGVyZm9ybScpO1xudmFyIGl0ZXJhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0ZScpO1xudmFyIFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Byb21pc2Utc3RhdGljcy1pbmNvcnJlY3QtaXRlcmF0aW9uJyk7XG5cbi8vIGBQcm9taXNlLnJhY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJhY2VcbiQoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mKEMpO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHByb21pc2VSZXNvbHZlID0gYUNhbGxhYmxlKEMucmVzb2x2ZSk7XG4gICAgICBpdGVyYXRlKGl0ZXJhYmxlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBjYWxsKCRwcm9taXNlUmVzb2x2ZSwgQywgcHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wcm9taXNlLWNvbnN0cnVjdG9yLWRldGVjdGlvbicpLkNPTlNUUlVDVE9SO1xuXG4vLyBgUHJvbWlzZS5yZWplY3RgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlamVjdFxuJCh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SIH0sIHtcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZih0aGlzKTtcbiAgICBjYWxsKGNhcGFiaWxpdHkucmVqZWN0LCB1bmRlZmluZWQsIHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcHJvbWlzZS1uYXRpdmUtY29uc3RydWN0b3InKTtcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wcm9taXNlLWNvbnN0cnVjdG9yLWRldGVjdGlvbicpLkNPTlNUUlVDVE9SO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Byb21pc2UtcmVzb2x2ZScpO1xuXG52YXIgUHJvbWlzZUNvbnN0cnVjdG9yV3JhcHBlciA9IGdldEJ1aWx0SW4oJ1Byb21pc2UnKTtcbnZhciBDSEVDS19XUkFQUEVSID0gSVNfUFVSRSAmJiAhRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1I7XG5cbi8vIGBQcm9taXNlLnJlc29sdmVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlc29sdmVcbiQoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBJU19QVVJFIHx8IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SIH0sIHtcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKENIRUNLX1dSQVBQRVIgJiYgdGhpcyA9PT0gUHJvbWlzZUNvbnN0cnVjdG9yV3JhcHBlciA/IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciA6IHRoaXMsIHgpO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgYXBwbHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYXBwbHknKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBhQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jb25zdHJ1Y3RvcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxudmFyIG5hdGl2ZUNvbnN0cnVjdCA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnY29uc3RydWN0Jyk7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBwdXNoID0gW10ucHVzaDtcblxuLy8gYFJlZmxlY3QuY29uc3RydWN0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVmbGVjdC5jb25zdHJ1Y3Rcbi8vIE1TIEVkZ2Ugc3VwcG9ydHMgb25seSAyIGFyZ3VtZW50cyBhbmQgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuLy8gRkYgTmlnaHRseSBzZXRzIHRoaXJkIGFyZ3VtZW50IGFzIGBuZXcudGFyZ2V0YCwgYnV0IGRvZXMgbm90IGNyZWF0ZSBgdGhpc2AgZnJvbSBpdFxudmFyIE5FV19UQVJHRVRfQlVHID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiAhKG5hdGl2ZUNvbnN0cnVjdChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIFtdLCBGKSBpbnN0YW5jZW9mIEYpO1xufSk7XG5cbnZhciBBUkdTX0JVRyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIG5hdGl2ZUNvbnN0cnVjdChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbnZhciBGT1JDRUQgPSBORVdfVEFSR0VUX0JVRyB8fCBBUkdTX0JVRztcblxuJCh7IHRhcmdldDogJ1JlZmxlY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCwgc2hhbTogRk9SQ0VEIH0sIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qICwgbmV3VGFyZ2V0ICovKSB7XG4gICAgYUNvbnN0cnVjdG9yKFRhcmdldCk7XG4gICAgYW5PYmplY3QoYXJncyk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUNvbnN0cnVjdG9yKGFyZ3VtZW50c1syXSk7XG4gICAgaWYgKEFSR1NfQlVHICYmICFORVdfVEFSR0VUX0JVRykgcmV0dXJuIG5hdGl2ZUNvbnN0cnVjdChUYXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG4gICAgaWYgKFRhcmdldCA9PSBuZXdUYXJnZXQpIHtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBUYXJnZXQoKTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH1cbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICBhcHBseShwdXNoLCAkYXJncywgYXJncyk7XG4gICAgICByZXR1cm4gbmV3IChhcHBseShiaW5kLCBUYXJnZXQsICRhcmdzKSkoKTtcbiAgICB9XG4gICAgLy8gd2l0aCBhbHRlcmVkIG5ld1RhcmdldCwgbm90IHN1cHBvcnQgYnVpbHQtaW4gY29uc3RydWN0b3JzXG4gICAgdmFyIHByb3RvID0gbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGUoaXNPYmplY3QocHJvdG8pID8gcHJvdG8gOiBPYmplY3RQcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBhcHBseShUYXJnZXQsIGluc3RhbmNlLCBhcmdzKTtcbiAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IGluc3RhbmNlO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGlzRGF0YURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZGF0YS1kZXNjcmlwdG9yJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xuXG4vLyBgUmVmbGVjdC5nZXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWZsZWN0LmdldFxuZnVuY3Rpb24gZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgLyogLCByZWNlaXZlciAqLykge1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXTtcbiAgdmFyIGRlc2NyaXB0b3IsIHByb3RvdHlwZTtcbiAgaWYgKGFuT2JqZWN0KHRhcmdldCkgPT09IHJlY2VpdmVyKSByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mKHRhcmdldCwgcHJvcGVydHlLZXkpO1xuICBpZiAoZGVzY3JpcHRvcikgcmV0dXJuIGlzRGF0YURlc2NyaXB0b3IoZGVzY3JpcHRvcilcbiAgICA/IGRlc2NyaXB0b3IudmFsdWVcbiAgICA6IGRlc2NyaXB0b3IuZ2V0ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjYWxsKGRlc2NyaXB0b3IuZ2V0LCByZWNlaXZlcik7XG4gIGlmIChpc09iamVjdChwcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSkgcmV0dXJuIGdldChwcm90b3R5cGUsIHByb3BlcnR5S2V5LCByZWNlaXZlcik7XG59XG5cbiQoeyB0YXJnZXQ6ICdSZWZsZWN0Jywgc3RhdDogdHJ1ZSB9LCB7XG4gIGdldDogZ2V0XG59KTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKS5mO1xudmFyIGlzUHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZicpO1xudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXJlZ2V4cCcpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIGdldFJlZ0V4cEZsYWdzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1nZXQtZmxhZ3MnKTtcbnZhciBzdGlja3lIZWxwZXJzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1zdGlja3ktaGVscGVycycpO1xudmFyIHByb3h5QWNjZXNzb3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcHJveHktYWNjZXNzb3InKTtcbnZhciBkZWZpbmVCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbicpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpLmVuZm9yY2U7XG52YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtc3BlY2llcycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIFVOU1VQUE9SVEVEX0RPVF9BTEwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLXVuc3VwcG9ydGVkLWRvdC1hbGwnKTtcbnZhciBVTlNVUFBPUlRFRF9OQ0cgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLXVuc3VwcG9ydGVkLW5jZycpO1xuXG52YXIgTUFUQ0ggPSB3ZWxsS25vd25TeW1ib2woJ21hdGNoJyk7XG52YXIgTmF0aXZlUmVnRXhwID0gZ2xvYmFsLlJlZ0V4cDtcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBOYXRpdmVSZWdFeHAucHJvdG90eXBlO1xudmFyIFN5bnRheEVycm9yID0gZ2xvYmFsLlN5bnRheEVycm9yO1xudmFyIGV4ZWMgPSB1bmN1cnJ5VGhpcyhSZWdFeHBQcm90b3R5cGUuZXhlYyk7XG52YXIgY2hhckF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckF0KTtcbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMoJycucmVwbGFjZSk7XG52YXIgc3RyaW5nSW5kZXhPZiA9IHVuY3VycnlUaGlzKCcnLmluZGV4T2YpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xuLy8gVE9ETzogVXNlIG9ubHkgcHJvcHBlciBSZWdFeHBJZGVudGlmaWVyTmFtZVxudmFyIElTX05DRyA9IC9eXFw/PFteXFxzXFxkISMlJiorPD0+QF5dW15cXHMhIyUmKis8PT5AXl0qPi87XG52YXIgcmUxID0gL2EvZztcbnZhciByZTIgPSAvYS9nO1xuXG4vLyBcIm5ld1wiIHNob3VsZCBjcmVhdGUgYSBuZXcgb2JqZWN0LCBvbGQgd2Via2l0IGJ1Z1xudmFyIENPUlJFQ1RfTkVXID0gbmV3IE5hdGl2ZVJlZ0V4cChyZTEpICE9PSByZTE7XG5cbnZhciBNSVNTRURfU1RJQ0tZID0gc3RpY2t5SGVscGVycy5NSVNTRURfU1RJQ0tZO1xudmFyIFVOU1VQUE9SVEVEX1kgPSBzdGlja3lIZWxwZXJzLlVOU1VQUE9SVEVEX1k7XG5cbnZhciBCQVNFX0ZPUkNFRCA9IERFU0NSSVBUT1JTICYmXG4gICghQ09SUkVDVF9ORVcgfHwgTUlTU0VEX1NUSUNLWSB8fCBVTlNVUFBPUlRFRF9ET1RfQUxMIHx8IFVOU1VQUE9SVEVEX05DRyB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgcmUyW01BVENIXSA9IGZhbHNlO1xuICAgIC8vIFJlZ0V4cCBjb25zdHJ1Y3RvciBjYW4gYWx0ZXIgZmxhZ3MgYW5kIElzUmVnRXhwIHdvcmtzIGNvcnJlY3Qgd2l0aCBAQG1hdGNoXG4gICAgcmV0dXJuIE5hdGl2ZVJlZ0V4cChyZTEpICE9IHJlMSB8fCBOYXRpdmVSZWdFeHAocmUyKSA9PSByZTIgfHwgTmF0aXZlUmVnRXhwKHJlMSwgJ2knKSAhPSAnL2EvaSc7XG4gIH0pKTtcblxudmFyIGhhbmRsZURvdEFsbCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIGJyYWNrZXRzID0gZmFsc2U7XG4gIHZhciBjaHI7XG4gIGZvciAoOyBpbmRleCA8PSBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBjaHIgPSBjaGFyQXQoc3RyaW5nLCBpbmRleCk7XG4gICAgaWYgKGNociA9PT0gJ1xcXFwnKSB7XG4gICAgICByZXN1bHQgKz0gY2hyICsgY2hhckF0KHN0cmluZywgKytpbmRleCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFicmFja2V0cyAmJiBjaHIgPT09ICcuJykge1xuICAgICAgcmVzdWx0ICs9ICdbXFxcXHNcXFxcU10nO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2hyID09PSAnWycpIHtcbiAgICAgICAgYnJhY2tldHMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChjaHIgPT09ICddJykge1xuICAgICAgICBicmFja2V0cyA9IGZhbHNlO1xuICAgICAgfSByZXN1bHQgKz0gY2hyO1xuICAgIH1cbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGhhbmRsZU5DRyA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIG5hbWVkID0gW107XG4gIHZhciBuYW1lcyA9IHt9O1xuICB2YXIgYnJhY2tldHMgPSBmYWxzZTtcbiAgdmFyIG5jZyA9IGZhbHNlO1xuICB2YXIgZ3JvdXBpZCA9IDA7XG4gIHZhciBncm91cG5hbWUgPSAnJztcbiAgdmFyIGNocjtcbiAgZm9yICg7IGluZGV4IDw9IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNociA9IGNoYXJBdChzdHJpbmcsIGluZGV4KTtcbiAgICBpZiAoY2hyID09PSAnXFxcXCcpIHtcbiAgICAgIGNociA9IGNociArIGNoYXJBdChzdHJpbmcsICsraW5kZXgpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAnXScpIHtcbiAgICAgIGJyYWNrZXRzID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghYnJhY2tldHMpIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSBjaHIgPT09ICdbJzpcbiAgICAgICAgYnJhY2tldHMgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgY2hyID09PSAnKCc6XG4gICAgICAgIGlmIChleGVjKElTX05DRywgc3RyaW5nU2xpY2Uoc3RyaW5nLCBpbmRleCArIDEpKSkge1xuICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgbmNnID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gY2hyO1xuICAgICAgICBncm91cGlkKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY2FzZSBjaHIgPT09ICc+JyAmJiBuY2c6XG4gICAgICAgIGlmIChncm91cG5hbWUgPT09ICcnIHx8IGhhc093bihuYW1lcywgZ3JvdXBuYW1lKSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBjYXB0dXJlIGdyb3VwIG5hbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lc1tncm91cG5hbWVdID0gdHJ1ZTtcbiAgICAgICAgbmFtZWRbbmFtZWQubGVuZ3RoXSA9IFtncm91cG5hbWUsIGdyb3VwaWRdO1xuICAgICAgICBuY2cgPSBmYWxzZTtcbiAgICAgICAgZ3JvdXBuYW1lID0gJyc7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobmNnKSBncm91cG5hbWUgKz0gY2hyO1xuICAgIGVsc2UgcmVzdWx0ICs9IGNocjtcbiAgfSByZXR1cm4gW3Jlc3VsdCwgbmFtZWRdO1xufTtcblxuLy8gYFJlZ0V4cGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwLWNvbnN0cnVjdG9yXG5pZiAoaXNGb3JjZWQoJ1JlZ0V4cCcsIEJBU0VfRk9SQ0VEKSkge1xuICB2YXIgUmVnRXhwV3JhcHBlciA9IGZ1bmN0aW9uIFJlZ0V4cChwYXR0ZXJuLCBmbGFncykge1xuICAgIHZhciB0aGlzSXNSZWdFeHAgPSBpc1Byb3RvdHlwZU9mKFJlZ0V4cFByb3RvdHlwZSwgdGhpcyk7XG4gICAgdmFyIHBhdHRlcm5Jc1JlZ0V4cCA9IGlzUmVnRXhwKHBhdHRlcm4pO1xuICAgIHZhciBmbGFnc0FyZVVuZGVmaW5lZCA9IGZsYWdzID09PSB1bmRlZmluZWQ7XG4gICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgIHZhciByYXdQYXR0ZXJuID0gcGF0dGVybjtcbiAgICB2YXIgcmF3RmxhZ3MsIGRvdEFsbCwgc3RpY2t5LCBoYW5kbGVkLCByZXN1bHQsIHN0YXRlO1xuXG4gICAgaWYgKCF0aGlzSXNSZWdFeHAgJiYgcGF0dGVybklzUmVnRXhwICYmIGZsYWdzQXJlVW5kZWZpbmVkICYmIHBhdHRlcm4uY29uc3RydWN0b3IgPT09IFJlZ0V4cFdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH1cblxuICAgIGlmIChwYXR0ZXJuSXNSZWdFeHAgfHwgaXNQcm90b3R5cGVPZihSZWdFeHBQcm90b3R5cGUsIHBhdHRlcm4pKSB7XG4gICAgICBwYXR0ZXJuID0gcGF0dGVybi5zb3VyY2U7XG4gICAgICBpZiAoZmxhZ3NBcmVVbmRlZmluZWQpIGZsYWdzID0gZ2V0UmVnRXhwRmxhZ3MocmF3UGF0dGVybik7XG4gICAgfVxuXG4gICAgcGF0dGVybiA9IHBhdHRlcm4gPT09IHVuZGVmaW5lZCA/ICcnIDogdG9TdHJpbmcocGF0dGVybik7XG4gICAgZmxhZ3MgPSBmbGFncyA9PT0gdW5kZWZpbmVkID8gJycgOiB0b1N0cmluZyhmbGFncyk7XG4gICAgcmF3UGF0dGVybiA9IHBhdHRlcm47XG5cbiAgICBpZiAoVU5TVVBQT1JURURfRE9UX0FMTCAmJiAnZG90QWxsJyBpbiByZTEpIHtcbiAgICAgIGRvdEFsbCA9ICEhZmxhZ3MgJiYgc3RyaW5nSW5kZXhPZihmbGFncywgJ3MnKSA+IC0xO1xuICAgICAgaWYgKGRvdEFsbCkgZmxhZ3MgPSByZXBsYWNlKGZsYWdzLCAvcy9nLCAnJyk7XG4gICAgfVxuXG4gICAgcmF3RmxhZ3MgPSBmbGFncztcblxuICAgIGlmIChNSVNTRURfU1RJQ0tZICYmICdzdGlja3knIGluIHJlMSkge1xuICAgICAgc3RpY2t5ID0gISFmbGFncyAmJiBzdHJpbmdJbmRleE9mKGZsYWdzLCAneScpID4gLTE7XG4gICAgICBpZiAoc3RpY2t5ICYmIFVOU1VQUE9SVEVEX1kpIGZsYWdzID0gcmVwbGFjZShmbGFncywgL3kvZywgJycpO1xuICAgIH1cblxuICAgIGlmIChVTlNVUFBPUlRFRF9OQ0cpIHtcbiAgICAgIGhhbmRsZWQgPSBoYW5kbGVOQ0cocGF0dGVybik7XG4gICAgICBwYXR0ZXJuID0gaGFuZGxlZFswXTtcbiAgICAgIGdyb3VwcyA9IGhhbmRsZWRbMV07XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gaW5oZXJpdElmUmVxdWlyZWQoTmF0aXZlUmVnRXhwKHBhdHRlcm4sIGZsYWdzKSwgdGhpc0lzUmVnRXhwID8gdGhpcyA6IFJlZ0V4cFByb3RvdHlwZSwgUmVnRXhwV3JhcHBlcik7XG5cbiAgICBpZiAoZG90QWxsIHx8IHN0aWNreSB8fCBncm91cHMubGVuZ3RoKSB7XG4gICAgICBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHJlc3VsdCk7XG4gICAgICBpZiAoZG90QWxsKSB7XG4gICAgICAgIHN0YXRlLmRvdEFsbCA9IHRydWU7XG4gICAgICAgIHN0YXRlLnJhdyA9IFJlZ0V4cFdyYXBwZXIoaGFuZGxlRG90QWxsKHBhdHRlcm4pLCByYXdGbGFncyk7XG4gICAgICB9XG4gICAgICBpZiAoc3RpY2t5KSBzdGF0ZS5zdGlja3kgPSB0cnVlO1xuICAgICAgaWYgKGdyb3Vwcy5sZW5ndGgpIHN0YXRlLmdyb3VwcyA9IGdyb3VwcztcbiAgICB9XG5cbiAgICBpZiAocGF0dGVybiAhPT0gcmF3UGF0dGVybikgdHJ5IHtcbiAgICAgIC8vIGZhaWxzIGluIG9sZCBlbmdpbmVzLCBidXQgd2UgaGF2ZSBubyBhbHRlcm5hdGl2ZXMgZm9yIHVuc3VwcG9ydGVkIHJlZ2V4IHN5bnRheFxuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHJlc3VsdCwgJ3NvdXJjZScsIHJhd1BhdHRlcm4gPT09ICcnID8gJyg/OiknIDogcmF3UGF0dGVybik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBmb3IgKHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhOYXRpdmVSZWdFeHApLCBpbmRleCA9IDA7IGtleXMubGVuZ3RoID4gaW5kZXg7KSB7XG4gICAgcHJveHlBY2Nlc3NvcihSZWdFeHBXcmFwcGVyLCBOYXRpdmVSZWdFeHAsIGtleXNbaW5kZXgrK10pO1xuICB9XG5cbiAgUmVnRXhwUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVnRXhwV3JhcHBlcjtcbiAgUmVnRXhwV3JhcHBlci5wcm90b3R5cGUgPSBSZWdFeHBQcm90b3R5cGU7XG4gIGRlZmluZUJ1aWx0SW4oZ2xvYmFsLCAnUmVnRXhwJywgUmVnRXhwV3JhcHBlciwgeyBjb25zdHJ1Y3RvcjogdHJ1ZSB9KTtcbn1cblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtcmVnZXhwLUBAc3BlY2llc1xuc2V0U3BlY2llcygnUmVnRXhwJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBleGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjJyk7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLmV4ZWNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLmV4ZWNcbiQoeyB0YXJnZXQ6ICdSZWdFeHAnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAvLi8uZXhlYyAhPT0gZXhlYyB9LCB7XG4gIGV4ZWM6IGV4ZWNcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUnKS5QUk9QRVI7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciAkdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBnZXRSZWdFeHBGbGFncyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZ2V0LWZsYWdzJyk7XG5cbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyIFJlZ0V4cFByb3RvdHlwZSA9IFJlZ0V4cC5wcm90b3R5cGU7XG52YXIgbiRUb1N0cmluZyA9IFJlZ0V4cFByb3RvdHlwZVtUT19TVFJJTkddO1xuXG52YXIgTk9UX0dFTkVSSUMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IHJldHVybiBuJFRvU3RyaW5nLmNhbGwoeyBzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJyB9KSAhPSAnL2EvYic7IH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbnZhciBJTkNPUlJFQ1RfTkFNRSA9IFBST1BFUl9GVU5DVElPTl9OQU1FICYmIG4kVG9TdHJpbmcubmFtZSAhPSBUT19TVFJJTkc7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuaWYgKE5PVF9HRU5FUklDIHx8IElOQ09SUkVDVF9OQU1FKSB7XG4gIGRlZmluZUJ1aWx0SW4oUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHZhciBwYXR0ZXJuID0gJHRvU3RyaW5nKFIuc291cmNlKTtcbiAgICB2YXIgZmxhZ3MgPSAkdG9TdHJpbmcoZ2V0UmVnRXhwRmxhZ3MoUikpO1xuICAgIHJldHVybiAnLycgKyBwYXR0ZXJuICsgJy8nICsgZmxhZ3M7XG4gIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29sbGVjdGlvbicpO1xudmFyIGNvbGxlY3Rpb25TdHJvbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gYFNldGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LW9iamVjdHNcbmNvbGxlY3Rpb24oJ1NldCcsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7IHJldHVybiBpbml0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwgY29sbGVjdGlvblN0cm9uZyk7XG4iLCIvLyBUT0RPOiBSZW1vdmUgdGhpcyBtb2R1bGUgZnJvbSBgY29yZS1qc0A0YCBzaW5jZSBpdCdzIHJlcGxhY2VkIHRvIG1vZHVsZSBiZWxvd1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zZXQuY29uc3RydWN0b3InKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjaGFyQXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZScpLmNoYXJBdDtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yJyk7XG5cbnZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5kZWZpbmVJdGVyYXRvcihTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgdHlwZTogU1RSSU5HX0lURVJBVE9SLFxuICAgIHN0cmluZzogdG9TdHJpbmcoaXRlcmF0ZWQpLFxuICAgIGluZGV4OiAwXG4gIH0pO1xuLy8gYCVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSBjaGFyQXQoc3RyaW5nLCBpbmRleCk7XG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgZ2V0TWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1tZXRob2QnKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG5cbi8vIEBAbWF0Y2ggbG9naWNcbmZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljKCdtYXRjaCcsIGZ1bmN0aW9uIChNQVRDSCwgbmF0aXZlTWF0Y2gsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLm1hdGNoYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUubWF0Y2hcbiAgICBmdW5jdGlvbiBtYXRjaChyZWdleHApIHtcbiAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgIHZhciBtYXRjaGVyID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGdldE1ldGhvZChyZWdleHAsIE1BVENIKTtcbiAgICAgIHJldHVybiBtYXRjaGVyID8gY2FsbChtYXRjaGVyLCByZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXSh0b1N0cmluZyhPKSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAbWF0Y2hcbiAgICBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICB2YXIgcnggPSBhbk9iamVjdCh0aGlzKTtcbiAgICAgIHZhciBTID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUobmF0aXZlTWF0Y2gsIHJ4LCBTKTtcblxuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG4gICAgICBpZiAoIXJ4Lmdsb2JhbCkgcmV0dXJuIHJlZ0V4cEV4ZWMocngsIFMpO1xuXG4gICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBBID0gW107XG4gICAgICB2YXIgbiA9IDA7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgd2hpbGUgKChyZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKSkgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIG1hdGNoU3RyID0gdG9TdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgQVtuXSA9IG1hdGNoU3RyO1xuICAgICAgICBpZiAobWF0Y2hTdHIgPT09ICcnKSByeC5sYXN0SW5kZXggPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgdG9MZW5ndGgocngubGFzdEluZGV4KSwgZnVsbFVuaWNvZGUpO1xuICAgICAgICBuKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gbiA9PT0gMCA/IG51bGwgOiBBO1xuICAgIH1cbiAgXTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFwcGx5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWFwcGx5Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eScpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkdmFuY2Utc3RyaW5nLWluZGV4Jyk7XG52YXIgZ2V0TWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1tZXRob2QnKTtcbnZhciBnZXRTdWJzdGl0dXRpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LXN1YnN0aXR1dGlvbicpO1xudmFyIHJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFJFUExBQ0UgPSB3ZWxsS25vd25TeW1ib2woJ3JlcGxhY2UnKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcbnZhciBzdHJpbmdJbmRleE9mID0gdW5jdXJyeVRoaXMoJycuaW5kZXhPZik7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG5cbnZhciBtYXliZVRvU3RyaW5nID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gaXQgOiBTdHJpbmcoaXQpO1xufTtcblxuLy8gSUUgPD0gMTEgcmVwbGFjZXMgJDAgd2l0aCB0aGUgd2hvbGUgbWF0Y2gsIGFzIGlmIGl0IHdhcyAkJlxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjAyNDY2Ni9nZXR0aW5nLWllLXRvLXJlcGxhY2UtYS1yZWdleC13aXRoLXRoZS1saXRlcmFsLXN0cmluZy0wXG52YXIgUkVQTEFDRV9LRUVQU18kMCA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvcHJlZmVyLWVzY2FwZS1yZXBsYWNlbWVudC1kb2xsYXItY2hhciAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gJ2EnLnJlcGxhY2UoLy4vLCAnJDAnKSA9PT0gJyQwJztcbn0pKCk7XG5cbi8vIFNhZmFyaSA8PSAxMy4wLjMoPykgc3Vic3RpdHV0ZXMgbnRoIGNhcHR1cmUgd2hlcmUgbj5tIHdpdGggYW4gZW1wdHkgc3RyaW5nXG52YXIgUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUgPSAoZnVuY3Rpb24gKCkge1xuICBpZiAoLy4vW1JFUExBQ0VdKSB7XG4gICAgcmV0dXJuIC8uL1tSRVBMQUNFXSgnYScsICckMCcpID09PSAnJztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59KSgpO1xuXG52YXIgUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUgPSAvLi87XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5ncm91cHMgPSB7IGE6ICc3JyB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tdXNlbGVzcy1kb2xsYXItcmVwbGFjZW1lbnRzIC0tIGZhbHNlIHBvc2l0aXZlXG4gIHJldHVybiAnJy5yZXBsYWNlKHJlLCAnJDxhPicpICE9PSAnNyc7XG59KTtcblxuLy8gQEByZXBsYWNlIGxvZ2ljXG5maXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYygncmVwbGFjZScsIGZ1bmN0aW9uIChfLCBuYXRpdmVSZXBsYWNlLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgdmFyIFVOU0FGRV9TVUJTVElUVVRFID0gUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUgPyAnJCcgOiAnJDAnO1xuXG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUucmVwbGFjZWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGxhY2VcbiAgICBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgIHZhciByZXBsYWNlciA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGdldE1ldGhvZChzZWFyY2hWYWx1ZSwgUkVQTEFDRSk7XG4gICAgICByZXR1cm4gcmVwbGFjZXJcbiAgICAgICAgPyBjYWxsKHJlcGxhY2VyLCBzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKVxuICAgICAgICA6IGNhbGwobmF0aXZlUmVwbGFjZSwgdG9TdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAcmVwbGFjZVxuICAgIGZ1bmN0aW9uIChzdHJpbmcsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QodGhpcyk7XG4gICAgICB2YXIgUyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHJlcGxhY2VWYWx1ZSA9PSAnc3RyaW5nJyAmJlxuICAgICAgICBzdHJpbmdJbmRleE9mKHJlcGxhY2VWYWx1ZSwgVU5TQUZFX1NVQlNUSVRVVEUpID09PSAtMSAmJlxuICAgICAgICBzdHJpbmdJbmRleE9mKHJlcGxhY2VWYWx1ZSwgJyQ8JykgPT09IC0xXG4gICAgICApIHtcbiAgICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZShuYXRpdmVSZXBsYWNlLCByeCwgUywgcmVwbGFjZVZhbHVlKTtcbiAgICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnVuY3Rpb25hbFJlcGxhY2UgPSBpc0NhbGxhYmxlKHJlcGxhY2VWYWx1ZSk7XG4gICAgICBpZiAoIWZ1bmN0aW9uYWxSZXBsYWNlKSByZXBsYWNlVmFsdWUgPSB0b1N0cmluZyhyZXBsYWNlVmFsdWUpO1xuXG4gICAgICB2YXIgZ2xvYmFsID0gcnguZ2xvYmFsO1xuICAgICAgaWYgKGdsb2JhbCkge1xuICAgICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgYnJlYWs7XG5cbiAgICAgICAgcHVzaChyZXN1bHRzLCByZXN1bHQpO1xuICAgICAgICBpZiAoIWdsb2JhbCkgYnJlYWs7XG5cbiAgICAgICAgdmFyIG1hdGNoU3RyID0gdG9TdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjY3VtdWxhdGVkUmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xuXG4gICAgICAgIHZhciBtYXRjaGVkID0gdG9TdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbWF4KG1pbih0b0ludGVnZXJPckluZmluaXR5KHJlc3VsdC5pbmRleCksIFMubGVuZ3RoKSwgMCk7XG4gICAgICAgIHZhciBjYXB0dXJlcyA9IFtdO1xuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgICAgLy8gICBjYXB0dXJlcyA9IHJlc3VsdC5zbGljZSgxKS5tYXAobWF5YmVUb1N0cmluZylcbiAgICAgICAgLy8gYnV0IGZvciBzb21lIHJlYXNvbiBgbmF0aXZlU2xpY2UuY2FsbChyZXN1bHQsIDEsIHJlc3VsdC5sZW5ndGgpYCAoY2FsbGVkIGluXG4gICAgICAgIC8vIHRoZSBzbGljZSBwb2x5ZmlsbCB3aGVuIHNsaWNpbmcgbmF0aXZlIGFycmF5cykgXCJkb2Vzbid0IHdvcmtcIiBpbiBzYWZhcmkgOSBhbmRcbiAgICAgICAgLy8gY2F1c2VzIGEgY3Jhc2ggKGh0dHBzOi8vcGFzdGViaW4uY29tL04yMVF6ZVFBKSB3aGVuIHRyeWluZyB0byBkZWJ1ZyBpdC5cbiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCByZXN1bHQubGVuZ3RoOyBqKyspIHB1c2goY2FwdHVyZXMsIG1heWJlVG9TdHJpbmcocmVzdWx0W2pdKSk7XG4gICAgICAgIHZhciBuYW1lZENhcHR1cmVzID0gcmVzdWx0Lmdyb3VwcztcbiAgICAgICAgaWYgKGZ1bmN0aW9uYWxSZXBsYWNlKSB7XG4gICAgICAgICAgdmFyIHJlcGxhY2VyQXJncyA9IGNvbmNhdChbbWF0Y2hlZF0sIGNhcHR1cmVzLCBwb3NpdGlvbiwgUyk7XG4gICAgICAgICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkgcHVzaChyZXBsYWNlckFyZ3MsIG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IHRvU3RyaW5nKGFwcGx5KHJlcGxhY2VWYWx1ZSwgdW5kZWZpbmVkLCByZXBsYWNlckFyZ3MpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXBsYWNlbWVudCA9IGdldFN1YnN0aXR1dGlvbihtYXRjaGVkLCBTLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID49IG5leHRTb3VyY2VQb3NpdGlvbikge1xuICAgICAgICAgIGFjY3VtdWxhdGVkUmVzdWx0ICs9IHN0cmluZ1NsaWNlKFMsIG5leHRTb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24pICsgcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgbmV4dFNvdXJjZVBvc2l0aW9uID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgc3RyaW5nU2xpY2UoUywgbmV4dFNvdXJjZVBvc2l0aW9uKTtcbiAgICB9XG4gIF07XG59LCAhUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgfHwgIVJFUExBQ0VfS0VFUFNfJDAgfHwgUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFwcGx5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWFwcGx5Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYycpO1xudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXJlZ2V4cCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciBnZXRNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LW1ldGhvZCcpO1xudmFyIGFycmF5U2xpY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc2xpY2Utc2ltcGxlJyk7XG52YXIgY2FsbFJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcbnZhciByZWdleHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjJyk7XG52YXIgc3RpY2t5SGVscGVycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtc3RpY2t5LWhlbHBlcnMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG52YXIgVU5TVVBQT1JURURfWSA9IHN0aWNreUhlbHBlcnMuVU5TVVBQT1JURURfWTtcbnZhciBNQVhfVUlOVDMyID0gMHhGRkZGRkZGRjtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciAkcHVzaCA9IFtdLnB1c2g7XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzKC8uLy5leGVjKTtcbnZhciBwdXNoID0gdW5jdXJyeVRoaXMoJHB1c2gpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xuXG4vLyBDaHJvbWUgNTEgaGFzIGEgYnVnZ3kgXCJzcGxpdFwiIGltcGxlbWVudGF0aW9uIHdoZW4gUmVnRXhwI2V4ZWMgIT09IG5hdGl2ZUV4ZWNcbi8vIFdlZXggSlMgaGFzIGZyb3plbiBidWlsdC1pbiBwcm90b3R5cGVzLCBzbyB1c2UgdHJ5IC8gY2F0Y2ggd3JhcHBlclxudmFyIFNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tZW1wdHktZ3JvdXAgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgdmFyIHJlID0gLyg/OikvO1xuICB2YXIgb3JpZ2luYWxFeGVjID0gcmUuZXhlYztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yaWdpbmFsRXhlYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICB2YXIgcmVzdWx0ID0gJ2FiJy5zcGxpdChyZSk7XG4gIHJldHVybiByZXN1bHQubGVuZ3RoICE9PSAyIHx8IHJlc3VsdFswXSAhPT0gJ2EnIHx8IHJlc3VsdFsxXSAhPT0gJ2InO1xufSk7XG5cbi8vIEBAc3BsaXQgbG9naWNcbmZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljKCdzcGxpdCcsIGZ1bmN0aW9uIChTUExJVCwgbmF0aXZlU3BsaXQsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICB2YXIgaW50ZXJuYWxTcGxpdDtcbiAgaWYgKFxuICAgICdhYmJjJy5zcGxpdCgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tZW1wdHktZ3JvdXAgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgICAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9IDQgfHxcbiAgICAnYWInLnNwbGl0KC8oPzphYikqLykubGVuZ3RoICE9IDIgfHxcbiAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9IDQgfHxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL25vLWVtcHR5LWNhcHR1cmluZy1ncm91cCwgcmVnZXhwL25vLWVtcHR5LWdyb3VwIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgJy4nLnNwbGl0KC8oKSgpLykubGVuZ3RoID4gMSB8fFxuICAgICcnLnNwbGl0KC8uPy8pLmxlbmd0aFxuICApIHtcbiAgICAvLyBiYXNlZCBvbiBlczUtc2hpbSBpbXBsZW1lbnRhdGlvbiwgbmVlZCB0byByZXdvcmsgaXRcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBzdHJpbmcgPSB0b1N0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKTtcbiAgICAgIHZhciBsaW0gPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX1VJTlQzMiA6IGxpbWl0ID4+PiAwO1xuICAgICAgaWYgKGxpbSA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW3N0cmluZ107XG4gICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgaWYgKCFpc1JlZ0V4cChzZXBhcmF0b3IpKSB7XG4gICAgICAgIHJldHVybiBjYWxsKG5hdGl2ZVNwbGl0LCBzdHJpbmcsIHNlcGFyYXRvciwgbGltKTtcbiAgICAgIH1cbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgd2hpbGUgKG1hdGNoID0gY2FsbChyZWdleHBFeGVjLCBzZXBhcmF0b3JDb3B5LCBzdHJpbmcpKSB7XG4gICAgICAgIGxhc3RJbmRleCA9IHNlcGFyYXRvckNvcHkubGFzdEluZGV4O1xuICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgIHB1c2gob3V0cHV0LCBzdHJpbmdTbGljZShzdHJpbmcsIGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmcubGVuZ3RoKSBhcHBseSgkcHVzaCwgb3V0cHV0LCBhcnJheVNsaWNlKG1hdGNoLCAxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcGFyYXRvckNvcHkubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkgc2VwYXJhdG9yQ29weS5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIWV4ZWMoc2VwYXJhdG9yQ29weSwgJycpKSBwdXNoKG91dHB1dCwgJycpO1xuICAgICAgfSBlbHNlIHB1c2gob3V0cHV0LCBzdHJpbmdTbGljZShzdHJpbmcsIGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltID8gYXJyYXlTbGljZShvdXRwdXQsIDAsIGxpbSkgOiBvdXRwdXQ7XG4gICAgfTtcbiAgLy8gQ2hha3JhLCBWOFxuICB9IGVsc2UgaWYgKCcwJy5zcGxpdCh1bmRlZmluZWQsIDApLmxlbmd0aCkge1xuICAgIGludGVybmFsU3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiBjYWxsKG5hdGl2ZVNwbGl0LCB0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xuICB9IGVsc2UgaW50ZXJuYWxTcGxpdCA9IG5hdGl2ZVNwbGl0O1xuXG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUuc3BsaXRgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zcGxpdFxuICAgIGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgIHZhciBzcGxpdHRlciA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBnZXRNZXRob2Qoc2VwYXJhdG9yLCBTUExJVCk7XG4gICAgICByZXR1cm4gc3BsaXR0ZXJcbiAgICAgICAgPyBjYWxsKHNwbGl0dGVyLCBzZXBhcmF0b3IsIE8sIGxpbWl0KVxuICAgICAgICA6IGNhbGwoaW50ZXJuYWxTcGxpdCwgdG9TdHJpbmcoTyksIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF1gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHNwbGl0XG4gICAgLy9cbiAgICAvLyBOT1RFOiBUaGlzIGNhbm5vdCBiZSBwcm9wZXJseSBwb2x5ZmlsbGVkIGluIGVuZ2luZXMgdGhhdCBkb24ndCBzdXBwb3J0XG4gICAgLy8gdGhlICd5JyBmbGFnLlxuICAgIGZ1bmN0aW9uIChzdHJpbmcsIGxpbWl0KSB7XG4gICAgICB2YXIgcnggPSBhbk9iamVjdCh0aGlzKTtcbiAgICAgIHZhciBTID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoaW50ZXJuYWxTcGxpdCwgcngsIFMsIGxpbWl0LCBpbnRlcm5hbFNwbGl0ICE9PSBuYXRpdmVTcGxpdCk7XG5cbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IocngsIFJlZ0V4cCk7XG5cbiAgICAgIHZhciB1bmljb2RlTWF0Y2hpbmcgPSByeC51bmljb2RlO1xuICAgICAgdmFyIGZsYWdzID0gKHJ4Lmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJ4Lm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocngudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoVU5TVVBQT1JURURfWSA/ICdnJyA6ICd5Jyk7XG5cbiAgICAgIC8vIF4oPyArIHJ4ICsgKSBpcyBuZWVkZWQsIGluIGNvbWJpbmF0aW9uIHdpdGggc29tZSBTIHNsaWNpbmcsIHRvXG4gICAgICAvLyBzaW11bGF0ZSB0aGUgJ3knIGZsYWcuXG4gICAgICB2YXIgc3BsaXR0ZXIgPSBuZXcgQyhVTlNVUFBPUlRFRF9ZID8gJ14oPzonICsgcnguc291cmNlICsgJyknIDogcngsIGZsYWdzKTtcbiAgICAgIHZhciBsaW0gPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX1VJTlQzMiA6IGxpbWl0ID4+PiAwO1xuICAgICAgaWYgKGxpbSA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgaWYgKFMubGVuZ3RoID09PSAwKSByZXR1cm4gY2FsbFJlZ0V4cEV4ZWMoc3BsaXR0ZXIsIFMpID09PSBudWxsID8gW1NdIDogW107XG4gICAgICB2YXIgcCA9IDA7XG4gICAgICB2YXIgcSA9IDA7XG4gICAgICB2YXIgQSA9IFtdO1xuICAgICAgd2hpbGUgKHEgPCBTLmxlbmd0aCkge1xuICAgICAgICBzcGxpdHRlci5sYXN0SW5kZXggPSBVTlNVUFBPUlRFRF9ZID8gMCA6IHE7XG4gICAgICAgIHZhciB6ID0gY2FsbFJlZ0V4cEV4ZWMoc3BsaXR0ZXIsIFVOU1VQUE9SVEVEX1kgPyBzdHJpbmdTbGljZShTLCBxKSA6IFMpO1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHogPT09IG51bGwgfHxcbiAgICAgICAgICAoZSA9IG1pbih0b0xlbmd0aChzcGxpdHRlci5sYXN0SW5kZXggKyAoVU5TVVBQT1JURURfWSA/IHEgOiAwKSksIFMubGVuZ3RoKSkgPT09IHBcbiAgICAgICAgKSB7XG4gICAgICAgICAgcSA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCBxLCB1bmljb2RlTWF0Y2hpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHB1c2goQSwgc3RyaW5nU2xpY2UoUywgcCwgcSkpO1xuICAgICAgICAgIGlmIChBLmxlbmd0aCA9PT0gbGltKSByZXR1cm4gQTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSB6Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgcHVzaChBLCB6W2ldKTtcbiAgICAgICAgICAgIGlmIChBLmxlbmd0aCA9PT0gbGltKSByZXR1cm4gQTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcSA9IHAgPSBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwdXNoKEEsIHN0cmluZ1NsaWNlKFMsIHApKTtcbiAgICAgIHJldHVybiBBO1xuICAgIH1cbiAgXTtcbn0sICFTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMsIFVOU1VQUE9SVEVEX1kpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKS5mO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIG5vdEFSZWdFeHAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbm90LWEtcmVnZXhwJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciBjb3JyZWN0SXNSZWdFeHBMb2dpYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3JyZWN0LWlzLXJlZ2V4cC1sb2dpYycpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1zdHJpbmctcHJvdG90eXBlLXN0YXJ0c3dpdGggLS0gc2FmZVxudmFyIHVuJFN0YXJ0c1dpdGggPSB1bmN1cnJ5VGhpcygnJy5zdGFydHNXaXRoKTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxudmFyIENPUlJFQ1RfSVNfUkVHRVhQX0xPR0lDID0gY29ycmVjdElzUmVnRXhwTG9naWMoJ3N0YXJ0c1dpdGgnKTtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL3B1bGwvNzAyXG52YXIgTUROX1BPTFlGSUxMX0JVRyA9ICFJU19QVVJFICYmICFDT1JSRUNUX0lTX1JFR0VYUF9MT0dJQyAmJiAhIWZ1bmN0aW9uICgpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoU3RyaW5nLnByb3RvdHlwZSwgJ3N0YXJ0c1dpdGgnKTtcbiAgcmV0dXJuIGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3Iud3JpdGFibGU7XG59KCk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGhgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnN0YXJ0c3dpdGhcbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhTUROX1BPTFlGSUxMX0JVRyAmJiAhQ09SUkVDVF9JU19SRUdFWFBfTE9HSUMgfSwge1xuICBzdGFydHNXaXRoOiBmdW5jdGlvbiBzdGFydHNXaXRoKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHZhciB0aGF0ID0gdG9TdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSk7XG4gICAgbm90QVJlZ0V4cChzZWFyY2hTdHJpbmcpO1xuICAgIHZhciBpbmRleCA9IHRvTGVuZ3RoKG1pbihhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdGhhdC5sZW5ndGgpKTtcbiAgICB2YXIgc2VhcmNoID0gdG9TdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gdW4kU3RhcnRzV2l0aFxuICAgICAgPyB1biRTdGFydHNXaXRoKHRoYXQsIHNlYXJjaCwgaW5kZXgpXG4gICAgICA6IHN0cmluZ1NsaWNlKHRoYXQsIGluZGV4LCBpbmRleCArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgJHRyaW0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLXRyaW0nKS50cmltO1xudmFyIGZvcmNlZFN0cmluZ1RyaW1NZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLXRyaW0tZm9yY2VkJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnRyaW1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1cbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBmb3JjZWRTdHJpbmdUcmltTWV0aG9kKCd0cmltJykgfSwge1xuICB0cmltOiBmdW5jdGlvbiB0cmltKCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgaXNQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXknKTtcbnZhciAkdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgbmF0aXZlT2JqZWN0Q3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy1leHRlcm5hbCcpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgZGVmaW5lUHJvcGVydGllc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZScpO1xudmFyIGRlZmluZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91aWQnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLXdyYXBwZWQnKTtcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sJyk7XG52YXIgZGVmaW5lU3ltYm9sVG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3ltYm9sLWRlZmluZS10by1wcmltaXRpdmUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciAkZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5mb3JFYWNoO1xuXG52YXIgSElEREVOID0gc2hhcmVkS2V5KCdoaWRkZW4nKTtcbnZhciBTWU1CT0wgPSAnU3ltYm9sJztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoU1lNQk9MKTtcblxudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyIFN5bWJvbFByb3RvdHlwZSA9ICRTeW1ib2wgJiYgJFN5bWJvbFtQUk9UT1RZUEVdO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xudmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzID0gZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmY7XG52YXIgbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90b3R5cGVTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcblxuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgVVNFX1NFVFRFUiA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RDcmVhdGUobmF0aXZlRGVmaW5lUHJvcGVydHkoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgdmFyIE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0UHJvdG90eXBlLCBQKTtcbiAgaWYgKE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IpIGRlbGV0ZSBPYmplY3RQcm90b3R5cGVbUF07XG4gIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICBpZiAoT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciAmJiBPICE9PSBPYmplY3RQcm90b3R5cGUpIHtcbiAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPYmplY3RQcm90b3R5cGUsIFAsIE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IpO1xuICB9XG59IDogbmF0aXZlRGVmaW5lUHJvcGVydHk7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZywgZGVzY3JpcHRpb24pIHtcbiAgdmFyIHN5bWJvbCA9IEFsbFN5bWJvbHNbdGFnXSA9IG5hdGl2ZU9iamVjdENyZWF0ZShTeW1ib2xQcm90b3R5cGUpO1xuICBzZXRJbnRlcm5hbFN0YXRlKHN5bWJvbCwge1xuICAgIHR5cGU6IFNZTUJPTCxcbiAgICB0YWc6IHRhZyxcbiAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb25cbiAgfSk7XG4gIGlmICghREVTQ1JJUFRPUlMpIHN5bWJvbC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICByZXR1cm4gc3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgaWYgKE8gPT09IE9iamVjdFByb3RvdHlwZSkgJGRlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIFAsIEF0dHJpYnV0ZXMpO1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleSA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoaGFzT3duKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUF0dHJpYnV0ZXMuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXNPd24oTywgSElEREVOKSkgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgSElEREVOLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwge30pKTtcbiAgICAgIE9bSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhc093bihPLCBISURERU4pICYmIE9bSElEREVOXVtrZXldKSBPW0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgQXR0cmlidXRlcyA9IG5hdGl2ZU9iamVjdENyZWF0ZShBdHRyaWJ1dGVzLCB7IGVudW1lcmFibGU6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzY3JpcHRvcihPLCBrZXksIEF0dHJpYnV0ZXMpO1xuICB9IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBrZXksIEF0dHJpYnV0ZXMpO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIgcHJvcGVydGllcyA9IHRvSW5kZXhlZE9iamVjdChQcm9wZXJ0aWVzKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKHByb3BlcnRpZXMpLmNvbmNhdCgkZ2V0T3duUHJvcGVydHlTeW1ib2xzKHByb3BlcnRpZXMpKTtcbiAgJGZvckVhY2goa2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghREVTQ1JJUFRPUlMgfHwgY2FsbCgkcHJvcGVydHlJc0VudW1lcmFibGUsIHByb3BlcnRpZXMsIGtleSkpICRkZWZpbmVQcm9wZXJ0eShPLCBrZXksIHByb3BlcnRpZXNba2V5XSk7XG4gIH0pO1xuICByZXR1cm4gTztcbn07XG5cbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IG5hdGl2ZU9iamVjdENyZWF0ZShPKSA6ICRkZWZpbmVQcm9wZXJ0aWVzKG5hdGl2ZU9iamVjdENyZWF0ZShPKSwgUHJvcGVydGllcyk7XG59O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgUCA9IHRvUHJvcGVydHlLZXkoVik7XG4gIHZhciBlbnVtZXJhYmxlID0gY2FsbChuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSwgdGhpcywgUCk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90b3R5cGUgJiYgaGFzT3duKEFsbFN5bWJvbHMsIFApICYmICFoYXNPd24oT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGVudW1lcmFibGUgfHwgIWhhc093bih0aGlzLCBQKSB8fCAhaGFzT3duKEFsbFN5bWJvbHMsIFApIHx8IGhhc093bih0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtQXVxuICAgID8gZW51bWVyYWJsZSA6IHRydWU7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIHZhciBpdCA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgdmFyIGtleSA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG90eXBlICYmIGhhc093bihBbGxTeW1ib2xzLCBrZXkpICYmICFoYXNPd24oT2JqZWN0UHJvdG90eXBlU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgZGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KTtcbiAgaWYgKGRlc2NyaXB0b3IgJiYgaGFzT3duKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXNPd24oaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkge1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGRlc2NyaXB0b3I7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgdmFyIG5hbWVzID0gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyh0b0luZGV4ZWRPYmplY3QoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFoYXNPd24oQWxsU3ltYm9scywga2V5KSAmJiAhaGFzT3duKGhpZGRlbktleXMsIGtleSkpIHB1c2gocmVzdWx0LCBrZXkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gKE8pIHtcbiAgdmFyIElTX09CSkVDVF9QUk9UT1RZUEUgPSBPID09PSBPYmplY3RQcm90b3R5cGU7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMoSVNfT0JKRUNUX1BST1RPVFlQRSA/IE9iamVjdFByb3RvdHlwZVN5bWJvbHMgOiB0b0luZGV4ZWRPYmplY3QoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGhhc093bihBbGxTeW1ib2xzLCBrZXkpICYmICghSVNfT0JKRUNUX1BST1RPVFlQRSB8fCBoYXNPd24oT2JqZWN0UHJvdG90eXBlLCBrZXkpKSkge1xuICAgICAgcHVzaChyZXN1bHQsIEFsbFN5bWJvbHNba2V5XSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIGBTeW1ib2xgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC1jb25zdHJ1Y3RvclxuaWYgKCFOQVRJVkVfU1lNQk9MKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKGlzUHJvdG90eXBlT2YoU3ltYm9sUHJvdG90eXBlLCB0aGlzKSkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSAhYXJndW1lbnRzLmxlbmd0aCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6ICR0b1N0cmluZyhhcmd1bWVudHNbMF0pO1xuICAgIHZhciB0YWcgPSB1aWQoZGVzY3JpcHRpb24pO1xuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90b3R5cGUpIGNhbGwoc2V0dGVyLCBPYmplY3RQcm90b3R5cGVTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzT3duKHRoaXMsIEhJRERFTikgJiYgaGFzT3duKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2NyaXB0b3IodGhpcywgdGFnLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBVU0VfU0VUVEVSKSBzZXRTeW1ib2xEZXNjcmlwdG9yKE9iamVjdFByb3RvdHlwZSwgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBzZXR0ZXIgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnLCBkZXNjcmlwdGlvbik7XG4gIH07XG5cbiAgU3ltYm9sUHJvdG90eXBlID0gJFN5bWJvbFtQUk9UT1RZUEVdO1xuXG4gIGRlZmluZUJ1aWx0SW4oU3ltYm9sUHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS50YWc7XG4gIH0pO1xuXG4gIGRlZmluZUJ1aWx0SW4oJFN5bWJvbCwgJ3dpdGhvdXRTZXR0ZXInLCBmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gd3JhcCh1aWQoZGVzY3JpcHRpb24pLCBkZXNjcmlwdGlvbik7XG4gIH0pO1xuXG4gIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIGRlZmluZVByb3BlcnR5TW9kdWxlLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIGRlZmluZVByb3BlcnRpZXNNb2R1bGUuZiA9ICRkZWZpbmVQcm9wZXJ0aWVzO1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZiA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdlbGxLbm93blN5bWJvbChuYW1lKSwgbmFtZSk7XG4gIH07XG5cbiAgaWYgKERFU0NSSVBUT1JTKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtU3ltYm9sLWRlc2NyaXB0aW9uXG4gICAgbmF0aXZlRGVmaW5lUHJvcGVydHkoU3ltYm9sUHJvdG90eXBlLCAnZGVzY3JpcHRpb24nLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5kZXNjcmlwdGlvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIUlTX1BVUkUpIHtcbiAgICAgIGRlZmluZUJ1aWx0SW4oT2JqZWN0UHJvdG90eXBlLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHsgdW5zYWZlOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxufVxuXG4kKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgd3JhcDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCwgc2hhbTogIU5BVElWRV9TWU1CT0wgfSwge1xuICBTeW1ib2w6ICRTeW1ib2xcbn0pO1xuXG4kZm9yRWFjaChvYmplY3RLZXlzKFdlbGxLbm93blN5bWJvbHNTdG9yZSksIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlZmluZVdlbGxLbm93blN5bWJvbChuYW1lKTtcbn0pO1xuXG4kKHsgdGFyZ2V0OiBTWU1CT0wsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wgfSwge1xuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgVVNFX1NFVFRFUiA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBVU0VfU0VUVEVSID0gZmFsc2U7IH1cbn0pO1xuXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvclxufSk7XG5cbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MIH0sIHtcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lc1xufSk7XG5cbi8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvcHJpbWl0aXZlXG5kZWZpbmVTeW1ib2xUb1ByaW1pdGl2ZSgpO1xuXG4vLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXWAgcHJvcGVydHlcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCBTWU1CT0wpO1xuXG5oaWRkZW5LZXlzW0hJRERFTl0gPSB0cnVlO1xuIiwiLy8gYFN5bWJvbC5wcm90b3R5cGUuZGVzY3JpcHRpb25gIGdldHRlclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLmRlc2NyaXB0aW9uXG4ndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc1Byb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcycpO1xuXG52YXIgTmF0aXZlU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciBTeW1ib2xQcm90b3R5cGUgPSBOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnByb3RvdHlwZTtcblxuaWYgKERFU0NSSVBUT1JTICYmIGlzQ2FsbGFibGUoTmF0aXZlU3ltYm9sKSAmJiAoISgnZGVzY3JpcHRpb24nIGluIFN5bWJvbFByb3RvdHlwZSkgfHxcbiAgLy8gU2FmYXJpIDEyIGJ1Z1xuICBOYXRpdmVTeW1ib2woKS5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkXG4pKSB7XG4gIHZhciBFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmUgPSB7fTtcbiAgLy8gd3JhcCBTeW1ib2wgY29uc3RydWN0b3IgZm9yIGNvcnJlY3Qgd29yayB3aXRoIHVuZGVmaW5lZCBkZXNjcmlwdGlvblxuICB2YXIgU3ltYm9sV3JhcHBlciA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDwgMSB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRvU3RyaW5nKGFyZ3VtZW50c1swXSk7XG4gICAgdmFyIHJlc3VsdCA9IGlzUHJvdG90eXBlT2YoU3ltYm9sUHJvdG90eXBlLCB0aGlzKVxuICAgICAgPyBuZXcgTmF0aXZlU3ltYm9sKGRlc2NyaXB0aW9uKVxuICAgICAgLy8gaW4gRWRnZSAxMywgU3RyaW5nKFN5bWJvbCh1bmRlZmluZWQpKSA9PT0gJ1N5bWJvbCh1bmRlZmluZWQpJ1xuICAgICAgOiBkZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkID8gTmF0aXZlU3ltYm9sKCkgOiBOYXRpdmVTeW1ib2woZGVzY3JpcHRpb24pO1xuICAgIGlmIChkZXNjcmlwdGlvbiA9PT0gJycpIEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZVtyZXN1bHRdID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoU3ltYm9sV3JhcHBlciwgTmF0aXZlU3ltYm9sKTtcbiAgU3ltYm9sV3JhcHBlci5wcm90b3R5cGUgPSBTeW1ib2xQcm90b3R5cGU7XG4gIFN5bWJvbFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN5bWJvbFdyYXBwZXI7XG5cbiAgdmFyIE5BVElWRV9TWU1CT0wgPSBTdHJpbmcoTmF0aXZlU3ltYm9sKCd0ZXN0JykpID09ICdTeW1ib2wodGVzdCknO1xuICB2YXIgc3ltYm9sVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhTeW1ib2xQcm90b3R5cGUudG9TdHJpbmcpO1xuICB2YXIgc3ltYm9sVmFsdWVPZiA9IHVuY3VycnlUaGlzKFN5bWJvbFByb3RvdHlwZS52YWx1ZU9mKTtcbiAgdmFyIHJlZ2V4cCA9IC9eU3ltYm9sXFwoKC4qKVxcKVteKV0rJC87XG4gIHZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMoJycucmVwbGFjZSk7XG4gIHZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxuICBkZWZpbmVQcm9wZXJ0eShTeW1ib2xQcm90b3R5cGUsICdkZXNjcmlwdGlvbicsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICAgIHZhciBzeW1ib2wgPSBzeW1ib2xWYWx1ZU9mKHRoaXMpO1xuICAgICAgdmFyIHN0cmluZyA9IHN5bWJvbFRvU3RyaW5nKHN5bWJvbCk7XG4gICAgICBpZiAoaGFzT3duKEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZSwgc3ltYm9sKSkgcmV0dXJuICcnO1xuICAgICAgdmFyIGRlc2MgPSBOQVRJVkVfU1lNQk9MID8gc3RyaW5nU2xpY2Uoc3RyaW5nLCA3LCAtMSkgOiByZXBsYWNlKHN0cmluZywgcmVnZXhwLCAnJDEnKTtcbiAgICAgIHJldHVybiBkZXNjID09PSAnJyA/IHVuZGVmaW5lZCA6IGRlc2M7XG4gICAgfVxuICB9KTtcblxuICAkKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIHtcbiAgICBTeW1ib2w6IFN5bWJvbFdyYXBwZXJcbiAgfSk7XG59XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIE5BVElWRV9TWU1CT0xfUkVHSVNUUlkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbC1yZWdpc3RyeScpO1xuXG52YXIgU3RyaW5nVG9TeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3RyaW5nLXRvLXN5bWJvbC1yZWdpc3RyeScpO1xudmFyIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC10by1zdHJpbmctcmVnaXN0cnknKTtcblxuLy8gYFN5bWJvbC5mb3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuZm9yXG4kKHsgdGFyZ2V0OiAnU3ltYm9sJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTF9SRUdJU1RSWSB9LCB7XG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHN0cmluZyA9IHRvU3RyaW5nKGtleSk7XG4gICAgaWYgKGhhc093bihTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5LCBzdHJpbmcpKSByZXR1cm4gU3RyaW5nVG9TeW1ib2xSZWdpc3RyeVtzdHJpbmddO1xuICAgIHZhciBzeW1ib2wgPSBnZXRCdWlsdEluKCdTeW1ib2wnKShzdHJpbmcpO1xuICAgIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnlbc3RyaW5nXSA9IHN5bWJvbDtcbiAgICBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5W3N5bWJvbF0gPSBzdHJpbmc7XG4gICAgcmV0dXJuIHN5bWJvbDtcbiAgfVxufSk7XG4iLCJ2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCcpO1xuXG4vLyBgU3ltYm9sLml0ZXJhdG9yYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuaXRlcmF0b3JcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbiIsIi8vIFRPRE86IFJlbW92ZSB0aGlzIG1vZHVsZSBmcm9tIGBjb3JlLWpzQDRgIHNpbmNlIGl0J3Mgc3BsaXQgdG8gbW9kdWxlcyBsaXN0ZWQgYmVsb3dcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3ltYm9sLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN5bWJvbC5mb3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3ltYm9sLmtleS1mb3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuanNvbi5zdHJpbmdpZnknKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktc3ltYm9scycpO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1zeW1ib2wnKTtcbnZhciB0cnlUb1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90cnktdG8tc3RyaW5nJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIE5BVElWRV9TWU1CT0xfUkVHSVNUUlkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbC1yZWdpc3RyeScpO1xuXG52YXIgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXRvLXN0cmluZy1yZWdpc3RyeScpO1xuXG4vLyBgU3ltYm9sLmtleUZvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5rZXlmb3JcbiQoeyB0YXJnZXQ6ICdTeW1ib2wnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MX1JFR0lTVFJZIH0sIHtcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3IodHJ5VG9TdHJpbmcoc3ltKSArICcgaXMgbm90IGEgc3ltYm9sJyk7XG4gICAgaWYgKGhhc093bihTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5LCBzeW0pKSByZXR1cm4gU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1dO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciAkQXJyYXlDb3B5V2l0aGluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWNvcHktd2l0aGluJyk7XG5cbnZhciB1JEFycmF5Q29weVdpdGhpbiA9IHVuY3VycnlUaGlzKCRBcnJheUNvcHlXaXRoaW4pO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5jb3B5V2l0aGluYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5jb3B5d2l0aGluXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCdjb3B5V2l0aGluJywgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0IC8qICwgZW5kICovKSB7XG4gIHJldHVybiB1JEFycmF5Q29weVdpdGhpbihhVHlwZWRBcnJheSh0aGlzKSwgdGFyZ2V0LCBzdGFydCwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgJGV2ZXJ5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLmV2ZXJ5O1xuXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5ldmVyeVxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgnZXZlcnknLCBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICByZXR1cm4gJGV2ZXJ5KGFUeXBlZEFycmF5KHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciAkZmlsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1maWxsJyk7XG52YXIgdG9CaWdJbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYmlnLWludCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCA9IEFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcbnZhciBzbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxuLy8gVjggfiBDaHJvbWUgPCA1OSwgU2FmYXJpIDwgMTQuMSwgRkYgPCA1NSwgRWRnZSA8PTE4XG52YXIgQ09OVkVSU0lPTl9CVUcgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLXR5cGVkLWFycmF5cyAtLSBzYWZlXG4gIG5ldyBJbnQ4QXJyYXkoMikuZmlsbCh7IHZhbHVlT2Y6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvdW50Kys7IH0gfSk7XG4gIHJldHVybiBjb3VudCAhPT0gMTtcbn0pO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5maWxsYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5maWxsXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCdmaWxsJywgZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0LCBlbmQgKi8pIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGFUeXBlZEFycmF5KHRoaXMpO1xuICB2YXIgYWN0dWFsVmFsdWUgPSBzbGljZShjbGFzc29mKHRoaXMpLCAwLCAzKSA9PT0gJ0JpZycgPyB0b0JpZ0ludCh2YWx1ZSkgOiArdmFsdWU7XG4gIHJldHVybiBjYWxsKCRmaWxsLCB0aGlzLCBhY3R1YWxWYWx1ZSwgbGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgbGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG59LCBDT05WRVJTSU9OX0JVRyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgJGZpbHRlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5maWx0ZXI7XG52YXIgZnJvbVNwZWNpZXNBbmRMaXN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWZyb20tc3BlY2llcy1hbmQtbGlzdCcpO1xuXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuZmlsdGVyXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCdmaWx0ZXInLCBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgdmFyIGxpc3QgPSAkZmlsdGVyKGFUeXBlZEFycmF5KHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIHJldHVybiBmcm9tU3BlY2llc0FuZExpc3QodGhpcywgbGlzdCk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciAkZmluZEluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLmZpbmRJbmRleDtcblxudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5maW5kSW5kZXhgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmZpbmRpbmRleFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgnZmluZEluZGV4JywgZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgcmV0dXJuICRmaW5kSW5kZXgoYVR5cGVkQXJyYXkodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgJGZpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuZmluZDtcblxudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5maW5kYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5maW5kXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCdmaW5kJywgZnVuY3Rpb24gZmluZChwcmVkaWNhdGUgLyogLCB0aGlzQXJnICovKSB7XG4gIHJldHVybiAkZmluZChhVHlwZWRBcnJheSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciAkZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5mb3JFYWNoO1xuXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmZvcmVhY2hcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ2ZvckVhY2gnLCBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICRmb3JFYWNoKGFUeXBlZEFycmF5KHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBUWVBFRF9BUlJBWVNfQ09OU1RSVUNUT1JTX1JFUVVJUkVTX1dSQVBQRVJTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9ycy1yZXF1aXJlLXdyYXBwZXJzJyk7XG52YXIgZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJykuZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZDtcbnZhciB0eXBlZEFycmF5RnJvbSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90eXBlZC1hcnJheS1mcm9tJyk7XG5cbi8vIGAlVHlwZWRBcnJheSUuZnJvbWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5mcm9tXG5leHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kKCdmcm9tJywgdHlwZWRBcnJheUZyb20sIFRZUEVEX0FSUkFZU19DT05TVFJVQ1RPUlNfUkVRVUlSRVNfV1JBUFBFUlMpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyICRpbmNsdWRlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlcycpLmluY2x1ZGVzO1xuXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5pbmNsdWRlc1xuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgnaW5jbHVkZXMnLCBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gIHJldHVybiAkaW5jbHVkZXMoYVR5cGVkQXJyYXkodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyICRpbmRleE9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzJykuaW5kZXhPZjtcblxudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5pbmRleG9mXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCdpbmRleE9mJywgZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gIHJldHVybiAkaW5kZXhPZihhVHlwZWRBcnJheSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xufSk7XG4iLCJ2YXIgY3JlYXRlVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9yJyk7XG5cbi8vIGBJbnQzMkFycmF5YCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10eXBlZGFycmF5LW9iamVjdHNcbmNyZWF0ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcignSW50MzInLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgQXJyYXlJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXk7XG52YXIgYXJyYXlWYWx1ZXMgPSB1bmN1cnJ5VGhpcyhBcnJheUl0ZXJhdG9ycy52YWx1ZXMpO1xudmFyIGFycmF5S2V5cyA9IHVuY3VycnlUaGlzKEFycmF5SXRlcmF0b3JzLmtleXMpO1xudmFyIGFycmF5RW50cmllcyA9IHVuY3VycnlUaGlzKEFycmF5SXRlcmF0b3JzLmVudHJpZXMpO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xudmFyIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBVaW50OEFycmF5ICYmIFVpbnQ4QXJyYXkucHJvdG90eXBlO1xuXG52YXIgR0VORVJJQyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIFR5cGVkQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdLmNhbGwoWzFdKTtcbn0pO1xuXG52YXIgSVRFUkFUT1JfSVNfVkFMVUVTID0gISFUeXBlZEFycmF5UHJvdG90eXBlXG4gICYmIFR5cGVkQXJyYXlQcm90b3R5cGUudmFsdWVzXG4gICYmIFR5cGVkQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdID09PSBUeXBlZEFycmF5UHJvdG90eXBlLnZhbHVlc1xuICAmJiBUeXBlZEFycmF5UHJvdG90eXBlLnZhbHVlcy5uYW1lID09PSAndmFsdWVzJztcblxudmFyIHR5cGVkQXJyYXlWYWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gIHJldHVybiBhcnJheVZhbHVlcyhhVHlwZWRBcnJheSh0aGlzKSk7XG59O1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5lbnRyaWVzXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCdlbnRyaWVzJywgZnVuY3Rpb24gZW50cmllcygpIHtcbiAgcmV0dXJuIGFycmF5RW50cmllcyhhVHlwZWRBcnJheSh0aGlzKSk7XG59LCBHRU5FUklDKTtcbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmtleXNcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ2tleXMnLCBmdW5jdGlvbiBrZXlzKCkge1xuICByZXR1cm4gYXJyYXlLZXlzKGFUeXBlZEFycmF5KHRoaXMpKTtcbn0sIEdFTkVSSUMpO1xuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS52YWx1ZXNcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ3ZhbHVlcycsIHR5cGVkQXJyYXlWYWx1ZXMsIEdFTkVSSUMgfHwgIUlURVJBVE9SX0lTX1ZBTFVFUywgeyBuYW1lOiAndmFsdWVzJyB9KTtcbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKElURVJBVE9SLCB0eXBlZEFycmF5VmFsdWVzLCBHRU5FUklDIHx8ICFJVEVSQVRPUl9JU19WQUxVRVMsIHsgbmFtZTogJ3ZhbHVlcycgfSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG5cbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCA9IEFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcbnZhciAkam9pbiA9IHVuY3VycnlUaGlzKFtdLmpvaW4pO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5qb2luYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5qb2luXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCdqb2luJywgZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgcmV0dXJuICRqb2luKGFUeXBlZEFycmF5KHRoaXMpLCBzZXBhcmF0b3IpO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgYXBwbHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYXBwbHknKTtcbnZhciAkbGFzdEluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbGFzdC1pbmRleC1vZicpO1xuXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmxhc3RJbmRleE9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5sYXN0aW5kZXhvZlxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgnbGFzdEluZGV4T2YnLCBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICByZXR1cm4gYXBwbHkoJGxhc3RJbmRleE9mLCBhVHlwZWRBcnJheSh0aGlzKSwgbGVuZ3RoID4gMSA/IFtzZWFyY2hFbGVtZW50LCBhcmd1bWVudHNbMV1dIDogW3NlYXJjaEVsZW1lbnRdKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyICRtYXAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykubWFwO1xudmFyIHR5cGVkQXJyYXlTcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHlwZWQtYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUubWFwXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCdtYXAnLCBmdW5jdGlvbiBtYXAobWFwZm4gLyogLCB0aGlzQXJnICovKSB7XG4gIHJldHVybiAkbWFwKGFUeXBlZEFycmF5KHRoaXMpLCBtYXBmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGZ1bmN0aW9uIChPLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3ICh0eXBlZEFycmF5U3BlY2llc0NvbnN0cnVjdG9yKE8pKShsZW5ndGgpO1xuICB9KTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyICRyZWR1Y2VSaWdodCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1yZWR1Y2UnKS5yaWdodDtcblxudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5yZWR1Y2VSaWNodGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUucmVkdWNlcmlnaHRcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ3JlZHVjZVJpZ2h0JywgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgcmV0dXJuICRyZWR1Y2VSaWdodChhVHlwZWRBcnJheSh0aGlzKSwgY2FsbGJhY2tmbiwgbGVuZ3RoLCBsZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyICRyZWR1Y2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktcmVkdWNlJykubGVmdDtcblxudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnJlZHVjZVxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgncmVkdWNlJywgZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHJldHVybiAkcmVkdWNlKGFUeXBlZEFycmF5KHRoaXMpLCBjYWxsYmFja2ZuLCBsZW5ndGgsIGxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG5cbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCA9IEFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnJldmVyc2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnJldmVyc2VcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ3JldmVyc2UnLCBmdW5jdGlvbiByZXZlcnNlKCkge1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHZhciBsZW5ndGggPSBhVHlwZWRBcnJheSh0aGF0KS5sZW5ndGg7XG4gIHZhciBtaWRkbGUgPSBmbG9vcihsZW5ndGggLyAyKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIHZhbHVlO1xuICB3aGlsZSAoaW5kZXggPCBtaWRkbGUpIHtcbiAgICB2YWx1ZSA9IHRoYXRbaW5kZXhdO1xuICAgIHRoYXRbaW5kZXgrK10gPSB0aGF0Wy0tbGVuZ3RoXTtcbiAgICB0aGF0W2xlbmd0aF0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdGhhdDtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xudmFyIHRvT2Zmc2V0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9mZnNldCcpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG52YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xudmFyIEludDhBcnJheSA9IGdsb2JhbC5JbnQ4QXJyYXk7XG52YXIgSW50OEFycmF5UHJvdG90eXBlID0gSW50OEFycmF5ICYmIEludDhBcnJheS5wcm90b3R5cGU7XG52YXIgJHNldCA9IEludDhBcnJheVByb3RvdHlwZSAmJiBJbnQ4QXJyYXlQcm90b3R5cGUuc2V0O1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xuXG52YXIgV09SS1NfV0lUSF9PQkpFQ1RTX0FORF9HRUVSSUNfT05fVFlQRURfQVJSQVlTID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tdHlwZWQtYXJyYXlzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHZhciBhcnJheSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSgyKTtcbiAgY2FsbCgkc2V0LCBhcnJheSwgeyBsZW5ndGg6IDEsIDA6IDMgfSwgMSk7XG4gIHJldHVybiBhcnJheVsxXSAhPT0gMztcbn0pO1xuXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0xMTI5NCBhbmQgb3RoZXJcbnZhciBUT19PQkpFQ1RfQlVHID0gV09SS1NfV0lUSF9PQkpFQ1RTX0FORF9HRUVSSUNfT05fVFlQRURfQVJSQVlTICYmIEFycmF5QnVmZmVyVmlld0NvcmUuTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnJheSA9IG5ldyBJbnQ4QXJyYXkoMik7XG4gIGFycmF5LnNldCgxKTtcbiAgYXJyYXkuc2V0KCcyJywgMSk7XG4gIHJldHVybiBhcnJheVswXSAhPT0gMCB8fCBhcnJheVsxXSAhPT0gMjtcbn0pO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5zZXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnNldFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgnc2V0JywgZnVuY3Rpb24gc2V0KGFycmF5TGlrZSAvKiAsIG9mZnNldCAqLykge1xuICBhVHlwZWRBcnJheSh0aGlzKTtcbiAgdmFyIG9mZnNldCA9IHRvT2Zmc2V0KGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAxKTtcbiAgdmFyIHNyYyA9IHRvSW5kZXhlZE9iamVjdChhcnJheUxpa2UpO1xuICBpZiAoV09SS1NfV0lUSF9PQkpFQ1RTX0FORF9HRUVSSUNfT05fVFlQRURfQVJSQVlTKSByZXR1cm4gY2FsbCgkc2V0LCB0aGlzLCBzcmMsIG9mZnNldCk7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgdmFyIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlKHNyYyk7XG4gIHZhciBpbmRleCA9IDA7XG4gIGlmIChsZW4gKyBvZmZzZXQgPiBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIGxlbmd0aCcpO1xuICB3aGlsZSAoaW5kZXggPCBsZW4pIHRoaXNbb2Zmc2V0ICsgaW5kZXhdID0gc3JjW2luZGV4KytdO1xufSwgIVdPUktTX1dJVEhfT0JKRUNUU19BTkRfR0VFUklDX09OX1RZUEVEX0FSUkFZUyB8fCBUT19PQkpFQ1RfQlVHKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciB0eXBlZEFycmF5U3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGFycmF5U2xpY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc2xpY2UnKTtcblxudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xuXG52YXIgRk9SQ0VEID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby10eXBlZC1hcnJheXMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgbmV3IEludDhBcnJheSgxKS5zbGljZSgpO1xufSk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnNsaWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5zbGljZVxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgnc2xpY2UnLCBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gIHZhciBsaXN0ID0gYXJyYXlTbGljZShhVHlwZWRBcnJheSh0aGlzKSwgc3RhcnQsIGVuZCk7XG4gIHZhciBDID0gdHlwZWRBcnJheVNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gbmV3IEMobGVuZ3RoKTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0sIEZPUkNFRCk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgJHNvbWUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuc29tZTtcblxudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5zb21lYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5zb21lXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCdzb21lJywgZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICByZXR1cm4gJHNvbWUoYVR5cGVkQXJyYXkodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGFDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWNhbGxhYmxlJyk7XG52YXIgaW50ZXJuYWxTb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNvcnQnKTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBGRiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtZmYtdmVyc2lvbicpO1xudmFyIElFX09SX0VER0UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLWlzLWllLW9yLWVkZ2UnKTtcbnZhciBWOCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvbicpO1xudmFyIFdFQktJVCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtd2Via2l0LXZlcnNpb24nKTtcblxudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xudmFyIFVpbnQxNkFycmF5ID0gZ2xvYmFsLlVpbnQxNkFycmF5O1xudmFyIHVuJFNvcnQgPSBVaW50MTZBcnJheSAmJiB1bmN1cnJ5VGhpcyhVaW50MTZBcnJheS5wcm90b3R5cGUuc29ydCk7XG5cbi8vIFdlYktpdFxudmFyIEFDQ0VQVF9JTkNPUlJFQ1RfQVJHVU1FTlRTID0gISF1biRTb3J0ICYmICEoZmFpbHMoZnVuY3Rpb24gKCkge1xuICB1biRTb3J0KG5ldyBVaW50MTZBcnJheSgyKSwgbnVsbCk7XG59KSAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHVuJFNvcnQobmV3IFVpbnQxNkFycmF5KDIpLCB7fSk7XG59KSk7XG5cbnZhciBTVEFCTEVfU09SVCA9ICEhdW4kU29ydCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBmZWF0dXJlIGRldGVjdGlvbiBjYW4gYmUgdG9vIHNsb3csIHNvIGNoZWNrIGVuZ2luZXMgdmVyc2lvbnNcbiAgaWYgKFY4KSByZXR1cm4gVjggPCA3NDtcbiAgaWYgKEZGKSByZXR1cm4gRkYgPCA2NztcbiAgaWYgKElFX09SX0VER0UpIHJldHVybiB0cnVlO1xuICBpZiAoV0VCS0lUKSByZXR1cm4gV0VCS0lUIDwgNjAyO1xuXG4gIHZhciBhcnJheSA9IG5ldyBVaW50MTZBcnJheSg1MTYpO1xuICB2YXIgZXhwZWN0ZWQgPSBBcnJheSg1MTYpO1xuICB2YXIgaW5kZXgsIG1vZDtcblxuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCA1MTY7IGluZGV4KyspIHtcbiAgICBtb2QgPSBpbmRleCAlIDQ7XG4gICAgYXJyYXlbaW5kZXhdID0gNTE1IC0gaW5kZXg7XG4gICAgZXhwZWN0ZWRbaW5kZXhdID0gaW5kZXggLSAyICogbW9kICsgMztcbiAgfVxuXG4gIHVuJFNvcnQoYXJyYXksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIChhIC8gNCB8IDApIC0gKGIgLyA0IHwgMCk7XG4gIH0pO1xuXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IDUxNjsgaW5kZXgrKykge1xuICAgIGlmIChhcnJheVtpbmRleF0gIT09IGV4cGVjdGVkW2luZGV4XSkgcmV0dXJuIHRydWU7XG4gIH1cbn0pO1xuXG52YXIgZ2V0U29ydENvbXBhcmUgPSBmdW5jdGlvbiAoY29tcGFyZWZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGlmIChjb21wYXJlZm4gIT09IHVuZGVmaW5lZCkgcmV0dXJuICtjb21wYXJlZm4oeCwgeSkgfHwgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmICh5ICE9PSB5KSByZXR1cm4gLTE7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoeCAhPT0geCkgcmV0dXJuIDE7XG4gICAgaWYgKHggPT09IDAgJiYgeSA9PT0gMCkgcmV0dXJuIDEgLyB4ID4gMCAmJiAxIC8geSA8IDAgPyAxIDogLTE7XG4gICAgcmV0dXJuIHggPiB5O1xuICB9O1xufTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuc29ydGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuc29ydFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgnc29ydCcsIGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gIGlmIChjb21wYXJlZm4gIT09IHVuZGVmaW5lZCkgYUNhbGxhYmxlKGNvbXBhcmVmbik7XG4gIGlmIChTVEFCTEVfU09SVCkgcmV0dXJuIHVuJFNvcnQodGhpcywgY29tcGFyZWZuKTtcblxuICByZXR1cm4gaW50ZXJuYWxTb3J0KGFUeXBlZEFycmF5KHRoaXMpLCBnZXRTb3J0Q29tcGFyZShjb21wYXJlZm4pKTtcbn0sICFTVEFCTEVfU09SVCB8fCBBQ0NFUFRfSU5DT1JSRUNUX0FSR1VNRU5UUyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdHlwZWRBcnJheVNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90eXBlZC1hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCA9IEFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuc3ViYXJyYXlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnN1YmFycmF5XG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCdzdWJhcnJheScsIGZ1bmN0aW9uIHN1YmFycmF5KGJlZ2luLCBlbmQpIHtcbiAgdmFyIE8gPSBhVHlwZWRBcnJheSh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IE8ubGVuZ3RoO1xuICB2YXIgYmVnaW5JbmRleCA9IHRvQWJzb2x1dGVJbmRleChiZWdpbiwgbGVuZ3RoKTtcbiAgdmFyIEMgPSB0eXBlZEFycmF5U3BlY2llc0NvbnN0cnVjdG9yKE8pO1xuICByZXR1cm4gbmV3IEMoXG4gICAgTy5idWZmZXIsXG4gICAgTy5ieXRlT2Zmc2V0ICsgYmVnaW5JbmRleCAqIE8uQllURVNfUEVSX0VMRU1FTlQsXG4gICAgdG9MZW5ndGgoKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKSkgLSBiZWdpbkluZGV4KVxuICApO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGFwcGx5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWFwcGx5Jyk7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBhcnJheVNsaWNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNsaWNlJyk7XG5cbnZhciBJbnQ4QXJyYXkgPSBnbG9iYWwuSW50OEFycmF5O1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xudmFyICR0b0xvY2FsZVN0cmluZyA9IFtdLnRvTG9jYWxlU3RyaW5nO1xuXG4vLyBpT1MgU2FmYXJpIDYueCBmYWlscyBoZXJlXG52YXIgVE9fTE9DQUxFX1NUUklOR19CVUcgPSAhIUludDhBcnJheSAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICR0b0xvY2FsZVN0cmluZy5jYWxsKG5ldyBJbnQ4QXJyYXkoMSkpO1xufSk7XG5cbnZhciBGT1JDRUQgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbMSwgMl0udG9Mb2NhbGVTdHJpbmcoKSAhPSBuZXcgSW50OEFycmF5KFsxLCAyXSkudG9Mb2NhbGVTdHJpbmcoKTtcbn0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIEludDhBcnJheS5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcuY2FsbChbMSwgMl0pO1xufSk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS50b2xvY2FsZXN0cmluZ1xuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgndG9Mb2NhbGVTdHJpbmcnLCBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpIHtcbiAgcmV0dXJuIGFwcGx5KFxuICAgICR0b0xvY2FsZVN0cmluZyxcbiAgICBUT19MT0NBTEVfU1RSSU5HX0JVRyA/IGFycmF5U2xpY2UoYVR5cGVkQXJyYXkodGhpcykpIDogYVR5cGVkQXJyYXkodGhpcyksXG4gICAgYXJyYXlTbGljZShhcmd1bWVudHMpXG4gICk7XG59LCBGT1JDRUQpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG5cbnZhciBVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXk7XG52YXIgVWludDhBcnJheVByb3RvdHlwZSA9IFVpbnQ4QXJyYXkgJiYgVWludDhBcnJheS5wcm90b3R5cGUgfHwge307XG52YXIgYXJyYXlUb1N0cmluZyA9IFtdLnRvU3RyaW5nO1xudmFyIGpvaW4gPSB1bmN1cnJ5VGhpcyhbXS5qb2luKTtcblxuaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHsgYXJyYXlUb1N0cmluZy5jYWxsKHt9KTsgfSkpIHtcbiAgYXJyYXlUb1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBqb2luKHRoaXMpO1xuICB9O1xufVxuXG52YXIgSVNfTk9UX0FSUkFZX01FVEhPRCA9IFVpbnQ4QXJyYXlQcm90b3R5cGUudG9TdHJpbmcgIT0gYXJyYXlUb1N0cmluZztcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnRvc3RyaW5nXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCd0b1N0cmluZycsIGFycmF5VG9TdHJpbmcsIElTX05PVF9BUlJBWV9NRVRIT0QpO1xuIiwidmFyIGNyZWF0ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90eXBlZC1hcnJheS1jb25zdHJ1Y3RvcicpO1xuXG4vLyBgVWludDhBcnJheWAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdHlwZWRhcnJheS1vYmplY3RzXG5jcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IoJ1VpbnQ4JywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBET01JdGVyYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlcycpO1xudmFyIERPTVRva2VuTGlzdFByb3RvdHlwZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb20tdG9rZW4tbGlzdC1wcm90b3R5cGUnKTtcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWZvci1lYWNoJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xuXG52YXIgaGFuZGxlUHJvdG90eXBlID0gZnVuY3Rpb24gKENvbGxlY3Rpb25Qcm90b3R5cGUpIHtcbiAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlICYmIENvbGxlY3Rpb25Qcm90b3R5cGUuZm9yRWFjaCAhPT0gZm9yRWFjaCkgdHJ5IHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgJ2ZvckVhY2gnLCBmb3JFYWNoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBDb2xsZWN0aW9uUHJvdG90eXBlLmZvckVhY2ggPSBmb3JFYWNoO1xuICB9XG59O1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIGlmIChET01JdGVyYWJsZXNbQ09MTEVDVElPTl9OQU1FXSkge1xuICAgIGhhbmRsZVByb3RvdHlwZShnbG9iYWxbQ09MTEVDVElPTl9OQU1FXSAmJiBnbG9iYWxbQ09MTEVDVElPTl9OQU1FXS5wcm90b3R5cGUpO1xuICB9XG59XG5cbmhhbmRsZVByb3RvdHlwZShET01Ub2tlbkxpc3RQcm90b3R5cGUpO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBET01JdGVyYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlcycpO1xudmFyIERPTVRva2VuTGlzdFByb3RvdHlwZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb20tdG9rZW4tbGlzdC1wcm90b3R5cGUnKTtcbnZhciBBcnJheUl0ZXJhdG9yTWV0aG9kcyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvck1ldGhvZHMudmFsdWVzO1xuXG52YXIgaGFuZGxlUHJvdG90eXBlID0gZnVuY3Rpb24gKENvbGxlY3Rpb25Qcm90b3R5cGUsIENPTExFQ1RJT05fTkFNRSkge1xuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSkge1xuICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gQXJyYXlWYWx1ZXMpIHRyeSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl0gPSBBcnJheVZhbHVlcztcbiAgICB9XG4gICAgaWYgKCFDb2xsZWN0aW9uUHJvdG90eXBlW1RPX1NUUklOR19UQUddKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgQ09MTEVDVElPTl9OQU1FKTtcbiAgICB9XG4gICAgaWYgKERPTUl0ZXJhYmxlc1tDT0xMRUNUSU9OX05BTUVdKSBmb3IgKHZhciBNRVRIT0RfTkFNRSBpbiBBcnJheUl0ZXJhdG9yTWV0aG9kcykge1xuICAgICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gIT09IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSkgdHJ5IHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIE1FVEhPRF9OQU1FLCBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gPSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIGhhbmRsZVByb3RvdHlwZShnbG9iYWxbQ09MTEVDVElPTl9OQU1FXSAmJiBnbG9iYWxbQ09MTEVDVElPTl9OQU1FXS5wcm90b3R5cGUsIENPTExFQ1RJT05fTkFNRSk7XG59XG5cbmhhbmRsZVByb3RvdHlwZShET01Ub2tlbkxpc3RQcm90b3R5cGUsICdET01Ub2tlbkxpc3QnKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFRPRE86IGluIGNvcmUtanNANCwgbW92ZSAvbW9kdWxlcy8gZGVwZW5kZW5jaWVzIHRvIHB1YmxpYyBlbnRyaWVzIGZvciBiZXR0ZXIgb3B0aW1pemF0aW9uIGJ5IHRvb2xzIGxpa2UgYHByZXNldC1lbnZgXG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBVU0VfTkFUSVZFX1VSTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtdXJsJyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciBkZWZpbmVCdWlsdElucyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW5zJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3RvcicpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciAkdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBnZXRJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtaXRlcmF0b3InKTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdmFsaWRhdGUtYXJndW1lbnRzLWxlbmd0aCcpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIGFycmF5U29ydCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zb3J0Jyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBVUkxfU0VBUkNIX1BBUkFNUyA9ICdVUkxTZWFyY2hQYXJhbXMnO1xudmFyIFVSTF9TRUFSQ0hfUEFSQU1TX0lURVJBVE9SID0gVVJMX1NFQVJDSF9QQVJBTVMgKyAnSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoVVJMX1NFQVJDSF9QQVJBTVMpO1xudmFyIGdldEludGVybmFsSXRlcmF0b3JTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFVSTF9TRUFSQ0hfUEFSQU1TX0lURVJBVE9SKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIEF2b2lkIE5vZGVKUyBleHBlcmltZW50YWwgd2FybmluZ1xudmFyIHNhZmVHZXRCdWlsdEluID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFERVNDUklQVE9SUykgcmV0dXJuIGdsb2JhbFtuYW1lXTtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsLCBuYW1lKTtcbiAgcmV0dXJuIGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbn07XG5cbnZhciBuYXRpdmVGZXRjaCA9IHNhZmVHZXRCdWlsdEluKCdmZXRjaCcpO1xudmFyIE5hdGl2ZVJlcXVlc3QgPSBzYWZlR2V0QnVpbHRJbignUmVxdWVzdCcpO1xudmFyIEhlYWRlcnMgPSBzYWZlR2V0QnVpbHRJbignSGVhZGVycycpO1xudmFyIFJlcXVlc3RQcm90b3R5cGUgPSBOYXRpdmVSZXF1ZXN0ICYmIE5hdGl2ZVJlcXVlc3QucHJvdG90eXBlO1xudmFyIEhlYWRlcnNQcm90b3R5cGUgPSBIZWFkZXJzICYmIEhlYWRlcnMucHJvdG90eXBlO1xudmFyIFJlZ0V4cCA9IGdsb2JhbC5SZWdFeHA7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBkZWNvZGVVUklDb21wb25lbnQgPSBnbG9iYWwuZGVjb2RlVVJJQ29tcG9uZW50O1xudmFyIGVuY29kZVVSSUNvbXBvbmVudCA9IGdsb2JhbC5lbmNvZGVVUklDb21wb25lbnQ7XG52YXIgY2hhckF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckF0KTtcbnZhciBqb2luID0gdW5jdXJyeVRoaXMoW10uam9pbik7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKFtdLnB1c2gpO1xudmFyIHJlcGxhY2UgPSB1bmN1cnJ5VGhpcygnJy5yZXBsYWNlKTtcbnZhciBzaGlmdCA9IHVuY3VycnlUaGlzKFtdLnNoaWZ0KTtcbnZhciBzcGxpY2UgPSB1bmN1cnJ5VGhpcyhbXS5zcGxpY2UpO1xudmFyIHNwbGl0ID0gdW5jdXJyeVRoaXMoJycuc3BsaXQpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xuXG52YXIgcGx1cyA9IC9cXCsvZztcbnZhciBzZXF1ZW5jZXMgPSBBcnJheSg0KTtcblxudmFyIHBlcmNlbnRTZXF1ZW5jZSA9IGZ1bmN0aW9uIChieXRlcykge1xuICByZXR1cm4gc2VxdWVuY2VzW2J5dGVzIC0gMV0gfHwgKHNlcXVlbmNlc1tieXRlcyAtIDFdID0gUmVnRXhwKCcoKD86JVtcXFxcZGEtZl17Mn0peycgKyBieXRlcyArICd9KScsICdnaScpKTtcbn07XG5cbnZhciBwZXJjZW50RGVjb2RlID0gZnVuY3Rpb24gKHNlcXVlbmNlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzZXF1ZW5jZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHNlcXVlbmNlO1xuICB9XG59O1xuXG52YXIgZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IHJlcGxhY2UoaXQsIHBsdXMsICcgJyk7XG4gIHZhciBieXRlcyA9IDQ7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChyZXN1bHQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHdoaWxlIChieXRlcykge1xuICAgICAgcmVzdWx0ID0gcmVwbGFjZShyZXN1bHQsIHBlcmNlbnRTZXF1ZW5jZShieXRlcy0tKSwgcGVyY2VudERlY29kZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBmaW5kID0gL1shJygpfl18JTIwL2c7XG5cbnZhciByZXBsYWNlbWVudHMgPSB7XG4gICchJzogJyUyMScsXG4gIFwiJ1wiOiAnJTI3JyxcbiAgJygnOiAnJTI4JyxcbiAgJyknOiAnJTI5JyxcbiAgJ34nOiAnJTdFJyxcbiAgJyUyMCc6ICcrJ1xufTtcblxudmFyIHJlcGxhY2VyID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gIHJldHVybiByZXBsYWNlbWVudHNbbWF0Y2hdO1xufTtcblxudmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gcmVwbGFjZShlbmNvZGVVUklDb21wb25lbnQoaXQpLCBmaW5kLCByZXBsYWNlcik7XG59O1xuXG52YXIgVVJMU2VhcmNoUGFyYW1zSXRlcmF0b3IgPSBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yKGZ1bmN0aW9uIEl0ZXJhdG9yKHBhcmFtcywga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICB0eXBlOiBVUkxfU0VBUkNIX1BBUkFNU19JVEVSQVRPUixcbiAgICBpdGVyYXRvcjogZ2V0SXRlcmF0b3IoZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZShwYXJhbXMpLmVudHJpZXMpLFxuICAgIGtpbmQ6IGtpbmRcbiAgfSk7XG59LCAnSXRlcmF0b3InLCBmdW5jdGlvbiBuZXh0KCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUodGhpcyk7XG4gIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgdmFyIHN0ZXAgPSBzdGF0ZS5pdGVyYXRvci5uZXh0KCk7XG4gIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gIGlmICghc3RlcC5kb25lKSB7XG4gICAgc3RlcC52YWx1ZSA9IGtpbmQgPT09ICdrZXlzJyA/IGVudHJ5LmtleSA6IGtpbmQgPT09ICd2YWx1ZXMnID8gZW50cnkudmFsdWUgOiBbZW50cnkua2V5LCBlbnRyeS52YWx1ZV07XG4gIH0gcmV0dXJuIHN0ZXA7XG59LCB0cnVlKTtcblxudmFyIFVSTFNlYXJjaFBhcmFtc1N0YXRlID0gZnVuY3Rpb24gKGluaXQpIHtcbiAgdGhpcy5lbnRyaWVzID0gW107XG4gIHRoaXMudXJsID0gbnVsbDtcblxuICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGlzT2JqZWN0KGluaXQpKSB0aGlzLnBhcnNlT2JqZWN0KGluaXQpO1xuICAgIGVsc2UgdGhpcy5wYXJzZVF1ZXJ5KHR5cGVvZiBpbml0ID09ICdzdHJpbmcnID8gY2hhckF0KGluaXQsIDApID09PSAnPycgPyBzdHJpbmdTbGljZShpbml0LCAxKSA6IGluaXQgOiAkdG9TdHJpbmcoaW5pdCkpO1xuICB9XG59O1xuXG5VUkxTZWFyY2hQYXJhbXNTdGF0ZS5wcm90b3R5cGUgPSB7XG4gIHR5cGU6IFVSTF9TRUFSQ0hfUEFSQU1TLFxuICBiaW5kVVJMOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfSxcbiAgcGFyc2VPYmplY3Q6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChvYmplY3QpO1xuICAgIHZhciBpdGVyYXRvciwgbmV4dCwgc3RlcCwgZW50cnlJdGVyYXRvciwgZW50cnlOZXh0LCBmaXJzdCwgc2Vjb25kO1xuXG4gICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKG9iamVjdCwgaXRlcmF0b3JNZXRob2QpO1xuICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG4gICAgICB3aGlsZSAoIShzdGVwID0gY2FsbChuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgICAgICAgZW50cnlJdGVyYXRvciA9IGdldEl0ZXJhdG9yKGFuT2JqZWN0KHN0ZXAudmFsdWUpKTtcbiAgICAgICAgZW50cnlOZXh0ID0gZW50cnlJdGVyYXRvci5uZXh0O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKGZpcnN0ID0gY2FsbChlbnRyeU5leHQsIGVudHJ5SXRlcmF0b3IpKS5kb25lIHx8XG4gICAgICAgICAgKHNlY29uZCA9IGNhbGwoZW50cnlOZXh0LCBlbnRyeUl0ZXJhdG9yKSkuZG9uZSB8fFxuICAgICAgICAgICFjYWxsKGVudHJ5TmV4dCwgZW50cnlJdGVyYXRvcikuZG9uZVxuICAgICAgICApIHRocm93IFR5cGVFcnJvcignRXhwZWN0ZWQgc2VxdWVuY2Ugd2l0aCBsZW5ndGggMicpO1xuICAgICAgICBwdXNoKHRoaXMuZW50cmllcywgeyBrZXk6ICR0b1N0cmluZyhmaXJzdC52YWx1ZSksIHZhbHVlOiAkdG9TdHJpbmcoc2Vjb25kLnZhbHVlKSB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgZm9yICh2YXIga2V5IGluIG9iamVjdCkgaWYgKGhhc093bihvYmplY3QsIGtleSkpIHtcbiAgICAgIHB1c2godGhpcy5lbnRyaWVzLCB7IGtleToga2V5LCB2YWx1ZTogJHRvU3RyaW5nKG9iamVjdFtrZXldKSB9KTtcbiAgICB9XG4gIH0sXG4gIHBhcnNlUXVlcnk6IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgIGlmIChxdWVyeSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzcGxpdChxdWVyeSwgJyYnKTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgYXR0cmlidXRlLCBlbnRyeTtcbiAgICAgIHdoaWxlIChpbmRleCA8IGF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaW5kZXgrK107XG4gICAgICAgIGlmIChhdHRyaWJ1dGUubGVuZ3RoKSB7XG4gICAgICAgICAgZW50cnkgPSBzcGxpdChhdHRyaWJ1dGUsICc9Jyk7XG4gICAgICAgICAgcHVzaCh0aGlzLmVudHJpZXMsIHtcbiAgICAgICAgICAgIGtleTogZGVzZXJpYWxpemUoc2hpZnQoZW50cnkpKSxcbiAgICAgICAgICAgIHZhbHVlOiBkZXNlcmlhbGl6ZShqb2luKGVudHJ5LCAnPScpKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzZXJpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgZW50cnk7XG4gICAgd2hpbGUgKGluZGV4IDwgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIGVudHJ5ID0gZW50cmllc1tpbmRleCsrXTtcbiAgICAgIHB1c2gocmVzdWx0LCBzZXJpYWxpemUoZW50cnkua2V5KSArICc9JyArIHNlcmlhbGl6ZShlbnRyeS52YWx1ZSkpO1xuICAgIH0gcmV0dXJuIGpvaW4ocmVzdWx0LCAnJicpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVudHJpZXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnBhcnNlUXVlcnkodGhpcy51cmwucXVlcnkpO1xuICB9LFxuICB1cGRhdGVVUkw6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy51cmwpIHRoaXMudXJsLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyBgVVJMU2VhcmNoUGFyYW1zYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNpbnRlcmZhY2UtdXJsc2VhcmNocGFyYW1zXG52YXIgVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBVUkxTZWFyY2hQYXJhbXMoLyogaW5pdCAqLykge1xuICBhbkluc3RhbmNlKHRoaXMsIFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSk7XG4gIHZhciBpbml0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQ7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywgbmV3IFVSTFNlYXJjaFBhcmFtc1N0YXRlKGluaXQpKTtcbn07XG5cbnZhciBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUgPSBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbmRlZmluZUJ1aWx0SW5zKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwge1xuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5hcHBlbmRgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtYXBwZW5kXG4gIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMik7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKTtcbiAgICBwdXNoKHN0YXRlLmVudHJpZXMsIHsga2V5OiAkdG9TdHJpbmcobmFtZSksIHZhbHVlOiAkdG9TdHJpbmcodmFsdWUpIH0pO1xuICAgIHN0YXRlLnVwZGF0ZVVSTCgpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5kZWxldGVgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtZGVsZXRlXG4gICdkZWxldGUnOiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcyk7XG4gICAgdmFyIGVudHJpZXMgPSBzdGF0ZS5lbnRyaWVzO1xuICAgIHZhciBrZXkgPSAkdG9TdHJpbmcobmFtZSk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgaWYgKGVudHJpZXNbaW5kZXhdLmtleSA9PT0ga2V5KSBzcGxpY2UoZW50cmllcywgaW5kZXgsIDEpO1xuICAgICAgZWxzZSBpbmRleCsrO1xuICAgIH1cbiAgICBzdGF0ZS51cGRhdGVVUkwoKTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuZ2V0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLWdldFxuICBnZXQ6IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIGVudHJpZXMgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpLmVudHJpZXM7XG4gICAgdmFyIGtleSA9ICR0b1N0cmluZyhuYW1lKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGZvciAoOyBpbmRleCA8IGVudHJpZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAoZW50cmllc1tpbmRleF0ua2V5ID09PSBrZXkpIHJldHVybiBlbnRyaWVzW2luZGV4XS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmdldEFsbGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1nZXRhbGxcbiAgZ2V0QWxsOiBmdW5jdGlvbiBnZXRBbGwobmFtZSkge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xuICAgIHZhciBrZXkgPSAkdG9TdHJpbmcobmFtZSk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgZm9yICg7IGluZGV4IDwgZW50cmllcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmIChlbnRyaWVzW2luZGV4XS5rZXkgPT09IGtleSkgcHVzaChyZXN1bHQsIGVudHJpZXNbaW5kZXhdLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaGFzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLWhhc1xuICBoYXM6IGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIGVudHJpZXMgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpLmVudHJpZXM7XG4gICAgdmFyIGtleSA9ICR0b1N0cmluZyhuYW1lKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICBpZiAoZW50cmllc1tpbmRleCsrXS5rZXkgPT09IGtleSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuc2V0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLXNldFxuICBzZXQ6IGZ1bmN0aW9uIHNldChuYW1lLCB2YWx1ZSkge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcyk7XG4gICAgdmFyIGVudHJpZXMgPSBzdGF0ZS5lbnRyaWVzO1xuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgIHZhciBrZXkgPSAkdG9TdHJpbmcobmFtZSk7XG4gICAgdmFyIHZhbCA9ICR0b1N0cmluZyh2YWx1ZSk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgZW50cnk7XG4gICAgZm9yICg7IGluZGV4IDwgZW50cmllcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICBpZiAoZW50cnkua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGZvdW5kKSBzcGxpY2UoZW50cmllcywgaW5kZXgtLSwgMSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBlbnRyeS52YWx1ZSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWZvdW5kKSBwdXNoKGVudHJpZXMsIHsga2V5OiBrZXksIHZhbHVlOiB2YWwgfSk7XG4gICAgc3RhdGUudXBkYXRlVVJMKCk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLnNvcnRgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtc29ydFxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KCkge1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcyk7XG4gICAgYXJyYXlTb3J0KHN0YXRlLmVudHJpZXMsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5rZXkgPiBiLmtleSA/IDEgOiAtMTtcbiAgICB9KTtcbiAgICBzdGF0ZS51cGRhdGVVUkwoKTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2sgLyogLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIGVudHJpZXMgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpLmVudHJpZXM7XG4gICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgZW50cnk7XG4gICAgd2hpbGUgKGluZGV4IDwgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIGVudHJ5ID0gZW50cmllc1tpbmRleCsrXTtcbiAgICAgIGJvdW5kRnVuY3Rpb24oZW50cnkudmFsdWUsIGVudHJ5LmtleSwgdGhpcyk7XG4gICAgfVxuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5rZXlzYCBtZXRob2RcbiAga2V5czogZnVuY3Rpb24ga2V5cygpIHtcbiAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtc0l0ZXJhdG9yKHRoaXMsICdrZXlzJyk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLnZhbHVlc2AgbWV0aG9kXG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zSXRlcmF0b3IodGhpcywgJ3ZhbHVlcycpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2RcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtc0l0ZXJhdG9yKHRoaXMsICdlbnRyaWVzJyk7XG4gIH1cbn0sIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuZGVmaW5lQnVpbHRJbihVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUsIElURVJBVE9SLCBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUuZW50cmllcywgeyBuYW1lOiAnZW50cmllcycgfSk7XG5cbi8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsc2VhcmNocGFyYW1zLXN0cmluZ2lmaWNhdGlvbi1iZWhhdmlvclxuZGVmaW5lQnVpbHRJbihVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5zZXJpYWxpemUoKTtcbn0sIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuc2V0VG9TdHJpbmdUYWcoVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IsIFVSTF9TRUFSQ0hfUEFSQU1TKTtcblxuJCh7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIGZvcmNlZDogIVVTRV9OQVRJVkVfVVJMIH0sIHtcbiAgVVJMU2VhcmNoUGFyYW1zOiBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3RvclxufSk7XG5cbi8vIFdyYXAgYGZldGNoYCBhbmQgYFJlcXVlc3RgIGZvciBjb3JyZWN0IHdvcmsgd2l0aCBwb2x5ZmlsbGVkIGBVUkxTZWFyY2hQYXJhbXNgXG5pZiAoIVVTRV9OQVRJVkVfVVJMICYmIGlzQ2FsbGFibGUoSGVhZGVycykpIHtcbiAgdmFyIGhlYWRlcnNIYXMgPSB1bmN1cnJ5VGhpcyhIZWFkZXJzUHJvdG90eXBlLmhhcyk7XG4gIHZhciBoZWFkZXJzU2V0ID0gdW5jdXJyeVRoaXMoSGVhZGVyc1Byb3RvdHlwZS5zZXQpO1xuXG4gIHZhciB3cmFwUmVxdWVzdE9wdGlvbnMgPSBmdW5jdGlvbiAoaW5pdCkge1xuICAgIGlmIChpc09iamVjdChpbml0KSkge1xuICAgICAgdmFyIGJvZHkgPSBpbml0LmJvZHk7XG4gICAgICB2YXIgaGVhZGVycztcbiAgICAgIGlmIChjbGFzc29mKGJvZHkpID09PSBVUkxfU0VBUkNIX1BBUkFNUykge1xuICAgICAgICBoZWFkZXJzID0gaW5pdC5oZWFkZXJzID8gbmV3IEhlYWRlcnMoaW5pdC5oZWFkZXJzKSA6IG5ldyBIZWFkZXJzKCk7XG4gICAgICAgIGlmICghaGVhZGVyc0hhcyhoZWFkZXJzLCAnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgICBoZWFkZXJzU2V0KGhlYWRlcnMsICdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlKGluaXQsIHtcbiAgICAgICAgICBib2R5OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgJHRvU3RyaW5nKGJvZHkpKSxcbiAgICAgICAgICBoZWFkZXJzOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgaGVhZGVycylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSByZXR1cm4gaW5pdDtcbiAgfTtcblxuICBpZiAoaXNDYWxsYWJsZShuYXRpdmVGZXRjaCkpIHtcbiAgICAkKHsgZ2xvYmFsOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCBkb250Q2FsbEdldFNldDogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIHtcbiAgICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaChpbnB1dCAvKiAsIGluaXQgKi8pIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUZldGNoKGlucHV0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHdyYXBSZXF1ZXN0T3B0aW9ucyhhcmd1bWVudHNbMV0pIDoge30pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGlzQ2FsbGFibGUoTmF0aXZlUmVxdWVzdCkpIHtcbiAgICB2YXIgUmVxdWVzdENvbnN0cnVjdG9yID0gZnVuY3Rpb24gUmVxdWVzdChpbnB1dCAvKiAsIGluaXQgKi8pIHtcbiAgICAgIGFuSW5zdGFuY2UodGhpcywgUmVxdWVzdFByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gbmV3IE5hdGl2ZVJlcXVlc3QoaW5wdXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gd3JhcFJlcXVlc3RPcHRpb25zKGFyZ3VtZW50c1sxXSkgOiB7fSk7XG4gICAgfTtcblxuICAgIFJlcXVlc3RQcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXF1ZXN0Q29uc3RydWN0b3I7XG4gICAgUmVxdWVzdENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IFJlcXVlc3RQcm90b3R5cGU7XG5cbiAgICAkKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgZG9udENhbGxHZXRTZXQ6IHRydWUsIGZvcmNlZDogdHJ1ZSB9LCB7XG4gICAgICBSZXF1ZXN0OiBSZXF1ZXN0Q29uc3RydWN0b3JcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVVJMU2VhcmNoUGFyYW1zOiBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3RvcixcbiAgZ2V0U3RhdGU6IGdldEludGVybmFsUGFyYW1zU3RhdGVcbn07XG4iLCIvLyBUT0RPOiBSZW1vdmUgdGhpcyBtb2R1bGUgZnJvbSBgY29yZS1qc0A0YCBzaW5jZSBpdCdzIHJlcGxhY2VkIHRvIG1vZHVsZSBiZWxvd1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIudXJsLXNlYXJjaC1wYXJhbXMuY29uc3RydWN0b3InKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFRPRE86IGluIGNvcmUtanNANCwgbW92ZSAvbW9kdWxlcy8gZGVwZW5kZW5jaWVzIHRvIHB1YmxpYyBlbnRyaWVzIGZvciBiZXR0ZXIgb3B0aW1pemF0aW9uIGJ5IHRvb2xzIGxpa2UgYHByZXNldC1lbnZgXG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvcicpO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBVU0VfTkFUSVZFX1VSTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtdXJsJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0Jyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciBkZWZpbmVCdWlsdEluQWNjZXNzb3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLWFjY2Vzc29yJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1pbnN0YW5jZScpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1hc3NpZ24nKTtcbnZhciBhcnJheUZyb20gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktZnJvbScpO1xudmFyIGFycmF5U2xpY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc2xpY2Utc2ltcGxlJyk7XG52YXIgY29kZUF0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy1tdWx0aWJ5dGUnKS5jb2RlQXQ7XG52YXIgdG9BU0NJSSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctcHVueWNvZGUtdG8tYXNjaWknKTtcbnZhciAkdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy92YWxpZGF0ZS1hcmd1bWVudHMtbGVuZ3RoJyk7XG52YXIgVVJMU2VhcmNoUGFyYW1zTW9kdWxlID0gcmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIudXJsLXNlYXJjaC1wYXJhbXMuY29uc3RydWN0b3InKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG5cbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxVUkxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKCdVUkwnKTtcbnZhciBVUkxTZWFyY2hQYXJhbXMgPSBVUkxTZWFyY2hQYXJhbXNNb2R1bGUuVVJMU2VhcmNoUGFyYW1zO1xudmFyIGdldEludGVybmFsU2VhcmNoUGFyYW1zU3RhdGUgPSBVUkxTZWFyY2hQYXJhbXNNb2R1bGUuZ2V0U3RhdGU7XG5cbnZhciBOYXRpdmVVUkwgPSBnbG9iYWwuVVJMO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgcGFyc2VJbnQgPSBnbG9iYWwucGFyc2VJbnQ7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIGNoYXJBdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJBdCk7XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzKC8uLy5leGVjKTtcbnZhciBqb2luID0gdW5jdXJyeVRoaXMoW10uam9pbik7XG52YXIgbnVtYmVyVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcygxLjAudG9TdHJpbmcpO1xudmFyIHBvcCA9IHVuY3VycnlUaGlzKFtdLnBvcCk7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKFtdLnB1c2gpO1xudmFyIHJlcGxhY2UgPSB1bmN1cnJ5VGhpcygnJy5yZXBsYWNlKTtcbnZhciBzaGlmdCA9IHVuY3VycnlUaGlzKFtdLnNoaWZ0KTtcbnZhciBzcGxpdCA9IHVuY3VycnlUaGlzKCcnLnNwbGl0KTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcbnZhciB0b0xvd2VyQ2FzZSA9IHVuY3VycnlUaGlzKCcnLnRvTG93ZXJDYXNlKTtcbnZhciB1bnNoaWZ0ID0gdW5jdXJyeVRoaXMoW10udW5zaGlmdCk7XG5cbnZhciBJTlZBTElEX0FVVEhPUklUWSA9ICdJbnZhbGlkIGF1dGhvcml0eSc7XG52YXIgSU5WQUxJRF9TQ0hFTUUgPSAnSW52YWxpZCBzY2hlbWUnO1xudmFyIElOVkFMSURfSE9TVCA9ICdJbnZhbGlkIGhvc3QnO1xudmFyIElOVkFMSURfUE9SVCA9ICdJbnZhbGlkIHBvcnQnO1xuXG52YXIgQUxQSEEgPSAvW2Etel0vaTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tb2JzY3VyZS1yYW5nZSAtLSBzYWZlXG52YXIgQUxQSEFOVU1FUklDID0gL1tcXGQrLS5hLXpdL2k7XG52YXIgRElHSVQgPSAvXFxkLztcbnZhciBIRVhfU1RBUlQgPSAvXjB4L2k7XG52YXIgT0NUID0gL15bMC03XSskLztcbnZhciBERUMgPSAvXlxcZCskLztcbnZhciBIRVggPSAvXltcXGRhLWZdKyQvaTtcbi8qIGVzbGludC1kaXNhYmxlIHJlZ2V4cC9uby1jb250cm9sLWNoYXJhY3RlciAtLSBzYWZlICovXG52YXIgRk9SQklEREVOX0hPU1RfQ09ERV9QT0lOVCA9IC9bXFwwXFx0XFxuXFxyICMlLzo8Pj9AW1xcXFxcXF1efF0vO1xudmFyIEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlRfRVhDTFVESU5HX1BFUkNFTlQgPSAvW1xcMFxcdFxcblxcciAjLzo8Pj9AW1xcXFxcXF1efF0vO1xudmFyIExFQURJTkdfQU5EX1RSQUlMSU5HX0MwX0NPTlRST0xfT1JfU1BBQ0UgPSAvXltcXHUwMDAwLVxcdTAwMjBdK3xbXFx1MDAwMC1cXHUwMDIwXSskL2c7XG52YXIgVEFCX0FORF9ORVdfTElORSA9IC9bXFx0XFxuXFxyXS9nO1xuLyogZXNsaW50LWVuYWJsZSByZWdleHAvbm8tY29udHJvbC1jaGFyYWN0ZXIgLS0gc2FmZSAqL1xudmFyIEVPRjtcblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNpcHY0LW51bWJlci1wYXJzZXJcbnZhciBwYXJzZUlQdjQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgdmFyIHBhcnRzID0gc3BsaXQoaW5wdXQsICcuJyk7XG4gIHZhciBwYXJ0c0xlbmd0aCwgbnVtYmVycywgaW5kZXgsIHBhcnQsIHJhZGl4LCBudW1iZXIsIGlwdjQ7XG4gIGlmIChwYXJ0cy5sZW5ndGggJiYgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0gPT0gJycpIHtcbiAgICBwYXJ0cy5sZW5ndGgtLTtcbiAgfVxuICBwYXJ0c0xlbmd0aCA9IHBhcnRzLmxlbmd0aDtcbiAgaWYgKHBhcnRzTGVuZ3RoID4gNCkgcmV0dXJuIGlucHV0O1xuICBudW1iZXJzID0gW107XG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHBhcnRzTGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgcGFydCA9IHBhcnRzW2luZGV4XTtcbiAgICBpZiAocGFydCA9PSAnJykgcmV0dXJuIGlucHV0O1xuICAgIHJhZGl4ID0gMTA7XG4gICAgaWYgKHBhcnQubGVuZ3RoID4gMSAmJiBjaGFyQXQocGFydCwgMCkgPT0gJzAnKSB7XG4gICAgICByYWRpeCA9IGV4ZWMoSEVYX1NUQVJULCBwYXJ0KSA/IDE2IDogODtcbiAgICAgIHBhcnQgPSBzdHJpbmdTbGljZShwYXJ0LCByYWRpeCA9PSA4ID8gMSA6IDIpO1xuICAgIH1cbiAgICBpZiAocGFydCA9PT0gJycpIHtcbiAgICAgIG51bWJlciA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghZXhlYyhyYWRpeCA9PSAxMCA/IERFQyA6IHJhZGl4ID09IDggPyBPQ1QgOiBIRVgsIHBhcnQpKSByZXR1cm4gaW5wdXQ7XG4gICAgICBudW1iZXIgPSBwYXJzZUludChwYXJ0LCByYWRpeCk7XG4gICAgfVxuICAgIHB1c2gobnVtYmVycywgbnVtYmVyKTtcbiAgfVxuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBwYXJ0c0xlbmd0aDsgaW5kZXgrKykge1xuICAgIG51bWJlciA9IG51bWJlcnNbaW5kZXhdO1xuICAgIGlmIChpbmRleCA9PSBwYXJ0c0xlbmd0aCAtIDEpIHtcbiAgICAgIGlmIChudW1iZXIgPj0gcG93KDI1NiwgNSAtIHBhcnRzTGVuZ3RoKSkgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChudW1iZXIgPiAyNTUpIHJldHVybiBudWxsO1xuICB9XG4gIGlwdjQgPSBwb3AobnVtYmVycyk7XG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IG51bWJlcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaXB2NCArPSBudW1iZXJzW2luZGV4XSAqIHBvdygyNTYsIDMgLSBpbmRleCk7XG4gIH1cbiAgcmV0dXJuIGlwdjQ7XG59O1xuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaXB2Ni1wYXJzZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50cyAtLSBUT0RPXG52YXIgcGFyc2VJUHY2ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIHZhciBhZGRyZXNzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICB2YXIgcGllY2VJbmRleCA9IDA7XG4gIHZhciBjb21wcmVzcyA9IG51bGw7XG4gIHZhciBwb2ludGVyID0gMDtcbiAgdmFyIHZhbHVlLCBsZW5ndGgsIG51bWJlcnNTZWVuLCBpcHY0UGllY2UsIG51bWJlciwgc3dhcHMsIHN3YXA7XG5cbiAgdmFyIGNociA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2hhckF0KGlucHV0LCBwb2ludGVyKTtcbiAgfTtcblxuICBpZiAoY2hyKCkgPT0gJzonKSB7XG4gICAgaWYgKGNoYXJBdChpbnB1dCwgMSkgIT0gJzonKSByZXR1cm47XG4gICAgcG9pbnRlciArPSAyO1xuICAgIHBpZWNlSW5kZXgrKztcbiAgICBjb21wcmVzcyA9IHBpZWNlSW5kZXg7XG4gIH1cbiAgd2hpbGUgKGNocigpKSB7XG4gICAgaWYgKHBpZWNlSW5kZXggPT0gOCkgcmV0dXJuO1xuICAgIGlmIChjaHIoKSA9PSAnOicpIHtcbiAgICAgIGlmIChjb21wcmVzcyAhPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgcG9pbnRlcisrO1xuICAgICAgcGllY2VJbmRleCsrO1xuICAgICAgY29tcHJlc3MgPSBwaWVjZUluZGV4O1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhbHVlID0gbGVuZ3RoID0gMDtcbiAgICB3aGlsZSAobGVuZ3RoIDwgNCAmJiBleGVjKEhFWCwgY2hyKCkpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICogMTYgKyBwYXJzZUludChjaHIoKSwgMTYpO1xuICAgICAgcG9pbnRlcisrO1xuICAgICAgbGVuZ3RoKys7XG4gICAgfVxuICAgIGlmIChjaHIoKSA9PSAnLicpIHtcbiAgICAgIGlmIChsZW5ndGggPT0gMCkgcmV0dXJuO1xuICAgICAgcG9pbnRlciAtPSBsZW5ndGg7XG4gICAgICBpZiAocGllY2VJbmRleCA+IDYpIHJldHVybjtcbiAgICAgIG51bWJlcnNTZWVuID0gMDtcbiAgICAgIHdoaWxlIChjaHIoKSkge1xuICAgICAgICBpcHY0UGllY2UgPSBudWxsO1xuICAgICAgICBpZiAobnVtYmVyc1NlZW4gPiAwKSB7XG4gICAgICAgICAgaWYgKGNocigpID09ICcuJyAmJiBudW1iZXJzU2VlbiA8IDQpIHBvaW50ZXIrKztcbiAgICAgICAgICBlbHNlIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV4ZWMoRElHSVQsIGNocigpKSkgcmV0dXJuO1xuICAgICAgICB3aGlsZSAoZXhlYyhESUdJVCwgY2hyKCkpKSB7XG4gICAgICAgICAgbnVtYmVyID0gcGFyc2VJbnQoY2hyKCksIDEwKTtcbiAgICAgICAgICBpZiAoaXB2NFBpZWNlID09PSBudWxsKSBpcHY0UGllY2UgPSBudW1iZXI7XG4gICAgICAgICAgZWxzZSBpZiAoaXB2NFBpZWNlID09IDApIHJldHVybjtcbiAgICAgICAgICBlbHNlIGlwdjRQaWVjZSA9IGlwdjRQaWVjZSAqIDEwICsgbnVtYmVyO1xuICAgICAgICAgIGlmIChpcHY0UGllY2UgPiAyNTUpIHJldHVybjtcbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH1cbiAgICAgICAgYWRkcmVzc1twaWVjZUluZGV4XSA9IGFkZHJlc3NbcGllY2VJbmRleF0gKiAyNTYgKyBpcHY0UGllY2U7XG4gICAgICAgIG51bWJlcnNTZWVuKys7XG4gICAgICAgIGlmIChudW1iZXJzU2VlbiA9PSAyIHx8IG51bWJlcnNTZWVuID09IDQpIHBpZWNlSW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChudW1iZXJzU2VlbiAhPSA0KSByZXR1cm47XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKGNocigpID09ICc6Jykge1xuICAgICAgcG9pbnRlcisrO1xuICAgICAgaWYgKCFjaHIoKSkgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoY2hyKCkpIHJldHVybjtcbiAgICBhZGRyZXNzW3BpZWNlSW5kZXgrK10gPSB2YWx1ZTtcbiAgfVxuICBpZiAoY29tcHJlc3MgIT09IG51bGwpIHtcbiAgICBzd2FwcyA9IHBpZWNlSW5kZXggLSBjb21wcmVzcztcbiAgICBwaWVjZUluZGV4ID0gNztcbiAgICB3aGlsZSAocGllY2VJbmRleCAhPSAwICYmIHN3YXBzID4gMCkge1xuICAgICAgc3dhcCA9IGFkZHJlc3NbcGllY2VJbmRleF07XG4gICAgICBhZGRyZXNzW3BpZWNlSW5kZXgtLV0gPSBhZGRyZXNzW2NvbXByZXNzICsgc3dhcHMgLSAxXTtcbiAgICAgIGFkZHJlc3NbY29tcHJlc3MgKyAtLXN3YXBzXSA9IHN3YXA7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBpZWNlSW5kZXggIT0gOCkgcmV0dXJuO1xuICByZXR1cm4gYWRkcmVzcztcbn07XG5cbnZhciBmaW5kTG9uZ2VzdFplcm9TZXF1ZW5jZSA9IGZ1bmN0aW9uIChpcHY2KSB7XG4gIHZhciBtYXhJbmRleCA9IG51bGw7XG4gIHZhciBtYXhMZW5ndGggPSAxO1xuICB2YXIgY3VyclN0YXJ0ID0gbnVsbDtcbiAgdmFyIGN1cnJMZW5ndGggPSAwO1xuICB2YXIgaW5kZXggPSAwO1xuICBmb3IgKDsgaW5kZXggPCA4OyBpbmRleCsrKSB7XG4gICAgaWYgKGlwdjZbaW5kZXhdICE9PSAwKSB7XG4gICAgICBpZiAoY3Vyckxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICBtYXhJbmRleCA9IGN1cnJTdGFydDtcbiAgICAgICAgbWF4TGVuZ3RoID0gY3Vyckxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGN1cnJTdGFydCA9IG51bGw7XG4gICAgICBjdXJyTGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGN1cnJTdGFydCA9PT0gbnVsbCkgY3VyclN0YXJ0ID0gaW5kZXg7XG4gICAgICArK2N1cnJMZW5ndGg7XG4gICAgfVxuICB9XG4gIGlmIChjdXJyTGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgbWF4SW5kZXggPSBjdXJyU3RhcnQ7XG4gICAgbWF4TGVuZ3RoID0gY3Vyckxlbmd0aDtcbiAgfVxuICByZXR1cm4gbWF4SW5kZXg7XG59O1xuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2hvc3Qtc2VyaWFsaXppbmdcbnZhciBzZXJpYWxpemVIb3N0ID0gZnVuY3Rpb24gKGhvc3QpIHtcbiAgdmFyIHJlc3VsdCwgaW5kZXgsIGNvbXByZXNzLCBpZ25vcmUwO1xuICAvLyBpcHY0XG4gIGlmICh0eXBlb2YgaG9zdCA9PSAnbnVtYmVyJykge1xuICAgIHJlc3VsdCA9IFtdO1xuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IDQ7IGluZGV4KyspIHtcbiAgICAgIHVuc2hpZnQocmVzdWx0LCBob3N0ICUgMjU2KTtcbiAgICAgIGhvc3QgPSBmbG9vcihob3N0IC8gMjU2KTtcbiAgICB9IHJldHVybiBqb2luKHJlc3VsdCwgJy4nKTtcbiAgLy8gaXB2NlxuICB9IGVsc2UgaWYgKHR5cGVvZiBob3N0ID09ICdvYmplY3QnKSB7XG4gICAgcmVzdWx0ID0gJyc7XG4gICAgY29tcHJlc3MgPSBmaW5kTG9uZ2VzdFplcm9TZXF1ZW5jZShob3N0KTtcbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCA4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoaWdub3JlMCAmJiBob3N0W2luZGV4XSA9PT0gMCkgY29udGludWU7XG4gICAgICBpZiAoaWdub3JlMCkgaWdub3JlMCA9IGZhbHNlO1xuICAgICAgaWYgKGNvbXByZXNzID09PSBpbmRleCkge1xuICAgICAgICByZXN1bHQgKz0gaW5kZXggPyAnOicgOiAnOjonO1xuICAgICAgICBpZ25vcmUwID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBudW1iZXJUb1N0cmluZyhob3N0W2luZGV4XSwgMTYpO1xuICAgICAgICBpZiAoaW5kZXggPCA3KSByZXN1bHQgKz0gJzonO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ1snICsgcmVzdWx0ICsgJ10nO1xuICB9IHJldHVybiBob3N0O1xufTtcblxudmFyIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQgPSB7fTtcbnZhciBmcmFnbWVudFBlcmNlbnRFbmNvZGVTZXQgPSBhc3NpZ24oe30sIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQsIHtcbiAgJyAnOiAxLCAnXCInOiAxLCAnPCc6IDEsICc+JzogMSwgJ2AnOiAxXG59KTtcbnZhciBwYXRoUGVyY2VudEVuY29kZVNldCA9IGFzc2lnbih7fSwgZnJhZ21lbnRQZXJjZW50RW5jb2RlU2V0LCB7XG4gICcjJzogMSwgJz8nOiAxLCAneyc6IDEsICd9JzogMVxufSk7XG52YXIgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0ID0gYXNzaWduKHt9LCBwYXRoUGVyY2VudEVuY29kZVNldCwge1xuICAnLyc6IDEsICc6JzogMSwgJzsnOiAxLCAnPSc6IDEsICdAJzogMSwgJ1snOiAxLCAnXFxcXCc6IDEsICddJzogMSwgJ14nOiAxLCAnfCc6IDFcbn0pO1xuXG52YXIgcGVyY2VudEVuY29kZSA9IGZ1bmN0aW9uIChjaHIsIHNldCkge1xuICB2YXIgY29kZSA9IGNvZGVBdChjaHIsIDApO1xuICByZXR1cm4gY29kZSA+IDB4MjAgJiYgY29kZSA8IDB4N0YgJiYgIWhhc093bihzZXQsIGNocikgPyBjaHIgOiBlbmNvZGVVUklDb21wb25lbnQoY2hyKTtcbn07XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jc3BlY2lhbC1zY2hlbWVcbnZhciBzcGVjaWFsU2NoZW1lcyA9IHtcbiAgZnRwOiAyMSxcbiAgZmlsZTogbnVsbCxcbiAgaHR0cDogODAsXG4gIGh0dHBzOiA0NDMsXG4gIHdzOiA4MCxcbiAgd3NzOiA0NDNcbn07XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jd2luZG93cy1kcml2ZS1sZXR0ZXJcbnZhciBpc1dpbmRvd3NEcml2ZUxldHRlciA9IGZ1bmN0aW9uIChzdHJpbmcsIG5vcm1hbGl6ZWQpIHtcbiAgdmFyIHNlY29uZDtcbiAgcmV0dXJuIHN0cmluZy5sZW5ndGggPT0gMiAmJiBleGVjKEFMUEhBLCBjaGFyQXQoc3RyaW5nLCAwKSlcbiAgICAmJiAoKHNlY29uZCA9IGNoYXJBdChzdHJpbmcsIDEpKSA9PSAnOicgfHwgKCFub3JtYWxpemVkICYmIHNlY29uZCA9PSAnfCcpKTtcbn07XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jc3RhcnQtd2l0aC1hLXdpbmRvd3MtZHJpdmUtbGV0dGVyXG52YXIgc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlciA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIHRoaXJkO1xuICByZXR1cm4gc3RyaW5nLmxlbmd0aCA+IDEgJiYgaXNXaW5kb3dzRHJpdmVMZXR0ZXIoc3RyaW5nU2xpY2Uoc3RyaW5nLCAwLCAyKSkgJiYgKFxuICAgIHN0cmluZy5sZW5ndGggPT0gMiB8fFxuICAgICgodGhpcmQgPSBjaGFyQXQoc3RyaW5nLCAyKSkgPT09ICcvJyB8fCB0aGlyZCA9PT0gJ1xcXFwnIHx8IHRoaXJkID09PSAnPycgfHwgdGhpcmQgPT09ICcjJylcbiAgKTtcbn07XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jc2luZ2xlLWRvdC1wYXRoLXNlZ21lbnRcbnZhciBpc1NpbmdsZURvdCA9IGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gIHJldHVybiBzZWdtZW50ID09PSAnLicgfHwgdG9Mb3dlckNhc2Uoc2VnbWVudCkgPT09ICclMmUnO1xufTtcblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb3VibGUtZG90LXBhdGgtc2VnbWVudFxudmFyIGlzRG91YmxlRG90ID0gZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgc2VnbWVudCA9IHRvTG93ZXJDYXNlKHNlZ21lbnQpO1xuICByZXR1cm4gc2VnbWVudCA9PT0gJy4uJyB8fCBzZWdtZW50ID09PSAnJTJlLicgfHwgc2VnbWVudCA9PT0gJy4lMmUnIHx8IHNlZ21lbnQgPT09ICclMmUlMmUnO1xufTtcblxuLy8gU3RhdGVzOlxudmFyIFNDSEVNRV9TVEFSVCA9IHt9O1xudmFyIFNDSEVNRSA9IHt9O1xudmFyIE5PX1NDSEVNRSA9IHt9O1xudmFyIFNQRUNJQUxfUkVMQVRJVkVfT1JfQVVUSE9SSVRZID0ge307XG52YXIgUEFUSF9PUl9BVVRIT1JJVFkgPSB7fTtcbnZhciBSRUxBVElWRSA9IHt9O1xudmFyIFJFTEFUSVZFX1NMQVNIID0ge307XG52YXIgU1BFQ0lBTF9BVVRIT1JJVFlfU0xBU0hFUyA9IHt9O1xudmFyIFNQRUNJQUxfQVVUSE9SSVRZX0lHTk9SRV9TTEFTSEVTID0ge307XG52YXIgQVVUSE9SSVRZID0ge307XG52YXIgSE9TVCA9IHt9O1xudmFyIEhPU1ROQU1FID0ge307XG52YXIgUE9SVCA9IHt9O1xudmFyIEZJTEUgPSB7fTtcbnZhciBGSUxFX1NMQVNIID0ge307XG52YXIgRklMRV9IT1NUID0ge307XG52YXIgUEFUSF9TVEFSVCA9IHt9O1xudmFyIFBBVEggPSB7fTtcbnZhciBDQU5OT1RfQkVfQV9CQVNFX1VSTF9QQVRIID0ge307XG52YXIgUVVFUlkgPSB7fTtcbnZhciBGUkFHTUVOVCA9IHt9O1xuXG52YXIgVVJMU3RhdGUgPSBmdW5jdGlvbiAodXJsLCBpc0Jhc2UsIGJhc2UpIHtcbiAgdmFyIHVybFN0cmluZyA9ICR0b1N0cmluZyh1cmwpO1xuICB2YXIgYmFzZVN0YXRlLCBmYWlsdXJlLCBzZWFyY2hQYXJhbXM7XG4gIGlmIChpc0Jhc2UpIHtcbiAgICBmYWlsdXJlID0gdGhpcy5wYXJzZSh1cmxTdHJpbmcpO1xuICAgIGlmIChmYWlsdXJlKSB0aHJvdyBUeXBlRXJyb3IoZmFpbHVyZSk7XG4gICAgdGhpcy5zZWFyY2hQYXJhbXMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIGlmIChiYXNlICE9PSB1bmRlZmluZWQpIGJhc2VTdGF0ZSA9IG5ldyBVUkxTdGF0ZShiYXNlLCB0cnVlKTtcbiAgICBmYWlsdXJlID0gdGhpcy5wYXJzZSh1cmxTdHJpbmcsIG51bGwsIGJhc2VTdGF0ZSk7XG4gICAgaWYgKGZhaWx1cmUpIHRocm93IFR5cGVFcnJvcihmYWlsdXJlKTtcbiAgICBzZWFyY2hQYXJhbXMgPSBnZXRJbnRlcm5hbFNlYXJjaFBhcmFtc1N0YXRlKG5ldyBVUkxTZWFyY2hQYXJhbXMoKSk7XG4gICAgc2VhcmNoUGFyYW1zLmJpbmRVUkwodGhpcyk7XG4gICAgdGhpcy5zZWFyY2hQYXJhbXMgPSBzZWFyY2hQYXJhbXM7XG4gIH1cbn07XG5cblVSTFN0YXRlLnByb3RvdHlwZSA9IHtcbiAgdHlwZTogJ1VSTCcsXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsLXBhcnNpbmdcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzIC0tIFRPRE9cbiAgcGFyc2U6IGZ1bmN0aW9uIChpbnB1dCwgc3RhdGVPdmVycmlkZSwgYmFzZSkge1xuICAgIHZhciB1cmwgPSB0aGlzO1xuICAgIHZhciBzdGF0ZSA9IHN0YXRlT3ZlcnJpZGUgfHwgU0NIRU1FX1NUQVJUO1xuICAgIHZhciBwb2ludGVyID0gMDtcbiAgICB2YXIgYnVmZmVyID0gJyc7XG4gICAgdmFyIHNlZW5BdCA9IGZhbHNlO1xuICAgIHZhciBzZWVuQnJhY2tldCA9IGZhbHNlO1xuICAgIHZhciBzZWVuUGFzc3dvcmRUb2tlbiA9IGZhbHNlO1xuICAgIHZhciBjb2RlUG9pbnRzLCBjaHIsIGJ1ZmZlckNvZGVQb2ludHMsIGZhaWx1cmU7XG5cbiAgICBpbnB1dCA9ICR0b1N0cmluZyhpbnB1dCk7XG5cbiAgICBpZiAoIXN0YXRlT3ZlcnJpZGUpIHtcbiAgICAgIHVybC5zY2hlbWUgPSAnJztcbiAgICAgIHVybC51c2VybmFtZSA9ICcnO1xuICAgICAgdXJsLnBhc3N3b3JkID0gJyc7XG4gICAgICB1cmwuaG9zdCA9IG51bGw7XG4gICAgICB1cmwucG9ydCA9IG51bGw7XG4gICAgICB1cmwucGF0aCA9IFtdO1xuICAgICAgdXJsLnF1ZXJ5ID0gbnVsbDtcbiAgICAgIHVybC5mcmFnbWVudCA9IG51bGw7XG4gICAgICB1cmwuY2Fubm90QmVBQmFzZVVSTCA9IGZhbHNlO1xuICAgICAgaW5wdXQgPSByZXBsYWNlKGlucHV0LCBMRUFESU5HX0FORF9UUkFJTElOR19DMF9DT05UUk9MX09SX1NQQUNFLCAnJyk7XG4gICAgfVxuXG4gICAgaW5wdXQgPSByZXBsYWNlKGlucHV0LCBUQUJfQU5EX05FV19MSU5FLCAnJyk7XG5cbiAgICBjb2RlUG9pbnRzID0gYXJyYXlGcm9tKGlucHV0KTtcblxuICAgIHdoaWxlIChwb2ludGVyIDw9IGNvZGVQb2ludHMubGVuZ3RoKSB7XG4gICAgICBjaHIgPSBjb2RlUG9pbnRzW3BvaW50ZXJdO1xuICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIFNDSEVNRV9TVEFSVDpcbiAgICAgICAgICBpZiAoY2hyICYmIGV4ZWMoQUxQSEEsIGNocikpIHtcbiAgICAgICAgICAgIGJ1ZmZlciArPSB0b0xvd2VyQ2FzZShjaHIpO1xuICAgICAgICAgICAgc3RhdGUgPSBTQ0hFTUU7XG4gICAgICAgICAgfSBlbHNlIGlmICghc3RhdGVPdmVycmlkZSkge1xuICAgICAgICAgICAgc3RhdGUgPSBOT19TQ0hFTUU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgcmV0dXJuIElOVkFMSURfU0NIRU1FO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU0NIRU1FOlxuICAgICAgICAgIGlmIChjaHIgJiYgKGV4ZWMoQUxQSEFOVU1FUklDLCBjaHIpIHx8IGNociA9PSAnKycgfHwgY2hyID09ICctJyB8fCBjaHIgPT0gJy4nKSkge1xuICAgICAgICAgICAgYnVmZmVyICs9IHRvTG93ZXJDYXNlKGNocik7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaHIgPT0gJzonKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSAmJiAoXG4gICAgICAgICAgICAgICh1cmwuaXNTcGVjaWFsKCkgIT0gaGFzT3duKHNwZWNpYWxTY2hlbWVzLCBidWZmZXIpKSB8fFxuICAgICAgICAgICAgICAoYnVmZmVyID09ICdmaWxlJyAmJiAodXJsLmluY2x1ZGVzQ3JlZGVudGlhbHMoKSB8fCB1cmwucG9ydCAhPT0gbnVsbCkpIHx8XG4gICAgICAgICAgICAgICh1cmwuc2NoZW1lID09ICdmaWxlJyAmJiAhdXJsLmhvc3QpXG4gICAgICAgICAgICApKSByZXR1cm47XG4gICAgICAgICAgICB1cmwuc2NoZW1lID0gYnVmZmVyO1xuICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgaWYgKHVybC5pc1NwZWNpYWwoKSAmJiBzcGVjaWFsU2NoZW1lc1t1cmwuc2NoZW1lXSA9PSB1cmwucG9ydCkgdXJsLnBvcnQgPSBudWxsO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIGlmICh1cmwuc2NoZW1lID09ICdmaWxlJykge1xuICAgICAgICAgICAgICBzdGF0ZSA9IEZJTEU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVybC5pc1NwZWNpYWwoKSAmJiBiYXNlICYmIGJhc2Uuc2NoZW1lID09IHVybC5zY2hlbWUpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSBTUEVDSUFMX1JFTEFUSVZFX09SX0FVVEhPUklUWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodXJsLmlzU3BlY2lhbCgpKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0gU1BFQ0lBTF9BVVRIT1JJVFlfU0xBU0hFUztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50c1twb2ludGVyICsgMV0gPT0gJy8nKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0gUEFUSF9PUl9BVVRIT1JJVFk7XG4gICAgICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVybC5jYW5ub3RCZUFCYXNlVVJMID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcHVzaCh1cmwucGF0aCwgJycpO1xuICAgICAgICAgICAgICBzdGF0ZSA9IENBTk5PVF9CRV9BX0JBU0VfVVJMX1BBVEg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghc3RhdGVPdmVycmlkZSkge1xuICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IE5PX1NDSEVNRTtcbiAgICAgICAgICAgIHBvaW50ZXIgPSAwO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHJldHVybiBJTlZBTElEX1NDSEVNRTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIE5PX1NDSEVNRTpcbiAgICAgICAgICBpZiAoIWJhc2UgfHwgKGJhc2UuY2Fubm90QmVBQmFzZVVSTCAmJiBjaHIgIT0gJyMnKSkgcmV0dXJuIElOVkFMSURfU0NIRU1FO1xuICAgICAgICAgIGlmIChiYXNlLmNhbm5vdEJlQUJhc2VVUkwgJiYgY2hyID09ICcjJykge1xuICAgICAgICAgICAgdXJsLnNjaGVtZSA9IGJhc2Uuc2NoZW1lO1xuICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgICB1cmwuY2Fubm90QmVBQmFzZVVSTCA9IHRydWU7XG4gICAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlID0gYmFzZS5zY2hlbWUgPT0gJ2ZpbGUnID8gRklMRSA6IFJFTEFUSVZFO1xuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIGNhc2UgU1BFQ0lBTF9SRUxBVElWRV9PUl9BVVRIT1JJVFk6XG4gICAgICAgICAgaWYgKGNociA9PSAnLycgJiYgY29kZVBvaW50c1twb2ludGVyICsgMV0gPT0gJy8nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFNQRUNJQUxfQVVUSE9SSVRZX0lHTk9SRV9TTEFTSEVTO1xuICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFJFTEFUSVZFO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIFBBVEhfT1JfQVVUSE9SSVRZOlxuICAgICAgICAgIGlmIChjaHIgPT0gJy8nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEFVVEhPUklUWTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUxBVElWRTpcbiAgICAgICAgICB1cmwuc2NoZW1lID0gYmFzZS5zY2hlbWU7XG4gICAgICAgICAgaWYgKGNociA9PSBFT0YpIHtcbiAgICAgICAgICAgIHVybC51c2VybmFtZSA9IGJhc2UudXNlcm5hbWU7XG4gICAgICAgICAgICB1cmwucGFzc3dvcmQgPSBiYXNlLnBhc3N3b3JkO1xuICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICB1cmwucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgICAgIHVybC5wYXRoID0gYXJyYXlTbGljZShiYXNlLnBhdGgpO1xuICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PSAnLycgfHwgKGNociA9PSAnXFxcXCcgJiYgdXJsLmlzU3BlY2lhbCgpKSkge1xuICAgICAgICAgICAgc3RhdGUgPSBSRUxBVElWRV9TTEFTSDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PSAnPycpIHtcbiAgICAgICAgICAgIHVybC51c2VybmFtZSA9IGJhc2UudXNlcm5hbWU7XG4gICAgICAgICAgICB1cmwucGFzc3dvcmQgPSBiYXNlLnBhc3N3b3JkO1xuICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICB1cmwucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgICAgIHVybC5wYXRoID0gYXJyYXlTbGljZShiYXNlLnBhdGgpO1xuICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IFFVRVJZO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICcjJykge1xuICAgICAgICAgICAgdXJsLnVzZXJuYW1lID0gYmFzZS51c2VybmFtZTtcbiAgICAgICAgICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgIHVybC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgICAgICAgICAgdXJsLnBhc3N3b3JkID0gYmFzZS5wYXNzd29yZDtcbiAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgICAgICAgICB1cmwucGF0aCA9IGFycmF5U2xpY2UoYmFzZS5wYXRoKTtcbiAgICAgICAgICAgIHVybC5wYXRoLmxlbmd0aC0tO1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIFJFTEFUSVZFX1NMQVNIOlxuICAgICAgICAgIGlmICh1cmwuaXNTcGVjaWFsKCkgJiYgKGNociA9PSAnLycgfHwgY2hyID09ICdcXFxcJykpIHtcbiAgICAgICAgICAgIHN0YXRlID0gU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVM7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaHIgPT0gJy8nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEFVVEhPUklUWTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsLnVzZXJuYW1lID0gYmFzZS51c2VybmFtZTtcbiAgICAgICAgICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgIHVybC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIFNQRUNJQUxfQVVUSE9SSVRZX1NMQVNIRVM6XG4gICAgICAgICAgc3RhdGUgPSBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUztcbiAgICAgICAgICBpZiAoY2hyICE9ICcvJyB8fCBjaGFyQXQoYnVmZmVyLCBwb2ludGVyICsgMSkgIT0gJy8nKSBjb250aW51ZTtcbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUzpcbiAgICAgICAgICBpZiAoY2hyICE9ICcvJyAmJiBjaHIgIT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEFVVEhPUklUWTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gYnJlYWs7XG5cbiAgICAgICAgY2FzZSBBVVRIT1JJVFk6XG4gICAgICAgICAgaWYgKGNociA9PSAnQCcpIHtcbiAgICAgICAgICAgIGlmIChzZWVuQXQpIGJ1ZmZlciA9ICclNDAnICsgYnVmZmVyO1xuICAgICAgICAgICAgc2VlbkF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJ1ZmZlckNvZGVQb2ludHMgPSBhcnJheUZyb20oYnVmZmVyKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyQ29kZVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gYnVmZmVyQ29kZVBvaW50c1tpXTtcbiAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA9PSAnOicgJiYgIXNlZW5QYXNzd29yZFRva2VuKSB7XG4gICAgICAgICAgICAgICAgc2VlblBhc3N3b3JkVG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBlbmNvZGVkQ29kZVBvaW50cyA9IHBlcmNlbnRFbmNvZGUoY29kZVBvaW50LCB1c2VyaW5mb1BlcmNlbnRFbmNvZGVTZXQpO1xuICAgICAgICAgICAgICBpZiAoc2VlblBhc3N3b3JkVG9rZW4pIHVybC5wYXNzd29yZCArPSBlbmNvZGVkQ29kZVBvaW50cztcbiAgICAgICAgICAgICAgZWxzZSB1cmwudXNlcm5hbWUgKz0gZW5jb2RlZENvZGVQb2ludHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgY2hyID09IEVPRiB8fCBjaHIgPT0gJy8nIHx8IGNociA9PSAnPycgfHwgY2hyID09ICcjJyB8fFxuICAgICAgICAgICAgKGNociA9PSAnXFxcXCcgJiYgdXJsLmlzU3BlY2lhbCgpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKHNlZW5BdCAmJiBidWZmZXIgPT0gJycpIHJldHVybiBJTlZBTElEX0FVVEhPUklUWTtcbiAgICAgICAgICAgIHBvaW50ZXIgLT0gYXJyYXlGcm9tKGJ1ZmZlcikubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBIT1NUO1xuICAgICAgICAgIH0gZWxzZSBidWZmZXIgKz0gY2hyO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgSE9TVDpcbiAgICAgICAgY2FzZSBIT1NUTkFNRTpcbiAgICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSAmJiB1cmwuc2NoZW1lID09ICdmaWxlJykge1xuICAgICAgICAgICAgc3RhdGUgPSBGSUxFX0hPU1Q7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PSAnOicgJiYgIXNlZW5CcmFja2V0KSB7XG4gICAgICAgICAgICBpZiAoYnVmZmVyID09ICcnKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgICAgICAgICAgZmFpbHVyZSA9IHVybC5wYXJzZUhvc3QoYnVmZmVyKTtcbiAgICAgICAgICAgIGlmIChmYWlsdXJlKSByZXR1cm4gZmFpbHVyZTtcbiAgICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBQT1JUO1xuICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUgPT0gSE9TVE5BTUUpIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgY2hyID09IEVPRiB8fCBjaHIgPT0gJy8nIHx8IGNociA9PSAnPycgfHwgY2hyID09ICcjJyB8fFxuICAgICAgICAgICAgKGNociA9PSAnXFxcXCcgJiYgdXJsLmlzU3BlY2lhbCgpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKHVybC5pc1NwZWNpYWwoKSAmJiBidWZmZXIgPT0gJycpIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSAmJiBidWZmZXIgPT0gJycgJiYgKHVybC5pbmNsdWRlc0NyZWRlbnRpYWxzKCkgfHwgdXJsLnBvcnQgIT09IG51bGwpKSByZXR1cm47XG4gICAgICAgICAgICBmYWlsdXJlID0gdXJsLnBhcnNlSG9zdChidWZmZXIpO1xuICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHJldHVybiBmYWlsdXJlO1xuICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEhfU1RBUlQ7XG4gICAgICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSkgcmV0dXJuO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjaHIgPT0gJ1snKSBzZWVuQnJhY2tldCA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChjaHIgPT0gJ10nKSBzZWVuQnJhY2tldCA9IGZhbHNlO1xuICAgICAgICAgICAgYnVmZmVyICs9IGNocjtcbiAgICAgICAgICB9IGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUE9SVDpcbiAgICAgICAgICBpZiAoZXhlYyhESUdJVCwgY2hyKSkge1xuICAgICAgICAgICAgYnVmZmVyICs9IGNocjtcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgY2hyID09IEVPRiB8fCBjaHIgPT0gJy8nIHx8IGNociA9PSAnPycgfHwgY2hyID09ICcjJyB8fFxuICAgICAgICAgICAgKGNociA9PSAnXFxcXCcgJiYgdXJsLmlzU3BlY2lhbCgpKSB8fFxuICAgICAgICAgICAgc3RhdGVPdmVycmlkZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlciAhPSAnJykge1xuICAgICAgICAgICAgICB2YXIgcG9ydCA9IHBhcnNlSW50KGJ1ZmZlciwgMTApO1xuICAgICAgICAgICAgICBpZiAocG9ydCA+IDB4RkZGRikgcmV0dXJuIElOVkFMSURfUE9SVDtcbiAgICAgICAgICAgICAgdXJsLnBvcnQgPSAodXJsLmlzU3BlY2lhbCgpICYmIHBvcnQgPT09IHNwZWNpYWxTY2hlbWVzW3VybC5zY2hlbWVdKSA/IG51bGwgOiBwb3J0O1xuICAgICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSByZXR1cm47XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEhfU1RBUlQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgcmV0dXJuIElOVkFMSURfUE9SVDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEZJTEU6XG4gICAgICAgICAgdXJsLnNjaGVtZSA9ICdmaWxlJztcbiAgICAgICAgICBpZiAoY2hyID09ICcvJyB8fCBjaHIgPT0gJ1xcXFwnKSBzdGF0ZSA9IEZJTEVfU0xBU0g7XG4gICAgICAgICAgZWxzZSBpZiAoYmFzZSAmJiBiYXNlLnNjaGVtZSA9PSAnZmlsZScpIHtcbiAgICAgICAgICAgIGlmIChjaHIgPT0gRU9GKSB7XG4gICAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgICB1cmwucGF0aCA9IGFycmF5U2xpY2UoYmFzZS5wYXRoKTtcbiAgICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICc/Jykge1xuICAgICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICAgIHVybC5xdWVyeSA9ICcnO1xuICAgICAgICAgICAgICBzdGF0ZSA9IFFVRVJZO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaHIgPT0gJyMnKSB7XG4gICAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgICB1cmwucGF0aCA9IGFycmF5U2xpY2UoYmFzZS5wYXRoKTtcbiAgICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIXN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXIoam9pbihhcnJheVNsaWNlKGNvZGVQb2ludHMsIHBvaW50ZXIpLCAnJykpKSB7XG4gICAgICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICAgICAgdXJsLnNob3J0ZW5QYXRoKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIEZJTEVfU0xBU0g6XG4gICAgICAgICAgaWYgKGNociA9PSAnLycgfHwgY2hyID09ICdcXFxcJykge1xuICAgICAgICAgICAgc3RhdGUgPSBGSUxFX0hPU1Q7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJhc2UgJiYgYmFzZS5zY2hlbWUgPT0gJ2ZpbGUnICYmICFzdGFydHNXaXRoV2luZG93c0RyaXZlTGV0dGVyKGpvaW4oYXJyYXlTbGljZShjb2RlUG9pbnRzLCBwb2ludGVyKSwgJycpKSkge1xuICAgICAgICAgICAgaWYgKGlzV2luZG93c0RyaXZlTGV0dGVyKGJhc2UucGF0aFswXSwgdHJ1ZSkpIHB1c2godXJsLnBhdGgsIGJhc2UucGF0aFswXSk7XG4gICAgICAgICAgICBlbHNlIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgY2FzZSBGSUxFX0hPU1Q6XG4gICAgICAgICAgaWYgKGNociA9PSBFT0YgfHwgY2hyID09ICcvJyB8fCBjaHIgPT0gJ1xcXFwnIHx8IGNociA9PSAnPycgfHwgY2hyID09ICcjJykge1xuICAgICAgICAgICAgaWYgKCFzdGF0ZU92ZXJyaWRlICYmIGlzV2luZG93c0RyaXZlTGV0dGVyKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChidWZmZXIgPT0gJycpIHtcbiAgICAgICAgICAgICAgdXJsLmhvc3QgPSAnJztcbiAgICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHJldHVybjtcbiAgICAgICAgICAgICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmFpbHVyZSA9IHVybC5wYXJzZUhvc3QoYnVmZmVyKTtcbiAgICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHJldHVybiBmYWlsdXJlO1xuICAgICAgICAgICAgICBpZiAodXJsLmhvc3QgPT0gJ2xvY2FsaG9zdCcpIHVybC5ob3N0ID0gJyc7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSByZXR1cm47XG4gICAgICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgICBzdGF0ZSA9IFBBVEhfU1RBUlQ7XG4gICAgICAgICAgICB9IGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBidWZmZXIgKz0gY2hyO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUEFUSF9TVEFSVDpcbiAgICAgICAgICBpZiAodXJsLmlzU3BlY2lhbCgpKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgICBpZiAoY2hyICE9ICcvJyAmJiBjaHIgIT0gJ1xcXFwnKSBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZU92ZXJyaWRlICYmIGNociA9PSAnPycpIHtcbiAgICAgICAgICAgIHVybC5xdWVyeSA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZU92ZXJyaWRlICYmIGNociA9PSAnIycpIHtcbiAgICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociAhPSBFT0YpIHtcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICAgIGlmIChjaHIgIT0gJy8nKSBjb250aW51ZTtcbiAgICAgICAgICB9IGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUEFUSDpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjaHIgPT0gRU9GIHx8IGNociA9PSAnLycgfHxcbiAgICAgICAgICAgIChjaHIgPT0gJ1xcXFwnICYmIHVybC5pc1NwZWNpYWwoKSkgfHxcbiAgICAgICAgICAgICghc3RhdGVPdmVycmlkZSAmJiAoY2hyID09ICc/JyB8fCBjaHIgPT0gJyMnKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChpc0RvdWJsZURvdChidWZmZXIpKSB7XG4gICAgICAgICAgICAgIHVybC5zaG9ydGVuUGF0aCgpO1xuICAgICAgICAgICAgICBpZiAoY2hyICE9ICcvJyAmJiAhKGNociA9PSAnXFxcXCcgJiYgdXJsLmlzU3BlY2lhbCgpKSkge1xuICAgICAgICAgICAgICAgIHB1c2godXJsLnBhdGgsICcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1NpbmdsZURvdChidWZmZXIpKSB7XG4gICAgICAgICAgICAgIGlmIChjaHIgIT0gJy8nICYmICEoY2hyID09ICdcXFxcJyAmJiB1cmwuaXNTcGVjaWFsKCkpKSB7XG4gICAgICAgICAgICAgICAgcHVzaCh1cmwucGF0aCwgJycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSAnZmlsZScgJiYgIXVybC5wYXRoLmxlbmd0aCAmJiBpc1dpbmRvd3NEcml2ZUxldHRlcihidWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVybC5ob3N0KSB1cmwuaG9zdCA9ICcnO1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGNoYXJBdChidWZmZXIsIDApICsgJzonOyAvLyBub3JtYWxpemUgd2luZG93cyBkcml2ZSBsZXR0ZXJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwdXNoKHVybC5wYXRoLCBidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSAnZmlsZScgJiYgKGNociA9PSBFT0YgfHwgY2hyID09ICc/JyB8fCBjaHIgPT0gJyMnKSkge1xuICAgICAgICAgICAgICB3aGlsZSAodXJsLnBhdGgubGVuZ3RoID4gMSAmJiB1cmwucGF0aFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBzaGlmdCh1cmwucGF0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaHIgPT0gJz8nKSB7XG4gICAgICAgICAgICAgIHVybC5xdWVyeSA9ICcnO1xuICAgICAgICAgICAgICBzdGF0ZSA9IFFVRVJZO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaHIgPT0gJyMnKSB7XG4gICAgICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIgKz0gcGVyY2VudEVuY29kZShjaHIsIHBhdGhQZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgICAgICB9IGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ0FOTk9UX0JFX0FfQkFTRV9VUkxfUEFUSDpcbiAgICAgICAgICBpZiAoY2hyID09ICc/Jykge1xuICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IFFVRVJZO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICcjJykge1xuICAgICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hyICE9IEVPRikge1xuICAgICAgICAgICAgdXJsLnBhdGhbMF0gKz0gcGVyY2VudEVuY29kZShjaHIsIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQpO1xuICAgICAgICAgIH0gYnJlYWs7XG5cbiAgICAgICAgY2FzZSBRVUVSWTpcbiAgICAgICAgICBpZiAoIXN0YXRlT3ZlcnJpZGUgJiYgY2hyID09ICcjJykge1xuICAgICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hyICE9IEVPRikge1xuICAgICAgICAgICAgaWYgKGNociA9PSBcIidcIiAmJiB1cmwuaXNTcGVjaWFsKCkpIHVybC5xdWVyeSArPSAnJTI3JztcbiAgICAgICAgICAgIGVsc2UgaWYgKGNociA9PSAnIycpIHVybC5xdWVyeSArPSAnJTIzJztcbiAgICAgICAgICAgIGVsc2UgdXJsLnF1ZXJ5ICs9IHBlcmNlbnRFbmNvZGUoY2hyLCBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgICAgICB9IGJyZWFrO1xuXG4gICAgICAgIGNhc2UgRlJBR01FTlQ6XG4gICAgICAgICAgaWYgKGNociAhPSBFT0YpIHVybC5mcmFnbWVudCArPSBwZXJjZW50RW5jb2RlKGNociwgZnJhZ21lbnRQZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcG9pbnRlcisrO1xuICAgIH1cbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNob3N0LXBhcnNpbmdcbiAgcGFyc2VIb3N0OiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB2YXIgcmVzdWx0LCBjb2RlUG9pbnRzLCBpbmRleDtcbiAgICBpZiAoY2hhckF0KGlucHV0LCAwKSA9PSAnWycpIHtcbiAgICAgIGlmIChjaGFyQXQoaW5wdXQsIGlucHV0Lmxlbmd0aCAtIDEpICE9ICddJykgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICAgIHJlc3VsdCA9IHBhcnNlSVB2NihzdHJpbmdTbGljZShpbnB1dCwgMSwgLTEpKTtcbiAgICAgIGlmICghcmVzdWx0KSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgICAgdGhpcy5ob3N0ID0gcmVzdWx0O1xuICAgIC8vIG9wYXF1ZSBob3N0XG4gICAgfSBlbHNlIGlmICghdGhpcy5pc1NwZWNpYWwoKSkge1xuICAgICAgaWYgKGV4ZWMoRk9SQklEREVOX0hPU1RfQ09ERV9QT0lOVF9FWENMVURJTkdfUEVSQ0VOVCwgaW5wdXQpKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICBjb2RlUG9pbnRzID0gYXJyYXlGcm9tKGlucHV0KTtcbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGNvZGVQb2ludHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3VsdCArPSBwZXJjZW50RW5jb2RlKGNvZGVQb2ludHNbaW5kZXhdLCBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaG9zdCA9IHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQgPSB0b0FTQ0lJKGlucHV0KTtcbiAgICAgIGlmIChleGVjKEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlQsIGlucHV0KSkgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICAgIHJlc3VsdCA9IHBhcnNlSVB2NChpbnB1dCk7XG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgICAgdGhpcy5ob3N0ID0gcmVzdWx0O1xuICAgIH1cbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNjYW5ub3QtaGF2ZS1hLXVzZXJuYW1lLXBhc3N3b3JkLXBvcnRcbiAgY2Fubm90SGF2ZVVzZXJuYW1lUGFzc3dvcmRQb3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICF0aGlzLmhvc3QgfHwgdGhpcy5jYW5ub3RCZUFCYXNlVVJMIHx8IHRoaXMuc2NoZW1lID09ICdmaWxlJztcbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNpbmNsdWRlLWNyZWRlbnRpYWxzXG4gIGluY2x1ZGVzQ3JlZGVudGlhbHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy51c2VybmFtZSAhPSAnJyB8fCB0aGlzLnBhc3N3b3JkICE9ICcnO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2lzLXNwZWNpYWxcbiAgaXNTcGVjaWFsOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGhhc093bihzcGVjaWFsU2NoZW1lcywgdGhpcy5zY2hlbWUpO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3Nob3J0ZW4tYS11cmxzLXBhdGhcbiAgc2hvcnRlblBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICB2YXIgcGF0aFNpemUgPSBwYXRoLmxlbmd0aDtcbiAgICBpZiAocGF0aFNpemUgJiYgKHRoaXMuc2NoZW1lICE9ICdmaWxlJyB8fCBwYXRoU2l6ZSAhPSAxIHx8ICFpc1dpbmRvd3NEcml2ZUxldHRlcihwYXRoWzBdLCB0cnVlKSkpIHtcbiAgICAgIHBhdGgubGVuZ3RoLS07XG4gICAgfVxuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtdXJsLXNlcmlhbGl6ZXJcbiAgc2VyaWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVybCA9IHRoaXM7XG4gICAgdmFyIHNjaGVtZSA9IHVybC5zY2hlbWU7XG4gICAgdmFyIHVzZXJuYW1lID0gdXJsLnVzZXJuYW1lO1xuICAgIHZhciBwYXNzd29yZCA9IHVybC5wYXNzd29yZDtcbiAgICB2YXIgaG9zdCA9IHVybC5ob3N0O1xuICAgIHZhciBwb3J0ID0gdXJsLnBvcnQ7XG4gICAgdmFyIHBhdGggPSB1cmwucGF0aDtcbiAgICB2YXIgcXVlcnkgPSB1cmwucXVlcnk7XG4gICAgdmFyIGZyYWdtZW50ID0gdXJsLmZyYWdtZW50O1xuICAgIHZhciBvdXRwdXQgPSBzY2hlbWUgKyAnOic7XG4gICAgaWYgKGhvc3QgIT09IG51bGwpIHtcbiAgICAgIG91dHB1dCArPSAnLy8nO1xuICAgICAgaWYgKHVybC5pbmNsdWRlc0NyZWRlbnRpYWxzKCkpIHtcbiAgICAgICAgb3V0cHV0ICs9IHVzZXJuYW1lICsgKHBhc3N3b3JkID8gJzonICsgcGFzc3dvcmQgOiAnJykgKyAnQCc7XG4gICAgICB9XG4gICAgICBvdXRwdXQgKz0gc2VyaWFsaXplSG9zdChob3N0KTtcbiAgICAgIGlmIChwb3J0ICE9PSBudWxsKSBvdXRwdXQgKz0gJzonICsgcG9ydDtcbiAgICB9IGVsc2UgaWYgKHNjaGVtZSA9PSAnZmlsZScpIG91dHB1dCArPSAnLy8nO1xuICAgIG91dHB1dCArPSB1cmwuY2Fubm90QmVBQmFzZVVSTCA/IHBhdGhbMF0gOiBwYXRoLmxlbmd0aCA/ICcvJyArIGpvaW4ocGF0aCwgJy8nKSA6ICcnO1xuICAgIGlmIChxdWVyeSAhPT0gbnVsbCkgb3V0cHV0ICs9ICc/JyArIHF1ZXJ5O1xuICAgIGlmIChmcmFnbWVudCAhPT0gbnVsbCkgb3V0cHV0ICs9ICcjJyArIGZyYWdtZW50O1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1ocmVmXG4gIHNldEhyZWY6IGZ1bmN0aW9uIChocmVmKSB7XG4gICAgdmFyIGZhaWx1cmUgPSB0aGlzLnBhcnNlKGhyZWYpO1xuICAgIGlmIChmYWlsdXJlKSB0aHJvdyBUeXBlRXJyb3IoZmFpbHVyZSk7XG4gICAgdGhpcy5zZWFyY2hQYXJhbXMudXBkYXRlKCk7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1vcmlnaW5cbiAgZ2V0T3JpZ2luOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjaGVtZSA9IHRoaXMuc2NoZW1lO1xuICAgIHZhciBwb3J0ID0gdGhpcy5wb3J0O1xuICAgIGlmIChzY2hlbWUgPT0gJ2Jsb2InKSB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBVUkxDb25zdHJ1Y3RvcihzY2hlbWUucGF0aFswXSkub3JpZ2luO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICBpZiAoc2NoZW1lID09ICdmaWxlJyB8fCAhdGhpcy5pc1NwZWNpYWwoKSkgcmV0dXJuICdudWxsJztcbiAgICByZXR1cm4gc2NoZW1lICsgJzovLycgKyBzZXJpYWxpemVIb3N0KHRoaXMuaG9zdCkgKyAocG9ydCAhPT0gbnVsbCA/ICc6JyArIHBvcnQgOiAnJyk7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wcm90b2NvbFxuICBnZXRQcm90b2NvbDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnNjaGVtZSArICc6JztcbiAgfSxcbiAgc2V0UHJvdG9jb2w6IGZ1bmN0aW9uIChwcm90b2NvbCkge1xuICAgIHRoaXMucGFyc2UoJHRvU3RyaW5nKHByb3RvY29sKSArICc6JywgU0NIRU1FX1NUQVJUKTtcbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXVzZXJuYW1lXG4gIGdldFVzZXJuYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlcm5hbWU7XG4gIH0sXG4gIHNldFVzZXJuYW1lOiBmdW5jdGlvbiAodXNlcm5hbWUpIHtcbiAgICB2YXIgY29kZVBvaW50cyA9IGFycmF5RnJvbSgkdG9TdHJpbmcodXNlcm5hbWUpKTtcbiAgICBpZiAodGhpcy5jYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQoKSkgcmV0dXJuO1xuICAgIHRoaXMudXNlcm5hbWUgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMudXNlcm5hbWUgKz0gcGVyY2VudEVuY29kZShjb2RlUG9pbnRzW2ldLCB1c2VyaW5mb1BlcmNlbnRFbmNvZGVTZXQpO1xuICAgIH1cbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXBhc3N3b3JkXG4gIGdldFBhc3N3b3JkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFzc3dvcmQ7XG4gIH0sXG4gIHNldFBhc3N3b3JkOiBmdW5jdGlvbiAocGFzc3dvcmQpIHtcbiAgICB2YXIgY29kZVBvaW50cyA9IGFycmF5RnJvbSgkdG9TdHJpbmcocGFzc3dvcmQpKTtcbiAgICBpZiAodGhpcy5jYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQoKSkgcmV0dXJuO1xuICAgIHRoaXMucGFzc3dvcmQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMucGFzc3dvcmQgKz0gcGVyY2VudEVuY29kZShjb2RlUG9pbnRzW2ldLCB1c2VyaW5mb1BlcmNlbnRFbmNvZGVTZXQpO1xuICAgIH1cbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhvc3RcbiAgZ2V0SG9zdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICAgIHZhciBwb3J0ID0gdGhpcy5wb3J0O1xuICAgIHJldHVybiBob3N0ID09PSBudWxsID8gJydcbiAgICAgIDogcG9ydCA9PT0gbnVsbCA/IHNlcmlhbGl6ZUhvc3QoaG9zdClcbiAgICAgIDogc2VyaWFsaXplSG9zdChob3N0KSArICc6JyArIHBvcnQ7XG4gIH0sXG4gIHNldEhvc3Q6IGZ1bmN0aW9uIChob3N0KSB7XG4gICAgaWYgKHRoaXMuY2Fubm90QmVBQmFzZVVSTCkgcmV0dXJuO1xuICAgIHRoaXMucGFyc2UoaG9zdCwgSE9TVCk7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1ob3N0bmFtZVxuICBnZXRIb3N0bmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICAgIHJldHVybiBob3N0ID09PSBudWxsID8gJycgOiBzZXJpYWxpemVIb3N0KGhvc3QpO1xuICB9LFxuICBzZXRIb3N0bmFtZTogZnVuY3Rpb24gKGhvc3RuYW1lKSB7XG4gICAgaWYgKHRoaXMuY2Fubm90QmVBQmFzZVVSTCkgcmV0dXJuO1xuICAgIHRoaXMucGFyc2UoaG9zdG5hbWUsIEhPU1ROQU1FKTtcbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXBvcnRcbiAgZ2V0UG9ydDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb3J0ID0gdGhpcy5wb3J0O1xuICAgIHJldHVybiBwb3J0ID09PSBudWxsID8gJycgOiAkdG9TdHJpbmcocG9ydCk7XG4gIH0sXG4gIHNldFBvcnQ6IGZ1bmN0aW9uIChwb3J0KSB7XG4gICAgaWYgKHRoaXMuY2Fubm90SGF2ZVVzZXJuYW1lUGFzc3dvcmRQb3J0KCkpIHJldHVybjtcbiAgICBwb3J0ID0gJHRvU3RyaW5nKHBvcnQpO1xuICAgIGlmIChwb3J0ID09ICcnKSB0aGlzLnBvcnQgPSBudWxsO1xuICAgIGVsc2UgdGhpcy5wYXJzZShwb3J0LCBQT1JUKTtcbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXBhdGhuYW1lXG4gIGdldFBhdGhuYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgcmV0dXJuIHRoaXMuY2Fubm90QmVBQmFzZVVSTCA/IHBhdGhbMF0gOiBwYXRoLmxlbmd0aCA/ICcvJyArIGpvaW4ocGF0aCwgJy8nKSA6ICcnO1xuICB9LFxuICBzZXRQYXRobmFtZTogZnVuY3Rpb24gKHBhdGhuYW1lKSB7XG4gICAgaWYgKHRoaXMuY2Fubm90QmVBQmFzZVVSTCkgcmV0dXJuO1xuICAgIHRoaXMucGF0aCA9IFtdO1xuICAgIHRoaXMucGFyc2UocGF0aG5hbWUsIFBBVEhfU1RBUlQpO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtc2VhcmNoXG4gIGdldFNlYXJjaDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcnk7XG4gICAgcmV0dXJuIHF1ZXJ5ID8gJz8nICsgcXVlcnkgOiAnJztcbiAgfSxcbiAgc2V0U2VhcmNoOiBmdW5jdGlvbiAoc2VhcmNoKSB7XG4gICAgc2VhcmNoID0gJHRvU3RyaW5nKHNlYXJjaCk7XG4gICAgaWYgKHNlYXJjaCA9PSAnJykge1xuICAgICAgdGhpcy5xdWVyeSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgnPycgPT0gY2hhckF0KHNlYXJjaCwgMCkpIHNlYXJjaCA9IHN0cmluZ1NsaWNlKHNlYXJjaCwgMSk7XG4gICAgICB0aGlzLnF1ZXJ5ID0gJyc7XG4gICAgICB0aGlzLnBhcnNlKHNlYXJjaCwgUVVFUlkpO1xuICAgIH1cbiAgICB0aGlzLnNlYXJjaFBhcmFtcy51cGRhdGUoKTtcbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXNlYXJjaHBhcmFtc1xuICBnZXRTZWFyY2hQYXJhbXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWFyY2hQYXJhbXMuZmFjYWRlO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaGFzaFxuICBnZXRIYXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudDtcbiAgICByZXR1cm4gZnJhZ21lbnQgPyAnIycgKyBmcmFnbWVudCA6ICcnO1xuICB9LFxuICBzZXRIYXNoOiBmdW5jdGlvbiAoaGFzaCkge1xuICAgIGhhc2ggPSAkdG9TdHJpbmcoaGFzaCk7XG4gICAgaWYgKGhhc2ggPT0gJycpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoJyMnID09IGNoYXJBdChoYXNoLCAwKSkgaGFzaCA9IHN0cmluZ1NsaWNlKGhhc2gsIDEpO1xuICAgIHRoaXMuZnJhZ21lbnQgPSAnJztcbiAgICB0aGlzLnBhcnNlKGhhc2gsIEZSQUdNRU5UKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoUGFyYW1zLnNlcmlhbGl6ZSgpIHx8IG51bGw7XG4gIH1cbn07XG5cbi8vIGBVUkxgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1jbGFzc1xudmFyIFVSTENvbnN0cnVjdG9yID0gZnVuY3Rpb24gVVJMKHVybCAvKiAsIGJhc2UgKi8pIHtcbiAgdmFyIHRoYXQgPSBhbkluc3RhbmNlKHRoaXMsIFVSTFByb3RvdHlwZSk7XG4gIHZhciBiYXNlID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSkgPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgc3RhdGUgPSBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIG5ldyBVUkxTdGF0ZSh1cmwsIGZhbHNlLCBiYXNlKSk7XG4gIGlmICghREVTQ1JJUFRPUlMpIHtcbiAgICB0aGF0LmhyZWYgPSBzdGF0ZS5zZXJpYWxpemUoKTtcbiAgICB0aGF0Lm9yaWdpbiA9IHN0YXRlLmdldE9yaWdpbigpO1xuICAgIHRoYXQucHJvdG9jb2wgPSBzdGF0ZS5nZXRQcm90b2NvbCgpO1xuICAgIHRoYXQudXNlcm5hbWUgPSBzdGF0ZS5nZXRVc2VybmFtZSgpO1xuICAgIHRoYXQucGFzc3dvcmQgPSBzdGF0ZS5nZXRQYXNzd29yZCgpO1xuICAgIHRoYXQuaG9zdCA9IHN0YXRlLmdldEhvc3QoKTtcbiAgICB0aGF0Lmhvc3RuYW1lID0gc3RhdGUuZ2V0SG9zdG5hbWUoKTtcbiAgICB0aGF0LnBvcnQgPSBzdGF0ZS5nZXRQb3J0KCk7XG4gICAgdGhhdC5wYXRobmFtZSA9IHN0YXRlLmdldFBhdGhuYW1lKCk7XG4gICAgdGhhdC5zZWFyY2ggPSBzdGF0ZS5nZXRTZWFyY2goKTtcbiAgICB0aGF0LnNlYXJjaFBhcmFtcyA9IHN0YXRlLmdldFNlYXJjaFBhcmFtcygpO1xuICAgIHRoYXQuaGFzaCA9IHN0YXRlLmdldEhhc2goKTtcbiAgfVxufTtcblxudmFyIFVSTFByb3RvdHlwZSA9IFVSTENvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxudmFyIGFjY2Vzc29yRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChnZXR0ZXIsIHNldHRlcikge1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldEludGVybmFsVVJMU3RhdGUodGhpcylbZ2V0dGVyXSgpO1xuICAgIH0sXG4gICAgc2V0OiBzZXR0ZXIgJiYgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKVtzZXR0ZXJdKHZhbHVlKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH07XG59O1xuXG5pZiAoREVTQ1JJUFRPUlMpIHtcbiAgLy8gYFVSTC5wcm90b3R5cGUuaHJlZmAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhyZWZcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFVSTFByb3RvdHlwZSwgJ2hyZWYnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ3NlcmlhbGl6ZScsICdzZXRIcmVmJykpO1xuICAvLyBgVVJMLnByb3RvdHlwZS5vcmlnaW5gIGdldHRlclxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtb3JpZ2luXG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxQcm90b3R5cGUsICdvcmlnaW4nLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldE9yaWdpbicpKTtcbiAgLy8gYFVSTC5wcm90b3R5cGUucHJvdG9jb2xgIGFjY2Vzc29ycyBwYWlyXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wcm90b2NvbFxuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoVVJMUHJvdG90eXBlLCAncHJvdG9jb2wnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldFByb3RvY29sJywgJ3NldFByb3RvY29sJykpO1xuICAvLyBgVVJMLnByb3RvdHlwZS51c2VybmFtZWAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXVzZXJuYW1lXG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxQcm90b3R5cGUsICd1c2VybmFtZScsIGFjY2Vzc29yRGVzY3JpcHRvcignZ2V0VXNlcm5hbWUnLCAnc2V0VXNlcm5hbWUnKSk7XG4gIC8vIGBVUkwucHJvdG90eXBlLnBhc3N3b3JkYCBhY2Nlc3NvcnMgcGFpclxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcGFzc3dvcmRcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFVSTFByb3RvdHlwZSwgJ3Bhc3N3b3JkJywgYWNjZXNzb3JEZXNjcmlwdG9yKCdnZXRQYXNzd29yZCcsICdzZXRQYXNzd29yZCcpKTtcbiAgLy8gYFVSTC5wcm90b3R5cGUuaG9zdGAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhvc3RcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFVSTFByb3RvdHlwZSwgJ2hvc3QnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldEhvc3QnLCAnc2V0SG9zdCcpKTtcbiAgLy8gYFVSTC5wcm90b3R5cGUuaG9zdG5hbWVgIGFjY2Vzc29ycyBwYWlyXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1ob3N0bmFtZVxuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoVVJMUHJvdG90eXBlLCAnaG9zdG5hbWUnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldEhvc3RuYW1lJywgJ3NldEhvc3RuYW1lJykpO1xuICAvLyBgVVJMLnByb3RvdHlwZS5wb3J0YCBhY2Nlc3NvcnMgcGFpclxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcG9ydFxuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoVVJMUHJvdG90eXBlLCAncG9ydCcsIGFjY2Vzc29yRGVzY3JpcHRvcignZ2V0UG9ydCcsICdzZXRQb3J0JykpO1xuICAvLyBgVVJMLnByb3RvdHlwZS5wYXRobmFtZWAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXBhdGhuYW1lXG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxQcm90b3R5cGUsICdwYXRobmFtZScsIGFjY2Vzc29yRGVzY3JpcHRvcignZ2V0UGF0aG5hbWUnLCAnc2V0UGF0aG5hbWUnKSk7XG4gIC8vIGBVUkwucHJvdG90eXBlLnNlYXJjaGAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXNlYXJjaFxuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoVVJMUHJvdG90eXBlLCAnc2VhcmNoJywgYWNjZXNzb3JEZXNjcmlwdG9yKCdnZXRTZWFyY2gnLCAnc2V0U2VhcmNoJykpO1xuICAvLyBgVVJMLnByb3RvdHlwZS5zZWFyY2hQYXJhbXNgIGdldHRlclxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtc2VhcmNocGFyYW1zXG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxQcm90b3R5cGUsICdzZWFyY2hQYXJhbXMnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldFNlYXJjaFBhcmFtcycpKTtcbiAgLy8gYFVSTC5wcm90b3R5cGUuaGFzaGAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhhc2hcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFVSTFByb3RvdHlwZSwgJ2hhc2gnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldEhhc2gnLCAnc2V0SGFzaCcpKTtcbn1cblxuLy8gYFVSTC5wcm90b3R5cGUudG9KU09OYCBtZXRob2Rcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC10b2pzb25cbmRlZmluZUJ1aWx0SW4oVVJMUHJvdG90eXBlLCAndG9KU09OJywgZnVuY3Rpb24gdG9KU09OKCkge1xuICByZXR1cm4gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5zZXJpYWxpemUoKTtcbn0sIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLy8gYFVSTC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNVUkwtc3RyaW5naWZpY2F0aW9uLWJlaGF2aW9yXG5kZWZpbmVCdWlsdEluKFVSTFByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLnNlcmlhbGl6ZSgpO1xufSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG5pZiAoTmF0aXZlVVJMKSB7XG4gIHZhciBuYXRpdmVDcmVhdGVPYmplY3RVUkwgPSBOYXRpdmVVUkwuY3JlYXRlT2JqZWN0VVJMO1xuICB2YXIgbmF0aXZlUmV2b2tlT2JqZWN0VVJMID0gTmF0aXZlVVJMLnJldm9rZU9iamVjdFVSTDtcbiAgLy8gYFVSTC5jcmVhdGVPYmplY3RVUkxgIG1ldGhvZFxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJML2NyZWF0ZU9iamVjdFVSTFxuICBpZiAobmF0aXZlQ3JlYXRlT2JqZWN0VVJMKSBkZWZpbmVCdWlsdEluKFVSTENvbnN0cnVjdG9yLCAnY3JlYXRlT2JqZWN0VVJMJywgYmluZChuYXRpdmVDcmVhdGVPYmplY3RVUkwsIE5hdGl2ZVVSTCkpO1xuICAvLyBgVVJMLnJldm9rZU9iamVjdFVSTGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9VUkwvcmV2b2tlT2JqZWN0VVJMXG4gIGlmIChuYXRpdmVSZXZva2VPYmplY3RVUkwpIGRlZmluZUJ1aWx0SW4oVVJMQ29uc3RydWN0b3IsICdyZXZva2VPYmplY3RVUkwnLCBiaW5kKG5hdGl2ZVJldm9rZU9iamVjdFVSTCwgTmF0aXZlVVJMKSk7XG59XG5cbnNldFRvU3RyaW5nVGFnKFVSTENvbnN0cnVjdG9yLCAnVVJMJyk7XG5cbiQoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCBmb3JjZWQ6ICFVU0VfTkFUSVZFX1VSTCwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgVVJMOiBVUkxDb25zdHJ1Y3RvclxufSk7XG4iLCIvLyBUT0RPOiBSZW1vdmUgdGhpcyBtb2R1bGUgZnJvbSBgY29yZS1qc0A0YCBzaW5jZSBpdCdzIHJlcGxhY2VkIHRvIG1vZHVsZSBiZWxvd1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIudXJsLmNvbnN0cnVjdG9yJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcblxuLy8gYFVSTC5wcm90b3R5cGUudG9KU09OYCBtZXRob2Rcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC10b2pzb25cbiQoeyB0YXJnZXQ6ICdVUkwnLCBwcm90bzogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSB9LCB7XG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiBjYWxsKFVSTC5wcm90b3R5cGUudG9TdHJpbmcsIHRoaXMpO1xuICB9XG59KTtcbiIsInZhciBnbG9iYWwgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcztcbnZhciBfX3NlbGZfXyA9IChmdW5jdGlvbiAoKSB7XG5mdW5jdGlvbiBGKCkge1xudGhpcy5mZXRjaCA9IGZhbHNlO1xudGhpcy5ET01FeGNlcHRpb24gPSBnbG9iYWwuRE9NRXhjZXB0aW9uXG59XG5GLnByb3RvdHlwZSA9IGdsb2JhbDtcbnJldHVybiBuZXcgRigpO1xufSkoKTtcbihmdW5jdGlvbihzZWxmKSB7XG5cbnZhciBpcnJlbGV2YW50ID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBzZWxmLFxuICAgIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBzZWxmICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICAgIGJsb2I6XG4gICAgICAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJlxuICAgICAgJ0Jsb2InIGluIHNlbGYgJiZcbiAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXcgQmxvYigpO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfTtcblxuICBmdW5jdGlvbiBpc0RhdGFWaWV3KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgICBdO1xuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICAgIEFycmF5QnVmZmVyLmlzVmlldyB8fFxuICAgICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXTtcbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgfTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKTtcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcik7XG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7XG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHM7XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kO1xuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTtcbiAgICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsO1xuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXQ7XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpO1xuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJztcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGw7XG4gICAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbDtcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbDtcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSk7XG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7Ym9keTogdGhpcy5fYm9keUluaXR9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBib2R5XG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoJyYnKVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjJcbiAgICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKTtcbiAgICBwcmVQcm9jZXNzZWRIZWFkZXJzLnNwbGl0KC9cXHI/XFxuLykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKCk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKCk7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnO1xuICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzO1xuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDA7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snO1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJztcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdCk7XG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKTtcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9O1xuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSk7XG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcic7XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH07XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdO1xuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH07XG5cbiAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBzZWxmLkRPTUV4Y2VwdGlvbjtcbiAgdHJ5IHtcbiAgICBuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIH07XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGV4cG9ydHMuRE9NRXhjZXB0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KTtcblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG5cbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdCk7XG4gICAgfSlcbiAgfVxuXG4gIGZldGNoLnBvbHlmaWxsID0gdHJ1ZTtcblxuICBpZiAoIXNlbGYuZmV0Y2gpIHtcbiAgICBzZWxmLmZldGNoID0gZmV0Y2g7XG4gICAgc2VsZi5IZWFkZXJzID0gSGVhZGVycztcbiAgICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICAgIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgfVxuXG4gIGV4cG9ydHMuSGVhZGVycyA9IEhlYWRlcnM7XG4gIGV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIGV4cG9ydHMuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgZXhwb3J0cy5mZXRjaCA9IGZldGNoO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0pKHt9KTtcbn0pKF9fc2VsZl9fKTtcbl9fc2VsZl9fLmZldGNoLnBvbnlmaWxsID0gdHJ1ZTtcbi8vIFJlbW92ZSBcInBvbHlmaWxsXCIgcHJvcGVydHkgYWRkZWQgYnkgd2hhdHdnLWZldGNoXG5kZWxldGUgX19zZWxmX18uZmV0Y2gucG9seWZpbGw7XG4vLyBDaG9vc2UgYmV0d2VlbiBuYXRpdmUgaW1wbGVtZW50YXRpb24gKGdsb2JhbCkgb3IgY3VzdG9tIGltcGxlbWVudGF0aW9uIChfX3NlbGZfXylcbi8vIHZhciBjdHggPSBnbG9iYWwuZmV0Y2ggPyBnbG9iYWwgOiBfX3NlbGZfXztcbnZhciBjdHggPSBfX3NlbGZfXzsgLy8gdGhpcyBsaW5lIGRpc2FibGUgc2VydmljZSB3b3JrZXIgc3VwcG9ydCB0ZW1wb3JhcmlseVxuZXhwb3J0cyA9IGN0eC5mZXRjaCAvLyBUbyBlbmFibGU6IGltcG9ydCBmZXRjaCBmcm9tICdjcm9zcy1mZXRjaCdcbmV4cG9ydHMuZGVmYXVsdCA9IGN0eC5mZXRjaCAvLyBGb3IgVHlwZVNjcmlwdCBjb25zdW1lcnMgd2l0aG91dCBlc01vZHVsZUludGVyb3AuXG5leHBvcnRzLmZldGNoID0gY3R4LmZldGNoIC8vIFRvIGVuYWJsZTogaW1wb3J0IHtmZXRjaH0gZnJvbSAnY3Jvc3MtZmV0Y2gnXG5leHBvcnRzLkhlYWRlcnMgPSBjdHguSGVhZGVyc1xuZXhwb3J0cy5SZXF1ZXN0ID0gY3R4LlJlcXVlc3RcbmV4cG9ydHMuUmVzcG9uc2UgPSBjdHguUmVzcG9uc2Vcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1xuIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiIsIiFmdW5jdGlvbihnbG9iYWxzKXtcbid1c2Ugc3RyaWN0J1xuXG4vLyoqKiBVTUQgQkVHSU5cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7IC8vcmVxdWlyZS5qcyAvIEFNRFxuICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWN1cmVSYW5kb21cbiAgfSlcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHsgLy9Db21tb25KU1xuICBtb2R1bGUuZXhwb3J0cyA9IHNlY3VyZVJhbmRvbVxufSBlbHNlIHsgLy9zY3JpcHQgLyBicm93c2VyXG4gIGdsb2JhbHMuc2VjdXJlUmFuZG9tID0gc2VjdXJlUmFuZG9tXG59XG4vLyoqKiBVTUQgRU5EXG5cbi8vb3B0aW9ucy50eXBlIGlzIHRoZSBvbmx5IHZhbGlkIG9wdGlvblxuZnVuY3Rpb24gc2VjdXJlUmFuZG9tKGNvdW50LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt0eXBlOiAnQXJyYXknfVxuICAvL3dlIGNoZWNrIGZvciBwcm9jZXNzLnBpZCB0byBwcmV2ZW50IGJyb3dzZXJpZnkgZnJvbSB0cmlja2luZyB1c1xuICBpZiAoXG4gICAgdHlwZW9mIHByb2Nlc3MgIT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB0eXBlb2YgcHJvY2Vzcy5waWQgPT0gJ251bWJlcidcbiAgICAmJiBwcm9jZXNzLnZlcnNpb25zXG4gICAgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlXG4gICkge1xuICAgIHJldHVybiBub2RlUmFuZG9tKGNvdW50LCBvcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIHZhciBjcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0b1xuICAgIGlmICghY3J5cHRvKSB0aHJvdyBuZXcgRXJyb3IoXCJZb3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB3aW5kb3cuY3J5cHRvLlwiKVxuICAgIHJldHVybiBicm93c2VyUmFuZG9tKGNvdW50LCBvcHRpb25zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vZGVSYW5kb20oY291bnQsIG9wdGlvbnMpIHtcbiAgdmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG4gIHZhciBidWYgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoY291bnQpXG5cbiAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICBjYXNlICdBcnJheSc6XG4gICAgICByZXR1cm4gW10uc2xpY2UuY2FsbChidWYpXG4gICAgY2FzZSAnQnVmZmVyJzpcbiAgICAgIHJldHVybiBidWZcbiAgICBjYXNlICdVaW50OEFycmF5JzpcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShjb3VudClcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkgeyBhcnJbaV0gPSBidWYucmVhZFVJbnQ4KGkpIH1cbiAgICAgIHJldHVybiBhcnJcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG9wdGlvbnMudHlwZSArIFwiIGlzIHVuc3VwcG9ydGVkLlwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJyb3dzZXJSYW5kb20oY291bnQsIG9wdGlvbnMpIHtcbiAgdmFyIG5hdGl2ZUFyciA9IG5ldyBVaW50OEFycmF5KGNvdW50KVxuICB2YXIgY3J5cHRvID0gd2luZG93LmNyeXB0byB8fCB3aW5kb3cubXNDcnlwdG9cbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuYXRpdmVBcnIpXG5cbiAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICBjYXNlICdBcnJheSc6XG4gICAgICByZXR1cm4gW10uc2xpY2UuY2FsbChuYXRpdmVBcnIpXG4gICAgY2FzZSAnQnVmZmVyJzpcbiAgICAgIHRyeSB7IHZhciBiID0gbmV3IEJ1ZmZlcigxKSB9IGNhdGNoKGUpIHsgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LiBVc2UgTm9kZS5qcyBvciBCcm93c2VyaWZ5IGZvciBicm93c2VyIHN1cHBvcnQuJyl9XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcihuYXRpdmVBcnIpXG4gICAgY2FzZSAnVWludDhBcnJheSc6XG4gICAgICByZXR1cm4gbmF0aXZlQXJyXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihvcHRpb25zLnR5cGUgKyBcIiBpcyB1bnN1cHBvcnRlZC5cIilcbiAgfVxufVxuXG5zZWN1cmVSYW5kb20ucmFuZG9tQXJyYXkgPSBmdW5jdGlvbihieXRlQ291bnQpIHtcbiAgcmV0dXJuIHNlY3VyZVJhbmRvbShieXRlQ291bnQsIHt0eXBlOiAnQXJyYXknfSlcbn1cblxuc2VjdXJlUmFuZG9tLnJhbmRvbVVpbnQ4QXJyYXkgPSBmdW5jdGlvbihieXRlQ291bnQpIHtcbiAgcmV0dXJuIHNlY3VyZVJhbmRvbShieXRlQ291bnQsIHt0eXBlOiAnVWludDhBcnJheSd9KVxufVxuXG5zZWN1cmVSYW5kb20ucmFuZG9tQnVmZmVyID0gZnVuY3Rpb24oYnl0ZUNvdW50KSB7XG4gIHJldHVybiBzZWN1cmVSYW5kb20oYnl0ZUNvdW50LCB7dHlwZTogJ0J1ZmZlcid9KVxufVxuXG5cbn0odGhpcyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC91dGlsL3R5cGVzLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBcmd1bWVudHNPYmplY3QgPSByZXF1aXJlKCdpcy1hcmd1bWVudHMnKTtcbnZhciBpc0dlbmVyYXRvckZ1bmN0aW9uID0gcmVxdWlyZSgnaXMtZ2VuZXJhdG9yLWZ1bmN0aW9uJyk7XG52YXIgd2hpY2hUeXBlZEFycmF5ID0gcmVxdWlyZSgnd2hpY2gtdHlwZWQtYXJyYXknKTtcbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZC1hcnJheScpO1xuXG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gIHJldHVybiBmLmNhbGwuYmluZChmKTtcbn1cblxudmFyIEJpZ0ludFN1cHBvcnRlZCA9IHR5cGVvZiBCaWdJbnQgIT09ICd1bmRlZmluZWQnO1xudmFyIFN5bWJvbFN1cHBvcnRlZCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgT2JqZWN0VG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxudmFyIG51bWJlclZhbHVlID0gdW5jdXJyeVRoaXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBzdHJpbmdWYWx1ZSA9IHVuY3VycnlUaGlzKFN0cmluZy5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgYm9vbGVhblZhbHVlID0gdW5jdXJyeVRoaXMoQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZik7XG5cbmlmIChCaWdJbnRTdXBwb3J0ZWQpIHtcbiAgdmFyIGJpZ0ludFZhbHVlID0gdW5jdXJyeVRoaXMoQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuaWYgKFN5bWJvbFN1cHBvcnRlZCkge1xuICB2YXIgc3ltYm9sVmFsdWUgPSB1bmN1cnJ5VGhpcyhTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YpO1xufVxuXG5mdW5jdGlvbiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBwcm90b3R5cGVWYWx1ZU9mKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgcHJvdG90eXBlVmFsdWVPZih2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnRzLmlzQXJndW1lbnRzT2JqZWN0ID0gaXNBcmd1bWVudHNPYmplY3Q7XG5leHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBpc0dlbmVyYXRvckZ1bmN0aW9uO1xuZXhwb3J0cy5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG5cbi8vIFRha2VuIGZyb20gaGVyZSBhbmQgbW9kaWZpZWQgZm9yIGJldHRlciBicm93c2VyIHN1cHBvcnRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcC1pcy1wcm9taXNlL2Jsb2IvY2RhMzVhNTEzYmRhMDNmOTc3YWQ1Y2RlM2EwNzlkMjM3ZTgyZDdlZi9pbmRleC5qc1xuZnVuY3Rpb24gaXNQcm9taXNlKGlucHV0KSB7XG5cdHJldHVybiAoXG5cdFx0KFxuXHRcdFx0dHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmXG5cdFx0XHRpbnB1dCBpbnN0YW5jZW9mIFByb21pc2Vcblx0XHQpIHx8XG5cdFx0KFxuXHRcdFx0aW5wdXQgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiBpbnB1dC50aGVuID09PSAnZnVuY3Rpb24nICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQuY2F0Y2ggPT09ICdmdW5jdGlvbidcblx0XHQpXG5cdCk7XG59XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIGlzVHlwZWRBcnJheSh2YWx1ZSkgfHxcbiAgICBpc0RhdGFWaWV3KHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0FycmF5QnVmZmVyVmlldyA9IGlzQXJyYXlCdWZmZXJWaWV3O1xuXG5cbmZ1bmN0aW9uIGlzVWludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4QXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4QXJyYXkgPSBpc1VpbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDhDbGFtcGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OENsYW1wZWRBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDhDbGFtcGVkQXJyYXkgPSBpc1VpbnQ4Q2xhbXBlZEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQxNkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQxNkFycmF5ID0gaXNVaW50MTZBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MzJBcnJheSA9IGlzVWludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQ4QXJyYXkgPSBpc0ludDhBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQxNkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50MTZBcnJheSc7XG59XG5leHBvcnRzLmlzSW50MTZBcnJheSA9IGlzSW50MTZBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzSW50MzJBcnJheSA9IGlzSW50MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0MzJBcnJheSA9IGlzRmxvYXQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0Zsb2F0NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0NjRBcnJheSc7XG59XG5leHBvcnRzLmlzRmxvYXQ2NEFycmF5ID0gaXNGbG9hdDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzQmlnSW50NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ0ludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ0ludDY0QXJyYXkgPSBpc0JpZ0ludDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzQmlnVWludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdVaW50NjRBcnJheSc7XG59XG5leHBvcnRzLmlzQmlnVWludDY0QXJyYXkgPSBpc0JpZ1VpbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcF0nO1xufVxuaXNNYXBUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc01hcFRvU3RyaW5nKG5ldyBNYXAoKSlcbik7XG5cbmZ1bmN0aW9uIGlzTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc01hcFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIE1hcDtcbn1cbmV4cG9ydHMuaXNNYXAgPSBpc01hcDtcblxuZnVuY3Rpb24gaXNTZXRUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXRdJztcbn1cbmlzU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNTZXRUb1N0cmluZyhuZXcgU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzU2V0VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNTZXRUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2V0O1xufVxuZXhwb3J0cy5pc1NldCA9IGlzU2V0O1xuXG5mdW5jdGlvbiBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWFrTWFwXSc7XG59XG5pc1dlYWtNYXBUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNXZWFrTWFwVG9TdHJpbmcobmV3IFdlYWtNYXAoKSlcbik7XG5mdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1dlYWtNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgV2Vha01hcDtcbn1cbmV4cG9ydHMuaXNXZWFrTWFwID0gaXNXZWFrTWFwO1xuXG5mdW5jdGlvbiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWFrU2V0XSc7XG59XG5pc1dlYWtTZXRUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgV2Vha1NldCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNXZWFrU2V0VG9TdHJpbmcobmV3IFdlYWtTZXQoKSlcbik7XG5mdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNXZWFrU2V0ID0gaXNXZWFrU2V0O1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cbmlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgQXJyYXlCdWZmZXIoKSlcbik7XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc0FycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufVxuZXhwb3J0cy5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGFWaWV3XSc7XG59XG5pc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgRGF0YVZpZXcgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzRGF0YVZpZXdUb1N0cmluZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpLCAwLCAxKSlcbik7XG5mdW5jdGlvbiBpc0RhdGFWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIERhdGFWaWV3O1xufVxuZXhwb3J0cy5pc0RhdGFWaWV3ID0gaXNEYXRhVmlldztcblxuLy8gU3RvcmUgYSBjb3B5IG9mIFNoYXJlZEFycmF5QnVmZmVyIGluIGNhc2UgaXQncyBkZWxldGVkIGVsc2V3aGVyZVxudmFyIFNoYXJlZEFycmF5QnVmZmVyQ29weSA9IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgPyBTaGFyZWRBcnJheUJ1ZmZlciA6IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTaGFyZWRBcnJheUJ1ZmZlcl0nO1xufVxuZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID09PSAndW5kZWZpbmVkJykge1xuICAgIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBTaGFyZWRBcnJheUJ1ZmZlckNvcHkoKSk7XG4gIH1cblxuICByZXR1cm4gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXJDb3B5O1xufVxuZXhwb3J0cy5pc1NoYXJlZEFycmF5QnVmZmVyID0gaXNTaGFyZWRBcnJheUJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJztcbn1cbmV4cG9ydHMuaXNBc3luY0Z1bmN0aW9uID0gaXNBc3luY0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc01hcEl0ZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcCBJdGVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc01hcEl0ZXJhdG9yID0gaXNNYXBJdGVyYXRvcjtcblxuZnVuY3Rpb24gaXNTZXRJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXQgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNTZXRJdGVyYXRvciA9IGlzU2V0SXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEdlbmVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc0dlbmVyYXRvck9iamVjdCA9IGlzR2VuZXJhdG9yT2JqZWN0O1xuXG5mdW5jdGlvbiBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2ViQXNzZW1ibHkuTW9kdWxlXSc7XG59XG5leHBvcnRzLmlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSA9IGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZTtcblxuZnVuY3Rpb24gaXNOdW1iZXJPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIG51bWJlclZhbHVlKTtcbn1cbmV4cG9ydHMuaXNOdW1iZXJPYmplY3QgPSBpc051bWJlck9iamVjdDtcblxuZnVuY3Rpb24gaXNTdHJpbmdPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN0cmluZ1ZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTdHJpbmdPYmplY3QgPSBpc1N0cmluZ09iamVjdDtcblxuZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBib29sZWFuVmFsdWUpO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW5PYmplY3QgPSBpc0Jvb2xlYW5PYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBCaWdJbnRTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYmlnSW50VmFsdWUpO1xufVxuZXhwb3J0cy5pc0JpZ0ludE9iamVjdCA9IGlzQmlnSW50T2JqZWN0O1xuXG5mdW5jdGlvbiBpc1N5bWJvbE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gU3ltYm9sU3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN5bWJvbFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTeW1ib2xPYmplY3QgPSBpc1N5bWJvbE9iamVjdDtcblxuZnVuY3Rpb24gaXNCb3hlZFByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0JpZ0ludE9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N5bWJvbE9iamVjdCh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNCb3hlZFByaW1pdGl2ZSA9IGlzQm94ZWRQcmltaXRpdmU7XG5cbmZ1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHxcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0FueUFycmF5QnVmZmVyID0gaXNBbnlBcnJheUJ1ZmZlcjtcblxuWydpc1Byb3h5JywgJ2lzRXh0ZXJuYWwnLCAnaXNNb2R1bGVOYW1lc3BhY2VPYmplY3QnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbWV0aG9kLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICcgaXMgbm90IHN1cHBvcnRlZCBpbiB1c2VybGFuZCcpO1xuICAgIH1cbiAgfSk7XG59KTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHx8XG4gIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciBkZXNjcmlwdG9ycyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzY3JpcHRvcnNba2V5c1tpXV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfTtcblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZSZWdleCA9IC9eJC87XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSB7XG4gIHZhciBkZWJ1Z0VudiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUc7XG4gIGRlYnVnRW52ID0gZGVidWdFbnYucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCs/Ll0vZywgJ1xcXFwkJicpXG4gICAgLnJlcGxhY2UoL1xcKi9nLCAnLionKVxuICAgIC5yZXBsYWNlKC8sL2csICckfF4nKVxuICAgIC50b1VwcGVyQ2FzZSgpO1xuICBkZWJ1Z0VudlJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBkZWJ1Z0VudiArICckJywgJ2knKTtcbn1cbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAoZGVidWdFbnZSZWdleC50ZXN0KHNldCkpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZXhwb3J0cy50eXBlcyA9IHJlcXVpcmUoJy4vc3VwcG9ydC90eXBlcycpO1xuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuZXhwb3J0cy50eXBlcy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbmV4cG9ydHMudHlwZXMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5leHBvcnRzLnR5cGVzLmlzTmF0aXZlRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuXG5leHBvcnRzLnByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XG4gICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgZm4sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgKTtcbn1cblxuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyZWFzb24sIGNiKSB7XG4gIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgLy8gb2NjdXJyZWRcIiwgd2UgZXJyb3Itd3JhcCBzbyB0aGUgY2FsbGJhY2sgY29uc3VtZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICBpZiAoIXJlYXNvbikge1xuICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoJ1Byb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZScpO1xuICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xuICB9XG4gIHJldHVybiBjYihyZWFzb24pO1xufVxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxuICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLCBudWxsLCByZXQpKSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLmJpbmQobnVsbCwgcmVqLCBjYikpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzVG9TdHJpbmdUYWdTaGFtcygpIHtcblx0cmV0dXJuIGhhc1N5bWJvbHMoKSAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG5cbnZhciBpc1N0YW5kYXJkQXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiAkdG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbnZhciBpc0xlZ2FjeUFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChpc1N0YW5kYXJkQXJndW1lbnRzKHZhbHVlKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gaXNTdGFuZGFyZEFyZ3VtZW50cyhhcmd1bWVudHMpO1xufSgpKTtcblxuaXNTdGFuZGFyZEFyZ3VtZW50cy5pc0xlZ2FjeUFyZ3VtZW50cyA9IGlzTGVnYWN5QXJndW1lbnRzOyAvLyBmb3IgdGVzdHNcblxubW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID8gaXNTdGFuZGFyZEFyZ3VtZW50cyA6IGlzTGVnYWN5QXJndW1lbnRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciByZWZsZWN0QXBwbHkgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdCAhPT0gbnVsbCAmJiBSZWZsZWN0LmFwcGx5O1xudmFyIGJhZEFycmF5TGlrZTtcbnZhciBpc0NhbGxhYmxlTWFya2VyO1xuaWYgKHR5cGVvZiByZWZsZWN0QXBwbHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuXHR0cnkge1xuXHRcdGJhZEFycmF5TGlrZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2xlbmd0aCcsIHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aHJvdyBpc0NhbGxhYmxlTWFya2VyO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlzQ2FsbGFibGVNYXJrZXIgPSB7fTtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuXHRcdHJlZmxlY3RBcHBseShmdW5jdGlvbiAoKSB7IHRocm93IDQyOyB9LCBudWxsLCBiYWRBcnJheUxpa2UpO1xuXHR9IGNhdGNoIChfKSB7XG5cdFx0aWYgKF8gIT09IGlzQ2FsbGFibGVNYXJrZXIpIHtcblx0XHRcdHJlZmxlY3RBcHBseSA9IG51bGw7XG5cdFx0fVxuXHR9XG59IGVsc2Uge1xuXHRyZWZsZWN0QXBwbHkgPSBudWxsO1xufVxuXG52YXIgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzXFxiLztcbnZhciBpc0VTNkNsYXNzRm4gPSBmdW5jdGlvbiBpc0VTNkNsYXNzRnVuY3Rpb24odmFsdWUpIHtcblx0dHJ5IHtcblx0XHR2YXIgZm5TdHIgPSBmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiBjb25zdHJ1Y3RvclJlZ2V4LnRlc3QoZm5TdHIpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBub3QgYSBmdW5jdGlvblxuXHR9XG59O1xuXG52YXIgdHJ5RnVuY3Rpb25PYmplY3QgPSBmdW5jdGlvbiB0cnlGdW5jdGlvblRvU3RyKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZm5DbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG52YXIgZ2VuQ2xhc3MgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZzsgLy8gYmV0dGVyOiB1c2UgYGhhcy10b3N0cmluZ3RhZ2Bcbi8qIGdsb2JhbHMgZG9jdW1lbnQ6IGZhbHNlICovXG52YXIgZG9jdW1lbnREb3RBbGwgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkb2N1bWVudC5hbGwgPT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmFsbCAhPT0gdW5kZWZpbmVkID8gZG9jdW1lbnQuYWxsIDoge307XG5cbm1vZHVsZS5leHBvcnRzID0gcmVmbGVjdEFwcGx5XG5cdD8gZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PT0gZG9jdW1lbnREb3RBbGwpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmICF2YWx1ZS5wcm90b3R5cGUpIHsgcmV0dXJuIHRydWU7IH1cblx0XHR0cnkge1xuXHRcdFx0cmVmbGVjdEFwcGx5KHZhbHVlLCBudWxsLCBiYWRBcnJheUxpa2UpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmIChlICE9PSBpc0NhbGxhYmxlTWFya2VyKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gIWlzRVM2Q2xhc3NGbih2YWx1ZSk7XG5cdH1cblx0OiBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09PSBkb2N1bWVudERvdEFsbCkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgIXZhbHVlLnByb3RvdHlwZSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmIChoYXNUb1N0cmluZ1RhZykgeyByZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpOyB9XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dmFyIHN0ckNsYXNzID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHN0ckNsYXNzID09PSBmbkNsYXNzIHx8IHN0ckNsYXNzID09PSBnZW5DbGFzcztcblx0fTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRm5SZWdleCA9IC9eXFxzKig/OmZ1bmN0aW9uKT9cXCovO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBnZXRHZW5lcmF0b3JGdW5jID0gZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiooKSB7fScpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0fVxufTtcbnZhciBHZW5lcmF0b3JGdW5jdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKGlzRm5SZWdleC50ZXN0KGZuVG9TdHIuY2FsbChmbikpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKGZuKTtcblx0XHRyZXR1cm4gc3RyID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXHR9XG5cdGlmICghZ2V0UHJvdG8pIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKHR5cGVvZiBHZW5lcmF0b3JGdW5jdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgZ2VuZXJhdG9yRnVuYyA9IGdldEdlbmVyYXRvckZ1bmMoKTtcblx0XHRHZW5lcmF0b3JGdW5jdGlvbiA9IGdlbmVyYXRvckZ1bmMgPyBnZXRQcm90byhnZW5lcmF0b3JGdW5jKSA6IGZhbHNlO1xuXHR9XG5cdHJldHVybiBnZXRQcm90byhmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCdjYWxsLWJpbmQnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgc2hpbSA9IHJlcXVpcmUoJy4vc2hpbScpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBOdW1iZXIpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbmRlZmluZShwb2x5ZmlsbCwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0aWYgKE51bWJlci5pc05hTiAmJiBOdW1iZXIuaXNOYU4oTmFOKSAmJiAhTnVtYmVyLmlzTmFOKCdhJykpIHtcblx0XHRyZXR1cm4gTnVtYmVyLmlzTmFOO1xuXHR9XG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU51bWJlcklzTmFOKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoTnVtYmVyLCB7IGlzTmFOOiBwb2x5ZmlsbCB9LCB7XG5cdFx0aXNOYU46IGZ1bmN0aW9uIHRlc3RJc05hTigpIHtcblx0XHRcdHJldHVybiBOdW1iZXIuaXNOYU4gIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yLWVhY2gnKTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcbnZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLmluZGV4T2YnLCB0cnVlKSB8fCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgdG9TdHJUYWdzID0ge307XG52YXIgZ09QRCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG5pZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBnZXRQcm90b3R5cGVPZikge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdGlmIChTeW1ib2wudG9TdHJpbmdUYWcgaW4gYXJyKSB7XG5cdFx0XHR2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihhcnIpO1xuXHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0aWYgKCFkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuXHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0fVxuXHRcdFx0dG9TdHJUYWdzW3R5cGVkQXJyYXldID0gZGVzY3JpcHRvci5nZXQ7XG5cdFx0fVxuXHR9KTtcbn1cblxudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcblx0dmFyIGFueVRydWUgPSBmYWxzZTtcblx0Zm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWFueVRydWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGFueVRydWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSkgPT09IHR5cGVkQXJyYXk7XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBhbnlUcnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnIHx8ICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSkge1xuXHRcdHZhciB0YWcgPSAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpO1xuXHRcdHJldHVybiAkaW5kZXhPZih0eXBlZEFycmF5cywgdGFnKSA+IC0xO1xuXHR9XG5cdGlmICghZ09QRCkgeyByZXR1cm4gZmFsc2U7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduSW47XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbicpLFxuICAgIGJhc2VBc3NpZ25JbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25JbicpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBjb3B5U3ltYm9scyA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzJyksXG4gICAgY29weVN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzSW4nKSxcbiAgICBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpLFxuICAgIGdldEFsbEtleXNJbiA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXNJbicpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGluaXRDbG9uZUFycmF5ID0gcmVxdWlyZSgnLi9faW5pdENsb25lQXJyYXknKSxcbiAgICBpbml0Q2xvbmVCeVRhZyA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUJ5VGFnJyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzTWFwID0gcmVxdWlyZSgnLi9pc01hcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU2V0ID0gcmVxdWlyZSgnLi9pc1NldCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2xvbmU7XG4iLCJ2YXIgYmFzZUZvck93biA9IHJlcXVpcmUoJy4vX2Jhc2VGb3JPd24nKSxcbiAgICBjcmVhdGVCYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKi9cbnZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VFYWNoO1xuIiwidmFyIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvck93bjtcbiIsInZhciBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hcCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXA7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNSZWdFeHBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1JlZ0V4cCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSByZWdleHBUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzUmVnRXhwO1xuIiwidmFyIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1NldDtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0RnVuY3Rpb247XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURhdGFWaWV3O1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVJlZ0V4cDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lU3ltYm9sO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9sc0luO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXNJbjtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG9iamVjdCkge1xuICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9sc0luO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVBcnJheTtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpLFxuICAgIGNsb25lRGF0YVZpZXcgPSByZXF1aXJlKCcuL19jbG9uZURhdGFWaWV3JyksXG4gICAgY2xvbmVSZWdFeHAgPSByZXF1aXJlKCcuL19jbG9uZVJlZ0V4cCcpLFxuICAgIGNsb25lU3ltYm9sID0gcmVxdWlyZSgnLi9fY2xvbmVTeW1ib2wnKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQnlUYWc7XG4iLCJ2YXIgYmFzZUNsb25lID0gcmVxdWlyZSgnLi9fYmFzZUNsb25lJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZVxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coZGVlcFswXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURlZXA7XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2VcbiAqIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdFxuICogcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICogT25jZSBhIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmRlZmF1bHRzRGVlcFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKi9cbnZhciBkZWZhdWx0cyA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMTtcbiAgdmFyIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoO1xuICB2YXIgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgbGVuZ3RoID0gMTtcbiAgfVxuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgIHZhciBwcm9wcyA9IGtleXNJbihzb3VyY2UpO1xuICAgIHZhciBwcm9wc0luZGV4ID0gLTE7XG4gICAgdmFyIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsrcHJvcHNJbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbcHJvcHNJbmRleF07XG4gICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAoZXEodmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZm9yRWFjaCcpO1xuIiwidmFyIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKSxcbiAgICBjYXN0RnVuY3Rpb24gPSByZXF1aXJlKCcuL19jYXN0RnVuY3Rpb24nKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIlxuICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcbiAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGFsaWFzIGVhY2hcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICogQHNlZSBfLmZvckVhY2hSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZvckVhY2goWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxuICpcbiAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAqICAgY29uc29sZS5sb2coa2V5KTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoIDogYmFzZUVhY2g7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGNhc3RGdW5jdGlvbihpdGVyYXRlZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7XG4iLCJ2YXIgYmFzZUlzTWFwID0gcmVxdWlyZSgnLi9fYmFzZUlzTWFwJyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc01hcChuZXcgTWFwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFwO1xuIiwidmFyIGJhc2VJc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2Jhc2VJc1JlZ0V4cCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNSZWdFeHAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1JlZ0V4cDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFJlZ0V4cGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNSZWdFeHAoL2FiYy8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNSZWdFeHAoJy9hYmMvJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNSZWdFeHAgPSBub2RlSXNSZWdFeHAgPyBiYXNlVW5hcnkobm9kZUlzUmVnRXhwKSA6IGJhc2VJc1JlZ0V4cDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1JlZ0V4cDtcbiIsInZhciBiYXNlSXNTZXQgPSByZXF1aXJlKCcuL19iYXNlSXNTZXQnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU2V0KG5ldyBTZXQpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTZXQ7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyksXG4gICAgY2FzdFNsaWNlID0gcmVxdWlyZSgnLi9fY2FzdFNsaWNlJyksXG4gICAgaGFzVW5pY29kZSA9IHJlcXVpcmUoJy4vX2hhc1VuaWNvZGUnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vaXNSZWdFeHAnKSxcbiAgICBzdHJpbmdTaXplID0gcmVxdWlyZSgnLi9fc3RyaW5nU2l6ZScpLFxuICAgIHN0cmluZ1RvQXJyYXkgPSByZXF1aXJlKCcuL19zdHJpbmdUb0FycmF5JyksXG4gICAgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqIFVzZWQgYXMgZGVmYXVsdCBvcHRpb25zIGZvciBgXy50cnVuY2F0ZWAuICovXG52YXIgREVGQVVMVF9UUlVOQ19MRU5HVEggPSAzMCxcbiAgICBERUZBVUxUX1RSVU5DX09NSVNTSU9OID0gJy4uLic7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIFRydW5jYXRlcyBgc3RyaW5nYCBpZiBpdCdzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gKiBUaGUgbGFzdCBjaGFyYWN0ZXJzIG9mIHRoZSB0cnVuY2F0ZWQgc3RyaW5nIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBvbWlzc2lvblxuICogc3RyaW5nIHdoaWNoIGRlZmF1bHRzIHRvIFwiLi4uXCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJ1bmNhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MzBdIFRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub21pc3Npb249Jy4uLiddIFRoZSBzdHJpbmcgdG8gaW5kaWNhdGUgdGV4dCBpcyBvbWl0dGVkLlxuICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbb3B0aW9ucy5zZXBhcmF0b3JdIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byB0cnVuY2F0ZSB0by5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRydW5jYXRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nKTtcbiAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm8uLi4nXG4gKlxuICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAqICAgJ2xlbmd0aCc6IDI0LFxuICogICAnc2VwYXJhdG9yJzogJyAnXG4gKiB9KTtcbiAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsLi4uJ1xuICpcbiAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gKiAgICdsZW5ndGgnOiAyNCxcbiAqICAgJ3NlcGFyYXRvcic6IC8sPyArL1xuICogfSk7XG4gKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLi4uJ1xuICpcbiAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gKiAgICdvbWlzc2lvbic6ICcgWy4uLl0nXG4gKiB9KTtcbiAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWcgWy4uLl0nXG4gKi9cbmZ1bmN0aW9uIHRydW5jYXRlKHN0cmluZywgb3B0aW9ucykge1xuICB2YXIgbGVuZ3RoID0gREVGQVVMVF9UUlVOQ19MRU5HVEgsXG4gICAgICBvbWlzc2lvbiA9IERFRkFVTFRfVFJVTkNfT01JU1NJT047XG5cbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgdmFyIHNlcGFyYXRvciA9ICdzZXBhcmF0b3InIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlcGFyYXRvciA6IHNlcGFyYXRvcjtcbiAgICBsZW5ndGggPSAnbGVuZ3RoJyBpbiBvcHRpb25zID8gdG9JbnRlZ2VyKG9wdGlvbnMubGVuZ3RoKSA6IGxlbmd0aDtcbiAgICBvbWlzc2lvbiA9ICdvbWlzc2lvbicgaW4gb3B0aW9ucyA/IGJhc2VUb1N0cmluZyhvcHRpb25zLm9taXNzaW9uKSA6IG9taXNzaW9uO1xuICB9XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgdmFyIHN0ckxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIGlmIChoYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKTtcbiAgICBzdHJMZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcbiAgfVxuICBpZiAobGVuZ3RoID49IHN0ckxlbmd0aCkge1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cbiAgdmFyIGVuZCA9IGxlbmd0aCAtIHN0cmluZ1NpemUob21pc3Npb24pO1xuICBpZiAoZW5kIDwgMSkge1xuICAgIHJldHVybiBvbWlzc2lvbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gc3RyU3ltYm9sc1xuICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJylcbiAgICA6IHN0cmluZy5zbGljZSgwLCBlbmQpO1xuXG4gIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgfVxuICBpZiAoc3RyU3ltYm9scykge1xuICAgIGVuZCArPSAocmVzdWx0Lmxlbmd0aCAtIGVuZCk7XG4gIH1cbiAgaWYgKGlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICBpZiAoc3RyaW5nLnNsaWNlKGVuZCkuc2VhcmNoKHNlcGFyYXRvcikpIHtcbiAgICAgIHZhciBtYXRjaCxcbiAgICAgICAgICBzdWJzdHJpbmcgPSByZXN1bHQ7XG5cbiAgICAgIGlmICghc2VwYXJhdG9yLmdsb2JhbCkge1xuICAgICAgICBzZXBhcmF0b3IgPSBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgdG9TdHJpbmcocmVGbGFncy5leGVjKHNlcGFyYXRvcikpICsgJ2cnKTtcbiAgICAgIH1cbiAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXggPSAwO1xuICAgICAgd2hpbGUgKChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN1YnN0cmluZykpKSB7XG4gICAgICAgIHZhciBuZXdFbmQgPSBtYXRjaC5pbmRleDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBuZXdFbmQgPT09IHVuZGVmaW5lZCA/IGVuZCA6IG5ld0VuZCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0cmluZy5pbmRleE9mKGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpLCBlbmQpICE9IGVuZCkge1xuICAgIHZhciBpbmRleCA9IHJlc3VsdC5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaW5kZXgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJ1bmNhdGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBudW1iZXJJc05hTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpcyhhLCBiKSB7XG5cdGlmIChhID09PSAwICYmIGIgPT09IDApIHtcblx0XHRyZXR1cm4gMSAvIGEgPT09IDEgLyBiO1xuXHR9XG5cdGlmIChhID09PSBiKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKG51bWJlcklzTmFOKGEpICYmIG51bWJlcklzTmFOKGIpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJ2NhbGwtYmluZCcpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgc2hpbSA9IHJlcXVpcmUoJy4vc2hpbScpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBPYmplY3QpO1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdHJldHVybiB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaW1wbGVtZW50YXRpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltT2JqZWN0SXMoKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShPYmplY3QsIHsgaXM6IHBvbHlmaWxsIH0sIHtcblx0XHRpczogZnVuY3Rpb24gdGVzdE9iamVjdElzKCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5pcyAhPT0gcG9seWZpbGw7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhhdCBvbmx5IHdvcmtzIG9uIERPTSBvYmplY3RzLlxuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgZGVmaW5lKEdwLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgaW4gbW9kZXJuIGVuZ2luZXNcbiAgLy8gd2UgY2FuIGV4cGxpY2l0bHkgYWNjZXNzIGdsb2JhbFRoaXMuIEluIG9sZGVyIGVuZ2luZXMgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICB9IGVsc2Uge1xuICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2V2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG52YXIgX2NvbmZpZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb25maWcpO1xuXG52YXIgX21ldGhvZHMgPSByZXF1aXJlKCcuL21ldGhvZHMnKTtcblxudmFyIF9tZXRob2RzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21ldGhvZHMpO1xuXG52YXIgX3RyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMnKTtcblxudmFyIF90cmFuc3BvcnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyYW5zcG9ydHMpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIF9odHRwID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2h0dHAnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuLy8gaW1wb3J0IFByb21pc2UgZnJvbSAnYmx1ZWJpcmQnO1xuXG4vLyBpbXBvcnQge1xuLy8gICAgIGhhc2hcbi8vIH0gZnJvbSAnLi4vYXV0aC9lY2MnO1xuLy8gaW1wb3J0IHtcbi8vICAgICBvcHNcbi8vIH0gZnJvbSAnLi4vYXV0aC9zZXJpYWxpemVyJztcblxuXG52YXIgU3RlZW0gPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICAgIF9pbmhlcml0cyhTdGVlbSwgX0V2ZW50RW1pdHRlcik7XG5cbiAgICBmdW5jdGlvbiBTdGVlbSgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGVlbSk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFN0ZWVtLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3RlZW0pKS5jYWxsKHRoaXMsIG9wdGlvbnMpKTtcblxuICAgICAgICBfdGhpcy5fc2V0VHJhbnNwb3J0KG9wdGlvbnMpO1xuICAgICAgICBfdGhpcy5fc2V0TG9nZ2VyKG9wdGlvbnMpO1xuICAgICAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgX3RoaXMuc2VxTm8gPSAwOyAvLyB1c2VkIGZvciBycGMgY2FsbHNcbiAgICAgICAgX21ldGhvZHMyLmRlZmF1bHQuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IG1ldGhvZC5tZXRob2RfbmFtZSB8fCAoMCwgX3V0aWxzLmNhbWVsQ2FzZSkobWV0aG9kLm1ldGhvZCk7XG4gICAgICAgICAgICB2YXIgbWV0aG9kUGFyYW1zID0gbWV0aG9kLnBhcmFtcyB8fCBbXTtcblxuICAgICAgICAgICAgX3RoaXNbbWV0aG9kTmFtZSArICdXaXRoJ10gPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZW5kKG1ldGhvZC5hcGksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogbWV0aG9kUGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uc1twYXJhbV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpO2Vsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfdGhpc1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gbWV0aG9kUGFyYW1zLnJlZHVjZShmdW5jdGlvbiAobWVtbywgcGFyYW0sIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtb1twYXJhbV0gPSBhcmdzW2ldOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzW21ldGhvZFBhcmFtcy5sZW5ndGhdO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpc1ttZXRob2ROYW1lICsgJ1dpdGgnXShvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyAgIHRoaXNbYCR7bWV0aG9kTmFtZX1XaXRoQXN5bmNgXSA9IFByb21pc2UucHJvbWlzaWZ5KHRoaXNbYCR7bWV0aG9kTmFtZX1XaXRoYF0pO1xuICAgICAgICAgICAgLy8gdGhpc1tgJHttZXRob2ROYW1lfUFzeW5jYF0gPSBQcm9taXNlLnByb21pc2lmeSh0aGlzW21ldGhvZE5hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoaXMuY2FsbEFzeW5jID0gUHJvbWlzZS5wcm9taXNpZnkodGhpcy5jYWxsKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhTdGVlbSwgW3tcbiAgICAgICAga2V5OiAnX3NldFRyYW5zcG9ydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0VHJhbnNwb3J0KG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVybCAmJiBvcHRpb25zLnVybC5tYXRjaCgnXigoaHR0cHxodHRwcyk/OlxcL1xcLyknKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudXJpID0gb3B0aW9ucy51cmw7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50cmFuc3BvcnQgPSAnaHR0cCc7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0VHlwZSA9IG9wdGlvbnMudHJhbnNwb3J0O1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBuZXcgX3RyYW5zcG9ydHMyLmRlZmF1bHQuaHR0cChvcHRpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy51cmwgJiYgb3B0aW9ucy51cmwubWF0Y2goJ14oKHdzfHdzcyk/OlxcL1xcLyknKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMud2Vic29ja2V0ID0gb3B0aW9ucy51cmw7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50cmFuc3BvcnQgPSAnd3MnO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zcG9ydFR5cGUgPSBvcHRpb25zLnRyYW5zcG9ydDtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3IF90cmFuc3BvcnRzMi5kZWZhdWx0LndzKG9wdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydCAmJiB0aGlzLl90cmFuc3BvcnRUeXBlICE9PSBvcHRpb25zLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0VHlwZSA9IG9wdGlvbnMudHJhbnNwb3J0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zcG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdHJhbnNwb3J0czIuZGVmYXVsdFtvcHRpb25zLnRyYW5zcG9ydF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYHRyYW5zcG9ydGAsIHZhbGlkIHZhbHVlcyBhcmUgYGh0dHBgLCBgd3NgIG9yIGEgY2xhc3MnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG5ldyBfdHJhbnNwb3J0czIuZGVmYXVsdFtvcHRpb25zLnRyYW5zcG9ydF0ob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBuZXcgb3B0aW9ucy50cmFuc3BvcnQob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG5ldyBfdHJhbnNwb3J0czIuZGVmYXVsdC53cyhvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3NldExvZ2dlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0TG9nZ2VyKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdsb2dnZXInKSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX3R5cGVvZihvcHRpb25zLmxvZ2dlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2xvZ2dlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2c6IG9wdGlvbnMubG9nZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9nZ2VyLmxvZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0T3B0aW9ucyh7bG9nZ2VyOnt9fSkgbXVzdCBoYXZlIGEgcHJvcGVydHkgLmxvZyBvZiB0eXBlIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fbG9nZ2VyID0gb3B0aW9ucy5sb2dnZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fbG9nZ2VyKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19sb2dnZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2xvZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2cobG9nTGV2ZWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9fbG9nZ2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiB0aGlzLl9fbG9nZ2VyW2xvZ0xldmVsXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19sb2dnZXJbbG9nTGV2ZWxdLmFwcGx5KHRoaXMuX19sb2dnZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19sb2dnZXIubG9nLmFwcGx5KHRoaXMuX19sb2dnZXIsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdGFydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5zdGFydCgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdG9wJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZW5kJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmQoYXBpLCBkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGNiID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBpZiAodGhpcy5fX2xvZ2dlcikge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCd4bWl0OicgKyBpZCArICc6JywgZGF0YSk7XG4gICAgICAgICAgICAgICAgY2IgPSBmdW5jdGlvbiBjYihlLCBkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZygnZXJyb3InLCAncnNwOicgKyBpZCArICc6XFxuXFxuJywgZSwgZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZygncnNwOicgKyBpZCArICc6JywgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5zZW5kKGFwaSwgZGF0YSwgY2IpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjYWxsJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGwobWV0aG9kLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0VHlwZSAhPT0gJ2h0dHAnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdSUEMgbWV0aG9kcyBjYW4gb25seSBiZSBjYWxsZWQgd2hlbiB1c2luZyBodHRwIHRyYW5zcG9ydCcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaWQgPSArK3RoaXMuc2VxTm87XG4gICAgICAgICAgICAoMCwgX2h0dHAuanNvblJwYykodGhpcy5vcHRpb25zLnVyaSwgeyBtZXRob2Q6IG1ldGhvZCwgcGFyYW1zOiBwYXJhbXMsIGlkOiBpZCB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuX3NldExvZ2dlcihvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFRyYW5zcG9ydChvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldFdlYlNvY2tldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRXZWJTb2NrZXQodXJsKSB7XG4gICAgICAgICAgICB0aGlzLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIHdlYnNvY2tldDogdXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0VXJpJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFVyaSh1cmwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgdXJpOiB1cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYnJvYWRjYXN0VHJhbnNhY3Rpb25TeW5jaHJvbm91c1dpdGgob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gY29uc3QgdHJ4ID0gb3B0aW9ucy50cng7XG4gICAgICAgIC8vIHJldHVybiB0aGlzLnNlbmQoXG4gICAgICAgIC8vICAgICAnbmV0d29ya19icm9hZGNhc3RfYXBpJywge1xuICAgICAgICAvLyAgICAgICAgIG1ldGhvZDogJ2Jyb2FkY2FzdF90cmFuc2FjdGlvbl9zeW5jaHJvbm91cycsXG4gICAgICAgIC8vICAgICAgICAgcGFyYW1zOiBbdHJ4XSxcbiAgICAgICAgLy8gICAgIH0sXG4gICAgICAgIC8vICAgICAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgLy8gICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgIC8vICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHNpZ25lZF90cmFuc2FjdGlvblxuICAgICAgICAvLyAgICAgICAgICAgICB9ID0gb3BzO1xuICAgICAgICAvLyAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0gYnJvYWRjYXN0VHJhbnNhY3Rpb25TeW5jaHJvbm91cyAtLT4nLCBKU09OLnN0cmluZ2lmeShzaWduZWRfdHJhbnNhY3Rpb24udG9PYmplY3QodHJ4KSwgbnVsbCwgMikpO1xuICAgICAgICAvLyAgICAgICAgICAgICAvLyB0b09iamVjdCBjb252ZXJ0cyBvYmplY3RzIGludG8gc2VyaWFsaXphYmxlIHR5cGVzXG4gICAgICAgIC8vICAgICAgICAgICAgIGNvbnN0IHRyT2JqZWN0ID0gc2lnbmVkX3RyYW5zYWN0aW9uLnRvT2JqZWN0KHRyeCk7XG4gICAgICAgIC8vICAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IHNpZ25lZF90cmFuc2FjdGlvbi50b0J1ZmZlcih0cngpO1xuICAgICAgICAvLyAgICAgICAgICAgICBlcnIuZGlnZXN0ID0gaGFzaC5zaGEyNTYoYnVmKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIC8vICAgICAgICAgICAgIGVyci50cmFuc2FjdGlvbl9pZCA9IGJ1Zi50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIC8vICAgICAgICAgICAgIGVyci50cmFuc2FjdGlvbiA9IEpTT04uc3RyaW5naWZ5KHRyT2JqZWN0KTtcbiAgICAgICAgLy8gICAgICAgICAgICAgY2FsbGJhY2soZXJyLCAnJyk7XG4gICAgICAgIC8vICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgY2FsbGJhY2soJycsIHJlc3VsdCk7XG4gICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAvLyAgICAgfSxcbiAgICAgICAgLy8gKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gfVxuXG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFN0ZWVtO1xufShfZXZlbnRzMi5kZWZhdWx0KTtcblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuXG5cbnZhciBzdGVlbSA9IG5ldyBTdGVlbShfY29uZmlnMi5kZWZhdWx0KTtcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHN0ZWVtO1xuZXhwb3J0cy5TdGVlbSA9IFN0ZWVtOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gW3tcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJzZXRfc3Vic2NyaWJlX2NhbGxiYWNrXCIsXG4gIFwicGFyYW1zXCI6IFtcImNhbGxiYWNrXCIsIFwiY2xlYXJGaWx0ZXJcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJzZXRfcGVuZGluZ190cmFuc2FjdGlvbl9jYWxsYmFja1wiLFxuICBcInBhcmFtc1wiOiBbXCJjYlwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcInNldF9ibG9ja19hcHBsaWVkX2NhbGxiYWNrXCIsXG4gIFwicGFyYW1zXCI6IFtcImNiXCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiY2FuY2VsX2FsbF9zdWJzY3JpcHRpb25zXCJcbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfdHJlbmRpbmdfdGFnc1wiLFxuICBcInBhcmFtc1wiOiBbXCJhZnRlclRhZ1wiLCBcImxpbWl0XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X3RhZ3NfdXNlZF9ieV9hdXRob3JcIixcbiAgXCJwYXJhbXNcIjogW1wiYXV0aG9yXCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X3Bvc3RfZGlzY3Vzc2lvbnNfYnlfcGF5b3V0XCIsXG4gIFwicGFyYW1zXCI6IFtcInF1ZXJ5XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2NvbW1lbnRfZGlzY3Vzc2lvbnNfYnlfcGF5b3V0XCIsXG4gIFwicGFyYW1zXCI6IFtcInF1ZXJ5XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2Rpc2N1c3Npb25zX2J5X3RyZW5kaW5nXCIsXG4gIFwicGFyYW1zXCI6IFtcInF1ZXJ5XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2Rpc2N1c3Npb25zX2J5X3RyZW5kaW5nMzBcIixcbiAgXCJwYXJhbXNcIjogW1wicXVlcnlcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZGlzY3Vzc2lvbnNfYnlfY3JlYXRlZFwiLFxuICBcInBhcmFtc1wiOiBbXCJxdWVyeVwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9kaXNjdXNzaW9uc19ieV9hY3RpdmVcIixcbiAgXCJwYXJhbXNcIjogW1wicXVlcnlcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZGlzY3Vzc2lvbnNfYnlfY2FzaG91dFwiLFxuICBcInBhcmFtc1wiOiBbXCJxdWVyeVwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9kaXNjdXNzaW9uc19ieV9wYXlvdXRcIixcbiAgXCJwYXJhbXNcIjogW1wicXVlcnlcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZGlzY3Vzc2lvbnNfYnlfdm90ZXNcIixcbiAgXCJwYXJhbXNcIjogW1wicXVlcnlcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZGlzY3Vzc2lvbnNfYnlfY2hpbGRyZW5cIixcbiAgXCJwYXJhbXNcIjogW1wicXVlcnlcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZGlzY3Vzc2lvbnNfYnlfaG90XCIsXG4gIFwicGFyYW1zXCI6IFtcInF1ZXJ5XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2Rpc2N1c3Npb25zX2J5X2ZlZWRcIixcbiAgXCJwYXJhbXNcIjogW1wicXVlcnlcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZGlzY3Vzc2lvbnNfYnlfYmxvZ1wiLFxuICBcInBhcmFtc1wiOiBbXCJxdWVyeVwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9kaXNjdXNzaW9uc19ieV9jb21tZW50c1wiLFxuICBcInBhcmFtc1wiOiBbXCJxdWVyeVwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9kaXNjdXNzaW9uc19ieV9wcm9tb3RlZFwiLFxuICBcInBhcmFtc1wiOiBbXCJxdWVyeVwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9ibG9ja19oZWFkZXJcIixcbiAgXCJwYXJhbXNcIjogW1wiYmxvY2tOdW1cIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfYmxvY2tcIixcbiAgXCJwYXJhbXNcIjogW1wiYmxvY2tOdW1cIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfb3BzX2luX2Jsb2NrXCIsXG4gIFwicGFyYW1zXCI6IFtcImJsb2NrTnVtXCIsIFwib25seVZpcnR1YWxcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfc3RhdGVcIixcbiAgXCJwYXJhbXNcIjogW1wicGF0aFwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF90cmVuZGluZ19jYXRlZ29yaWVzXCIsXG4gIFwicGFyYW1zXCI6IFtcImFmdGVyXCIsIFwibGltaXRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfYmVzdF9jYXRlZ29yaWVzXCIsXG4gIFwicGFyYW1zXCI6IFtcImFmdGVyXCIsIFwibGltaXRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfYWN0aXZlX2NhdGVnb3JpZXNcIixcbiAgXCJwYXJhbXNcIjogW1wiYWZ0ZXJcIiwgXCJsaW1pdFwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9yZWNlbnRfY2F0ZWdvcmllc1wiLFxuICBcInBhcmFtc1wiOiBbXCJhZnRlclwiLCBcImxpbWl0XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2NvbmZpZ1wiXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2R5bmFtaWNfZ2xvYmFsX3Byb3BlcnRpZXNcIlxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9jaGFpbl9wcm9wZXJ0aWVzXCJcbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZmVlZF9oaXN0b3J5XCJcbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfY3VycmVudF9tZWRpYW5faGlzdG9yeV9wcmljZVwiXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X3dpdG5lc3Nfc2NoZWR1bGVcIlxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9oYXJkZm9ya192ZXJzaW9uXCJcbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfbmV4dF9zY2hlZHVsZWRfaGFyZGZvcmtcIlxufSwge1xuICBcImFwaVwiOiBcImFjY291bnRfYnlfa2V5X2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9rZXlfcmVmZXJlbmNlc1wiLFxuICBcInBhcmFtc1wiOiBbXCJrZXlcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfYWNjb3VudHNcIixcbiAgXCJwYXJhbXNcIjogW1wibmFtZXNcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfYWNjb3VudF9yZWZlcmVuY2VzXCIsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnRJZFwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImxvb2t1cF9hY2NvdW50X25hbWVzXCIsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnROYW1lc1wiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImxvb2t1cF9hY2NvdW50c1wiLFxuICBcInBhcmFtc1wiOiBbXCJsb3dlckJvdW5kTmFtZVwiLCBcImxpbWl0XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2FjY291bnRfY291bnRcIlxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9jb252ZXJzaW9uX3JlcXVlc3RzXCIsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnROYW1lXCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2FjY291bnRfaGlzdG9yeVwiLFxuICBcInBhcmFtc1wiOiBbXCJhY2NvdW50XCIsIFwiZnJvbVwiLCBcImxpbWl0XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X293bmVyX2hpc3RvcnlcIixcbiAgXCJwYXJhbXNcIjogW1wiYWNjb3VudFwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9yZWNvdmVyeV9yZXF1ZXN0XCIsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZXNjcm93XCIsXG4gIFwicGFyYW1zXCI6IFtcImZyb21cIiwgXCJlc2Nyb3dJZFwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF93aXRoZHJhd19yb3V0ZXNcIixcbiAgXCJwYXJhbXNcIjogW1wiYWNjb3VudFwiLCBcIndpdGhkcmF3Um91dGVUeXBlXCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2FjY291bnRfYmFuZHdpZHRoXCIsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnRcIiwgXCJiYW5kd2lkdGhUeXBlXCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X3NhdmluZ3Nfd2l0aGRyYXdfZnJvbVwiLFxuICBcInBhcmFtc1wiOiBbXCJhY2NvdW50XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X3NhdmluZ3Nfd2l0aGRyYXdfdG9cIixcbiAgXCJwYXJhbXNcIjogW1wiYWNjb3VudFwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9vcmRlcl9ib29rXCIsXG4gIFwicGFyYW1zXCI6IFtcImxpbWl0XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X29wZW5fb3JkZXJzXCIsXG4gIFwicGFyYW1zXCI6IFtcIm93bmVyXCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2xpcXVpZGl0eV9xdWV1ZVwiLFxuICBcInBhcmFtc1wiOiBbXCJzdGFydEFjY291bnRcIiwgXCJsaW1pdFwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF90cmFuc2FjdGlvbl9oZXhcIixcbiAgXCJwYXJhbXNcIjogW1widHJ4XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X3RyYW5zYWN0aW9uXCIsXG4gIFwicGFyYW1zXCI6IFtcInRyeElkXCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXNcIixcbiAgXCJwYXJhbXNcIjogW1widHJ4XCIsIFwiYXZhaWxhYmxlS2V5c1wiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9wb3RlbnRpYWxfc2lnbmF0dXJlc1wiLFxuICBcInBhcmFtc1wiOiBbXCJ0cnhcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJ2ZXJpZnlfYXV0aG9yaXR5XCIsXG4gIFwicGFyYW1zXCI6IFtcInRyeFwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcInZlcmlmeV9hY2NvdW50X2F1dGhvcml0eVwiLFxuICBcInBhcmFtc1wiOiBbXCJuYW1lT3JJZFwiLCBcInNpZ25lcnNcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfYWN0aXZlX3ZvdGVzXCIsXG4gIFwicGFyYW1zXCI6IFtcImF1dGhvclwiLCBcInBlcm1saW5rXCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2FjY291bnRfdm90ZXNcIixcbiAgXCJwYXJhbXNcIjogW1widm90ZXJcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfY29udGVudFwiLFxuICBcInBhcmFtc1wiOiBbXCJhdXRob3JcIiwgXCJwZXJtbGlua1wiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9jb250ZW50X3JlcGxpZXNcIixcbiAgXCJwYXJhbXNcIjogW1wiYXV0aG9yXCIsIFwicGVybWxpbmtcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZGlzY3Vzc2lvbnNfYnlfYXV0aG9yX2JlZm9yZV9kYXRlXCIsXG4gIFwicGFyYW1zXCI6IFtcImF1dGhvclwiLCBcInN0YXJ0UGVybWxpbmtcIiwgXCJiZWZvcmVEYXRlXCIsIFwibGltaXRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfcmVwbGllc19ieV9sYXN0X3VwZGF0ZVwiLFxuICBcInBhcmFtc1wiOiBbXCJzdGFydEF1dGhvclwiLCBcInN0YXJ0UGVybWxpbmtcIiwgXCJsaW1pdFwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF93aXRuZXNzZXNcIixcbiAgXCJwYXJhbXNcIjogW1wid2l0bmVzc0lkc1wiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF93aXRuZXNzX2J5X2FjY291bnRcIixcbiAgXCJwYXJhbXNcIjogW1wiYWNjb3VudE5hbWVcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfd2l0bmVzc2VzX2J5X3ZvdGVcIixcbiAgXCJwYXJhbXNcIjogW1wiZnJvbVwiLCBcImxpbWl0XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwibG9va3VwX3dpdG5lc3NfYWNjb3VudHNcIixcbiAgXCJwYXJhbXNcIjogW1wibG93ZXJCb3VuZE5hbWVcIiwgXCJsaW1pdFwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF93aXRuZXNzX2NvdW50XCJcbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfYWN0aXZlX3dpdG5lc3Nlc1wiXG59LCB7XG4gIFwiYXBpXCI6IFwiZGF0YWJhc2VfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X21pbmVyX3F1ZXVlXCJcbn0sIHtcbiAgXCJhcGlcIjogXCJkYXRhYmFzZV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfcmV3YXJkX2Z1bmRcIixcbiAgXCJwYXJhbXNcIjogW1wibmFtZVwiXVxufSwge1xuICBcImFwaVwiOiBcImRhdGFiYXNlX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF92ZXN0aW5nX2RlbGVnYXRpb25zXCIsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnRcIiwgXCJmcm9tXCIsIFwibGltaXRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJsb2dpbl9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJsb2dpblwiLFxuICBcInBhcmFtc1wiOiBbXCJ1c2VybmFtZVwiLCBcInBhc3N3b3JkXCJdXG59LCB7XG4gIFwiYXBpXCI6IFwibG9naW5fYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2FwaV9ieV9uYW1lXCIsXG4gIFwicGFyYW1zXCI6IFtcImRhdGFiYXNlX2FwaVwiXVxufSwge1xuICBcImFwaVwiOiBcImxvZ2luX2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF92ZXJzaW9uXCJcbn0sIHtcbiAgXCJhcGlcIjogXCJmb2xsb3dfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2ZvbGxvd2Vyc1wiLFxuICBcInBhcmFtc1wiOiBbXCJmb2xsb3dpbmdcIiwgXCJzdGFydEZvbGxvd2VyXCIsIFwiZm9sbG93VHlwZVwiLCBcImxpbWl0XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZm9sbG93X2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9mb2xsb3dpbmdcIixcbiAgXCJwYXJhbXNcIjogW1wiZm9sbG93ZXJcIiwgXCJzdGFydEZvbGxvd2luZ1wiLCBcImZvbGxvd1R5cGVcIiwgXCJsaW1pdFwiXVxufSwge1xuICBcImFwaVwiOiBcImZvbGxvd19hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfZm9sbG93X2NvdW50XCIsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJmb2xsb3dfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2ZlZWRfZW50cmllc1wiLFxuICBcInBhcmFtc1wiOiBbXCJhY2NvdW50XCIsIFwiZW50cnlJZFwiLCBcImxpbWl0XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZm9sbG93X2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9mZWVkXCIsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnRcIiwgXCJlbnRyeUlkXCIsIFwibGltaXRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJmb2xsb3dfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2Jsb2dfZW50cmllc1wiLFxuICBcInBhcmFtc1wiOiBbXCJhY2NvdW50XCIsIFwiZW50cnlJZFwiLCBcImxpbWl0XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZm9sbG93X2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9ibG9nXCIsXG4gIFwicGFyYW1zXCI6IFtcImFjY291bnRcIiwgXCJlbnRyeUlkXCIsIFwibGltaXRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJmb2xsb3dfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X2FjY291bnRfcmVwdXRhdGlvbnNcIixcbiAgXCJwYXJhbXNcIjogW1wibG93ZXJCb3VuZE5hbWVcIiwgXCJsaW1pdFwiXVxufSwge1xuICBcImFwaVwiOiBcImZvbGxvd19hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfcmVibG9nZ2VkX2J5XCIsXG4gIFwicGFyYW1zXCI6IFtcImF1dGhvclwiLCBcInBlcm1saW5rXCJdXG59LCB7XG4gIFwiYXBpXCI6IFwiZm9sbG93X2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9ibG9nX2F1dGhvcnNcIixcbiAgXCJwYXJhbXNcIjogW1wiYmxvZ0FjY291bnRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJuZXR3b3JrX2Jyb2FkY2FzdF9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJicm9hZGNhc3RfdHJhbnNhY3Rpb25cIixcbiAgXCJwYXJhbXNcIjogW1widHJ4XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwibmV0d29ya19icm9hZGNhc3RfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiYnJvYWRjYXN0X3RyYW5zYWN0aW9uX3dpdGhfY2FsbGJhY2tcIixcbiAgXCJwYXJhbXNcIjogW1wiY29uZmlybWF0aW9uQ2FsbGJhY2tcIiwgXCJ0cnhcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJuZXR3b3JrX2Jyb2FkY2FzdF9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJicm9hZGNhc3RfdHJhbnNhY3Rpb25fc3luY2hyb25vdXNcIixcbiAgXCJwYXJhbXNcIjogW1widHJ4XCJdXG59LCB7XG4gIFwiYXBpXCI6IFwibmV0d29ya19icm9hZGNhc3RfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiYnJvYWRjYXN0X2Jsb2NrXCIsXG4gIFwicGFyYW1zXCI6IFtcImJcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJuZXR3b3JrX2Jyb2FkY2FzdF9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJzZXRfbWF4X2Jsb2NrX2FnZVwiLFxuICBcInBhcmFtc1wiOiBbXCJtYXhCbG9ja0FnZVwiXVxufSwge1xuICBcImFwaVwiOiBcIm1hcmtldF9oaXN0b3J5X2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF90aWNrZXJcIixcbiAgXCJwYXJhbXNcIjogW11cbn0sIHtcbiAgXCJhcGlcIjogXCJtYXJrZXRfaGlzdG9yeV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfdm9sdW1lXCIsXG4gIFwicGFyYW1zXCI6IFtdXG59LCB7XG4gIFwiYXBpXCI6IFwibWFya2V0X2hpc3RvcnlfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X29yZGVyX2Jvb2tcIixcbiAgXCJtZXRob2RfbmFtZVwiOiBcImdldE1hcmtldE9yZGVyQm9va1wiLFxuICBcInBhcmFtc1wiOiBbXCJsaW1pdFwiXVxufSwge1xuICBcImFwaVwiOiBcIm1hcmtldF9oaXN0b3J5X2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF90cmFkZV9oaXN0b3J5XCIsXG4gIFwicGFyYW1zXCI6IFtcInN0YXJ0XCIsIFwiZW5kXCIsIFwibGltaXRcIl1cbn0sIHtcbiAgXCJhcGlcIjogXCJtYXJrZXRfaGlzdG9yeV9hcGlcIixcbiAgXCJtZXRob2RcIjogXCJnZXRfcmVjZW50X3RyYWRlc1wiLFxuICBcInBhcmFtc1wiOiBbXCJsaW1pdFwiXVxufSwge1xuICBcImFwaVwiOiBcIm1hcmtldF9oaXN0b3J5X2FwaVwiLFxuICBcIm1ldGhvZFwiOiBcImdldF9tYXJrZXRfaGlzdG9yeVwiLFxuICBcInBhcmFtc1wiOiBbXCJidWNrZXRfc2Vjb25kc1wiLCBcInN0YXJ0XCIsIFwiZW5kXCJdXG59LCB7XG4gIFwiYXBpXCI6IFwibWFya2V0X2hpc3RvcnlfYXBpXCIsXG4gIFwibWV0aG9kXCI6IFwiZ2V0X21hcmtldF9oaXN0b3J5X2J1Y2tldHNcIixcbiAgXCJwYXJhbXNcIjogW11cbn1dOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9ldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVHJhbnNwb3J0ID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKFRyYW5zcG9ydCwgX0V2ZW50RW1pdHRlcik7XG5cbiAgZnVuY3Rpb24gVHJhbnNwb3J0KCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc3BvcnQpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFRyYW5zcG9ydC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRyYW5zcG9ydCkpLmNhbGwodGhpcywgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgX3RoaXMuaWQgPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUcmFuc3BvcnQsIFt7XG4gICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGlzdGVuVG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW5Ubyh0YXJnZXQsIGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjayk7ZWxzZSB0YXJnZXQub24oZXZlbnROYW1lLCBjYWxsYmFjayk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcikgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjayk7ZWxzZSB0YXJnZXQucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NlbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kKCkge31cbiAgfSwge1xuICAgIGtleTogJ3N0YXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7fVxuICB9LCB7XG4gICAga2V5OiAnc3RvcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIFRyYW5zcG9ydDtcbn0oX2V2ZW50czIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRyYW5zcG9ydDsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmV4cG9ydHMuanNvblJwYyA9IGpzb25ScGM7XG5cbnZhciBfY3Jvc3NGZXRjaCA9IHJlcXVpcmUoJ2Nyb3NzLWZldGNoJyk7XG5cbnZhciBfY3Jvc3NGZXRjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcm9zc0ZldGNoKTtcblxudmFyIF9kZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJyk7XG5cbnZhciBfZGVidWcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVidWcpO1xuXG52YXIgX2Jhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcblxudmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBkZWJ1ZyA9ICgwLCBfZGVidWcyLmRlZmF1bHQpKCdzdGVlbTpodHRwJyk7XG5cbnZhciBSUENFcnJvciA9IGZ1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKFJQQ0Vycm9yLCBfRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIFJQQ0Vycm9yKHJwY0Vycm9yKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJQQ0Vycm9yKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChSUENFcnJvci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFJQQ0Vycm9yKSkuY2FsbCh0aGlzLCBycGNFcnJvci5tZXNzYWdlKSk7XG5cbiAgICBfdGhpcy5uYW1lID0gJ1JQQ0Vycm9yJztcbiAgICBfdGhpcy5jb2RlID0gcnBjRXJyb3IuY29kZTtcbiAgICBfdGhpcy5kYXRhID0gcnBjRXJyb3IuZGF0YTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gUlBDRXJyb3I7XG59KEVycm9yKTtcblxuZnVuY3Rpb24ganNvblJwYyh1cmksIF9yZWYpIHtcbiAgdmFyIG1ldGhvZCA9IF9yZWYubWV0aG9kLFxuICAgICAgaWQgPSBfcmVmLmlkLFxuICAgICAgcGFyYW1zID0gX3JlZi5wYXJhbXM7XG5cbiAgdmFyIHBheWxvYWQgPSB7IGlkOiBpZCwganNvbnJwYzogJzIuMCcsIG1ldGhvZDogbWV0aG9kLCBwYXJhbXM6IHBhcmFtcyB9O1xuICByZXR1cm4gKDAsIF9jcm9zc0ZldGNoMi5kZWZhdWx0KSh1cmksIHtcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgICBtZXRob2Q6ICdwb3N0JyxcbiAgICBtb2RlOiAnY29ycycsXG4gICAgaGVhZGVyczoge1xuICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJyxcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICB9XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hUVFAgJyArIHJlcy5zdGF0dXMgKyAnOiAnICsgcmVzLnN0YXR1c1RleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLmpzb24oKTtcbiAgfSkudGhlbihmdW5jdGlvbiAocnBjUmVzKSB7XG4gICAgaWYgKHJwY1Jlcy5pZCAhPT0gaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBpZDogJyArIHJwY1Jlcy5pZCk7XG4gICAgfVxuICAgIGlmIChycGNSZXMuZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBSUENFcnJvcihycGNSZXMuZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gcnBjUmVzLnJlc3VsdDtcbiAgfSk7XG59XG5cbnZhciBIdHRwVHJhbnNwb3J0ID0gZnVuY3Rpb24gKF9UcmFuc3BvcnQpIHtcbiAgX2luaGVyaXRzKEh0dHBUcmFuc3BvcnQsIF9UcmFuc3BvcnQpO1xuXG4gIGZ1bmN0aW9uIEh0dHBUcmFuc3BvcnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEh0dHBUcmFuc3BvcnQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChIdHRwVHJhbnNwb3J0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSHR0cFRyYW5zcG9ydCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEh0dHBUcmFuc3BvcnQsIFt7XG4gICAga2V5OiAnc2VuZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmQoYXBpLCBkYXRhLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VBcHBiYXNlQXBpKSB7XG4gICAgICAgIGFwaSA9ICdjb25kZW5zZXJfYXBpJztcbiAgICAgIH1cbiAgICAgIGRlYnVnKCdTdGVlbTo6c2VuZCcsIGFwaSwgZGF0YSk7XG4gICAgICB2YXIgaWQgPSBkYXRhLmlkIHx8IHRoaXMuaWQrKztcbiAgICAgIHZhciBwYXJhbXMgPSBbYXBpLCBkYXRhLm1ldGhvZCwgZGF0YS5wYXJhbXNdO1xuICAgICAganNvblJwYyh0aGlzLm9wdGlvbnMudXJpLCB7IG1ldGhvZDogJ2NhbGwnLCBpZDogaWQsIHBhcmFtczogcGFyYW1zIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEh0dHBUcmFuc3BvcnQ7XG59KF9iYXNlMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSHR0cFRyYW5zcG9ydDsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfaHR0cCA9IHJlcXVpcmUoJy4vaHR0cCcpO1xuXG52YXIgX2h0dHAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaHR0cCk7XG5cbnZhciBfd3MgPSByZXF1aXJlKCcuL3dzJyk7XG5cbnZhciBfd3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGh0dHA6IF9odHRwMi5kZWZhdWx0LFxuICB3czogX3dzMi5kZWZhdWx0XG59OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9kZXRlY3ROb2RlID0gcmVxdWlyZSgnZGV0ZWN0LW5vZGUnKTtcblxudmFyIF9kZXRlY3ROb2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RldGVjdE5vZGUpO1xuXG52YXIgX2RlYnVnID0gcmVxdWlyZSgnZGVidWcnKTtcblxudmFyIF9kZWJ1ZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWJ1Zyk7XG5cbnZhciBfYmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuXG52YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFdlYlNvY2tldCA9IHZvaWQgMDtcbmlmIChfZGV0ZWN0Tm9kZTIuZGVmYXVsdCkge1xuICBXZWJTb2NrZXQgPSByZXF1aXJlKCd3cycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdsb2JhbC1yZXF1aXJlXG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIFdlYlNvY2tldCA9IHdpbmRvdy5XZWJTb2NrZXQ7XG59IGVsc2Uge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBkZWNpZGUgb24gYSBgV2ViU29ja2V0YCBjbGFzc1wiKTtcbn1cblxudmFyIGRlYnVnID0gKDAsIF9kZWJ1ZzIuZGVmYXVsdCkoJ3N0ZWVtOndzJyk7XG5cbnZhciBXc1RyYW5zcG9ydCA9IGZ1bmN0aW9uIChfVHJhbnNwb3J0KSB7XG4gIF9pbmhlcml0cyhXc1RyYW5zcG9ydCwgX1RyYW5zcG9ydCk7XG5cbiAgZnVuY3Rpb24gV3NUcmFuc3BvcnQoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdzVHJhbnNwb3J0KTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChXc1RyYW5zcG9ydC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFdzVHJhbnNwb3J0KSkuY2FsbCh0aGlzLCBPYmplY3QuYXNzaWduKHsgaWQ6IDAgfSwgb3B0aW9ucykpKTtcblxuICAgIF90aGlzLl9yZXF1ZXN0cyA9IG5ldyBNYXAoKTtcbiAgICBfdGhpcy5pbkZsaWdodCA9IDA7XG4gICAgX3RoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFdzVHJhbnNwb3J0LCBbe1xuICAgIGtleTogJ3N0YXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuc3RhcnRQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0UHJvbWlzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFydFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF90aGlzMi53cyA9IG5ldyBXZWJTb2NrZXQoX3RoaXMyLm9wdGlvbnMud2Vic29ja2V0KTtcbiAgICAgICAgX3RoaXMyLndzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgX3RoaXMyLnN0YXJ0UHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzMi53cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLmlzT3BlbiA9IHRydWU7XG4gICAgICAgICAgX3RoaXMyLndzLm9uZXJyb3IgPSBfdGhpczIub25FcnJvci5iaW5kKF90aGlzMik7XG4gICAgICAgICAgX3RoaXMyLndzLm9ubWVzc2FnZSA9IF90aGlzMi5vbk1lc3NhZ2UuYmluZChfdGhpczIpO1xuICAgICAgICAgIF90aGlzMi53cy5vbmNsb3NlID0gX3RoaXMyLm9uQ2xvc2UuYmluZChfdGhpczIpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnRQcm9taXNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0b3AnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgZGVidWcoJ1N0b3BwaW5nLi4uJyk7XG5cbiAgICAgIHRoaXMuc3RhcnRQcm9taXNlID0gbnVsbDtcbiAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZXF1ZXN0cy5jbGVhcigpO1xuXG4gICAgICBpZiAodGhpcy53cykge1xuICAgICAgICB0aGlzLndzLm9uZXJyb3IgPSB0aGlzLndzLm9ubWVzc2FnZSA9IHRoaXMud3Mub25jbG9zZSA9IG51bGw7XG4gICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICAgICAgdGhpcy53cyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2VuZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmQoYXBpLCBkYXRhLCBjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGRlYnVnKCdTdGVlbTo6c2VuZCcsIGFwaSwgZGF0YSk7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVmZXJyYWwgPSB7fTtcbiAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGRlZmVycmFsLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXNvbHZlKHZhbCk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB2YWwpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZGVmZXJyYWwucmVqZWN0ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmVqZWN0KHZhbCk7XG4gICAgICAgICAgICBjYWxsYmFjayh2YWwpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChfdGhpczMub3B0aW9ucy51c2VBcHBiYXNlQXBpKSB7XG4gICAgICAgICAgYXBpID0gJ2NvbmRlbnNlcl9hcGknO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9yZXF1ZXN0ID0ge1xuICAgICAgICAgIGRlZmVycmFsOiBkZWZlcnJhbCxcbiAgICAgICAgICBzdGFydGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgaWQ6IGRhdGEuaWQgfHwgX3RoaXMzLmlkKyssXG4gICAgICAgICAgICBtZXRob2Q6ICdjYWxsJyxcbiAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgcGFyYW1zOiBbYXBpLCBkYXRhLm1ldGhvZCwgZGF0YS5wYXJhbXNdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpczMuaW5GbGlnaHQrKztcbiAgICAgICAgX3RoaXMzLl9yZXF1ZXN0cy5zZXQoX3JlcXVlc3QubWVzc2FnZS5pZCwgX3JlcXVlc3QpO1xuICAgICAgICBfdGhpczMud3Muc2VuZChKU09OLnN0cmluZ2lmeShfcmVxdWVzdC5tZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJhbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRXJyb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGhpcy5fcmVxdWVzdHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIF9yZXF1ZXN0ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICBfcmVxdWVzdC5kZWZlcnJhbC5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25DbG9zZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2xvc2UoKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gd2FzIGNsb3NlZCcpO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB0aGlzLl9yZXF1ZXN0c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBfcmVxdWVzdCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIF9yZXF1ZXN0LmRlZmVycmFsLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVxdWVzdHMuY2xlYXIoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbk1lc3NhZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lc3NhZ2Uod2Vic29ja2V0TWVzc2FnZSkge1xuICAgICAgdmFyIG1lc3NhZ2UgPSBKU09OLnBhcnNlKHdlYnNvY2tldE1lc3NhZ2UuZGF0YSk7XG4gICAgICBkZWJ1ZygnLS0gU3RlZW0ub25NZXNzYWdlIC0tPicsIG1lc3NhZ2UuaWQpO1xuICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0cy5oYXMobWVzc2FnZS5pZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYW5pYzogbm8gcmVxdWVzdCBpbiBxdWV1ZSBmb3IgbWVzc2FnZSBpZCAnICsgbWVzc2FnZS5pZCk7XG4gICAgICB9XG4gICAgICB2YXIgX3JlcXVlc3QgPSB0aGlzLl9yZXF1ZXN0cy5nZXQobWVzc2FnZS5pZCk7XG4gICAgICB0aGlzLl9yZXF1ZXN0cy5kZWxldGUobWVzc2FnZS5pZCk7XG5cbiAgICAgIHZhciBlcnJvckNhdXNlID0gbWVzc2FnZS5lcnJvcjtcbiAgICAgIGlmIChlcnJvckNhdXNlKSB7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItdGVtcGxhdGVcbiAgICAgICAgKGVycm9yQ2F1c2UubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGNvbXBsZXRlIG9wZXJhdGlvbicpICsgJyAoc2VlIGVyci5wYXlsb2FkIGZvciB0aGUgZnVsbCBlcnJvciBwYXlsb2FkKScpO1xuICAgICAgICBlcnIucGF5bG9hZCA9IG1lc3NhZ2U7XG4gICAgICAgIF9yZXF1ZXN0LmRlZmVycmFsLnJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbWl0KCd0cmFjay1wZXJmb3JtYW5jZScsIF9yZXF1ZXN0Lm1lc3NhZ2UubWV0aG9kLCBEYXRlLm5vdygpIC0gX3JlcXVlc3Quc3RhcnRlZEF0KTtcbiAgICAgICAgX3JlcXVlc3QuZGVmZXJyYWwucmVzb2x2ZShtZXNzYWdlLnJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFdzVHJhbnNwb3J0O1xufShfYmFzZTIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFdzVHJhbnNwb3J0OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9lYWNoID0gcmVxdWlyZSgnbG9kYXNoL2VhY2gnKTtcblxudmFyIF9lYWNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgZGVmYXVsdENvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZy5qc29uJyk7XG5cbnZhciBDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbmZpZyhjKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25maWcpO1xuXG4gICAgKDAsIF9lYWNoMi5kZWZhdWx0KShjLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgX3RoaXNba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvbmZpZywgW3tcbiAgICBrZXk6ICdnZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoaykge1xuICAgICAgcmV0dXJuIHRoaXNba107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGssIHYpIHtcbiAgICAgIHRoaXNba10gPSB2O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb25maWc7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IENvbmZpZyhkZWZhdWx0Q29uZmlnKTtcbmlmICh0eXBlb2YgbW9kdWxlLmV4cG9ydHMuQ29uZmlnICE9PSAndW5kZWZpbmVkJykge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZhdWx0IGNvbmZpZy5qc29uIGZpbGUgbWF5IG5vdCBjb250YWluIGEgcHJvcGVydHkgJ0NvbmZpZydcIik7XG59XG5tb2R1bGUuZXhwb3J0cy5Db25maWcgPSBDb25maWc7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXBpID0gcmVxdWlyZSgnLi9hcGknKTtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXBpOiBhcGksXG4gIGNvbmZpZzogY29uZmlnLFxuICB1dGlsczogdXRpbHNcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbnZhciBzbmFrZUNhc2VSZSA9IC9fKFthLXpdKS9nO1xuZnVuY3Rpb24gY2FtZWxDYXNlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2Uoc25ha2VDYXNlUmUsIGZ1bmN0aW9uIChfbSwgbCkge1xuICAgIHJldHVybiBsLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufSIsIi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICByZXR1cm4gZGVidWc7XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yLWVhY2gnKTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcbnZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG5cbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciB0b1N0clRhZ3MgPSB7fTtcbnZhciBnT1BEID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcbmlmIChoYXNUb1N0cmluZ1RhZyAmJiBnT1BEICYmIGdldFByb3RvdHlwZU9mKSB7XG5cdGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0aWYgKHR5cGVvZiBnW3R5cGVkQXJyYXldID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR2YXIgYXJyID0gbmV3IGdbdHlwZWRBcnJheV0oKTtcblx0XHRcdGlmIChTeW1ib2wudG9TdHJpbmdUYWcgaW4gYXJyKSB7XG5cdFx0XHRcdHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XG5cdFx0XHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdFx0aWYgKCFkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdFx0dmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG5cdFx0XHRcdFx0ZGVzY3JpcHRvciA9IGdPUEQoc3VwZXJQcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0b1N0clRhZ3NbdHlwZWRBcnJheV0gPSBkZXNjcmlwdG9yLmdldDtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG52YXIgdHJ5VHlwZWRBcnJheXMgPSBmdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyh2YWx1ZSkge1xuXHR2YXIgZm91bmROYW1lID0gZmFsc2U7XG5cdGZvckVhY2godG9TdHJUYWdzLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFmb3VuZE5hbWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBuYW1lID0gZ2V0dGVyLmNhbGwodmFsdWUpO1xuXHRcdFx0XHRpZiAobmFtZSA9PT0gdHlwZWRBcnJheSkge1xuXHRcdFx0XHRcdGZvdW5kTmFtZSA9IG5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGZvdW5kTmFtZTtcbn07XG5cbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZC1hcnJheScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRpZiAoIWlzVHlwZWRBcnJheSh2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcgfHwgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpKSB7IHJldHVybiAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpOyB9XG5cdHJldHVybiB0cnlUeXBlZEFycmF5cyh2YWx1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcG9zc2libGVOYW1lcyA9IFtcblx0J0JpZ0ludDY0QXJyYXknLFxuXHQnQmlnVWludDY0QXJyYXknLFxuXHQnRmxvYXQzMkFycmF5Jyxcblx0J0Zsb2F0NjRBcnJheScsXG5cdCdJbnQxNkFycmF5Jyxcblx0J0ludDMyQXJyYXknLFxuXHQnSW50OEFycmF5Jyxcblx0J1VpbnQxNkFycmF5Jyxcblx0J1VpbnQzMkFycmF5Jyxcblx0J1VpbnQ4QXJyYXknLFxuXHQnVWludDhDbGFtcGVkQXJyYXknXG5dO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IGdsb2JhbFRoaXM7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXZhaWxhYmxlVHlwZWRBcnJheXMoKSB7XG5cdHZhciBvdXQgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb3NzaWJsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHR5cGVvZiBnW3Bvc3NpYmxlTmFtZXNbaV1dID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRvdXRbb3V0Lmxlbmd0aF0gPSBwb3NzaWJsZU5hbWVzW2ldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKFtdLCAnbGVuZ3RoJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBnT1BEXG5cdFx0JGdPUEQgPSBudWxsO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGdPUEQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJywgdHJ1ZSk7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRChbXSwgJ2xlbmd0aCcpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZ09QRFxuXHRcdCRnT1BEID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICRnT1BEO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9